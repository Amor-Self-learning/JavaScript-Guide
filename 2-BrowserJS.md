# Browser JS
# 1.1 DOM Fundamentals

The **Document Object Model (DOM)** is the programming interface that bridges HTML/XML documents and JavaScript. When a browser parses an HTML file, it does not keep the raw text in memory — it constructs a live, in-memory tree of objects. JavaScript reads and manipulates that tree, and the browser synchronises the screen with every change.

Understanding the DOM at a deep level is the foundation for all browser-side JavaScript: event handling, dynamic UIs, animations, and frameworks like React and Vue all operate on top of these primitives.

---

## 1.1.1 DOM Tree Structure

### What the DOM Is

The DOM is defined by the **WHATWG DOM Living Standard** (https://dom.spec.whatwg.org/). It specifies a language-neutral, platform-independent API — implementations exist in every browser and even in server-side environments such as jsdom (used by Jest and Node.js testing).

When a browser receives this HTML:

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Example</title>
  </head>
  <body>
    <h1 id="title">Hello</h1>
    <p class="intro">World</p>
  </body>
</html>
```

It builds this tree:

```
Document
└── DocumentType (<!DOCTYPE html>)
└── Element <html lang="en">
    ├── Element <head>
    │   └── Element <title>
    │       └── Text "Example"
    └── Element <body>
        ├── Text "\n    "           ← whitespace text node
        ├── Element <h1 id="title">
        │   └── Text "Hello"
        ├── Text "\n    "
        ├── Element <p class="intro">
        │   └── Text "World"
        └── Text "\n  "
```

Every box in the diagram is a **node** — an object that implements the `Node` interface.

### Key Structural Facts

1. **There is exactly one root node per document** — the `Document` node.
2. **Every element is surrounded by whitespace text nodes** when the source is formatted with indentation. This surprises beginners: `document.body.firstChild` is often a text node, not an element.
3. **The DOM is a live view** — modify it and the browser repaints automatically.
4. **The DOM is ordered** — children have a defined index order matching source order.
5. **The tree is deep, not flat** — nesting produces depth; typical real-world pages have DOM trees hundreds of levels deep.

### The DOM is Not HTML

The DOM and the HTML source are related but distinct:

```javascript
// The parser repairs invalid HTML
// Source: <table><td>cell</td></table>  (missing <tr>)
// DOM:    table > tbody > tr > td

// innerHTML can differ from source
const el = document.createElement('div');
el.innerHTML = '<p>Hello</p>';
console.log(el.innerHTML);  // "<p>Hello</p>" — serialised DOM, not original source

// The DOM reflects live state; HTML is static text
document.title = 'New Title';
// <title> in DOM is updated; original HTML file is unchanged
```

---

## 1.1.2 Node Types

Every object in the DOM tree is a **Node**. The `Node` interface defines a numeric `nodeType` property (an integer constant) that identifies what kind of node it is.

### All 12 Node Types

| Constant | Value | Description | Example |
|---|---|---|---|
| `Node.ELEMENT_NODE` | 1 | HTML or SVG element | `<div>`, `<p>`, `<svg>` |
| `Node.ATTRIBUTE_NODE` | 2 | Element attribute *(deprecated as node)* | `id="title"` |
| `Node.TEXT_NODE` | 3 | Text content | `"Hello, World"` |
| `Node.CDATA_SECTION_NODE` | 4 | CDATA section (XML only) | `<![CDATA[...]]>` |
| `Node.ENTITY_REFERENCE_NODE` | 5 | *(Removed from DOM4)* | — |
| `Node.ENTITY_NODE` | 6 | *(Removed from DOM4)* | — |
| `Node.PROCESSING_INSTRUCTION_NODE` | 7 | XML processing instruction | `<?xml version="1.0"?>` |
| `Node.COMMENT_NODE` | 8 | HTML/XML comment | `<!-- comment -->` |
| `Node.DOCUMENT_NODE` | 9 | The `document` itself | `document` |
| `Node.DOCUMENT_TYPE_NODE` | 10 | Doctype declaration | `<!DOCTYPE html>` |
| `Node.DOCUMENT_FRAGMENT_NODE` | 11 | Lightweight document | `createDocumentFragment()` |
| `Node.NOTATION_NODE` | 12 | *(Removed from DOM4)* | — |

> **In practice, types 2, 4, 5, 6, 12 are either deprecated or XML-only. Day-to-day browser work uses types 1, 3, 8, 9, 10, and 11.**

### Checking `nodeType`

```javascript
// Always check nodeType when traversing raw childNodes
function logNodeInfo(node) {
  switch (node.nodeType) {
    case Node.ELEMENT_NODE:           // 1
      console.log('Element:', node.tagName);
      break;
    case Node.TEXT_NODE:              // 3
      console.log('Text:', JSON.stringify(node.nodeValue));
      break;
    case Node.COMMENT_NODE:           // 8
      console.log('Comment:', node.nodeValue);
      break;
    case Node.DOCUMENT_NODE:          // 9
      console.log('Document');
      break;
    case Node.DOCUMENT_TYPE_NODE:     // 10
      console.log('Doctype:', node.name);
      break;
    case Node.DOCUMENT_FRAGMENT_NODE: // 11
      console.log('DocumentFragment');
      break;
    default:
      console.log('Other node type:', node.nodeType);
  }
}

logNodeInfo(document);              // Document
logNodeInfo(document.doctype);      // Doctype: html
logNodeInfo(document.body);         // Element: BODY
logNodeInfo(document.body.firstChild); // Text: "\n  " (whitespace)
```

### `Node.ELEMENT_NODE` (type 1) — the most common

Element nodes represent HTML tags. They are the only node type that can have attributes and child elements.

```javascript
const div = document.createElement('div');
console.log(div.nodeType);    // 1
console.log(div.nodeName);    // "DIV"  (uppercase for HTML, lowercase for SVG/XML)
console.log(div.tagName);     // "DIV"  (same as nodeName for elements)
console.log(div.nodeValue);   // null   (elements have no direct value)

// For SVG elements:
const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
console.log(circle.nodeName); // "circle" (lowercase for SVG namespace)
```

### `Node.TEXT_NODE` (type 3) — the invisible workhorse

Text nodes hold the actual text content. They are children of elements, and they are created implicitly by the parser for any text between tags.

```javascript
const p = document.createElement('p');
p.textContent = 'Hello world';

const textNode = p.firstChild;
console.log(textNode.nodeType);    // 3
console.log(textNode.nodeName);    // "#text"
console.log(textNode.nodeValue);   // "Hello world"
console.log(textNode.data);        // "Hello world" (alias for nodeValue on text nodes)
console.log(textNode.length);      // 11

// Whitespace creates text nodes
document.body.innerHTML = `
  <p>First</p>
  <p>Second</p>
`;
// document.body.childNodes contains:
//   [0] Text "\n  "
//   [1] Element <p>
//   [2] Text "\n  "
//   [3] Element <p>
//   [4] Text "\n"
console.log(document.body.childNodes.length); // 5, not 2!
```

**Common Gotcha — Whitespace Text Nodes:**

```javascript
// FRAGILE: assumes first child is the <p> element
const firstParagraph = document.body.firstChild; // ❌ This is a text node!

// ROBUST: use firstElementChild to skip text nodes
const firstParagraph = document.body.firstElementChild; // ✅ Element <p>
```

### `Node.COMMENT_NODE` (type 8)

HTML comments are full nodes in the DOM. This matters when traversing raw `childNodes`.

```javascript
document.body.innerHTML = '<!-- Step 1 --><p>Content</p>';
document.body.childNodes[0].nodeType; // 8 (comment)
document.body.childNodes[0].nodeValue; // " Step 1 "

// Comments are sometimes used as placeholders by frameworks
// e.g., Angular uses <!--bindings={...}--> markers
```

### `Node.DOCUMENT_NODE` (type 9)

There is exactly one `Document` node — the global `document` object in browsers.

```javascript
console.log(document.nodeType);  // 9
console.log(document.nodeName);  // "#document"
console.log(document === document.ownerDocument); // false — document has no ownerDocument
console.log(document.body.ownerDocument === document); // true
```

### `Node.DOCUMENT_TYPE_NODE` (type 10)

```javascript
const doctype = document.doctype;
console.log(doctype.nodeType);  // 10
console.log(doctype.name);      // "html"
console.log(doctype.publicId);  // "" (empty for HTML5)
console.log(doctype.systemId);  // "" (empty for HTML5)
```

### `Node.DOCUMENT_FRAGMENT_NODE` (type 11)

A `DocumentFragment` is a lightweight, detached subtree. It is used as an off-screen staging area to batch DOM changes efficiently.

```javascript
const fragment = document.createDocumentFragment();
console.log(fragment.nodeType);  // 11
console.log(fragment.nodeName);  // "#document-fragment"

// Build a list off-screen, then insert in one operation
const ul = document.querySelector('ul');
const frag = document.createDocumentFragment();

['Alpha', 'Beta', 'Gamma'].forEach(text => {
  const li = document.createElement('li');
  li.textContent = text;
  frag.appendChild(li);
});

ul.appendChild(frag); // Single reflow — all three <li>s inserted at once
// Note: the fragment itself is not inserted; only its children are moved
console.log(frag.childNodes.length); // 0 — fragment is now empty
```

---

## 1.1.3 Node Interface: Core Properties

Every node, regardless of type, inherits these properties from the `Node` interface:

```javascript
// Common Node properties
node.nodeType       // Integer (1–12), see table above
node.nodeName       // String: "DIV", "#text", "#comment", "html", etc.
node.nodeValue      // String | null — text for TEXT/COMMENT, null for ELEMENT
node.textContent    // Get/set all text content (strips tags)
node.ownerDocument  // The Document this node belongs to
node.parentNode     // Parent node (any type) or null
node.parentElement  // Parent element node or null (null if parent is Document)
node.childNodes     // NodeList of all children (all node types)
node.firstChild     // First child (any type) or null
node.lastChild      // Last child (any type) or null
node.nextSibling    // Next sibling (any type) or null
node.previousSibling// Previous sibling (any type) or null
node.isConnected    // true if this node is in the live document
```

### `textContent` vs `nodeValue` vs `data`

```javascript
const p = document.createElement('p');
p.innerHTML = '<strong>Hello</strong> world';

// textContent: all text inside the element, tags stripped
console.log(p.textContent);  // "Hello world"

// Setting textContent replaces ALL children with a single text node
p.textContent = 'Plain text <with> "entities"';
console.log(p.innerHTML);    // "Plain text &lt;with&gt; &quot;entities&quot;"
// ↑ Safe: textContent never interprets HTML, so no XSS risk

// nodeValue: null for elements; actual text for text/comment nodes
console.log(p.nodeValue);    // null
console.log(p.firstChild.nodeValue); // "Plain text <with> \"entities\""

// .data is an alias for nodeValue on CharacterData nodes (Text, Comment, CDATASection)
console.log(p.firstChild.data); // same as nodeValue
```

---

## 1.1.4 Node Relationships (Parent, Child, Sibling)

The DOM tree has three fundamental relationship types: **ancestry** (parent/child/descendant/ancestor), **siblinghood**, and **ownership** (the `ownerDocument`).

### Parent–Child Relationships

```javascript
// Given this HTML:
// <div id="outer">
//   <p id="inner">Text</p>
// </div>

const outer = document.getElementById('outer');
const inner = document.getElementById('inner');
const textNode = inner.firstChild; // Text node "Text"

// Parent relationships
console.log(inner.parentNode);     // <div id="outer">
console.log(inner.parentElement);  // <div id="outer">

// parentNode vs parentElement:
// parentNode can be Document, DocumentFragment, or Element
// parentElement is null when the parent is not an Element
console.log(document.documentElement.parentNode);     // document (Document node)
console.log(document.documentElement.parentElement);  // null

// Child relationships
console.log(outer.childNodes);       // NodeList [text, p, text] (if whitespace present)
console.log(outer.children);         // HTMLCollection [p]   ← elements only
console.log(outer.firstChild);       // Text node (whitespace) or <p>
console.log(outer.firstElementChild);// <p id="inner">
console.log(outer.lastChild);        // Text node (whitespace) or <p>
console.log(outer.lastElementChild); // <p id="inner">
console.log(outer.childElementCount);// 1

// Checking if a node contains another (inclusive)
console.log(outer.contains(inner));  // true
console.log(outer.contains(textNode));// true
console.log(inner.contains(outer));  // false

// Checking ancestor–descendant with compareDocumentPosition
const pos = outer.compareDocumentPosition(inner);
// Returns a bitmask:
// Node.DOCUMENT_POSITION_CONTAINED_BY = 16 → inner is inside outer
console.log(pos & Node.DOCUMENT_POSITION_CONTAINED_BY); // 16 (truthy)
```

### Sibling Relationships

```javascript
// <ul>
//   <li id="a">A</li>
//   <li id="b">B</li>
//   <li id="c">C</li>
// </ul>

const b = document.getElementById('b');

// Raw siblings (include text nodes)
console.log(b.previousSibling); // Text "\n  " (whitespace)
console.log(b.nextSibling);     // Text "\n  " (whitespace)

// Element-only siblings (skip text nodes)
console.log(b.previousElementSibling); // <li id="a">
console.log(b.nextElementSibling);     // <li id="c">

// Getting index among siblings
function getElementIndex(el) {
  let index = 0;
  let sibling = el.previousElementSibling;
  while (sibling) {
    index++;
    sibling = sibling.previousElementSibling;
  }
  return index;
}
console.log(getElementIndex(b)); // 1 (zero-based)
```

### Ancestry — Walking Up the Tree

```javascript
// Check if an element is inside another
function isDescendant(ancestor, descendant) {
  return ancestor.contains(descendant);
}

// Find the closest ancestor matching a CSS selector (built-in)
const link = document.querySelector('.nav a');
const navContainer = link.closest('.nav');    // walks up the tree
const tableCell = link.closest('td, th');     // first td or th ancestor

// Manual ancestor walk
function getAncestors(node) {
  const ancestors = [];
  let current = node.parentElement;
  while (current) {
    ancestors.push(current);
    current = current.parentElement;
  }
  return ancestors;
}
```

### The `compareDocumentPosition` Bitmask

```javascript
// Node.compareDocumentPosition() returns a bitmask of these flags:
const flags = {
  DOCUMENT_POSITION_DISCONNECTED:            1,  // Nodes in different trees
  DOCUMENT_POSITION_PRECEDING:               2,  // Argument precedes in tree order
  DOCUMENT_POSITION_FOLLOWING:               4,  // Argument follows in tree order
  DOCUMENT_POSITION_CONTAINS:               8,  // Argument contains this node
  DOCUMENT_POSITION_CONTAINED_BY:           16, // Argument is contained by this node
  DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: 32,
};

const a = document.getElementById('a');
const c = document.getElementById('c');

const result = a.compareDocumentPosition(c);
// c follows a in the document
console.log(result & 4); // 4 — DOCUMENT_POSITION_FOLLOWING (truthy: c is after a)
console.log(result & 2); // 0 — not PRECEDING

// Practical: sort nodes in document order
function sortByDocumentOrder(nodes) {
  return [...nodes].sort((a, b) => {
    const pos = a.compareDocumentPosition(b);
    return pos & 4 ? -1 : pos & 2 ? 1 : 0;
  });
}
```

---

## 1.1.5 NodeList vs HTMLCollection

The DOM exposes two collection types for groups of nodes. They have different behaviours, and confusing them is a very common source of bugs.

### `NodeList`

A `NodeList` is a collection of `Node` objects (any node type). It is returned by:

- `node.childNodes`  ← **live** NodeList
- `document.querySelectorAll()` ← **static** NodeList
- `node.querySelectorAll()` ← **static** NodeList

```javascript
// NodeList basics
const all = document.querySelectorAll('p');
console.log(all instanceof NodeList); // true
console.log(all.length);             // e.g. 3

// Indexed access
console.log(all[0]);        // first <p>
console.log(all.item(0));   // same as all[0]

// NodeList is array-like but NOT an Array
console.log(Array.isArray(all)); // false
console.log(typeof all.map);     // "undefined" — no .map() method!

// Convert to real array for full array methods
const array = Array.from(all);          // modern, preferred
const array2 = [...all];                // spread (also works)
const array3 = Array.prototype.slice.call(all); // legacy

array.map(p => p.textContent);     // ✅ now .map() works
array.filter(p => p.id !== '');    // ✅
array.sort((a, b) => ...);         // ✅

// NodeList IS iterable (supports for...of)
for (const p of all) {
  console.log(p.textContent);
}

// NodeList also supports forEach directly (since ~2016)
all.forEach(p => console.log(p.textContent));
```

### `HTMLCollection`

An `HTMLCollection` is a collection of **`Element`** nodes only (no text nodes, no comments). It is returned by:

- `node.children` ← **live** HTMLCollection
- `document.getElementsByTagName()` ← **live** HTMLCollection
- `document.getElementsByClassName()` ← **live** HTMLCollection
- `document.getElementsByName()` ← **live** NodeList (special case)
- `form.elements` ← **live** HTMLFormControlsCollection (subtype)

```javascript
const children = document.body.children;
console.log(children instanceof HTMLCollection); // true

// Named access by id or name attribute (unique to HTMLCollection)
document.body.innerHTML = '<div id="hero"></div>';
const divs = document.body.children;
console.log(divs.namedItem('hero')); // <div id="hero">
console.log(divs['hero']);           // same — bracket access works too

// HTMLCollection is NOT iterable in older browsers!
// for...of works in modern browsers but NOT in IE11:
for (const el of children) { ... } // ✅ modern
// For legacy support, convert first:
Array.from(children).forEach(el => ...);

// HTMLCollection has no forEach, no map, no filter — convert always
Array.from(children).filter(el => el.classList.contains('active'));
```

---

## 1.1.6 Live vs Static Collections

This is the most important distinction between collection types and the source of subtle, hard-to-find bugs.

### Live Collections

A **live collection** automatically reflects DOM changes. If you add or remove nodes that match the collection's criteria, the collection updates itself instantly — without any re-query.

```javascript
// ─── Live NodeList example ───
const list = document.createElement('ul');
document.body.appendChild(list);

list.innerHTML = '<li>First</li><li>Second</li>';
const liveChildren = list.childNodes;  // Live NodeList
console.log(liveChildren.length);      // 2

// Add a new child
const li = document.createElement('li');
li.textContent = 'Third';
list.appendChild(li);

// The collection updated automatically
console.log(liveChildren.length);      // 3  ← reflects the new node

// ─── Live HTMLCollection example ───
const livePs = document.getElementsByTagName('p');
console.log(livePs.length);            // 2 (say)

document.body.appendChild(document.createElement('p'));
console.log(livePs.length);            // 3  ← live update

// ─── Bug: Infinite loop with live collections ───
const items = document.getElementsByClassName('item'); // live
// DON'T DO THIS — every iteration of the loop changes items.length:
for (let i = 0; i < items.length; i++) {
  const clone = items[i].cloneNode(true);
  clone.classList.add('item');
  document.body.appendChild(clone); // adds to items → loop never ends!
}

// FIX: snapshot the live collection first
const snapshot = Array.from(items); // static copy
for (const item of snapshot) {
  const clone = item.cloneNode(true);
  clone.classList.add('item');
  document.body.appendChild(clone); // safe
}
```

**Live collections that mutate during loops:**

```javascript
// Another common bug: removing elements by class with getElementsByClassName
const toRemove = document.getElementsByClassName('remove-me'); // live
// WRONG: as elements are removed, indices shift
for (let i = 0; i < toRemove.length; i++) {
  toRemove[i].remove(); // only removes odd-indexed elements!
}
// After removing index 0, what was index 1 becomes index 0, so i=1 skips it.

// FIX 1: iterate backwards
for (let i = toRemove.length - 1; i >= 0; i--) {
  toRemove[i].remove(); // ✅ safe
}

// FIX 2: convert to array
Array.from(toRemove).forEach(el => el.remove()); // ✅ safe
// [...toRemove].forEach(el => el.remove());       // ✅ also works

// FIX 3: use querySelectorAll (static)
document.querySelectorAll('.remove-me').forEach(el => el.remove()); // ✅
```

### Static Collections

A **static collection** is a snapshot taken at the moment of the query. Subsequent DOM changes do not affect it.

```javascript
// querySelectorAll returns a STATIC NodeList
const staticPs = document.querySelectorAll('p');
const countBefore = staticPs.length;

document.body.appendChild(document.createElement('p'));
const countAfter = staticPs.length;

console.log(countBefore === countAfter); // true — static snapshot not updated

// Compare: live vs static side by side
const live = document.getElementsByTagName('div');   // live HTMLCollection
const stat = document.querySelectorAll('div');        // static NodeList

const newDiv = document.createElement('div');
document.body.appendChild(newDiv);

console.log(live.length); // increased by 1
console.log(stat.length); // unchanged
```

### Choosing Between Live and Static

| Use case | Recommended | Reason |
|---|---|---|
| One-time DOM manipulation | `querySelectorAll` (static) | Predictable; avoids mutation bugs |
| Observing structural changes | Live (`children`, `childNodes`) | Automatically up-to-date |
| Iterating and removing nodes | Static or reverse iteration | Avoids shifting indices |
| Performance-sensitive repeated reads | Live then cache `.length` | Avoids re-querying |
| Building interactive UIs | Static | Easier to reason about |

```javascript
// Performance note: querying the DOM is relatively expensive.
// Cache static snapshots when you will reuse the result.
const buttons = document.querySelectorAll('.btn'); // query once
buttons.forEach(btn => {
  btn.addEventListener('click', handleClick); // use the snapshot
});
// vs querying inside a loop (bad):
document.querySelectorAll('.btn').forEach(...); // re-queries every time in a loop context
```

---

## 1.1.7 The `Node` Interface in Depth

Beyond the basics, the `Node` interface exposes several utility methods essential for every-day DOM work.

### Cloning Nodes

```javascript
// node.cloneNode(deep)
// deep = false: clone only the node itself (no children)
// deep = true:  clone the node and all descendants

const original = document.getElementById('card');

// Shallow clone — no children
const shallow = original.cloneNode(false);
console.log(shallow.childNodes.length); // 0

// Deep clone — full subtree
const deep = original.cloneNode(true);
console.log(deep.innerHTML); // same as original.innerHTML

// ⚠️ Important: cloneNode does NOT copy event listeners
// (listeners attached with addEventListener are not cloned)
original.addEventListener('click', handler);
const clone = original.cloneNode(true);
// clone does NOT have the click handler

// ⚠️ Cloning elements with id creates duplicate IDs — fix immediately
const cloneWithId = original.cloneNode(true);
cloneWithId.id = 'card-clone'; // remove or change the id
cloneWithId.querySelectorAll('[id]').forEach(el => {
  el.id = el.id + '-clone'; // suffix all descendant ids
});
```

### Comparing Nodes

```javascript
// node.isSameNode(other) — checks if they are the exact same object (reference equality)
const div = document.createElement('div');
const ref = div;
console.log(div.isSameNode(ref));      // true  (same reference)
console.log(div.isSameNode(div.cloneNode(true))); // false (different objects)

// Alternative: === operator (identical behaviour)
console.log(div === ref);              // true

// node.isEqualNode(other) — checks structural equality (same type, attributes, children)
const a = document.createElement('p');
const b = document.createElement('p');
a.textContent = 'Hello';
b.textContent = 'Hello';
console.log(a.isSameNode(b));   // false — different objects
console.log(a.isEqualNode(b));  // true  — same structure

a.setAttribute('class', 'note');
console.log(a.isEqualNode(b));  // false — different attributes now
```

### Checking Node Containment

```javascript
// node.contains(other)
// Returns true if 'other' is this node, a child, or any descendant
const container = document.getElementById('container');
const button = document.getElementById('button');

if (container.contains(button)) {
  console.log('button is inside container');
}

// Practical use: event delegation (checking if click target is inside an element)
document.addEventListener('click', event => {
  if (!dropdown.contains(event.target)) {
    dropdown.classList.remove('open'); // close dropdown when clicking outside
  }
});

// node.getRootNode() — walk up to the root (Document or ShadowRoot)
console.log(button.getRootNode()); // document (or ShadowRoot if in shadow DOM)
console.log(button.getRootNode({ composed: true })); // document (even from inside shadow)
```

### Inserting and Moving Nodes

```javascript
// node.appendChild(child) — appends child as last child
const ul = document.querySelector('ul');
const li = document.createElement('li');
li.textContent = 'New item';
ul.appendChild(li);        // li is now the last child of ul

// node.insertBefore(newNode, referenceNode) — inserts before reference
const first = ul.firstElementChild;
ul.insertBefore(li, first); // li is now the first child

// Moving: appending an existing node removes it from its current position
const existingLi = document.querySelector('li.special');
ul.appendChild(existingLi); // moves it (not copies) to the end

// node.removeChild(child)
ul.removeChild(ul.firstChild); // removes the first child

// Modern alternatives (covered in detail in chapter 1.5):
// append(), prepend(), before(), after(), replaceWith(), remove()
```

### Normalising the DOM

```javascript
// node.normalize() — merges adjacent text nodes and removes empty text nodes
const div = document.createElement('div');
div.appendChild(document.createTextNode('Hello'));
div.appendChild(document.createTextNode(' '));
div.appendChild(document.createTextNode('World'));
console.log(div.childNodes.length); // 3 — three text nodes

div.normalize();
console.log(div.childNodes.length); // 1 — merged into "Hello World"
console.log(div.firstChild.nodeValue); // "Hello World"

// Why normalize? Text nodes can become fragmented after:
// - Direct text node manipulation
// - Using splitText()
// - Undo/redo in contenteditable
```

### `splitText` — Splitting Text Nodes

```javascript
const p = document.createElement('p');
p.textContent = 'Hello World';

const textNode = p.firstChild; // "Hello World"
const secondHalf = textNode.splitText(6); // split at index 6

console.log(textNode.nodeValue);    // "Hello " (first part)
console.log(secondHalf.nodeValue);  // "World"  (new text node)
console.log(p.childNodes.length);   // 2

// Use case: wrap a specific portion of text in a <strong>
function wrapText(textNode, start, end) {
  // Split into three: before, target, after
  const after = textNode.splitText(end);
  const target = textNode.splitText(start);
  // At this point: textNode = before, target = middle, after = end
  const strong = document.createElement('strong');
  target.parentNode.insertBefore(strong, target);
  strong.appendChild(target);
  return strong;
}
```

---

## 1.1.8 The Document Fragment

`DocumentFragment` (node type 11) is one of the most important performance tools in the DOM API. It acts as a temporary, lightweight container for building subtrees off-screen.

### Why Fragments Matter

Every time you insert a node into the live DOM, the browser may need to recalculate layout (reflow) and repaint. Inserting many nodes individually triggers many reflows:

```javascript
// Slow: 100 reflows
const list = document.querySelector('ul');
for (let i = 0; i < 100; i++) {
  const li = document.createElement('li');
  li.textContent = `Item ${i}`;
  list.appendChild(li); // each triggers a potential reflow
}

// Fast: 1 reflow
const fragment = document.createDocumentFragment();
for (let i = 0; i < 100; i++) {
  const li = document.createElement('li');
  li.textContent = `Item ${i}`;
  fragment.appendChild(li); // off-screen — no reflow
}
list.appendChild(fragment); // single DOM insertion = single reflow
```

### Fragment Behaviour

```javascript
const frag = document.createDocumentFragment();

// Fragments can hold multiple top-level children
frag.appendChild(document.createElement('div'));
frag.appendChild(document.createElement('p'));
frag.appendChild(document.createTextNode('Some text'));
console.log(frag.childNodes.length); // 3

// When inserted, the fragment itself is NOT added — only its children are
const container = document.querySelector('#container');
container.appendChild(frag);
console.log(frag.childNodes.length); // 0 — fragment is now empty (children moved)
console.log(container.childNodes.length); // 3

// Fragments can be cloned to reuse the same template
const template = document.createDocumentFragment();
const card = document.createElement('div');
card.className = 'card';
template.appendChild(card);

function cloneTemplate() {
  return template.firstElementChild.cloneNode(true);
}
// Use cloneTemplate() to create new cards from the template
```

### Modern Alternative: `<template>` Element

The HTML `<template>` element provides declarative fragment templates in HTML:

```html
<template id="card-template">
  <article class="card">
    <h2 class="card-title"></h2>
    <p class="card-body"></p>
  </article>
</template>
```

```javascript
const tpl = document.getElementById('card-template');
// tpl.content is a DocumentFragment containing the template's subtree
console.log(tpl.content.nodeType);  // 11 (DocumentFragment)
console.log(tpl.content.querySelector('.card-title')); // h2.card-title

// Clone the template content to create a new instance
function createCard(title, body) {
  const instance = tpl.content.cloneNode(true); // deep clone
  instance.querySelector('.card-title').textContent = title;
  instance.querySelector('.card-body').textContent = body;
  return instance; // returns a DocumentFragment
}

const container = document.querySelector('#cards');
container.appendChild(createCard('First Card', 'Some text here.'));
container.appendChild(createCard('Second Card', 'More text here.'));
```

---

## 1.1.9 Practical Patterns and Gotchas

### Gotcha 1 — `innerHTML` Parses HTML (XSS Risk)

```javascript
// DANGEROUS: user-controlled input
const userInput = '<img src=x onerror="alert(1)">';
el.innerHTML = userInput;     // ❌ Executes XSS payload

// SAFE alternatives:
el.textContent = userInput;   // ✅ Treats everything as text
// or:
el.insertAdjacentText('beforeend', userInput); // ✅ Text only
// or use the Sanitizer API (discussed in chapter 54):
el.setHTML(userInput);        // ✅ Sanitizes HTML (newer browsers)
```

### Gotcha 2 — `innerHTML` Destroys Event Listeners

```javascript
const container = document.getElementById('container');
const button = container.querySelector('button');
button.addEventListener('click', () => console.log('clicked'));

// Re-assigning innerHTML destroys the entire subtree and recreates it from scratch
container.innerHTML += '<span>extra</span>'; // ❌ button's listener is lost!

// Better: use appendChild/append for additive changes
const span = document.createElement('span');
span.textContent = 'extra';
container.appendChild(span); // ✅ existing children (and their listeners) intact
```

### Gotcha 3 — Scripts Injected via `innerHTML` Do Not Execute

```javascript
// innerHTML does NOT execute scripts — this is intentional security behaviour
el.innerHTML = '<script>alert("XSS")</script>'; // script tag created but NOT run

// However, event-handler attributes and some elements still fire:
el.innerHTML = '<img src=x onerror=alert(1)>'; // ❌ this DOES fire
el.innerHTML = '<svg onload=alert(1)>';          // ❌ this also fires

// Only DOMParser / createContextualFragment execute sanitised content
```

### Gotcha 4 — Table Elements Require Proper Nesting

```javascript
// Browsers require <table> > <tbody> > <tr> > <td>
// Direct innerHTML injection may auto-wrap or silently drop elements:
const table = document.createElement('table');
table.innerHTML = '<td>Cell</td>'; // ❌ parsed differently — td stripped!

// Correct: use full nesting
table.innerHTML = '<tbody><tr><td>Cell</td></tr></tbody>'; // ✅

// Or build programmatically
const tbody = table.createTBody();
const row = tbody.insertRow();
const cell = row.insertCell();
cell.textContent = 'Cell'; // ✅
```

### Gotcha 5 — Detached Nodes

A node that has been created but not inserted into the document is **detached**. Queries against detached trees work, but you cannot use `document.getElementById()` on them — you must query relative to the root element.

```javascript
const div = document.createElement('div');
div.innerHTML = '<p id="foo">Hello</p>';

// getElementById only searches the live document
document.getElementById('foo');    // null — div is not in the document

// querySelector works on any node
div.querySelector('#foo');          // <p id="foo"> ✅
div.querySelector('p');             // <p id="foo"> ✅

// Check if a node is in the live document
console.log(div.isConnected);       // false — detached
document.body.appendChild(div);
console.log(div.isConnected);       // true  — connected

// getElementById now works
document.getElementById('foo');    // <p id="foo"> ✅
```

### Gotcha 6 — `document.body` Can Be `null`

If a script runs in the `<head>` before `<body>` is parsed, `document.body` is `null`.

```html
<head>
  <script>
    console.log(document.body); // null — body not parsed yet
  </script>
</head>
```

```javascript
// Solutions:
// 1. Move scripts to bottom of <body>
// 2. Use defer attribute
// 3. Listen for DOMContentLoaded
document.addEventListener('DOMContentLoaded', () => {
  // Safe to access document.body here
  console.log(document.body); // <body>
});
```

---

## 1.1.10 `Node` vs `Element` — The Interface Hierarchy

The DOM is built on a rich inheritance chain. Understanding it prevents confusion about which properties and methods are available where.

```
EventTarget
  └── Node
        ├── CharacterData
        │     ├── Text
        │     ├── Comment
        │     └── CDATASection
        ├── Document
        │     └── HTMLDocument
        ├── DocumentFragment
        ├── DocumentType
        └── Element
              └── HTMLElement
                    ├── HTMLDivElement
                    ├── HTMLInputElement
                    ├── HTMLAnchorElement
                    └── ... (one per HTML tag)
```

```javascript
const div = document.createElement('div');

// EventTarget
console.log(div instanceof EventTarget); // true
div.addEventListener('click', () => {});

// Node
console.log(div instanceof Node);        // true
console.log(div.nodeType);               // 1
console.log(div.parentNode);             // null (detached)

// Element
console.log(div instanceof Element);     // true
console.log(div.tagName);               // "DIV"
console.log(div.getAttribute('id'));    // null

// HTMLElement
console.log(div instanceof HTMLElement); // true
console.log(div.hidden);                // false
console.log(div.style);                 // CSSStyleDeclaration {}

// HTMLDivElement (specific)
console.log(div instanceof HTMLDivElement); // true
// (HTMLDivElement adds no additional properties; just marks the specific type)

// Text node — does NOT implement Element interface
const text = document.createTextNode('hi');
console.log(text instanceof Node);    // true
console.log(text instanceof Element); // false  ← no tagName, no classList, etc.
console.log(text.nodeName);           // "#text"
// text.tagName   → undefined (not inherited)
// text.classList → TypeError in older browsers; undefined in newer
```

### Properties Unique to `Element` (not on plain `Node`)

```javascript
// These are available on Element nodes but NOT on Text, Comment, or Document:
element.tagName           // "DIV"
element.id                // ""
element.className         // ""
element.classList         // DOMTokenList []
element.attributes        // NamedNodeMap (all attributes)
element.getAttribute()    // read attribute by name
element.setAttribute()    // set attribute
element.removeAttribute() // remove attribute
element.hasAttribute()    // check attribute existence
element.querySelector()   // search subtree
element.querySelectorAll()// search subtree
element.closest()         // walk ancestors
element.matches()         // test CSS selector
element.children          // HTMLCollection of child elements
element.childElementCount // count of child elements
element.innerHTML         // HTML string of content
element.outerHTML         // HTML string including the element itself
element.insertAdjacentHTML()  // insert HTML relative to element
element.getBoundingClientRect()// size and position
element.scrollIntoView()  // scroll to element
```

---

## 1.1.11 Performance Considerations

DOM operations are among the most expensive things JavaScript can do. The DOM is maintained in a separate process (the rendering engine), and every crossing of the JS–rendering boundary has overhead.

### Minimise DOM Reads That Force Layout

Some DOM properties force the browser to **flush the layout queue** (synchronously recalculate all pending style/layout changes) before they can return a value:

```javascript
// Layout-forcing properties (partial list):
element.offsetWidth  / element.offsetHeight
element.offsetTop    / element.offsetLeft
element.scrollWidth  / element.scrollHeight
element.scrollTop    / element.scrollLeft
element.clientWidth  / element.clientHeight
element.getBoundingClientRect()
window.getComputedStyle(element)
```

**Layout thrashing** — alternating reads and writes in a loop — is a catastrophic performance pattern:

```javascript
// BAD: Layout thrashing (forces layout on every iteration)
const items = document.querySelectorAll('.item');
for (const item of items) {
  const height = item.offsetHeight;           // READ  — forces layout
  item.style.height = (height * 2) + 'px';   // WRITE — invalidates layout
}
// N reads × N writes = N reflows

// GOOD: Batch reads, then batch writes
const heights = [];
for (const item of items) {
  heights.push(item.offsetHeight);            // READ batch
}
for (let i = 0; i < items.length; i++) {
  items[i].style.height = (heights[i] * 2) + 'px'; // WRITE batch
}
// 1 reflow total
```

### Cache Node References

```javascript
// BAD: Queries the DOM on every call
function updateTitle() {
  document.querySelector('#title').textContent = getNewTitle();
}

// GOOD: Cache the reference
const titleEl = document.querySelector('#title');
function updateTitle() {
  titleEl.textContent = getNewTitle(); // no DOM query
}
```

### Use `DocumentFragment` and `innerHTML` Strategically

```javascript
// For building large lists from data, innerHTML can be faster than individual appends:
const items = ['A', 'B', 'C', /* ...1000 items */];
const ul = document.querySelector('ul');

// Approach 1: fragment (good for generic nodes)
const frag = document.createDocumentFragment();
items.forEach(item => {
  const li = document.createElement('li');
  li.textContent = item;
  frag.appendChild(li);
});
ul.appendChild(frag);

// Approach 2: innerHTML (fastest for large amounts of static HTML)
ul.innerHTML = items.map(item => `<li>${item}</li>`).join('');
// ⚠️ Only safe if items are trusted (not user input); destroys existing event listeners

// Approach 3: insertAdjacentHTML (fast, does not destroy existing content)
ul.insertAdjacentHTML('beforeend', items.map(item => `<li>${item}</li>`).join(''));
```

---

## 1.1.12 Summary

| Concept | Key Points |
|---|---|
| DOM tree | In-memory tree of Node objects; built from parsed HTML; live view of the document |
| Node types | 12 types; practical ones are Element (1), Text (3), Comment (8), Document (9), DocType (10), Fragment (11) |
| `nodeType` | Integer constant identifying the type; use `Node.ELEMENT_NODE` etc. |
| `nodeName` | `"DIV"`, `"#text"`, `"#comment"`, `"#document"`, `"html"`, `"#document-fragment"` |
| `nodeValue` | Text content for Text/Comment nodes; `null` for Element and Document |
| `textContent` | All text inside a node, HTML stripped; setting it is XSS-safe |
| Relationships | `parentNode`/`parentElement`, `childNodes`/`children`, `firstChild`/`firstElementChild`, siblings |
| `NodeList` | Can hold any node type; `querySelectorAll` → static; `childNodes` → live |
| `HTMLCollection` | Elements only; always live; returned by `getElementsByTagName`, `.children` |
| Live collection | Reflects DOM changes automatically; dangerous in mutation loops |
| Static collection | Snapshot at query time; predictable; returned by `querySelectorAll` |
| `DocumentFragment` | Off-screen container; children moved (not copied) on insert; enables batch inserts |
| `isConnected` | `true` if node is in the live document tree |
| Layout thrashing | Alternating DOM reads/writes in a loop; batch reads then writes to avoid |

---

**End of Chapter 1.1: DOM Fundamentals**

This chapter established the foundational model for all browser-side JavaScript. You now understand:

- The DOM as a live, in-memory tree of Node objects built from parsed HTML
- All 12 node types, their `nodeType` constants, and when each appears
- How `parentNode`, `parentElement`, `childNodes`, `children`, and sibling properties differ
- The critical distinction between live collections (`getElementsByTagName`, `.childNodes`) and static snapshots (`querySelectorAll`)
- How `DocumentFragment` enables high-performance batch DOM insertions
- The `Node` → `Element` → `HTMLElement` inheritance chain and which APIs each level provides
- Common gotchas: whitespace text nodes, `innerHTML` XSS risk, live-collection mutation bugs, and layout thrashing

Chapter 1.2 explores the `document` object itself — its properties, methods, and lifecycle events.
# 1.2 Document Interface

The `document` object is the entry point to the DOM. It represents the entire HTML or XML document loaded in the browser and provides properties and methods to access every element, create new content, and query document state. Every script that manipulates the page starts here.

Understanding the Document interface deeply is essential because:
- **All element access starts here** — `getElementById`, `querySelector`, etc. are Document methods
- **Document state matters** — code that runs before `DOMContentLoaded` can't find elements
- **Security boundaries** — cookies, referrer, and origin are exposed through Document
- **Dynamic content** — creating elements, writing HTML, and managing the document lifecycle all happen through this interface

---

## 1.2.1 The document Object

### What It Is

The `document` object is a global variable (actually `window.document`) that implements the `Document` interface. In a browser, it's always an `HTMLDocument` (which extends `Document`).

```javascript
// document is globally available
console.log(document);                    // #document
console.log(document.constructor.name);   // HTMLDocument
console.log(document instanceof Document); // true
console.log(document.nodeType);           // 9 (Node.DOCUMENT_NODE)

// document is the same as window.document
console.log(document === window.document); // true
```

### Document vs HTMLDocument

```javascript
// Document is the base interface (XML and HTML)
// HTMLDocument extends Document with HTML-specific properties

// HTML-specific properties (only on HTMLDocument):
document.body;        // <body> element
document.head;        // <head> element
document.cookie;      // Cookie access
document.domain;      // Security domain

// Generic Document properties (XML and HTML):
document.documentElement;  // Root element
document.doctype;          // DOCTYPE declaration
document.URL;              // Document URL
```

---

## 1.2.2 documentElement, head, and body

### documentElement

The `documentElement` property returns the root element of the document — for HTML, this is always `<html>`.

```javascript
const html = document.documentElement;

console.log(html.tagName);        // "HTML"
console.log(html.nodeName);       // "HTML"
console.log(html === document.querySelector('html')); // true

// documentElement is the parent of <head> and <body>
console.log(html.children.length);    // 2 (head + body, typically)
console.log(html.children[0].tagName); // "HEAD"
console.log(html.children[1].tagName); // "BODY"

// Useful for getting viewport dimensions
const viewportWidth = document.documentElement.clientWidth;
const viewportHeight = document.documentElement.clientHeight;
```

### head

The `head` property returns the `<head>` element — there's always exactly one.

```javascript
const head = document.head;

console.log(head.tagName);  // "HEAD"

// Access meta tags, stylesheets, scripts in head
const metas = head.querySelectorAll('meta');
const title = head.querySelector('title');

// Add a new stylesheet dynamically
const link = document.createElement('link');
link.rel = 'stylesheet';
link.href = '/styles/dynamic.css';
head.appendChild(link);

// Add a meta tag
const meta = document.createElement('meta');
meta.name = 'viewport';
meta.content = 'width=device-width, initial-scale=1';
head.appendChild(meta);
```

### body

The `body` property returns the `<body>` element (or `<frameset>` in legacy documents).

```javascript
const body = document.body;

console.log(body.tagName);  // "BODY"

// ⚠️ GOTCHA: body can be null if accessed too early
// This happens in <head> scripts before body is parsed
console.log(document.body);  // null (if script is in <head>)

// Safe pattern: wait for DOMContentLoaded
document.addEventListener('DOMContentLoaded', () => {
  console.log(document.body);  // <body> element (guaranteed)
});

// Or place scripts at end of <body>
// Or use defer attribute on script tags
```

### Gotcha: Accessing body Too Early

```javascript
// ❌ WRONG: Script in <head> without waiting
// <head>
//   <script>
//     document.body.style.background = 'red';  // TypeError: null
//   </script>
// </head>

// ✅ CORRECT: Wait for DOM
document.addEventListener('DOMContentLoaded', () => {
  document.body.style.background = 'red';  // Works
});

// ✅ CORRECT: Use defer
// <script defer src="app.js"></script>
// Script runs after DOM is ready

// ✅ CORRECT: Place script at end of body
// <body>
//   ...content...
//   <script src="app.js"></script>
// </body>
```

---

## 1.2.3 Document Properties

### title

The `title` property gets or sets the document title (shown in browser tab).

```javascript
// Get current title
console.log(document.title);  // "My Page"

// Set new title
document.title = 'Updated Title';

// Dynamic title based on state
function updateTitle(unreadCount) {
  document.title = unreadCount > 0 
    ? `(${unreadCount}) Messages` 
    : 'Messages';
}

// Restore title on visibility change
let originalTitle = document.title;
document.addEventListener('visibilitychange', () => {
  if (document.hidden) {
    document.title = 'Come back!';
  } else {
    document.title = originalTitle;
  }
});
```

### URL, domain, and origin

```javascript
// URL - full URL of the document (read-only)
console.log(document.URL);
// "https://example.com/page?query=1#section"

// Same as location.href
console.log(document.URL === location.href);  // true

// documentURI - same as URL in HTML documents
console.log(document.documentURI);

// domain - hostname (can be relaxed for same-origin policy)
console.log(document.domain);  // "example.com"

// ⚠️ Setting domain is deprecated and restricted
// document.domain = 'example.com';  // Deprecated

// origin - scheme + host (inherited from location)
// Note: document doesn't have origin, use location
console.log(location.origin);  // "https://example.com"
```

### referrer

The `referrer` property contains the URL of the page that linked to the current page.

```javascript
console.log(document.referrer);
// "https://google.com/search?q=..." (if from Google)
// "" (if direct navigation or referrer blocked)

// Use cases:
// 1. Analytics - track where visitors come from
if (document.referrer.includes('google.com')) {
  analytics.track('organic_search');
}

// 2. Conditional content
if (document.referrer.includes('partner-site.com')) {
  showPartnerDiscount();
}

// ⚠️ Security: referrer can be empty or spoofed
// - Empty if: direct navigation, HTTPS→HTTP, Referrer-Policy: no-referrer
// - Don't rely on it for security decisions
```

### characterSet

```javascript
// Returns the character encoding of the document
console.log(document.characterSet);  // "UTF-8"

// Also available as charset (legacy alias)
console.log(document.charset);  // "UTF-8"

// Should match <meta charset="UTF-8">
```

### contentType

```javascript
// MIME type of the document
console.log(document.contentType);  // "text/html"

// For XML documents: "application/xml" or "text/xml"
// For XHTML: "application/xhtml+xml"
```

### lastModified

```javascript
// Date the document was last modified (from HTTP header)
console.log(document.lastModified);  // "02/18/2024 15:30:45"

// ⚠️ Format is locale-dependent, not ISO
// ⚠️ May return current time if server doesn't send Last-Modified header
```

### dir

```javascript
// Base text direction of the document
console.log(document.dir);  // "ltr" or "rtl" or ""

// Set document direction
document.dir = 'rtl';  // Right-to-left (Arabic, Hebrew)
document.dir = 'ltr';  // Left-to-right (English, etc.)

// Usually set via <html dir="rtl"> attribute
```

---

## 1.2.4 readyState and DOMContentLoaded

### readyState

The `readyState` property indicates the loading state of the document.

```javascript
// Three possible values:
console.log(document.readyState);
// "loading"     - Document is still loading
// "interactive" - DOM is ready, but resources (images) still loading
// "complete"    - Everything loaded

// Check if DOM is ready
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', init);
} else {
  init();  // DOM already ready
}
```

### readystatechange Event

```javascript
// Fires when readyState changes
document.addEventListener('readystatechange', () => {
  console.log(`State: ${document.readyState}`);
});

// Output order:
// State: loading      (initial, or not fired if already past)
// State: interactive  (DOMContentLoaded fires here)
// State: complete     (load event fires here)
```

### DOMContentLoaded vs load

```javascript
// DOMContentLoaded - fires when HTML is parsed and DOM tree is built
// Does NOT wait for stylesheets, images, subframes
document.addEventListener('DOMContentLoaded', () => {
  console.log('DOM ready');
  // Safe to query and manipulate DOM
  const el = document.getElementById('app');
});

// load - fires when EVERYTHING is loaded (images, styles, etc.)
window.addEventListener('load', () => {
  console.log('Everything loaded');
  // Safe to get computed styles, image dimensions, etc.
  const img = document.querySelector('img');
  console.log(img.naturalWidth);  // Actual image width
});

// Timing:
// 1. HTML parsing begins
// 2. Scripts execute (unless defer/async)
// 3. DOM tree complete → readyState = "interactive"
// 4. DOMContentLoaded fires
// 5. Images, stylesheets, iframes load
// 6. readyState = "complete"
// 7. load fires
```

### Best Practice: Safe DOM Access

```javascript
// Pattern 1: Wrap in DOMContentLoaded
document.addEventListener('DOMContentLoaded', () => {
  // All DOM code here
});

// Pattern 2: Check readyState first
function whenReady(fn) {
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', fn);
  } else {
    fn();
  }
}

whenReady(() => {
  console.log('DOM is ready');
});

// Pattern 3: Use defer attribute (preferred)
// <script defer src="app.js"></script>
// Script runs after DOM ready, before DOMContentLoaded
```

---

## 1.2.5 cookie Property

The `document.cookie` property provides read/write access to cookies for the current document.

### Reading Cookies

```javascript
// Get all cookies as a single string
console.log(document.cookie);
// "session_id=abc123; user_name=john; theme=dark"

// Parse cookies into an object
function getCookies() {
  return document.cookie
    .split('; ')
    .reduce((cookies, cookie) => {
      const [name, value] = cookie.split('=');
      cookies[name] = decodeURIComponent(value);
      return cookies;
    }, {});
}

const cookies = getCookies();
console.log(cookies.session_id);  // "abc123"
console.log(cookies.theme);       // "dark"

// Get a specific cookie
function getCookie(name) {
  const match = document.cookie.match(
    new RegExp('(^|; )' + name + '=([^;]*)')
  );
  return match ? decodeURIComponent(match[2]) : null;
}

console.log(getCookie('theme'));  // "dark"
```

### Writing Cookies

```javascript
// Set a simple cookie
document.cookie = 'username=john';

// ⚠️ Setting document.cookie ADDS a cookie, doesn't replace all!
document.cookie = 'theme=dark';
// Now both username and theme are set

// Cookie with options
document.cookie = 'token=xyz; max-age=3600; path=/; secure; samesite=strict';

// Cookie options:
// expires=DATE    - Expiration date (UTC string)
// max-age=SECONDS - Seconds until expiration (preferred over expires)
// path=PATH       - Cookie path (default: current path)
// domain=DOMAIN   - Cookie domain (default: current host)
// secure          - Only send over HTTPS
// samesite=VALUE  - CSRF protection (strict/lax/none)
```

### Setting Cookies with Helper

```javascript
function setCookie(name, value, options = {}) {
  let cookie = `${encodeURIComponent(name)}=${encodeURIComponent(value)}`;
  
  if (options.maxAge) {
    cookie += `; max-age=${options.maxAge}`;
  }
  if (options.expires) {
    cookie += `; expires=${options.expires.toUTCString()}`;
  }
  if (options.path) {
    cookie += `; path=${options.path}`;
  }
  if (options.domain) {
    cookie += `; domain=${options.domain}`;
  }
  if (options.secure) {
    cookie += '; secure';
  }
  if (options.sameSite) {
    cookie += `; samesite=${options.sameSite}`;
  }
  
  document.cookie = cookie;
}

// Usage
setCookie('session', 'abc123', {
  maxAge: 86400,      // 1 day
  path: '/',
  secure: true,
  sameSite: 'strict'
});
```

### Deleting Cookies

```javascript
// Delete by setting expiration in the past
function deleteCookie(name, path = '/') {
  document.cookie = `${name}=; max-age=0; path=${path}`;
}

deleteCookie('session');

// ⚠️ Must match the path used when setting
// Cookie set with path=/admin can only be deleted with path=/admin
```

### Cookie Limitations and Security

```javascript
// ❌ LIMITATIONS:
// - 4KB max per cookie
// - ~50 cookies per domain
// - Sent with EVERY request (bandwidth)
// - String-only (must serialize objects)

// ❌ SECURITY ISSUES:
// - XSS can steal cookies (unless HttpOnly)
// - CSRF if SameSite not set

// ✅ BEST PRACTICES:
// 1. Use HttpOnly for sensitive cookies (set by server, not JS)
// 2. Use Secure flag for HTTPS-only
// 3. Use SameSite=Strict or Lax
// 4. Set appropriate expiration
// 5. Use narrow path when possible

// For client-side storage, prefer:
// - localStorage/sessionStorage (more space, no request overhead)
// - IndexedDB (structured data)
```

---

## 1.2.6 Document Methods

### open(), write(), close()

These legacy methods write to the document stream. **Avoid them in modern code.**

```javascript
// ❌ LEGACY: document.write()
// Opens stream, writes HTML, can replace entire document
document.write('<h1>Hello</h1>');

// ⚠️ DANGEROUS: If called after page load, replaces entire document!
window.addEventListener('load', () => {
  document.write('Oops!');  // Entire page replaced with "Oops!"
});

// document.open() - explicitly opens the stream
// document.close() - closes the stream

// ✅ MODERN ALTERNATIVE: innerHTML or DOM methods
document.body.innerHTML = '<h1>Hello</h1>';

// Or:
const h1 = document.createElement('h1');
h1.textContent = 'Hello';
document.body.appendChild(h1);
```

### hasFocus()

```javascript
// Returns true if document or any element in it has focus
console.log(document.hasFocus());  // true (if tab is active)

// Use case: pause animations when tab loses focus
if (!document.hasFocus()) {
  pauseAnimation();
}

// Listen for focus changes
window.addEventListener('blur', () => {
  console.log('Window lost focus');
});
window.addEventListener('focus', () => {
  console.log('Window gained focus');
});
```

### activeElement

```javascript
// Returns the currently focused element
console.log(document.activeElement);  // <input>, <button>, etc.

// If no element is focused, returns <body> or null
console.log(document.activeElement.tagName);  // "BODY"

// Useful for:
// 1. Saving focus before modal opens
const previousFocus = document.activeElement;
openModal();
// ... later
previousFocus.focus();  // Restore focus

// 2. Validating which element has focus
if (document.activeElement === usernameInput) {
  showUsernameTips();
}
```

### getSelection()

```javascript
// Returns the Selection object representing selected text
const selection = document.getSelection();

console.log(selection.toString());    // Selected text as string
console.log(selection.rangeCount);    // Number of selection ranges
console.log(selection.anchorNode);    // Node where selection started
console.log(selection.focusNode);     // Node where selection ended

// Get selected range
if (selection.rangeCount > 0) {
  const range = selection.getRangeAt(0);
  console.log(range.startContainer);  // Start node
  console.log(range.endContainer);    // End node
}

// Clear selection
selection.removeAllRanges();

// Programmatically select text
const range = document.createRange();
range.selectNodeContents(document.getElementById('content'));
selection.removeAllRanges();
selection.addRange(range);
```

### elementFromPoint() and elementsFromPoint()

```javascript
// Get element at specific coordinates
const element = document.elementFromPoint(100, 200);
console.log(element);  // Element at x=100, y=200

// Get all elements at coordinates (topmost first)
const elements = document.elementsFromPoint(100, 200);
console.log(elements);  // [<span>, <div>, <body>, <html>]

// Use case: Custom tooltip at cursor position
document.addEventListener('mousemove', (e) => {
  const el = document.elementFromPoint(e.clientX, e.clientY);
  if (el.dataset.tooltip) {
    showTooltip(el.dataset.tooltip, e.clientX, e.clientY);
  }
});
```

---

## 1.2.7 Document Collections

### forms, images, links, scripts

```javascript
// Legacy HTMLCollections - live collections of specific elements

// All <form> elements
console.log(document.forms);              // HTMLCollection
console.log(document.forms.length);       // Number of forms
console.log(document.forms[0]);           // First form
console.log(document.forms.myForm);       // Form with name="myForm"

// All <img> elements
console.log(document.images);
console.log(document.images.length);

// All <a> and <area> elements with href
console.log(document.links);

// All <script> elements
console.log(document.scripts);

// All <style> and <link rel="stylesheet"> elements
console.log(document.styleSheets);

// All <embed> elements
console.log(document.embeds);
console.log(document.plugins);  // Same as embeds

// ⚠️ These are LIVE collections
// Adding/removing elements updates them automatically
const formCount = document.forms.length;  // e.g., 2
document.body.innerHTML += '<form></form>';
console.log(document.forms.length);       // 3 (updated!)
```

### Accessing Forms by Name

```javascript
// Forms can be accessed by name attribute
// <form name="login">...</form>
const loginForm = document.forms.login;
const loginForm2 = document.forms['login'];
const loginForm3 = document.forms.namedItem('login');

// Form elements can be accessed the same way
// <input name="username">
const username = loginForm.elements.username;
const password = loginForm.elements.password;

// Or by index
const firstInput = loginForm.elements[0];
```

---

## 1.2.8 Common Pitfalls

### Pitfall 1: Accessing DOM Before Ready

```javascript
// ❌ Script in <head> without defer
// document.body is null!
document.body.className = 'loaded';  // TypeError

// ✅ Use DOMContentLoaded or defer
document.addEventListener('DOMContentLoaded', () => {
  document.body.className = 'loaded';
});
```

### Pitfall 2: document.write After Load

```javascript
// ❌ document.write after page load replaces everything
setTimeout(() => {
  document.write('Oops!');  // Entire page wiped!
}, 1000);

// ✅ Use DOM methods instead
setTimeout(() => {
  document.body.innerHTML = '<p>New content</p>';
}, 1000);
```

### Pitfall 3: Cookie String Manipulation

```javascript
// ❌ Thinking document.cookie = 'x=1' replaces all cookies
document.cookie = 'a=1';
document.cookie = 'b=2';  // Both a and b exist now

// ❌ Forgetting to encode values
document.cookie = 'name=John Doe';  // Space may cause issues

// ✅ Always encode
document.cookie = `name=${encodeURIComponent('John Doe')}`;
```

### Pitfall 4: Live vs Static Collections

```javascript
// document.forms/images/links are LIVE
const forms = document.forms;
console.log(forms.length);  // 2

document.body.appendChild(document.createElement('form'));
console.log(forms.length);  // 3 (automatically updated!)

// querySelectorAll returns STATIC NodeList
const forms2 = document.querySelectorAll('form');
console.log(forms2.length);  // 3

document.body.appendChild(document.createElement('form'));
console.log(forms2.length);  // Still 3 (not updated)
```

---

## 1.2.9 Summary

| Property/Method | Purpose |
|-----------------|---------|
| `document.documentElement` | Root `<html>` element |
| `document.head` | `<head>` element |
| `document.body` | `<body>` element |
| `document.title` | Document title (read/write) |
| `document.URL` | Full document URL |
| `document.referrer` | URL of linking page |
| `document.readyState` | Loading state (loading/interactive/complete) |
| `document.cookie` | Cookie access (read/write) |
| `document.activeElement` | Currently focused element |
| `document.hasFocus()` | Whether document has focus |
| `document.getSelection()` | Current text selection |
| `document.elementFromPoint()` | Element at coordinates |
| `document.forms/images/links` | Live element collections |

### Best Practices

1. **Always wait for DOM ready** — use `DOMContentLoaded` or `defer`
2. **Never use `document.write()`** — use DOM methods instead
3. **Use `document.cookie` carefully** — encode values, set proper flags
4. **Prefer `querySelector`** over legacy collections
5. **Check `readyState`** before accessing body

---

**End of Chapter 1.2: Document Interface**

Next chapter: **1.3 Selecting Elements** — covers `getElementById`, `querySelector`, `querySelectorAll`, and more.
# 1.3 Selecting Elements

Selecting elements is the most fundamental DOM operation. Before you can read content, change styles, or attach event listeners, you must first obtain a reference to the target element. JavaScript provides multiple selection methods, each with distinct performance characteristics and use cases.

This chapter covers every selection method in depth — when to use each, performance implications, and common pitfalls that trip up developers.

---

## 1.3.1 getElementById

The fastest and most direct way to select a single element.

### How It Works

```javascript
// HTML: <div id="app">Content</div>

const app = document.getElementById('app');

console.log(app);              // <div id="app">Content</div>
console.log(app.id);           // "app"
console.log(app.textContent);  // "Content"
```

### Key Characteristics

```javascript
// Returns single Element or null (never a collection)
const found = document.getElementById('exists');     // Element
const notFound = document.getElementById('missing'); // null

// IDs should be unique; if duplicates exist, returns FIRST match
// <div id="dup">First</div>
// <div id="dup">Second</div>
const el = document.getElementById('dup');  // First one

// ID matching is case-sensitive in HTML5
document.getElementById('App');  // null (if id is "app")

// Do NOT include # in the ID
document.getElementById('#app');  // null (wrong!)
document.getElementById('app');   // correct
```

### Performance

```javascript
// getElementById is the FASTEST selection method
// Browsers maintain an ID → Element hash map

// Benchmark comparison (relative):
// getElementById:    1x (baseline)
// querySelector:     2-3x slower
// getElementsByClassName: 1.5x slower (but returns collection)

// Use getElementById when:
// - You know the exact ID
// - You need maximum performance
// - You only need one element
```

### Gotchas

```javascript
// ❌ GOTCHA: IDs with special characters need querySelector
// <div id="user:123">...</div>
document.getElementById('user:123');  // null (some browsers)
document.querySelector('#user\\:123');  // Works (escaped)

// ❌ GOTCHA: getElementById only on document
const parent = document.getElementById('parent');
parent.getElementById('child');  // ERROR: not a method on Element!

// ✅ Use querySelector on elements
parent.querySelector('#child');  // Works
```

---

## 1.3.2 getElementsByClassName

Returns a **live HTMLCollection** of elements with the specified class.

### How It Works

```javascript
// HTML:
// <p class="intro">First</p>
// <p class="intro">Second</p>
// <p class="outro">Third</p>

const intros = document.getElementsByClassName('intro');

console.log(intros);           // HTMLCollection(2) [p.intro, p.intro]
console.log(intros.length);    // 2
console.log(intros[0]);        // <p class="intro">First</p>
console.log(intros.item(1));   // <p class="intro">Second</p>
```

### Multiple Classes

```javascript
// Match elements with BOTH classes
// <div class="card featured">...</div>
// <div class="card">...</div>
// <div class="featured">...</div>

const featuredCards = document.getElementsByClassName('card featured');
console.log(featuredCards.length);  // 1 (only the element with both)

// Order doesn't matter
document.getElementsByClassName('featured card');  // Same result
```

### Live Collection Behavior

```javascript
const items = document.getElementsByClassName('item');
console.log(items.length);  // 3

// Add a new element with class="item"
const newItem = document.createElement('div');
newItem.className = 'item';
document.body.appendChild(newItem);

console.log(items.length);  // 4 (automatically updated!)

// ⚠️ This can cause issues in loops
const elements = document.getElementsByClassName('remove-me');

// ❌ WRONG: Collection shrinks as you remove, skipping elements!
for (let i = 0; i < elements.length; i++) {
  elements[i].remove();
}

// ✅ CORRECT: Iterate backwards
for (let i = elements.length - 1; i >= 0; i--) {
  elements[i].remove();
}

// ✅ CORRECT: Convert to static array first
Array.from(elements).forEach(el => el.remove());

// ✅ CORRECT: Use while loop
while (elements.length > 0) {
  elements[0].remove();
}
```

### Scoped Selection

```javascript
// Can be called on any element, not just document
const nav = document.getElementById('nav');
const navLinks = nav.getElementsByClassName('link');

// Only finds .link elements inside #nav
```

---

## 1.3.3 getElementsByTagName

Returns a **live HTMLCollection** of elements with the specified tag name.

### How It Works

```javascript
const paragraphs = document.getElementsByTagName('p');

console.log(paragraphs);        // HTMLCollection of all <p> elements
console.log(paragraphs.length); // Number of paragraphs

// Tag name is case-insensitive
document.getElementsByTagName('DIV');  // Same as 'div'
document.getElementsByTagName('P');    // Same as 'p'
```

### Special Cases

```javascript
// Get ALL elements
const allElements = document.getElementsByTagName('*');
console.log(allElements.length);  // Total number of elements

// Scoped to parent
const table = document.querySelector('table');
const cells = table.getElementsByTagName('td');

// Works with SVG and other namespaced elements
const svgElements = document.getElementsByTagName('circle');
```

### Performance Note

```javascript
// getElementsByTagName is very fast for simple tag queries
// Use it when:
// - You need all elements of a specific type
// - You're working with a known structure
// - You need a live collection

// Avoid when:
// - You need to filter by attributes/classes (use querySelector)
// - You need a static snapshot (convert to array)
```

---

## 1.3.4 getElementsByName

Returns a **live NodeList** of elements with the specified `name` attribute.

### How It Works

```javascript
// HTML:
// <input type="radio" name="color" value="red">
// <input type="radio" name="color" value="blue">
// <input type="radio" name="size" value="large">

const colorInputs = document.getElementsByName('color');

console.log(colorInputs);        // NodeList(2)
console.log(colorInputs.length); // 2
console.log(colorInputs[0].value); // "red"
```

### Primary Use Case: Form Controls

```javascript
// Radio button groups
const colors = document.getElementsByName('color');
let selectedColor;
colors.forEach(radio => {
  if (radio.checked) {
    selectedColor = radio.value;
  }
});

// Or more concisely
const selected = document.querySelector('input[name="color"]:checked');

// Checkbox groups
const features = document.getElementsByName('features');
const selectedFeatures = Array.from(features)
  .filter(cb => cb.checked)
  .map(cb => cb.value);
```

### Note: Returns NodeList, Not HTMLCollection

```javascript
// getElementsByName returns NodeList (has forEach)
const inputs = document.getElementsByName('field');
inputs.forEach(input => console.log(input.value));

// getElementsByClassName/TagName return HTMLCollection (no forEach)
const divs = document.getElementsByClassName('box');
// divs.forEach(...)  // ERROR!
Array.from(divs).forEach(div => console.log(div));
```

---

## 1.3.5 querySelector

Returns the **first** element matching a CSS selector. The most versatile selection method.

### How It Works

```javascript
// Select by ID
const app = document.querySelector('#app');

// Select by class
const firstCard = document.querySelector('.card');

// Select by tag
const firstParagraph = document.querySelector('p');

// Select by attribute
const emailInput = document.querySelector('input[type="email"]');

// Complex selectors
const activeMenuItem = document.querySelector('nav > ul > li.active');
const firstChildParagraph = document.querySelector('article p:first-child');
```

### Returns First Match or Null

```javascript
// Always returns ONE element or null
const card = document.querySelector('.card');

if (card) {
  card.classList.add('selected');
}

// For multiple elements, use querySelectorAll
```

### Any Valid CSS Selector Works

```javascript
// Descendant
document.querySelector('article p');

// Child
document.querySelector('ul > li');

// Adjacent sibling
document.querySelector('h2 + p');

// General sibling
document.querySelector('h2 ~ p');

// Attribute selectors
document.querySelector('[data-id]');           // Has attribute
document.querySelector('[data-id="123"]');     // Exact value
document.querySelector('[href^="https"]');     // Starts with
document.querySelector('[href$=".pdf"]');      // Ends with
document.querySelector('[class*="card"]');     // Contains

// Pseudo-classes
document.querySelector('li:first-child');
document.querySelector('li:last-child');
document.querySelector('li:nth-child(2)');
document.querySelector('li:nth-child(odd)');
document.querySelector('input:checked');
document.querySelector('input:disabled');
document.querySelector('a:not(.external)');
document.querySelector('input:focus');

// Multiple selectors (matches first from either)
document.querySelector('h1, h2, h3');

// Pseudo-elements DON'T work (they're not elements)
document.querySelector('p::before');  // null (can't select pseudo-elements)
```

### Scoped Selection

```javascript
// Call querySelector on any element
const nav = document.getElementById('nav');
const activeLink = nav.querySelector('a.active');

// Selectors are relative to the element
// <nav id="nav">
//   <ul>
//     <li><a class="active">Link</a></li>
//   </ul>
// </nav>

nav.querySelector('a');  // First <a> inside nav
nav.querySelector('ul > li:first-child a');  // More specific
```

### :scope Pseudo-Class

```javascript
// :scope refers to the element querySelector is called on
const parent = document.querySelector('.parent');

// Select direct children only
parent.querySelector(':scope > .child');

// Without :scope, this would search anywhere in parent:
parent.querySelector('.child');  // Any .child descendant
```

---

## 1.3.6 querySelectorAll

Returns a **static NodeList** of ALL elements matching a CSS selector.

### How It Works

```javascript
const cards = document.querySelectorAll('.card');

console.log(cards);        // NodeList(5)
console.log(cards.length); // 5
console.log(cards[0]);     // First card
```

### Static Collection (Not Live)

```javascript
const cards = document.querySelectorAll('.card');
console.log(cards.length);  // 3

// Add a new card
const newCard = document.createElement('div');
newCard.className = 'card';
document.body.appendChild(newCard);

console.log(cards.length);  // Still 3! (not updated)

// To get updated list, call querySelectorAll again
const updatedCards = document.querySelectorAll('.card');
console.log(updatedCards.length);  // 4
```

### Iterating NodeList

```javascript
const items = document.querySelectorAll('.item');

// forEach (works on NodeList!)
items.forEach(item => {
  console.log(item.textContent);
});

// for...of
for (const item of items) {
  console.log(item.textContent);
}

// Classic for loop
for (let i = 0; i < items.length; i++) {
  console.log(items[i].textContent);
}

// Convert to array for array methods
const itemArray = Array.from(items);
const filtered = itemArray.filter(item => item.classList.contains('active'));

// Or spread
const itemArray2 = [...items];
```

### Complex Selections

```javascript
// Multiple selectors (OR)
const headings = document.querySelectorAll('h1, h2, h3, h4, h5, h6');

// Specific patterns
const evenRows = document.querySelectorAll('tr:nth-child(even)');
const notFirst = document.querySelectorAll('li:not(:first-child)');
const hasDataId = document.querySelectorAll('[data-id]');

// Scoped selection
const nav = document.querySelector('nav');
const navLinks = nav.querySelectorAll('a');
```

---

## 1.3.7 closest

Traverses UP the DOM tree to find the nearest ancestor (including self) matching a selector.

### How It Works

```javascript
// HTML:
// <div class="card" data-id="42">
//   <div class="content">
//     <button class="delete">Delete</button>
//   </div>
// </div>

const button = document.querySelector('.delete');

// Find closest ancestor with class "card"
const card = button.closest('.card');
console.log(card);               // <div class="card" data-id="42">
console.log(card.dataset.id);    // "42"

// closest checks the element itself first
button.closest('.delete');       // Returns the button itself
button.closest('button');        // Also returns the button

// Returns null if no match found
button.closest('form');          // null
```

### Primary Use Case: Event Delegation

```javascript
// Handle clicks on dynamically added elements
document.body.addEventListener('click', (e) => {
  // Find if click was inside a card
  const card = e.target.closest('.card');
  if (card) {
    console.log('Clicked card:', card.dataset.id);
  }
  
  // Check for specific button
  const deleteBtn = e.target.closest('.delete-btn');
  if (deleteBtn) {
    const card = deleteBtn.closest('.card');
    deleteCard(card);
  }
});
```

### Gotchas

```javascript
// closest starts from the element itself
const div = document.querySelector('.child');

// If .child is itself inside .parent, this works:
div.closest('.parent');  // Finds the parent

// If .child IS the .parent, it returns itself:
// <div class="child parent">...</div>
div.closest('.parent');  // Returns div (itself!)

// closest doesn't search DOWN, only UP
const parent = document.querySelector('.parent');
parent.closest('.child');  // null (children are not ancestors)
```

---

## 1.3.8 matches

Tests whether an element matches a CSS selector. Returns boolean.

### How It Works

```javascript
const element = document.querySelector('.card');

// Test if element matches selector
console.log(element.matches('.card'));         // true
console.log(element.matches('.card.active'));  // depends on classes
console.log(element.matches('div'));           // true if it's a div
console.log(element.matches('#myCard'));       // depends on ID
```

### Use Case: Filtering Elements

```javascript
const elements = document.querySelectorAll('.item');

// Filter to only active items
const activeItems = Array.from(elements)
  .filter(el => el.matches('.active'));

// Check condition
elements.forEach(el => {
  if (el.matches('[data-important]')) {
    el.classList.add('highlighted');
  }
});
```

### Use Case: Event Delegation

```javascript
// Check if clicked element matches a selector
document.body.addEventListener('click', (e) => {
  if (e.target.matches('button.submit')) {
    handleSubmit(e);
  }
  
  if (e.target.matches('a[href^="http"]')) {
    // External link clicked
    trackOutboundLink(e.target.href);
  }
});
```

### Combined with closest

```javascript
document.body.addEventListener('click', (e) => {
  // Does clicked element or any ancestor match?
  const button = e.target.closest('button');
  if (button && button.matches('.delete')) {
    handleDelete(button);
  }
});
```

---

## 1.3.9 Live vs Static Collections

Understanding the difference is crucial for avoiding bugs.

### HTMLCollection (Live)

```javascript
// getElementsByClassName, getElementsByTagName return HTMLCollection

const items = document.getElementsByClassName('item');
console.log(items.length);  // 3

// Add element
document.body.innerHTML += '<div class="item">New</div>';
console.log(items.length);  // 4 (automatically updated!)

// Remove element
items[0].remove();
console.log(items.length);  // 3 (automatically updated!)

// HTMLCollection characteristics:
// - Live (updates automatically)
// - No forEach (must convert to array)
// - Access by index or namedItem()
```

### NodeList (Can Be Live or Static)

```javascript
// querySelectorAll returns STATIC NodeList
const qsItems = document.querySelectorAll('.item');
// Changes to DOM don't affect qsItems

// childNodes returns LIVE NodeList
const children = document.body.childNodes;
// Adding children updates this list

// NodeList characteristics:
// - Has forEach
// - Has length
// - Has item() method
```

### When to Use Each

```javascript
// Use getElementsBy* when:
// - You need a live collection (rare)
// - Maximum performance for simple queries
// - You're repeatedly checking the collection

// Use querySelectorAll when:
// - You need a snapshot at a point in time
// - You want forEach support
// - You have complex selection criteria
// - You're modifying the DOM in a loop

// Performance comparison:
// getElementsByClassName: ~0.1ms
// querySelectorAll:       ~0.3ms
// But querySelectorAll is more predictable
```

---

## 1.3.10 Selection Performance

### Performance Hierarchy

```javascript
// Fastest to slowest:
// 1. getElementById         - O(1) hash lookup
// 2. getElementsByClassName - optimized internal
// 3. getElementsByTagName   - optimized internal
// 4. querySelector          - CSS parser overhead
// 5. querySelectorAll       - CSS parser + collection build

// But... readability and maintainability often matter more
// The difference is microseconds in most cases
```

### Caching Selections

```javascript
// ❌ BAD: Re-selecting in loop
function highlightAll() {
  for (let i = 0; i < 1000; i++) {
    const box = document.getElementById('box');  // 1000 lookups!
    box.style.opacity = i / 1000;
  }
}

// ✅ GOOD: Cache the selection
function highlightAll() {
  const box = document.getElementById('box');  // 1 lookup
  for (let i = 0; i < 1000; i++) {
    box.style.opacity = i / 1000;
  }
}

// ✅ GOOD: Cache at module level for frequently used elements
const elements = {
  app: document.getElementById('app'),
  header: document.getElementById('header'),
  nav: document.querySelector('nav'),
};

function update() {
  elements.header.textContent = 'Updated';
}
```

### Narrow Your Scope

```javascript
// ❌ Slow: Search entire document
const button = document.querySelector('section#main article.featured button.cta');

// ✅ Faster: Narrow scope first
const section = document.getElementById('main');
const article = section.querySelector('.featured');
const button = article.querySelector('.cta');

// Each query searches fewer elements
```

---

## 1.3.11 Summary

| Method | Returns | Live? | Performance | Use Case |
|--------|---------|-------|-------------|----------|
| `getElementById` | Element/null | N/A | Fastest | Single element by ID |
| `getElementsByClassName` | HTMLCollection | Yes | Fast | Multiple by class |
| `getElementsByTagName` | HTMLCollection | Yes | Fast | Multiple by tag |
| `getElementsByName` | NodeList | Yes | Fast | Form elements |
| `querySelector` | Element/null | N/A | Medium | First match, any selector |
| `querySelectorAll` | NodeList | No | Medium | All matches, any selector |
| `closest` | Element/null | N/A | Medium | Find ancestor |
| `matches` | Boolean | N/A | Fast | Test selector |

### Best Practices

1. **Use `getElementById` for IDs** — fastest and clearest
2. **Use `querySelector` for complex selections** — most flexible
3. **Cache DOM references** — don't re-query in loops
4. **Be aware of live vs static** — convert to array when modifying
5. **Narrow your scope** — call selection methods on parent elements
6. **Use `closest` for event delegation** — cleaner than manual traversal

---

**End of Chapter 1.3: Selecting Elements**

Next chapter: **1.4 Creating Elements** — covers `createElement`, `createTextNode`, `createDocumentFragment`, and `cloneNode`.
# 1.4 Creating Elements

Creating DOM elements programmatically is fundamental to building dynamic web applications. Whether you're rendering data from an API, building UI components, or creating interactive features, you'll frequently need to create and insert elements.

This chapter covers all element creation methods, from basic `createElement` to performance-optimized `DocumentFragment`, plus cloning techniques and best practices.

---

## 1.4.1 createElement

The primary method for creating new elements.

### How It Works

```javascript
// Create an element by tag name
const div = document.createElement('div');
const paragraph = document.createElement('p');
const button = document.createElement('button');

// Element is created but NOT in the document yet
console.log(div.parentNode);  // null

// Add to document
document.body.appendChild(div);
console.log(div.parentNode);  // <body>
```

### Setting Properties and Attributes

```javascript
const link = document.createElement('a');

// Set properties directly
link.href = 'https://example.com';
link.textContent = 'Visit Example';
link.className = 'external-link';
link.id = 'main-link';

// Set attributes
link.setAttribute('target', '_blank');
link.setAttribute('rel', 'noopener noreferrer');
link.setAttribute('data-category', 'external');

// Custom data attributes
link.dataset.trackId = '12345';
link.dataset.source = 'homepage';

// Result:
// <a href="https://example.com" 
//    class="external-link" 
//    id="main-link" 
//    target="_blank" 
//    rel="noopener noreferrer"
//    data-category="external"
//    data-track-id="12345"
//    data-source="homepage">Visit Example</a>
```

### Creating Different Element Types

```javascript
// Form elements
const input = document.createElement('input');
input.type = 'email';
input.name = 'email';
input.placeholder = 'Enter your email';
input.required = true;

const select = document.createElement('select');
select.name = 'country';

const option = document.createElement('option');
option.value = 'us';
option.textContent = 'United States';
select.appendChild(option);

// Table elements
const table = document.createElement('table');
const row = document.createElement('tr');
const cell = document.createElement('td');
cell.textContent = 'Cell content';
row.appendChild(cell);
table.appendChild(row);

// Image
const img = document.createElement('img');
img.src = '/images/photo.jpg';
img.alt = 'A photo';
img.loading = 'lazy';  // Native lazy loading

// Canvas
const canvas = document.createElement('canvas');
canvas.width = 800;
canvas.height = 600;
const ctx = canvas.getContext('2d');
```

### Creating Custom Elements

```javascript
// If you've defined a custom element
class MyCard extends HTMLElement {
  connectedCallback() {
    this.innerHTML = '<div class="card-content"></div>';
  }
}
customElements.define('my-card', MyCard);

// Create it like any other element
const card = document.createElement('my-card');
document.body.appendChild(card);
```

---

## 1.4.2 createTextNode

Creates a text node that can be appended to elements.

### How It Works

```javascript
const text = document.createTextNode('Hello, World!');

const paragraph = document.createElement('p');
paragraph.appendChild(text);
document.body.appendChild(paragraph);

// Result: <p>Hello, World!</p>
```

### Why Use createTextNode?

```javascript
// createTextNode is safe from XSS - content is never parsed as HTML
const userInput = '<script>alert("XSS")</script>';

// ❌ DANGEROUS: innerHTML parses HTML
const div1 = document.createElement('div');
div1.innerHTML = userInput;  // XSS risk!

// ✅ SAFE: createTextNode treats input as plain text
const div2 = document.createElement('div');
const text = document.createTextNode(userInput);
div2.appendChild(text);
// Result: <div>&lt;script&gt;alert("XSS")&lt;/script&gt;</div>
// The script is displayed as text, not executed

// ✅ ALSO SAFE: textContent treats input as plain text
const div3 = document.createElement('div');
div3.textContent = userInput;  // Same safe result
```

### Combining Text with Other Elements

```javascript
// Building: <p>Click <a href="#">here</a> to continue.</p>

const p = document.createElement('p');

// Add text node
p.appendChild(document.createTextNode('Click '));

// Add link
const link = document.createElement('a');
link.href = '#';
link.textContent = 'here';
p.appendChild(link);

// Add more text
p.appendChild(document.createTextNode(' to continue.'));

document.body.appendChild(p);
```

### Whitespace and Special Characters

```javascript
// Whitespace is preserved
const text1 = document.createTextNode('   spaces preserved   ');

// Special characters are displayed, not interpreted
const text2 = document.createTextNode('5 > 3 and 2 < 4');
// Result: "5 > 3 and 2 < 4" (displayed correctly)

// Newlines become single spaces in inline context
const text3 = document.createTextNode('Line 1\nLine 2');
// In HTML: appears as "Line 1 Line 2" unless in <pre> or white-space: pre
```

---

## 1.4.3 createDocumentFragment

A lightweight container for building DOM structures efficiently.

### The Problem It Solves

```javascript
// ❌ SLOW: Multiple DOM operations cause multiple reflows
const list = document.getElementById('list');

for (let i = 0; i < 1000; i++) {
  const li = document.createElement('li');
  li.textContent = `Item ${i}`;
  list.appendChild(li);  // 1000 DOM operations!
}
```

### Using DocumentFragment

```javascript
// ✅ FAST: Build in fragment, insert once
const list = document.getElementById('list');
const fragment = document.createDocumentFragment();

for (let i = 0; i < 1000; i++) {
  const li = document.createElement('li');
  li.textContent = `Item ${i}`;
  fragment.appendChild(li);  // No reflow - fragment is not in DOM
}

list.appendChild(fragment);  // Single DOM operation!
```

### How It Works

```javascript
const fragment = document.createDocumentFragment();

// Fragment is a minimal document that can hold nodes
console.log(fragment.nodeType);  // 11 (DOCUMENT_FRAGMENT_NODE)

// You can append multiple elements
const h1 = document.createElement('h1');
h1.textContent = 'Title';
const p = document.createElement('p');
p.textContent = 'Content';

fragment.appendChild(h1);
fragment.appendChild(p);

// Fragment itself is never inserted
// Only its children are moved to the target
document.body.appendChild(fragment);

// After insertion, fragment is empty
console.log(fragment.childNodes.length);  // 0
console.log(fragment.hasChildNodes());    // false
```

### Building Complex Structures

```javascript
function createCard(data) {
  const fragment = document.createDocumentFragment();
  
  const card = document.createElement('article');
  card.className = 'card';
  
  const header = document.createElement('header');
  header.textContent = data.title;
  
  const content = document.createElement('div');
  content.className = 'content';
  content.textContent = data.description;
  
  const footer = document.createElement('footer');
  const button = document.createElement('button');
  button.textContent = 'Learn More';
  footer.appendChild(button);
  
  card.appendChild(header);
  card.appendChild(content);
  card.appendChild(footer);
  
  fragment.appendChild(card);
  
  return fragment;
}

// Usage
const container = document.getElementById('cards');
const data = [
  { title: 'Card 1', description: 'First card' },
  { title: 'Card 2', description: 'Second card' },
];

const fragment = document.createDocumentFragment();
data.forEach(item => {
  fragment.appendChild(createCard(item));
});
container.appendChild(fragment);
```

### Query Methods on Fragments

```javascript
const fragment = document.createDocumentFragment();

const div1 = document.createElement('div');
div1.className = 'item';
div1.id = 'first';

const div2 = document.createElement('div');
div2.className = 'item';

fragment.appendChild(div1);
fragment.appendChild(div2);

// querySelector works on fragments
const first = fragment.querySelector('.item');
console.log(first.id);  // "first"

// querySelectorAll too
const items = fragment.querySelectorAll('.item');
console.log(items.length);  // 2

// But getElementById does NOT work
fragment.getElementById('first');  // ERROR: not a method
```

---

## 1.4.4 cloneNode

Creates a copy of an existing node.

### Shallow Clone

```javascript
const original = document.querySelector('.card');
// <div class="card" data-id="1">
//   <h2>Title</h2>
//   <p>Content</p>
// </div>

// Shallow clone - copies element only, not children
const shallowClone = original.cloneNode(false);
console.log(shallowClone.outerHTML);
// <div class="card" data-id="1"></div>
// Note: children are NOT copied
```

### Deep Clone

```javascript
// Deep clone - copies element AND all descendants
const deepClone = original.cloneNode(true);
console.log(deepClone.outerHTML);
// <div class="card" data-id="1">
//   <h2>Title</h2>
//   <p>Content</p>
// </div>
```

### What Gets Cloned

```javascript
const original = document.getElementById('original');

// These ARE copied:
// - The element itself
// - All attributes (class, id, data-*, etc.)
// - Inline styles
// - Children (if deep clone)

// These are NOT copied:
// - Event listeners added with addEventListener
// - Properties set via JavaScript (that aren't attributes)
// - Expanded state of form elements (partially)

// Example with event listeners
original.addEventListener('click', () => console.log('clicked'));
const clone = original.cloneNode(true);
// clone does NOT have the click listener!

// Example with properties
original.myCustomProp = 'value';
const clone2 = original.cloneNode(true);
console.log(clone2.myCustomProp);  // undefined
```

### Handling ID Conflicts

```javascript
// ⚠️ Cloning an element with an ID creates duplicates!
const original = document.getElementById('uniqueId');
const clone = original.cloneNode(true);
document.body.appendChild(clone);

// Now there are TWO elements with id="uniqueId" - bad!
// document.getElementById('uniqueId') returns the first one

// ✅ Always update IDs on clones
const clone2 = original.cloneNode(true);
clone2.id = 'uniqueId-copy';
// Or remove it
clone2.removeAttribute('id');
```

### Common Use Cases

```javascript
// 1. Template-based creation
const template = document.querySelector('.card-template');
function createCard(data) {
  const card = template.cloneNode(true);
  card.classList.remove('card-template');
  card.classList.add('card');
  card.querySelector('.title').textContent = data.title;
  card.querySelector('.content').textContent = data.content;
  card.removeAttribute('hidden');
  return card;
}

// 2. Repeating elements
const row = document.querySelector('tr.template');
for (let i = 0; i < 10; i++) {
  const newRow = row.cloneNode(true);
  newRow.classList.remove('template');
  newRow.cells[0].textContent = i + 1;
  tbody.appendChild(newRow);
}

// 3. Moving elements (clone then remove original)
const element = document.getElementById('moveable');
const clone = element.cloneNode(true);
newParent.appendChild(clone);
element.remove();
```

---

## 1.4.5 Using Templates

The `<template>` element provides a native way to define reusable content.

### Template Element Basics

```html
<!-- Templates are not rendered -->
<template id="card-template">
  <div class="card">
    <h2 class="card-title"></h2>
    <p class="card-content"></p>
    <button class="card-action">Learn More</button>
  </div>
</template>
```

```javascript
// Get the template
const template = document.getElementById('card-template');

// Template content is in a DocumentFragment
console.log(template.content);  // #document-fragment

// Clone the content
const clone = template.content.cloneNode(true);

// Fill in the data
clone.querySelector('.card-title').textContent = 'My Card';
clone.querySelector('.card-content').textContent = 'Card description here';

// Insert into document
document.getElementById('container').appendChild(clone);
```

### Why Use Templates

```javascript
// 1. Better separation of concerns
// HTML structure stays in HTML, not JavaScript strings

// 2. Better IDE support
// Templates in HTML get syntax highlighting, validation

// 3. No XSS from template
// Template content is inert - scripts don't run, images don't load

// 4. Performance
// Browser parses template once, cloning is fast
```

### Template with Slots (Shadow DOM)

```javascript
// For Web Components, templates work with slots
const template = document.createElement('template');
template.innerHTML = `
  <style>
    .wrapper { border: 1px solid #ccc; padding: 1rem; }
  </style>
  <div class="wrapper">
    <slot name="title"></slot>
    <slot></slot>
  </div>
`;

class MyComponent extends HTMLElement {
  constructor() {
    super();
    const shadow = this.attachShadow({ mode: 'open' });
    shadow.appendChild(template.content.cloneNode(true));
  }
}
```

---

## 1.4.6 createElement vs innerHTML

Understanding when to use each approach.

### innerHTML: Quick but Risky

```javascript
// ✅ innerHTML is fast for static content
container.innerHTML = '<h1>Welcome</h1><p>Hello there</p>';

// ❌ Never use innerHTML with user data!
const userInput = '<img src=x onerror="alert(\'XSS\')">';
container.innerHTML = userInput;  // XSS attack!

// innerHTML destroys existing event listeners
container.innerHTML += '<p>More content</p>';
// All listeners on existing children are gone!
```

### createElement: Safe and Flexible

```javascript
// ✅ Safe with any input
const div = document.createElement('div');
div.textContent = userInput;  // Treated as text, not HTML

// ✅ Preserves existing content and listeners
container.appendChild(div);  // Existing children untouched

// ❌ More verbose for complex structures
const list = document.createElement('ul');
const items = ['a', 'b', 'c'];
items.forEach(item => {
  const li = document.createElement('li');
  li.textContent = item;
  list.appendChild(li);
});
```

### Performance Comparison

```javascript
// For small, simple content: innerHTML is faster
container.innerHTML = '<div><p>Small content</p></div>';

// For many items: createElement + fragment is faster
const fragment = document.createDocumentFragment();
for (let i = 0; i < 10000; i++) {
  const div = document.createElement('div');
  div.textContent = `Item ${i}`;
  fragment.appendChild(div);
}
container.appendChild(fragment);

// innerHTML with large strings forces complete re-parse
// createElement builds the tree directly
```

### Best Practice: Sanitize or Avoid

```javascript
// If you must use innerHTML with user data, sanitize it
import DOMPurify from 'dompurify';

const clean = DOMPurify.sanitize(userInput);
container.innerHTML = clean;

// Or use a templating library that auto-escapes
// (React, Vue, etc. do this automatically)
```

---

## 1.4.7 Factory Pattern for Elements

Creating helper functions for cleaner code.

### Basic Factory

```javascript
function createElement(tag, options = {}) {
  const element = document.createElement(tag);
  
  // Set attributes
  if (options.attrs) {
    for (const [key, value] of Object.entries(options.attrs)) {
      element.setAttribute(key, value);
    }
  }
  
  // Set properties
  if (options.props) {
    Object.assign(element, options.props);
  }
  
  // Add classes
  if (options.classes) {
    element.classList.add(...options.classes);
  }
  
  // Set text content
  if (options.text) {
    element.textContent = options.text;
  }
  
  // Append children
  if (options.children) {
    options.children.forEach(child => {
      if (typeof child === 'string') {
        element.appendChild(document.createTextNode(child));
      } else {
        element.appendChild(child);
      }
    });
  }
  
  // Add event listeners
  if (options.events) {
    for (const [event, handler] of Object.entries(options.events)) {
      element.addEventListener(event, handler);
    }
  }
  
  return element;
}
```

### Usage

```javascript
const card = createElement('article', {
  classes: ['card', 'featured'],
  attrs: { 'data-id': '42' },
  children: [
    createElement('h2', { text: 'Card Title' }),
    createElement('p', { 
      text: 'Card content goes here',
      classes: ['content']
    }),
    createElement('button', {
      text: 'Click Me',
      events: {
        click: () => console.log('Clicked!')
      }
    })
  ]
});

document.body.appendChild(card);
```

### JSX-like Syntax (without React)

```javascript
// A more React-like factory
function h(tag, props = {}, ...children) {
  const element = document.createElement(tag);
  
  for (const [key, value] of Object.entries(props)) {
    if (key === 'className') {
      element.className = value;
    } else if (key.startsWith('on')) {
      const event = key.slice(2).toLowerCase();
      element.addEventListener(event, value);
    } else if (key === 'style' && typeof value === 'object') {
      Object.assign(element.style, value);
    } else {
      element.setAttribute(key, value);
    }
  }
  
  children.forEach(child => {
    if (typeof child === 'string') {
      element.appendChild(document.createTextNode(child));
    } else if (child instanceof Node) {
      element.appendChild(child);
    }
  });
  
  return element;
}

// Usage looks cleaner
const nav = h('nav', { className: 'main-nav' },
  h('a', { href: '/', onClick: handleHome }, 'Home'),
  h('a', { href: '/about' }, 'About'),
  h('a', { href: '/contact' }, 'Contact')
);
```

---

## 1.4.8 Summary

| Method | Purpose | Returns | Key Notes |
|--------|---------|---------|-----------|
| `createElement(tag)` | Create new element | Element | Main creation method |
| `createTextNode(text)` | Create text node | Text | XSS-safe for user input |
| `createDocumentFragment()` | Create container | DocumentFragment | Batch insertions, no reflow |
| `cloneNode(deep)` | Copy existing node | Node | Events not copied |
| `template.content` | Get template content | DocumentFragment | Native templating |

### Best Practices

1. **Use `createDocumentFragment`** when adding multiple elements
2. **Never use `innerHTML` with user data** — XSS vulnerability
3. **Use `textContent` or `createTextNode`** for user-provided text
4. **Remember to update IDs** when cloning elements
5. **Consider `<template>` elements** for reusable structures
6. **Build factory functions** for cleaner code at scale
7. **Clone event listeners manually** — they don't copy with `cloneNode`

### Common Gotchas

```javascript
// ❌ Forgetting that fragment empties after insertion
const fragment = document.createDocumentFragment();
fragment.appendChild(div);
body.appendChild(fragment);
console.log(fragment.childNodes.length);  // 0, not 1!

// ❌ Expecting cloned elements to have event listeners
const clone = original.cloneNode(true);
// Clone has no listeners — add them after cloning

// ❌ Creating duplicate IDs with cloneNode
// Always remove or change IDs on clones

// ❌ Using innerHTML += (destroys existing listeners)
container.innerHTML += '<p>New</p>';  // Bad
container.appendChild(createElement('p'));  // Good
```

---

**End of Chapter 1.4: Creating Elements**

Next chapter: **1.5 Manipulating Elements** — covers inserting, removing, and moving elements with `appendChild`, `insertBefore`, `remove`, `append`, `prepend`, `before`, `after`, and `replaceWith`.
# 1.5 Manipulating Elements

Once you've selected or created elements, you need to insert them into the DOM, move them around, or remove them. This chapter covers all DOM manipulation methods — from classic approaches like `appendChild` to modern convenience methods like `append` and `replaceWith`.

Understanding these methods is crucial for building dynamic interfaces that respond to user actions and data changes.

---

## 1.5.1 appendChild

The classic method for adding a child element to a parent.

### How It Works

```javascript
const parent = document.getElementById('container');
const child = document.createElement('div');
child.textContent = 'New content';

// appendChild adds the element as the LAST child
parent.appendChild(child);

// Returns the appended node
const appended = parent.appendChild(child);
console.log(appended === child);  // true
```

### Key Behaviors

```javascript
// appendChild moves elements if already in DOM
const existingElement = document.getElementById('moveable');
const newParent = document.getElementById('new-container');

// This MOVES the element, not copies
newParent.appendChild(existingElement);
// existingElement is no longer in its original location

// To copy instead, clone first
const clone = existingElement.cloneNode(true);
newParent.appendChild(clone);
```

### Appending Multiple Elements

```javascript
// appendChild only takes one node at a time
const parent = document.getElementById('list');

// ❌ This doesn't work
parent.appendChild(child1, child2);  // Only child1 is added

// ✅ Loop or chain
parent.appendChild(child1);
parent.appendChild(child2);
parent.appendChild(child3);

// ✅ Or use DocumentFragment
const fragment = document.createDocumentFragment();
fragment.appendChild(child1);
fragment.appendChild(child2);
fragment.appendChild(child3);
parent.appendChild(fragment);

// ✅ Or use append() - see section 1.5.5
parent.append(child1, child2, child3);
```

---

## 1.5.2 insertBefore

Inserts an element before a specific reference node.

### How It Works

```javascript
const parent = document.getElementById('list');
const newItem = document.createElement('li');
newItem.textContent = 'Inserted item';

// Get the reference node (the element to insert before)
const referenceNode = parent.children[2];  // Third child

// Insert newItem before referenceNode
parent.insertBefore(newItem, referenceNode);
```

### Edge Cases

```javascript
// If referenceNode is null, appendChild to end
parent.insertBefore(newItem, null);
// Same as parent.appendChild(newItem)

// Reference must be a child of parent
const unrelatedElement = document.getElementById('other');
parent.insertBefore(newItem, unrelatedElement);
// DOMException: The node before which the new node is to be 
// inserted is not a child of this node.
```

### Insert at Beginning

```javascript
// Insert as first child
const parent = document.getElementById('container');
const newFirst = document.createElement('div');

parent.insertBefore(newFirst, parent.firstChild);

// If parent has no children, firstChild is null
// So this still works (appends)
```

### Insert After (Helper)

```javascript
// DOM has no native "insertAfter" - build your own
function insertAfter(newNode, referenceNode) {
  referenceNode.parentNode.insertBefore(newNode, referenceNode.nextSibling);
}

// Usage
const newElement = document.createElement('div');
const existingElement = document.getElementById('existing');
insertAfter(newElement, existingElement);

// Or use modern after() method - see section 1.5.6
existingElement.after(newElement);
```

---

## 1.5.3 removeChild

Removes a child element from its parent.

### How It Works

```javascript
const parent = document.getElementById('container');
const child = document.getElementById('remove-me');

// Remove and get reference to removed node
const removed = parent.removeChild(child);

// The element is removed from DOM but still exists in memory
console.log(removed.id);  // "remove-me"
console.log(removed.parentNode);  // null

// Can re-insert it later
document.body.appendChild(removed);
```

### Common Pattern: Remove Self

```javascript
// To remove an element, you need its parent
const element = document.getElementById('remove-me');

// Classic pattern
element.parentNode.removeChild(element);

// Modern alternative (see section 1.5.4)
element.remove();
```

### Remove All Children

```javascript
const container = document.getElementById('container');

// Method 1: Loop (careful with live collections!)
while (container.firstChild) {
  container.removeChild(container.firstChild);
}

// Method 2: innerHTML (faster but has drawbacks)
container.innerHTML = '';
// ⚠️ Destroys event listeners on children

// Method 3: replaceChildren (modern)
container.replaceChildren();
// Removes all children cleanly
```

### Error Handling

```javascript
const parent = document.getElementById('parent');
const notAChild = document.getElementById('other');

try {
  parent.removeChild(notAChild);
} catch (e) {
  console.log(e.name);  // "NotFoundError"
  // "The node to be removed is not a child of this node"
}

// Check first
if (notAChild.parentNode === parent) {
  parent.removeChild(notAChild);
}
```

---

## 1.5.4 remove

Modern method to remove an element from the DOM.

### How It Works

```javascript
const element = document.getElementById('remove-me');

// Simply remove it - no parent reference needed
element.remove();

// Element is detached but still exists
console.log(element.id);  // "remove-me"
console.log(element.parentNode);  // null
```

### Comparison with removeChild

```javascript
const element = document.getElementById('item');

// Classic way - need parent reference
element.parentNode.removeChild(element);

// Modern way - cleaner
element.remove();

// Both achieve the same result
```

### Remove Multiple Elements

```javascript
// Remove all elements matching a selector
document.querySelectorAll('.temp-item').forEach(el => el.remove());

// Remove children matching a condition
const container = document.getElementById('list');
Array.from(container.children)
  .filter(child => child.classList.contains('completed'))
  .forEach(child => child.remove());
```

---

## 1.5.5 append and prepend

Modern methods for inserting content at the end or beginning.

### append()

```javascript
const parent = document.getElementById('container');

// Append single element
const div = document.createElement('div');
parent.append(div);

// Append multiple elements at once!
const p1 = document.createElement('p');
const p2 = document.createElement('p');
const p3 = document.createElement('p');
parent.append(p1, p2, p3);

// Append strings (converted to text nodes)
parent.append('Hello, ', 'World!');

// Mix elements and strings
const strong = document.createElement('strong');
strong.textContent = 'bold';
parent.append('This is ', strong, ' text.');
```

### prepend()

```javascript
const parent = document.getElementById('container');

// Insert at the beginning
const header = document.createElement('header');
parent.prepend(header);

// Multiple items
parent.prepend(child1, child2, 'Some text');

// After prepend, children are:
// [child1, child2, "Some text", ...existing children]
```

### Comparison: appendChild vs append

```javascript
// appendChild:
// - Takes exactly one Node
// - Returns the appended node
// - Classic, older API

const returned = parent.appendChild(child);
console.log(returned === child);  // true

// append:
// - Takes multiple nodes or strings
// - Returns undefined
// - Modern, more flexible

parent.append(child1, child2, 'text');  // Returns undefined
```

---

## 1.5.6 before and after

Insert elements adjacent to (not inside) an element.

### after()

```javascript
const reference = document.getElementById('reference');

// Insert after the reference element (as next sibling)
const newElement = document.createElement('div');
reference.after(newElement);

// Multiple items
reference.after(sibling1, sibling2, 'Text');

// Structure:
// <parent>
//   <div id="reference"></div>
//   <div><!-- newElement --></div>
//   <!-- sibling1, sibling2, "Text" here -->
// </parent>
```

### before()

```javascript
const reference = document.getElementById('reference');

// Insert before the reference element (as previous sibling)
const newElement = document.createElement('div');
reference.before(newElement);

// Multiple items
reference.before(item1, item2);

// Structure:
// <parent>
//   <!-- item1, item2 here -->
//   <div><!-- newElement --></div>
//   <div id="reference"></div>
// </parent>
```

### Use Cases

```javascript
// Insert error message after input
const input = document.querySelector('input[name="email"]');
const error = document.createElement('span');
error.className = 'error';
error.textContent = 'Invalid email';
input.after(error);

// Insert icon before button text
const button = document.querySelector('button');
const icon = document.createElement('span');
icon.className = 'icon';
button.prepend(icon);  // Inside button, at start

// Insert wrapper around element
const element = document.getElementById('wrap-me');
const wrapper = document.createElement('div');
wrapper.className = 'wrapper';
element.before(wrapper);
wrapper.append(element);  // Move element into wrapper
```

---

## 1.5.7 replaceChild and replaceWith

Replace existing elements with new content.

### replaceChild()

```javascript
const parent = document.getElementById('container');
const oldChild = document.getElementById('old');
const newChild = document.createElement('div');
newChild.textContent = 'New content';

// Replace old with new (returns the old element)
const replaced = parent.replaceChild(newChild, oldChild);

console.log(replaced === oldChild);  // true
console.log(oldChild.parentNode);    // null (removed from DOM)
```

### replaceWith()

```javascript
const oldElement = document.getElementById('old');
const newElement = document.createElement('div');
newElement.textContent = 'Replacement';

// Replace oldElement with newElement
oldElement.replaceWith(newElement);

// Can replace with multiple nodes/strings
oldElement.replaceWith(
  document.createElement('p'),
  'Some text',
  document.createElement('span')
);

// Returns undefined
```

### Common Use Cases

```javascript
// Replace loading placeholder with content
const placeholder = document.querySelector('.loading');
const content = document.createElement('div');
content.innerHTML = fetchedHTML;  // Sanitized!
placeholder.replaceWith(content);

// Swap elements
function swapElements(el1, el2) {
  const temp = document.createElement('div');
  el1.replaceWith(temp);
  el2.replaceWith(el1);
  temp.replaceWith(el2);
}
```

---

## 1.5.8 replaceChildren

Replace all children of an element at once.

### How It Works

```javascript
const container = document.getElementById('container');

// Replace all children with new content
const newChild1 = document.createElement('p');
const newChild2 = document.createElement('p');
container.replaceChildren(newChild1, newChild2);

// Previous children are removed, new ones inserted

// Clear all children
container.replaceChildren();
// Equivalent to removing all children
```

### Comparison with innerHTML

```javascript
// innerHTML approach:
container.innerHTML = '';  // Clear
container.appendChild(child1);
container.appendChild(child2);

// replaceChildren approach:
container.replaceChildren(child1, child2);

// replaceChildren advantages:
// - Single operation
// - Works with Node objects directly
// - Doesn't require HTML parsing
// - Preserves references to inserted nodes
```

### Use Case: Re-render List

```javascript
function renderList(items, container) {
  const elements = items.map(item => {
    const li = document.createElement('li');
    li.textContent = item.name;
    return li;
  });
  
  // Replace all existing items with new ones
  container.replaceChildren(...elements);
}

// Usage
const list = document.getElementById('todo-list');
renderList(todos, list);

// When data changes, just call again
renderList(updatedTodos, list);
```

---

## 1.5.9 Moving Elements

Elements can only exist in one place. Appending moves them.

### The Move Behavior

```javascript
// Element in original location
// <div id="source">
//   <p id="moveable">Content</p>
// </div>
// <div id="target"></div>

const element = document.getElementById('moveable');
const target = document.getElementById('target');

// Append moves the element
target.appendChild(element);

// Now:
// <div id="source">
//   <!-- empty -->
// </div>
// <div id="target">
//   <p id="moveable">Content</p>
// </div>
```

### Copy Instead of Move

```javascript
const original = document.getElementById('original');
const target = document.getElementById('target');

// Clone to copy
const copy = original.cloneNode(true);
target.appendChild(copy);

// Original stays in place, copy is added to target
```

### Rearranging Children

```javascript
const list = document.getElementById('sortable-list');

// Move last child to first
const lastItem = list.lastElementChild;
list.insertBefore(lastItem, list.firstElementChild);

// Reverse all children
const children = Array.from(list.children);
children.reverse().forEach(child => list.appendChild(child));

// Sort children alphabetically
const sorted = Array.from(list.children)
  .sort((a, b) => a.textContent.localeCompare(b.textContent));
list.replaceChildren(...sorted);
```

---

## 1.5.10 Batch Operations and Performance

### Minimize Reflows

```javascript
// ❌ BAD: Triggers reflow on each operation
const container = document.getElementById('container');
for (let i = 0; i < 1000; i++) {
  const div = document.createElement('div');
  div.textContent = `Item ${i}`;
  container.appendChild(div);  // Reflow!
}

// ✅ GOOD: Single reflow with DocumentFragment
const fragment = document.createDocumentFragment();
for (let i = 0; i < 1000; i++) {
  const div = document.createElement('div');
  div.textContent = `Item ${i}`;
  fragment.appendChild(div);  // No reflow
}
container.appendChild(fragment);  // Single reflow
```

### Detach, Modify, Reattach

```javascript
const container = document.getElementById('heavy-container');
const parent = container.parentNode;
const nextSibling = container.nextSibling;

// Detach from DOM
container.remove();

// Make many modifications (no reflows!)
for (let i = 0; i < 100; i++) {
  const div = document.createElement('div');
  container.appendChild(div);
}

// Reattach
parent.insertBefore(container, nextSibling);
```

### Use requestAnimationFrame

```javascript
// For visual updates, batch in animation frame
function addManyItems(items) {
  let index = 0;
  
  function processChunk() {
    const chunkSize = 50;
    const end = Math.min(index + chunkSize, items.length);
    
    const fragment = document.createDocumentFragment();
    while (index < end) {
      const el = createItemElement(items[index]);
      fragment.appendChild(el);
      index++;
    }
    container.appendChild(fragment);
    
    if (index < items.length) {
      requestAnimationFrame(processChunk);
    }
  }
  
  requestAnimationFrame(processChunk);
}
```

---

## 1.5.11 Summary

| Method | Called On | Purpose | Accepts |
|--------|-----------|---------|---------|
| `appendChild(node)` | Parent | Add as last child | 1 Node |
| `insertBefore(node, ref)` | Parent | Insert before reference | 1 Node |
| `removeChild(node)` | Parent | Remove child | 1 Node |
| `replaceChild(new, old)` | Parent | Replace child | 2 Nodes |
| `remove()` | Element | Remove self | - |
| `append(...nodes)` | Parent | Add to end | Multiple |
| `prepend(...nodes)` | Parent | Add to start | Multiple |
| `after(...nodes)` | Element | Insert after | Multiple |
| `before(...nodes)` | Element | Insert before | Multiple |
| `replaceWith(...nodes)` | Element | Replace self | Multiple |
| `replaceChildren(...nodes)` | Parent | Replace all children | Multiple |

### Modern vs Classic Methods

| Classic | Modern Equivalent |
|---------|-------------------|
| `parent.appendChild(child)` | `parent.append(child)` |
| `parent.insertBefore(child, first)` | `first.before(child)` |
| `parent.insertBefore(child, ref.nextSibling)` | `ref.after(child)` |
| `parent.removeChild(child)` | `child.remove()` |
| `parent.replaceChild(new, old)` | `old.replaceWith(new)` |

### Best Practices

1. **Use modern methods** (`append`, `remove`, `replaceWith`) — cleaner API
2. **Use DocumentFragment** for batch insertions
3. **Remember moves, not copies** — appending relocates elements
4. **Clone when needed** — use `cloneNode(true)` to copy
5. **Batch DOM operations** — minimize reflows
6. **Use `replaceChildren`** for efficient list re-renders

---

**End of Chapter 1.5: Manipulating Elements**

Next chapter: **1.6 Element Properties and Methods** — covers `innerHTML`, `textContent`, `outerHTML`, `dataset`, `style`, `getBoundingClientRect`, and more.
# 1.6 Element Properties and Methods

Every DOM element exposes properties and methods that let you read and modify its content, attributes, dimensions, and styles. This chapter covers the most important element APIs — from content manipulation with `innerHTML` and `textContent` to position calculation with `getBoundingClientRect`.

Understanding these properties deeply enables you to build responsive, dynamic interfaces that adapt to content and user interactions.

---

## 1.6.1 Content Properties: innerHTML, textContent, outerHTML

Three ways to read and modify element content, each with distinct behavior.

### innerHTML

Reads or sets the HTML content inside an element.

```javascript
const div = document.getElementById('content');

// Read HTML content
console.log(div.innerHTML);
// "<p>Hello <strong>World</strong></p>"

// Set HTML content (parses HTML)
div.innerHTML = '<h1>New Title</h1><p>New paragraph</p>';

// Append HTML (warning: has performance issues)
div.innerHTML += '<p>Appended</p>';  // Reparsing entire content!
```

### ⚠️ innerHTML Security Warning

```javascript
// ❌ DANGEROUS: Never use innerHTML with untrusted data!
const userInput = '<img src=x onerror="alert(\'XSS\')">';
div.innerHTML = userInput;  // XSS attack executes!

// ❌ DANGEROUS: Query parameters, form inputs, URLs
const param = new URLSearchParams(location.search).get('q');
div.innerHTML = param;  // Potential XSS!

// ✅ SAFE: Use textContent for user data
div.textContent = userInput;  // Displays as text

// ✅ SAFE: If you must use HTML, sanitize first
import DOMPurify from 'dompurify';
div.innerHTML = DOMPurify.sanitize(userInput);
```

### textContent

Reads or sets plain text content. Strips all HTML tags.

```javascript
const div = document.getElementById('content');
// <div id="content"><p>Hello <strong>World</strong></p></div>

// Read text only (no tags)
console.log(div.textContent);  // "Hello World"

// Set text (HTML is escaped, not parsed)
div.textContent = '<script>alert("safe")</script>';
// Displays: <script>alert("safe")</script>
// Does NOT execute!
```

### textContent vs innerText

```javascript
const div = document.createElement('div');
div.innerHTML = 'Hello   <span style="display:none">Hidden</span>   World';

// textContent: raw text, includes hidden, preserves nothing
console.log(div.textContent);  // "Hello   Hidden   World"

// innerText: rendered text, respects CSS, collapses whitespace
console.log(div.innerText);    // "Hello World" (hidden text excluded)

// innerText causes reflow (performance impact)
// textContent is faster

// Use textContent unless you specifically need rendered text
```

### outerHTML

Includes the element itself, not just its contents.

```javascript
const p = document.querySelector('p');
// <p class="intro">Hello</p>

// Read: includes the element
console.log(p.outerHTML);  // '<p class="intro">Hello</p>'

// Write: replaces the element entirely
p.outerHTML = '<div class="new">Replaced</div>';
// ⚠️ After this, 'p' variable still references the OLD element!
// The old element is no longer in DOM

// Gotcha: variable becomes stale
const element = document.querySelector('.item');
element.outerHTML = '<div class="new-item">New</div>';
console.log(element.parentNode);  // null (removed from DOM!)
// Must re-query to get the new element
const newElement = document.querySelector('.new-item');
```

### Comparison Table

| Property | Reads | Writes | HTML Parsed? | Safe for User Input? |
|----------|-------|--------|--------------|---------------------|
| `innerHTML` | HTML string | HTML string | Yes | ❌ No |
| `textContent` | Plain text | Plain text | No (escaped) | ✅ Yes |
| `innerText` | Rendered text | Plain text | No | ✅ Yes |
| `outerHTML` | Element + content | Element + content | Yes | ❌ No |

---

## 1.6.2 Attribute Methods

Elements have attributes in HTML and corresponding properties in JavaScript.

### getAttribute and setAttribute

```javascript
const link = document.querySelector('a');

// Get attribute value
const href = link.getAttribute('href');
const target = link.getAttribute('target');

// Get non-existent attribute
link.getAttribute('data-missing');  // null

// Set attribute
link.setAttribute('href', 'https://example.com');
link.setAttribute('target', '_blank');
link.setAttribute('rel', 'noopener noreferrer');

// Set custom attributes
link.setAttribute('data-track-id', '12345');
```

### hasAttribute and removeAttribute

```javascript
const input = document.querySelector('input');

// Check if attribute exists
if (input.hasAttribute('required')) {
  console.log('This field is required');
}

// Remove attribute
input.removeAttribute('disabled');
input.removeAttribute('data-temp');

// Boolean attributes
input.setAttribute('disabled', '');  // Presence = true
input.removeAttribute('disabled');    // Removal = false
```

### Attributes vs Properties

```javascript
// Attributes: HTML markup values (strings)
// Properties: DOM object values (can be any type)

const checkbox = document.querySelector('input[type="checkbox"]');

// These are different!
checkbox.getAttribute('checked');  // "checked" or null (initial HTML)
checkbox.checked;                   // true or false (current state)

// Setting attribute doesn't always update property
checkbox.setAttribute('checked', 'checked');
// Visual state might not change if user already unchecked

// Setting property DOES update state
checkbox.checked = true;  // Immediately checks the box

// For form elements, prefer properties:
input.value = 'new value';     // ✅ Property (current value)
input.setAttribute('value', 'new');  // ❌ Attribute (initial value only)
```

### Common Attribute/Property Differences

```javascript
// href: property returns absolute URL
const link = document.createElement('a');
link.setAttribute('href', '/page');
link.getAttribute('href');  // "/page" (relative)
link.href;                   // "https://example.com/page" (absolute)

// class: attribute name differs from property
element.getAttribute('class');  // "foo bar"
element.className;              // "foo bar"
element.classList;              // DOMTokenList

// for: attribute name differs from property
label.getAttribute('for');      // "input-id"
label.htmlFor;                  // "input-id"

// style: attribute is string, property is object
element.getAttribute('style');  // "color: red; font-size: 16px"
element.style;                  // CSSStyleDeclaration object
```

---

## 1.6.3 data-* Attributes (dataset)

Custom data attributes provide a clean way to store data on elements.

### Reading and Writing Data Attributes

```javascript
// HTML: <div id="user" data-user-id="42" data-role="admin">

const div = document.getElementById('user');

// Read via dataset (camelCase)
console.log(div.dataset.userId);  // "42"
console.log(div.dataset.role);    // "admin"

// Write via dataset
div.dataset.score = '100';
div.dataset.lastLogin = '2024-01-15';

// Results in:
// <div data-user-id="42" data-role="admin" 
//      data-score="100" data-last-login="2024-01-15">

// Delete data attribute
delete div.dataset.score;
```

### Naming Convention

```javascript
// HTML attribute:  data-user-name     → dataset.userName  (camelCase)
// HTML attribute:  data-api-endpoint  → dataset.apiEndpoint
// HTML attribute:  data-x             → dataset.x
// HTML attribute:  data-XMLParser     → dataset.xmlparser (lowercased)

// Setting via dataset:
div.dataset.firstName = 'John';
// Creates: data-first-name="John"

div.dataset.apiURL = 'https://...';
// Creates: data-api-u-r-l="https://..."  ⚠️ Watch for this!
```

### Practical Use Cases

```javascript
// 1. Store metadata for event handlers
const buttons = document.querySelectorAll('[data-action]');
buttons.forEach(btn => {
  btn.addEventListener('click', (e) => {
    const action = e.target.dataset.action;
    const id = e.target.dataset.id;
    handleAction(action, id);
  });
});

// 2. Configure components
const carousel = document.querySelector('[data-carousel]');
const config = {
  autoplay: carousel.dataset.autoplay === 'true',
  interval: parseInt(carousel.dataset.interval) || 3000,
  loop: carousel.dataset.loop !== 'false'
};

// 3. Track state
function toggleExpand(element) {
  if (element.dataset.expanded === 'true') {
    element.dataset.expanded = 'false';
    element.classList.remove('expanded');
  } else {
    element.dataset.expanded = 'true';
    element.classList.add('expanded');
  }
}

// 4. CSS hooks
// [data-state="loading"] { opacity: 0.5; }
// [data-state="error"] { border-color: red; }
element.dataset.state = 'loading';
```

### Dataset vs getAttribute

```javascript
// Both work, but dataset is cleaner for data-* attributes
div.getAttribute('data-user-id');  // "42"
div.dataset.userId;                // "42"

// dataset only works for data-* attributes
div.getAttribute('id');            // Works
div.dataset.id;                    // undefined! (id is not data-id)

// Performance: roughly equivalent for reads
// dataset creates the DOMStringMap object once
```

---

## 1.6.4 The style Property

Direct access to an element's inline styles.

### Reading and Writing Styles

```javascript
const div = document.getElementById('box');

// Write styles (use camelCase)
div.style.backgroundColor = 'blue';
div.style.fontSize = '16px';
div.style.marginTop = '10px';
div.style.border = '1px solid black';

// Read inline styles only
console.log(div.style.backgroundColor);  // "blue" (if set inline)

// Does NOT read styles from CSS!
// <div style="">  ← no inline styles
console.log(div.style.backgroundColor);  // "" (empty string)
```

### CSS Property Names

```javascript
// CSS property → JavaScript property
// background-color  → backgroundColor
// font-size         → fontSize
// z-index           → zIndex
// -webkit-transform → webkitTransform

// Some properties have special names
div.style.cssFloat = 'left';  // Not 'float' (reserved word)

// CSS custom properties (variables)
div.style.setProperty('--theme-color', 'blue');
div.style.getPropertyValue('--theme-color');  // "blue"
```

### Removing Styles

```javascript
// Set to empty string
div.style.backgroundColor = '';

// Or removeProperty
div.style.removeProperty('background-color');  // Use CSS name

// Clear all inline styles
div.style.cssText = '';
// Or
div.removeAttribute('style');
```

### style.cssText

```javascript
// Set multiple styles at once
div.style.cssText = 'color: red; font-size: 20px; margin: 10px';

// ⚠️ Overwrites ALL inline styles
div.style.cssText = 'color: blue';  // fontSize and margin are gone

// Read all inline styles as string
console.log(div.style.cssText);  // "color: blue;"
```

### getComputedStyle

```javascript
// To read ACTUAL applied styles (from CSS + inline)
const div = document.getElementById('styled');
const computed = getComputedStyle(div);

// Read computed values
console.log(computed.backgroundColor);  // "rgb(0, 0, 255)"
console.log(computed.fontSize);          // "16px"
console.log(computed.display);           // "block"

// Computed values are RESOLVED (rgb, px, etc.)
// Not the values you wrote in CSS

// Pseudo-elements
const beforeStyles = getComputedStyle(div, '::before');
console.log(beforeStyles.content);  // '"Hello"'

// ⚠️ getComputedStyle is read-only
computed.backgroundColor = 'red';  // Does nothing
```

---

## 1.6.5 Dimensions and Position

### Element Dimensions

```javascript
const box = document.getElementById('box');

// Content dimensions (CSS width/height)
console.log(box.clientWidth);   // Content + padding (no border, no scrollbar)
console.log(box.clientHeight);

console.log(box.offsetWidth);   // Content + padding + border + scrollbar
console.log(box.offsetHeight);

console.log(box.scrollWidth);   // Full scrollable width (including overflow)
console.log(box.scrollHeight);  // Full scrollable height

// Visual representation (box 200x100, padding 10, border 2):
// offsetWidth  = 200 + 10*2 + 2*2 = 224
// clientWidth  = 200 + 10*2       = 220
// scrollWidth  = actual content width (may be larger if overflow)
```

### getBoundingClientRect

Returns element's size and position relative to viewport.

```javascript
const element = document.getElementById('target');
const rect = element.getBoundingClientRect();

console.log(rect.top);      // Distance from viewport top
console.log(rect.right);    // Distance from viewport left to element right
console.log(rect.bottom);   // Distance from viewport top to element bottom
console.log(rect.left);     // Distance from viewport left
console.log(rect.width);    // Element width (including border)
console.log(rect.height);   // Element height (including border)
console.log(rect.x);        // Same as left
console.log(rect.y);        // Same as top

// ⚠️ Values change as page scrolls!
// ⚠️ Can be fractional (subpixel precision)
```

### Position Relative to Document

```javascript
function getDocumentPosition(element) {
  const rect = element.getBoundingClientRect();
  return {
    top: rect.top + window.scrollY,
    left: rect.left + window.scrollX
  };
}

// Or use offsetTop/offsetLeft (relative to offsetParent)
const pos = {
  top: element.offsetTop,
  left: element.offsetLeft
};
```

### Offset Properties

```javascript
const element = document.querySelector('.child');

// Position relative to offsetParent
console.log(element.offsetTop);     // Pixels from offsetParent top
console.log(element.offsetLeft);    // Pixels from offsetParent left
console.log(element.offsetParent);  // Nearest positioned ancestor

// offsetParent is null for:
// - document.body (or <html>)
// - Elements with display: none
// - Fixed position elements (varies by browser)
```

### Check Element Visibility

```javascript
function isInViewport(element) {
  const rect = element.getBoundingClientRect();
  return (
    rect.top >= 0 &&
    rect.left >= 0 &&
    rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) &&
    rect.right <= (window.innerWidth || document.documentElement.clientWidth)
  );
}

// Partially visible
function isPartiallyVisible(element) {
  const rect = element.getBoundingClientRect();
  const viewHeight = window.innerHeight || document.documentElement.clientHeight;
  const viewWidth = window.innerWidth || document.documentElement.clientWidth;
  
  return (
    rect.top < viewHeight &&
    rect.bottom > 0 &&
    rect.left < viewWidth &&
    rect.right > 0
  );
}
```

---

## 1.6.6 Scroll Properties and Methods

### Scroll Position

```javascript
const scrollable = document.getElementById('scrollable');

// Current scroll position
console.log(scrollable.scrollTop);   // Pixels scrolled from top
console.log(scrollable.scrollLeft);  // Pixels scrolled from left

// Set scroll position
scrollable.scrollTop = 100;   // Scroll to 100px from top
scrollable.scrollLeft = 0;    // Scroll to left edge

// Document scroll
console.log(window.scrollY);  // Or pageYOffset (alias)
console.log(window.scrollX);  // Or pageXOffset (alias)
```

### Scroll Methods

```javascript
const element = document.getElementById('target');

// Scroll element into view
element.scrollIntoView();               // Align to top
element.scrollIntoView(false);          // Align to bottom
element.scrollIntoView({ 
  behavior: 'smooth',                   // 'auto' or 'smooth'
  block: 'center',                      // 'start', 'center', 'end', 'nearest'
  inline: 'nearest'                     // 'start', 'center', 'end', 'nearest'
});

// Scroll container
const container = document.getElementById('container');
container.scrollTo(0, 500);             // scrollTo(x, y)
container.scrollTo({ 
  top: 500, 
  left: 0, 
  behavior: 'smooth' 
});

container.scrollBy(0, 100);             // Scroll by relative amount
container.scrollBy({ 
  top: 100, 
  behavior: 'smooth' 
});

// Window scroll
window.scrollTo(0, 0);                  // Scroll to top
window.scrollTo({ top: 0, behavior: 'smooth' });
```

---

## 1.6.7 className and classList

### className Property

```javascript
const div = document.getElementById('box');

// Read all classes as string
console.log(div.className);  // "card featured active"

// Set all classes (replaces existing)
div.className = 'card highlighted';

// Add class (clunky)
div.className += ' new-class';

// ⚠️ className replaces everything - easy to lose classes
```

### classList API (Preferred)

```javascript
const div = document.getElementById('box');

// Add classes
div.classList.add('active');
div.classList.add('highlighted', 'featured');  // Multiple

// Remove classes
div.classList.remove('active');
div.classList.remove('highlighted', 'featured');

// Toggle class
div.classList.toggle('active');  // Add if missing, remove if present
const isNowActive = div.classList.toggle('active');  // Returns new state

// Conditional toggle
div.classList.toggle('active', condition);  // Add if true, remove if false

// Check for class
if (div.classList.contains('active')) {
  console.log('Is active');
}

// Replace class
div.classList.replace('old-class', 'new-class');

// Iterate classes
div.classList.forEach(className => {
  console.log(className);
});

// Access by index
console.log(div.classList[0]);      // First class
console.log(div.classList.length);  // Number of classes
```

### classList Best Practices

```javascript
// ✅ Use classList for class manipulation
element.classList.add('active');
element.classList.remove('loading');

// ❌ Avoid className for add/remove (loses other classes)
element.className = 'active';  // Removes all other classes!

// ✅ Use toggle for binary states
element.classList.toggle('expanded');

// ✅ Use conditional toggle for state binding
element.classList.toggle('visible', isVisible);
element.classList.toggle('error', hasError);

// ✅ Use replace for state changes
element.classList.replace('loading', 'loaded');
```

---

## 1.6.8 Hidden and Visibility

### hidden Attribute

```javascript
const element = document.getElementById('modal');

// Hide element (like display: none)
element.hidden = true;

// Show element
element.hidden = false;

// Check visibility
if (element.hidden) {
  console.log('Element is hidden');
}

// hidden is a boolean attribute
// <div hidden>  is hidden
// <div>         is visible
```

### hidden vs CSS

```javascript
// hidden attribute = display: none
element.hidden = true;

// Equivalent CSS
element.style.display = 'none';

// But hidden can be overridden by CSS!
// If your CSS says .modal { display: block !important; }
// element.hidden = true won't hide it

// Use CSS for complex visibility logic
// Use hidden for simple show/hide
```

### Checking Actual Visibility

```javascript
function isElementVisible(element) {
  // Check multiple conditions
  if (element.hidden) return false;
  
  const style = getComputedStyle(element);
  if (style.display === 'none') return false;
  if (style.visibility === 'hidden') return false;
  if (style.opacity === '0') return false;
  
  // Check if in viewport (optional)
  const rect = element.getBoundingClientRect();
  if (rect.width === 0 && rect.height === 0) return false;
  
  return true;
}
```

---

## 1.6.9 Other Useful Properties

### id

```javascript
element.id = 'new-id';
console.log(element.id);  // "new-id"
```

### tagName and nodeName

```javascript
const div = document.querySelector('div');
console.log(div.tagName);   // "DIV" (uppercase)
console.log(div.nodeName);  // "DIV" (uppercase)

// For elements, they're the same
// For other nodes, nodeName varies:
// Text node: "#text"
// Comment: "#comment"
// Document: "#document"
```

### children vs childNodes

```javascript
const parent = document.getElementById('parent');

// children: only Element nodes
console.log(parent.children);        // HTMLCollection of child elements
console.log(parent.children.length); // Number of child elements

// childNodes: all nodes including text and comments
console.log(parent.childNodes);        // NodeList of all child nodes
console.log(parent.childNodes.length); // Includes whitespace text nodes!
```

### parentElement vs parentNode

```javascript
const element = document.querySelector('.child');

// Usually the same
console.log(element.parentElement);  // Parent Element
console.log(element.parentNode);     // Parent Node

// Differ at document level
console.log(document.documentElement.parentElement);  // null
console.log(document.documentElement.parentNode);     // #document
```

---

## 1.6.10 Summary

| Property/Method | Purpose | Read/Write |
|-----------------|---------|------------|
| `innerHTML` | HTML content | Both |
| `textContent` | Plain text content (safe) | Both |
| `outerHTML` | Element + content as HTML | Both |
| `getAttribute/setAttribute` | HTML attributes | Both |
| `dataset` | data-* attributes | Both |
| `style` | Inline CSS styles | Both |
| `getComputedStyle()` | Computed CSS values | Read |
| `classList` | CSS classes | Both |
| `className` | Class attribute string | Both |
| `hidden` | Visibility (display: none) | Both |
| `getBoundingClientRect()` | Position and size | Read |
| `clientWidth/Height` | Content + padding | Read |
| `offsetWidth/Height` | Including border | Read |
| `scrollWidth/Height` | Full scrollable size | Read |
| `scrollTop/Left` | Scroll position | Both |

### Best Practices

1. **Use `textContent` for user data** — prevents XSS
2. **Prefer `classList` over `className`** — safer manipulation
3. **Use `dataset` for custom data** — clean, semantic
4. **Use `getComputedStyle` to read styles** — `style` only reads inline
5. **Cache `getBoundingClientRect` results** — triggers reflow
6. **Use properties over attributes** for form elements

---

**End of Chapter 1.6: Element Properties and Methods**

Next chapter: **1.7 DOM Traversal** — covers navigating between elements with `parentNode`, `children`, `siblings`, and more.
# 1.7 DOM Traversal

DOM traversal is the art of navigating between related elements — moving from parents to children, between siblings, or finding specific ancestors. Efficient traversal is essential for event delegation, dynamic UI updates, and working with complex document structures.

This chapter covers all traversal methods and properties, with patterns for real-world use cases.

---

## 1.7.1 Parent Traversal

### parentNode

Returns the parent of any node, including non-element nodes.

```javascript
const child = document.getElementById('child');

// Get parent
const parent = child.parentNode;

// parentNode can be:
// - Element (most common)
// - Document (for <html>)
// - DocumentFragment

// Chain for ancestors
const grandparent = child.parentNode.parentNode;
const greatGrandparent = child.parentNode.parentNode.parentNode;
```

### parentElement

Returns the parent Element only. Returns `null` if parent is not an Element.

```javascript
const child = document.getElementById('child');

// For most cases, same as parentNode
const parent = child.parentElement;

// Difference at document level
const html = document.documentElement;
console.log(html.parentNode);     // #document (Document node)
console.log(html.parentElement);  // null (Document is not an Element)
```

### Climbing the DOM Tree

```javascript
// Find all ancestors
function getAncestors(element) {
  const ancestors = [];
  let current = element.parentElement;
  
  while (current) {
    ancestors.push(current);
    current = current.parentElement;
  }
  
  return ancestors;
}

const path = getAncestors(document.getElementById('deep-child'));
// [parentDiv, grandparentDiv, ..., body, html]
```

### closest() for Ancestor Selection

```javascript
// Better than manual traversal when you know what you're looking for
const button = document.querySelector('button.delete');

// Find nearest ancestor matching selector
const card = button.closest('.card');
const form = button.closest('form');
const modal = button.closest('[data-modal]');

// closest checks the element itself first!
button.closest('button');  // Returns button itself

// Returns null if not found
button.closest('.nonexistent');  // null
```

---

## 1.7.2 Child Traversal

### children (Element Children Only)

```javascript
const parent = document.getElementById('list');

// Get all child elements
const children = parent.children;  // HTMLCollection (live)

console.log(children.length);     // Number of child elements
console.log(children[0]);         // First child element
console.log(children[children.length - 1]);  // Last child element

// Iterate
for (const child of children) {
  console.log(child.tagName);
}

// Convert to array for array methods
Array.from(children).filter(el => el.classList.contains('active'));
```

### childNodes (All Child Nodes)

```javascript
const parent = document.getElementById('content');

// Get ALL child nodes (elements, text, comments)
const nodes = parent.childNodes;  // NodeList (live)

// Includes whitespace text nodes!
// <div id="content">
//   <p>Hello</p>
// </div>
// childNodes: [TextNode("\n  "), <p>, TextNode("\n")]

nodes.forEach(node => {
  console.log(node.nodeType);
  // 1 = Element
  // 3 = Text
  // 8 = Comment
});

// Filter to elements only
const elements = Array.from(nodes).filter(n => n.nodeType === 1);
```

### firstChild, lastChild

```javascript
const parent = document.getElementById('container');

// First/last of ANY node type
console.log(parent.firstChild);  // Could be text node (whitespace)
console.log(parent.lastChild);   // Could be text node

// Filter for elements
if (parent.firstChild && parent.firstChild.nodeType === 1) {
  // First child is an element
}
```

### firstElementChild, lastElementChild

```javascript
const parent = document.getElementById('container');

// First/last ELEMENT child only (skips text/comments)
const first = parent.firstElementChild;  // First child element
const last = parent.lastElementChild;    // Last child element

// Much cleaner than firstChild when you want elements
if (first) {
  first.classList.add('first-item');
}
if (last) {
  last.classList.add('last-item');
}
```

### childElementCount

```javascript
const parent = document.getElementById('list');

// Number of child elements (not all nodes)
console.log(parent.childElementCount);  // e.g., 5

// Same as children.length but potentially faster
// No HTMLCollection creation
```

---

## 1.7.3 Sibling Traversal

### nextSibling, previousSibling

```javascript
const current = document.getElementById('item-3');

// Get adjacent siblings (any node type)
const next = current.nextSibling;
const prev = current.previousSibling;

// ⚠️ Often returns text nodes (whitespace)!
// <li id="item-2">...</li>
// <li id="item-3">...</li>
// ↑ Text node between them!
```

### nextElementSibling, previousElementSibling

```javascript
const current = document.getElementById('item-3');

// Get adjacent ELEMENT siblings (skip text/comments)
const nextEl = current.nextElementSibling;   // Next element or null
const prevEl = current.previousElementSibling;  // Previous element or null

// Much more useful for most cases
if (nextEl) {
  nextEl.classList.add('after-selected');
}
```

### Getting All Siblings

```javascript
function getSiblings(element) {
  // Get all siblings (excluding self)
  const parent = element.parentElement;
  if (!parent) return [];
  
  return Array.from(parent.children).filter(child => child !== element);
}

function getNextSiblings(element) {
  const siblings = [];
  let current = element.nextElementSibling;
  
  while (current) {
    siblings.push(current);
    current = current.nextElementSibling;
  }
  
  return siblings;
}

function getPreviousSiblings(element) {
  const siblings = [];
  let current = element.previousElementSibling;
  
  while (current) {
    siblings.unshift(current);  // Add to beginning
    current = current.previousElementSibling;
  }
  
  return siblings;
}
```

---

## 1.7.4 Node Type Properties

### nodeType

```javascript
const node = element.firstChild;

// Check what type of node
switch (node.nodeType) {
  case Node.ELEMENT_NODE:         // 1
    console.log('Element:', node.tagName);
    break;
  case Node.TEXT_NODE:            // 3
    console.log('Text:', node.textContent);
    break;
  case Node.COMMENT_NODE:         // 8
    console.log('Comment:', node.textContent);
    break;
  case Node.DOCUMENT_NODE:        // 9
    console.log('Document');
    break;
  case Node.DOCUMENT_TYPE_NODE:   // 10
    console.log('DOCTYPE');
    break;
  case Node.DOCUMENT_FRAGMENT_NODE:  // 11
    console.log('DocumentFragment');
    break;
}

// Common pattern: filter to elements
function getElementChildren(node) {
  return Array.from(node.childNodes)
    .filter(child => child.nodeType === Node.ELEMENT_NODE);
}
```

### nodeName and tagName

```javascript
// nodeName works on any node
textNode.nodeName;      // "#text"
commentNode.nodeName;   // "#comment"
element.nodeName;       // "DIV" (uppercase)
document.nodeName;      // "#document"

// tagName only works on elements
element.tagName;        // "DIV" (uppercase)
textNode.tagName;       // undefined
```

---

## 1.7.5 Traversal Methods Overview

### Element Properties vs Node Properties

| Element Property | Node Property | Returns |
|------------------|---------------|---------|
| `parentElement` | `parentNode` | Parent |
| `children` | `childNodes` | Children |
| `firstElementChild` | `firstChild` | First child |
| `lastElementChild` | `lastChild` | Last child |
| `nextElementSibling` | `nextSibling` | Next sibling |
| `previousElementSibling` | `previousSibling` | Previous sibling |
| `childElementCount` | `childNodes.length` | Child count |

### When to Use Each

```javascript
// ✅ Use Element properties for most DOM work
parent.children                  // Cleaner than filtering childNodes
element.nextElementSibling       // Skips whitespace text nodes
parent.firstElementChild         // Direct access to first element

// ⚠️ Use Node properties when you need ALL nodes
parent.childNodes                // Including text, comments
element.nextSibling              // Including text nodes

// ⚠️ Use Node properties for DOM libraries/parsers
// When you're processing arbitrary content
```

---

## 1.7.6 Tree Walker and Node Iterator

For complex traversal needs, the DOM provides iterator APIs.

### TreeWalker

```javascript
// Create a TreeWalker
const walker = document.createTreeWalker(
  document.body,                      // Root node to traverse
  NodeFilter.SHOW_ELEMENT,            // What to show
  {                                   // Optional filter function
    acceptNode: (node) => {
      return node.classList.contains('skip')
        ? NodeFilter.FILTER_REJECT    // Skip this node and children
        : NodeFilter.FILTER_ACCEPT;   // Include this node
    }
  }
);

// Navigate
const first = walker.firstChild();    // First child of root
const next = walker.nextNode();       // Next node in document order
const prev = walker.previousNode();   // Previous node
const parent = walker.parentNode();   // Parent node
const sibling = walker.nextSibling(); // Next sibling

// Iterate all matching nodes
let node;
while (node = walker.nextNode()) {
  console.log(node.tagName);
}
```

### NodeFilter Constants

```javascript
// What types of nodes to show
NodeFilter.SHOW_ALL           // All nodes
NodeFilter.SHOW_ELEMENT       // Element nodes only
NodeFilter.SHOW_TEXT          // Text nodes only
NodeFilter.SHOW_COMMENT       // Comment nodes only
NodeFilter.SHOW_DOCUMENT      // Document node

// Combine with bitwise OR
const filter = NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_TEXT;

// Filter return values
NodeFilter.FILTER_ACCEPT      // Include this node
NodeFilter.FILTER_REJECT      // Skip node and its descendants
NodeFilter.FILTER_SKIP        // Skip node, but check descendants
```

### Use Case: Find All Text Nodes

```javascript
function getAllTextNodes(root) {
  const textNodes = [];
  const walker = document.createTreeWalker(
    root,
    NodeFilter.SHOW_TEXT,
    null
  );
  
  let node;
  while (node = walker.nextNode()) {
    // Skip whitespace-only text nodes
    if (node.textContent.trim()) {
      textNodes.push(node);
    }
  }
  
  return textNodes;
}

const textNodes = getAllTextNodes(document.body);
textNodes.forEach(node => {
  console.log(node.textContent.trim());
});
```

### NodeIterator

```javascript
// Similar to TreeWalker but simpler (forward-only)
const iterator = document.createNodeIterator(
  document.body,
  NodeFilter.SHOW_ELEMENT,
  {
    acceptNode: (node) => {
      return node.tagName === 'P'
        ? NodeFilter.FILTER_ACCEPT
        : NodeFilter.FILTER_REJECT;
    }
  }
);

// Iterate
let node;
while (node = iterator.nextNode()) {
  console.log(node.textContent);
}

// Can also go back
iterator.previousNode();

// Difference from TreeWalker:
// - NodeIterator: nextNode/previousNode only (no tree navigation)
// - TreeWalker: full tree navigation (firstChild, parentNode, etc.)
```

---

## 1.7.7 Practical Traversal Patterns

### Event Delegation with Traversal

```javascript
// Handle clicks on list items, even dynamic ones
document.getElementById('list').addEventListener('click', (e) => {
  // Find the clicked list item
  const li = e.target.closest('li');
  if (!li) return;
  
  // Do something with the item
  const id = li.dataset.id;
  selectItem(id);
});
```

### Find All Descendants Matching Criteria

```javascript
function findDescendants(root, predicate) {
  const results = [];
  
  function traverse(node) {
    if (node.nodeType === Node.ELEMENT_NODE) {
      if (predicate(node)) {
        results.push(node);
      }
      
      for (const child of node.children) {
        traverse(child);
      }
    }
  }
  
  for (const child of root.children) {
    traverse(child);
  }
  
  return results;
}

// Find all disabled inputs
const disabled = findDescendants(form, el => 
  el.tagName === 'INPUT' && el.disabled
);

// Usually querySelectorAll is easier:
const disabled2 = form.querySelectorAll('input:disabled');
```

### Find Common Ancestor

```javascript
function findCommonAncestor(element1, element2) {
  const ancestors1 = new Set();
  
  // Collect all ancestors of element1
  let current = element1;
  while (current) {
    ancestors1.add(current);
    current = current.parentElement;
  }
  
  // Walk up element2's tree until we find a match
  current = element2;
  while (current) {
    if (ancestors1.has(current)) {
      return current;
    }
    current = current.parentElement;
  }
  
  return null;  // No common ancestor
}
```

### Check if Element Contains Another

```javascript
const container = document.getElementById('container');
const target = document.getElementById('target');

// Built-in method
if (container.contains(target)) {
  console.log('target is inside container');
}

// contains returns true if:
// - container === target
// - target is a descendant of container

// Check if target is a STRICT descendant (not same element)
if (container.contains(target) && container !== target) {
  console.log('target is a descendant of container');
}
```

### Walk DOM in Document Order

```javascript
function* walkDOM(root) {
  yield root;
  
  for (const child of root.children) {
    yield* walkDOM(child);
  }
}

// Usage
for (const element of walkDOM(document.body)) {
  console.log(element.tagName);
}

// With TreeWalker (more efficient for large DOMs)
function* walkDOMEfficient(root) {
  const walker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT);
  let node = walker.currentNode;
  
  while (node) {
    yield node;
    node = walker.nextNode();
  }
}
```

---

## 1.7.8 Performance Considerations

### Cache Traversal Results

```javascript
// ❌ Repeated traversal in loop
function highlightSiblings(element) {
  for (let i = 0; i < 100; i++) {
    element.nextElementSibling.classList.add('highlight');  // Same lookup!
  }
}

// ✅ Cache the result
function highlightSiblings(element) {
  const sibling = element.nextElementSibling;
  if (sibling) {
    for (let i = 0; i < 100; i++) {
      sibling.classList.add('highlight');
    }
  }
}
```

### Avoid Deep Traversal When Possible

```javascript
// ❌ Walking entire tree
function findTarget(root) {
  for (const child of root.children) {
    if (child.id === 'target') return child;
    const found = findTarget(child);
    if (found) return found;
  }
  return null;
}

// ✅ Use built-in methods (optimized by browser)
const target = root.querySelector('#target');
```

### Use Appropriate Collection Type

```javascript
// Live collections update automatically but can be slow
const liveCollection = document.getElementsByClassName('item');

// Static collections are snapshots - faster for iteration
const staticCollection = document.querySelectorAll('.item');

// If you need to iterate and modify, use static
staticCollection.forEach(item => item.remove());  // Safe

// Live collection changes during iteration - problematic
// liveCollection shrinks as you remove items
```

---

## 1.7.9 Summary

| Property/Method | Returns | Notes |
|-----------------|---------|-------|
| `parentNode` | Node | Any parent node |
| `parentElement` | Element | Element parent only |
| `children` | HTMLCollection | Element children (live) |
| `childNodes` | NodeList | All child nodes (live) |
| `firstElementChild` | Element | First element child |
| `lastElementChild` | Element | Last element child |
| `nextElementSibling` | Element | Next element sibling |
| `previousElementSibling` | Element | Previous element sibling |
| `closest(selector)` | Element | Nearest matching ancestor |
| `contains(node)` | Boolean | Check if node is descendant |

### Best Practices

1. **Use Element properties** (`children`, `nextElementSibling`) for typical DOM work
2. **Use `closest()`** for finding ancestors by selector
3. **Use `contains()`** to check ancestor/descendant relationships
4. **Cache traversal results** when used multiple times
5. **Prefer `querySelector`/`querySelectorAll`** over manual traversal
6. **Use TreeWalker** for complex traversal with filtering
7. **Convert live collections to arrays** before modifying DOM

---

**End of Chapter 1.7: DOM Traversal**

Next chapter: **1.8 ClassList API** — deep dive into `add`, `remove`, `toggle`, `contains`, `replace`, and class manipulation patterns.
# 1.8 ClassList API

The `classList` property provides a powerful, intuitive API for manipulating CSS classes on elements. Before `classList`, developers used string manipulation on the `className` property — error-prone and verbose. `classList` makes class manipulation clean, efficient, and safe.

This chapter covers the complete `classList` API with practical patterns for state management, animations, and component development.

---

## 1.8.1 The DOMTokenList Interface

`classList` returns a `DOMTokenList` — a live, ordered collection of class tokens.

### Basic Access

```javascript
const element = document.getElementById('card');
// <div id="card" class="card featured active">

// Access classList
const classes = element.classList;

console.log(classes);          // DOMTokenList ["card", "featured", "active"]
console.log(classes.length);   // 3
console.log(classes[0]);       // "card"
console.log(classes[1]);       // "featured"
console.log(classes.value);    // "card featured active" (string)
```

### Live Nature

```javascript
const classes = element.classList;
console.log(classes.length);  // 3

element.classList.add('new-class');
console.log(classes.length);  // 4 (automatically updated)

// classList and className are linked
element.className = 'single-class';
console.log(classes.length);  // 1 (reflects className change)
```

### Iteration

```javascript
const element = document.querySelector('.multi-class');

// forEach
element.classList.forEach(className => {
  console.log(className);
});

// for...of
for (const className of element.classList) {
  console.log(className);
}

// Convert to array
const classArray = Array.from(element.classList);
const classArray2 = [...element.classList];

// entries, keys, values
for (const [index, className] of element.classList.entries()) {
  console.log(`${index}: ${className}`);
}
```

---

## 1.8.2 add()

Adds one or more classes to the element.

### Basic Usage

```javascript
const element = document.getElementById('box');

// Add single class
element.classList.add('active');

// Add multiple classes
element.classList.add('highlighted', 'visible', 'animated');

// Spread array of classes
const classesToAdd = ['class1', 'class2', 'class3'];
element.classList.add(...classesToAdd);
```

### Behavior Details

```javascript
// Adding existing class does nothing (no duplicates)
element.classList.add('active');
element.classList.add('active');  // No error, no duplicate
console.log(element.className);   // "... active ..." (only once)

// Empty strings and whitespace throw errors
element.classList.add('');           // SyntaxError!
element.classList.add('has space');  // InvalidCharacterError!
element.classList.add('has\ttab');   // InvalidCharacterError!

// Returns undefined
const result = element.classList.add('test');
console.log(result);  // undefined
```

### Common Patterns

```javascript
// Show element
element.classList.add('visible');

// Activate item
element.classList.add('active');

// Apply animation
element.classList.add('animate-fade-in');

// Multiple state classes
function selectCard(card) {
  card.classList.add('selected', 'elevated', 'focused');
}
```

---

## 1.8.3 remove()

Removes one or more classes from the element.

### Basic Usage

```javascript
const element = document.getElementById('modal');

// Remove single class
element.classList.remove('hidden');

// Remove multiple classes
element.classList.remove('loading', 'pending', 'disabled');

// Spread array
const classesToRemove = ['temp1', 'temp2'];
element.classList.remove(...classesToRemove);
```

### Behavior Details

```javascript
// Removing non-existent class does nothing (no error)
element.classList.remove('nonexistent');  // Safe, no error

// Cannot remove with empty/whitespace strings
element.classList.remove('');           // SyntaxError!
element.classList.remove('has space');  // InvalidCharacterError!

// Returns undefined
const result = element.classList.remove('test');
console.log(result);  // undefined
```

### Common Patterns

```javascript
// Hide element
element.classList.remove('visible');

// Clear loading state
element.classList.remove('loading', 'spinner-active');

// Cleanup animation classes
function onAnimationEnd(element) {
  element.classList.remove(
    'animate-slide-in',
    'animate-fade-in',
    'animate-bounce'
  );
}

// Remove all matching classes
function removeClassesStartingWith(element, prefix) {
  const toRemove = Array.from(element.classList)
    .filter(c => c.startsWith(prefix));
  element.classList.remove(...toRemove);
}

removeClassesStartingWith(element, 'temp-');
```

---

## 1.8.4 toggle()

Toggles a class — adds if missing, removes if present.

### Basic Usage

```javascript
const button = document.getElementById('toggle-btn');

// Toggle class
button.classList.toggle('active');

// Returns new state: true if added, false if removed
const isNowActive = button.classList.toggle('active');
console.log(isNowActive);  // true or false
```

### Conditional Toggle (Force Parameter)

```javascript
const element = document.getElementById('box');

// toggle(class, force)
// force = true: always add (like add)
// force = false: always remove (like remove)

element.classList.toggle('visible', true);   // Always adds
element.classList.toggle('visible', false);  // Always removes

// Useful for binding to conditions
const isLoggedIn = checkAuth();
element.classList.toggle('authenticated', isLoggedIn);
element.classList.toggle('guest', !isLoggedIn);

// Sync with variable
let darkMode = loadPreference('darkMode');
document.body.classList.toggle('dark-theme', darkMode);

function toggleDarkMode() {
  darkMode = !darkMode;
  document.body.classList.toggle('dark-theme', darkMode);
  savePreference('darkMode', darkMode);
}
```

### Common Patterns

```javascript
// Expand/collapse
function toggleAccordion(header) {
  const content = header.nextElementSibling;
  const isExpanded = header.classList.toggle('expanded');
  content.classList.toggle('expanded', isExpanded);
  header.setAttribute('aria-expanded', isExpanded);
}

// Menu toggle
function toggleMenu() {
  const isOpen = navMenu.classList.toggle('open');
  menuButton.classList.toggle('active', isOpen);
  menuButton.setAttribute('aria-expanded', isOpen);
}

// Selection toggle
function toggleSelection(item) {
  item.classList.toggle('selected');
}

// Toggle with animation
function togglePanel(panel) {
  const isOpening = panel.classList.toggle('open');
  
  if (isOpening) {
    panel.classList.add('animating-in');
    panel.addEventListener('animationend', () => {
      panel.classList.remove('animating-in');
    }, { once: true });
  } else {
    panel.classList.add('animating-out');
    panel.addEventListener('animationend', () => {
      panel.classList.remove('animating-out');
    }, { once: true });
  }
}
```

---

## 1.8.5 contains()

Checks if the element has a specific class.

### Basic Usage

```javascript
const element = document.getElementById('box');

// Check for class
const hasActive = element.classList.contains('active');
console.log(hasActive);  // true or false

// Common usage
if (element.classList.contains('loading')) {
  console.log('Still loading...');
}

if (!element.classList.contains('initialized')) {
  initializeComponent(element);
  element.classList.add('initialized');
}
```

### Patterns

```javascript
// State checking
function isSelected(item) {
  return item.classList.contains('selected');
}

// Filter elements by class
const cards = document.querySelectorAll('.card');
const activeCards = Array.from(cards)
  .filter(card => card.classList.contains('active'));

// Conditional actions
function handleClick(element) {
  if (element.classList.contains('disabled')) {
    return;  // Don't process disabled elements
  }
  
  if (element.classList.contains('expandable')) {
    toggleExpand(element);
  }
}

// Accessibility: sync with ARIA
function updateAccessibility(button) {
  const isPressed = button.classList.contains('pressed');
  button.setAttribute('aria-pressed', isPressed);
}
```

---

## 1.8.6 replace()

Replaces one class with another in a single operation.

### Basic Usage

```javascript
const element = document.getElementById('status');

// Replace old class with new class
element.classList.replace('loading', 'loaded');

// Returns true if old class was replaced
const wasReplaced = element.classList.replace('pending', 'complete');
console.log(wasReplaced);  // true if 'pending' existed and was replaced

// Returns false if old class didn't exist
const notReplaced = element.classList.replace('nonexistent', 'new');
console.log(notReplaced);  // false (nothing happened)
```

### vs remove() + add()

```javascript
// These are functionally similar but...
element.classList.replace('old', 'new');

// vs
element.classList.remove('old');
element.classList.add('new');

// replace() advantages:
// - Single operation (potentially faster)
// - Returns whether replacement occurred
// - More semantic intent
// - Atomic: both happen or neither

// remove+add advantages:
// - Works even if old class doesn't exist
// - Can remove/add different numbers of classes
```

### Common Patterns

```javascript
// State transitions
function setStatus(element, newStatus) {
  const statuses = ['pending', 'loading', 'success', 'error'];
  
  for (const status of statuses) {
    if (element.classList.contains(status)) {
      element.classList.replace(status, newStatus);
      return;
    }
  }
  
  // No existing status found, just add
  element.classList.add(newStatus);
}

// Theme switching
function setTheme(theme) {
  const themes = ['theme-light', 'theme-dark', 'theme-auto'];
  const newTheme = `theme-${theme}`;
  
  for (const t of themes) {
    if (document.body.classList.replace(t, newTheme)) {
      return;  // Replaced existing theme
    }
  }
  
  // No existing theme, add new one
  document.body.classList.add(newTheme);
}

// Size variants
function setSize(element, size) {
  const sizes = ['size-sm', 'size-md', 'size-lg', 'size-xl'];
  const newSize = `size-${size}`;
  
  for (const s of sizes) {
    element.classList.replace(s, newSize);
  }
}
```

---

## 1.8.7 item() and Index Access

Access classes by index.

### Usage

```javascript
const element = document.querySelector('.multi-class');
// <div class="primary secondary tertiary">

// Index access
console.log(element.classList[0]);  // "primary"
console.log(element.classList[1]);  // "secondary"

// item() method
console.log(element.classList.item(0));  // "primary"
console.log(element.classList.item(2));  // "tertiary"

// Out of bounds
console.log(element.classList[99]);       // undefined
console.log(element.classList.item(99));  // null

// Practical use is rare - usually use contains() instead
```

---

## 1.8.8 value Property

Access or set all classes as a string.

### Usage

```javascript
const element = document.querySelector('.card');

// Read all classes as string
console.log(element.classList.value);  // "card featured active"

// Same as className
console.log(element.classList.value === element.className);  // true

// Set all classes
element.classList.value = 'new-class other-class';
// Replaces all existing classes

// Functionally same as:
element.className = 'new-class other-class';
```

---

## 1.8.9 Advanced Patterns

### State Machine with Classes

```javascript
class ElementStateMachine {
  constructor(element, states) {
    this.element = element;
    this.states = states;
    this.currentState = null;
  }
  
  setState(newState) {
    if (!this.states.includes(newState)) {
      throw new Error(`Invalid state: ${newState}`);
    }
    
    // Remove current state
    if (this.currentState) {
      this.element.classList.remove(`state-${this.currentState}`);
    }
    
    // Add new state
    this.element.classList.add(`state-${newState}`);
    this.currentState = newState;
    
    // Emit event
    this.element.dispatchEvent(new CustomEvent('statechange', {
      detail: { from: this.currentState, to: newState }
    }));
  }
  
  getState() {
    return this.currentState;
  }
}

// Usage
const button = document.getElementById('submit-btn');
const buttonState = new ElementStateMachine(button, [
  'idle', 'loading', 'success', 'error'
]);

buttonState.setState('loading');
// Button now has class "state-loading"
```

### BEM Modifier Management

```javascript
// BEM: Block__Element--Modifier pattern
class BEMElement {
  constructor(element, block, elementName = null) {
    this.element = element;
    this.prefix = elementName ? `${block}__${elementName}` : block;
  }
  
  addModifier(modifier) {
    this.element.classList.add(`${this.prefix}--${modifier}`);
    return this;
  }
  
  removeModifier(modifier) {
    this.element.classList.remove(`${this.prefix}--${modifier}`);
    return this;
  }
  
  toggleModifier(modifier, force) {
    this.element.classList.toggle(`${this.prefix}--${modifier}`, force);
    return this;
  }
  
  hasModifier(modifier) {
    return this.element.classList.contains(`${this.prefix}--${modifier}`);
  }
}

// Usage
const card = new BEMElement(document.querySelector('.card'), 'card');
card.addModifier('featured')
    .addModifier('large');
// Classes: card card--featured card--large

const cardTitle = new BEMElement(
  document.querySelector('.card__title'), 
  'card', 
  'title'
);
cardTitle.addModifier('bold');
// Classes: card__title card__title--bold
```

### Animation Helpers

```javascript
// Trigger CSS animation and clean up
function animate(element, animationClass) {
  return new Promise((resolve) => {
    element.classList.add(animationClass);
    
    element.addEventListener('animationend', function handler(e) {
      if (e.target === element) {
        element.classList.remove(animationClass);
        element.removeEventListener('animationend', handler);
        resolve();
      }
    });
  });
}

// Usage
async function showNotification(element) {
  await animate(element, 'slide-in');
  await delay(3000);
  await animate(element, 'fade-out');
  element.remove();
}

// One-time animation
function animateOnce(element, animationClass) {
  element.classList.add(animationClass);
  element.addEventListener('animationend', () => {
    element.classList.remove(animationClass);
  }, { once: true });
}
```

### Conditional Class Application

```javascript
// Apply classes based on conditions
function applyClasses(element, classConditions) {
  for (const [className, condition] of Object.entries(classConditions)) {
    element.classList.toggle(className, Boolean(condition));
  }
}

// Usage
applyClasses(element, {
  'is-active': isActive,
  'is-disabled': isDisabled,
  'is-loading': isLoading,
  'has-error': errorMessage,
  'is-empty': items.length === 0
});

// With computed classes
function computeClasses(state) {
  return {
    'card': true,
    'card--featured': state.featured,
    'card--archived': state.archived,
    [`card--${state.size}`]: state.size,
    [`card--theme-${state.theme}`]: state.theme
  };
}

function setClasses(element, classMap) {
  for (const [className, shouldHave] of Object.entries(classMap)) {
    if (shouldHave) {
      element.classList.add(className);
    } else {
      element.classList.remove(className);
    }
  }
}

setClasses(cardElement, computeClasses(cardState));
```

---

## 1.8.10 Comparison: classList vs className

### className (Legacy Approach)

```javascript
// Read
const classes = element.className;  // "card active featured"

// Set (replaces ALL classes)
element.className = 'card';

// Add class (string manipulation)
element.className += ' active';  // ⚠️ Leading space needed!

// Remove class (regex)
element.className = element.className.replace(/\bactive\b/g, '').trim();

// Check for class
const hasActive = /\bactive\b/.test(element.className);

// Toggle (complex!)
if (/\bactive\b/.test(element.className)) {
  element.className = element.className.replace(/\bactive\b/g, '');
} else {
  element.className += ' active';
}
```

### classList (Modern Approach)

```javascript
// Read
const classes = element.classList;  // DOMTokenList

// Add
element.classList.add('active');

// Remove
element.classList.remove('active');

// Check
const hasActive = element.classList.contains('active');

// Toggle
element.classList.toggle('active');
```

### Verdict

| Feature | className | classList |
|---------|-----------|-----------|
| Add single class | Awkward | Clean |
| Remove class | Regex needed | Simple |
| Toggle | Manual logic | Built-in |
| Check | Regex needed | Built-in |
| Multiple operations | Multiple assignments | Chained methods |
| Replace all | Direct | Use `.value` |
| Performance | Slightly faster write | Negligible difference |

**Use `classList`** for all class manipulation. **Use `className`** only when you need to replace all classes at once.

---

## 1.8.11 Summary

| Method | Purpose | Returns |
|--------|---------|---------|
| `add(...classes)` | Add classes | `undefined` |
| `remove(...classes)` | Remove classes | `undefined` |
| `toggle(class, force?)` | Toggle class | `boolean` (new state) |
| `contains(class)` | Check for class | `boolean` |
| `replace(old, new)` | Replace class | `boolean` (success) |
| `item(index)` | Get class by index | `string` or `null` |
| `length` | Number of classes | `number` |
| `value` | All classes as string | `string` |

### Best Practices

1. **Use `classList` over `className`** — cleaner, safer, more powerful
2. **Use `toggle` with force parameter** for syncing with state
3. **Use `contains` before conditional operations** when appropriate
4. **Use `replace` for state transitions** — cleaner than remove+add
5. **Handle animation cleanup** — remove animation classes after completion
6. **Consider utility classes** — build helpers for complex patterns
7. **Keep class lists short** — many classes indicate potential refactoring

### Gotchas

```javascript
// ❌ Classes cannot contain spaces
element.classList.add('has space');  // InvalidCharacterError

// ❌ Cannot add empty string
element.classList.add('');  // SyntaxError

// ⚠️ classList is live — loops can be affected
element.classList.forEach(c => element.classList.remove(c));
// May not remove all classes due to live nature

// ✅ Convert to array first
[...element.classList].forEach(c => element.classList.remove(c));
```

---

**End of Chapter 1.8: ClassList API**

This completes Group 01: DOM. Next group: **02 — Browser Object Model (BOM)** — starting with **2.1 Window Object**.
# 2.1 Window Object

The `window` object is the global object in browser JavaScript — the root of the Browser Object Model (BOM). It represents the browser window or tab and serves as the global scope for all JavaScript code. Every global variable, function, and object becomes a property of `window`.

This chapter covers the Window object comprehensively — from viewport dimensions to popup management, media queries, and advanced features like `matchMedia` and selection APIs.

---

## 2.1.1 The Global Object

In browsers, `window` is the global execution context.

### Global Scope Relationship

```javascript
// Global variables become window properties
var globalVar = 'hello';
console.log(window.globalVar);  // "hello"

// let/const do NOT become window properties
let letVar = 'world';
const constVar = '!';
console.log(window.letVar);    // undefined
console.log(window.constVar);  // undefined

// Global functions become window methods
function globalFunction() {
  return 'I am global';
}
console.log(window.globalFunction());  // "I am global"

// this in global scope
console.log(this === window);  // true (in non-strict mode)

// window is the global object
console.log(window.window === window);  // true
console.log(window.self === window);    // true
console.log(window.globalThis === window);  // true (ES2020)
```

### Implicit Window Reference

```javascript
// These are equivalent
window.alert('Hello');
alert('Hello');

window.console.log('test');
console.log('test');

window.document.getElementById('x');
document.getElementById('x');

// Built-in objects are window properties
console.log(window.Array === Array);    // true
console.log(window.Object === Object);  // true
console.log(window.Promise === Promise);  // true
```

### Window vs globalThis

```javascript
// globalThis is the ES2020 standard global object
// Works in all environments (browser, Node.js, workers)

// Browser main thread
console.log(globalThis === window);  // true

// Web Worker
// console.log(globalThis === self);  // true (no window in workers)

// Use globalThis for cross-environment code
const global = globalThis || window || self;
```

---

## 2.1.2 Viewport Dimensions

Understanding viewport and window dimensions is crucial for responsive design and layout calculations.

### Inner Dimensions (Viewport)

```javascript
// Viewport dimensions (visible content area)
const viewportWidth = window.innerWidth;   // Includes scrollbar
const viewportHeight = window.innerHeight;

console.log(`Viewport: ${viewportWidth} x ${viewportHeight}`);

// These change when browser is resized
window.addEventListener('resize', () => {
  console.log(`New size: ${innerWidth} x ${innerHeight}`);
});
```

### Outer Dimensions (Browser Window)

```javascript
// Entire browser window including toolbars, borders
const browserWidth = window.outerWidth;
const browserHeight = window.outerHeight;

console.log(`Browser window: ${browserWidth} x ${browserHeight}`);

// Difference between inner and outer indicates chrome size
const chromeHeight = outerHeight - innerHeight;  // Toolbars, address bar
const chromeWidth = outerWidth - innerWidth;     // Usually 0 or small
```

### Document vs Viewport Dimensions

```javascript
// Document dimensions (scrollable area)
const docWidth = document.documentElement.scrollWidth;
const docHeight = document.documentElement.scrollHeight;

// Client dimensions (viewport without scrollbar)
const clientWidth = document.documentElement.clientWidth;
const clientHeight = document.documentElement.clientHeight;

// innerWidth includes scrollbar, clientWidth excludes it
const scrollbarWidth = innerWidth - clientWidth;
console.log(`Scrollbar width: ${scrollbarWidth}px`);
```

### Dimension Comparison

| Property | Includes Scrollbar? | Includes Chrome? |
|----------|---------------------|------------------|
| `innerWidth/Height` | Yes | No |
| `outerWidth/Height` | Yes | Yes |
| `clientWidth/Height` | No | No |

---

## 2.1.3 Scroll Position

Track and control the document's scroll position.

### Reading Scroll Position

```javascript
// Current scroll position
const scrollX = window.scrollX;  // Horizontal scroll
const scrollY = window.scrollY;  // Vertical scroll

// Aliases (older API)
const pageXOffset = window.pageXOffset;  // Same as scrollX
const pageYOffset = window.pageYOffset;  // Same as scrollY

console.log(`Scrolled: ${scrollX}px right, ${scrollY}px down`);

// Track scroll
window.addEventListener('scroll', () => {
  console.log(`Scroll position: ${scrollX}, ${scrollY}`);
});
```

### scrollTo() — Scroll to Absolute Position

```javascript
// Scroll to specific coordinates
window.scrollTo(0, 500);  // Scroll to 500px from top

// With options (smooth scrolling)
window.scrollTo({
  top: 500,
  left: 0,
  behavior: 'smooth'  // 'auto' (instant) or 'smooth'
});

// Scroll to top
window.scrollTo(0, 0);

// Scroll to bottom
window.scrollTo(0, document.documentElement.scrollHeight);
```

### scrollBy() — Scroll by Relative Amount

```javascript
// Scroll relative to current position
window.scrollBy(0, 100);  // Scroll down 100px

// With options
window.scrollBy({
  top: 100,
  left: 0,
  behavior: 'smooth'
});

// Scroll up
window.scrollBy(0, -100);
```

### Scroll Restoration

```javascript
// Control scroll behavior on navigation
// 'auto': browser handles (restores scroll on back)
// 'manual': you handle it

history.scrollRestoration = 'manual';

// Useful for SPAs where you manage scroll yourself
window.addEventListener('popstate', () => {
  // Handle scroll manually
  window.scrollTo(0, 0);
});
```

---

## 2.1.4 Window Position and Size

Control the browser window's position and size (with limitations).

### Window Position

```javascript
// Position of window on screen
const x = window.screenX;  // Or screenLeft (older)
const y = window.screenY;  // Or screenTop (older)

console.log(`Window at screen position: ${x}, ${y}`);
```

### moveTo() and moveBy()

```javascript
// ⚠️ Only works on windows opened by window.open()
// Modern browsers block this for user-opened windows

// Move window to absolute position
window.moveTo(100, 100);  // Move to screen coordinates (100, 100)

// Move window by relative amount
window.moveBy(50, 50);    // Move 50px right and down

// Practical use with popup
const popup = window.open('about:blank', 'popup', 'width=400,height=300');
popup.moveTo(0, 0);       // Move popup to top-left corner
```

### resizeTo() and resizeBy()

```javascript
// ⚠️ Same restrictions as moveTo/moveBy

// Resize to absolute dimensions
window.resizeTo(800, 600);

// Resize by relative amount
window.resizeBy(100, 0);  // Make 100px wider

// With popup
const popup = window.open('about:blank', 'popup', 'width=200,height=200');
popup.resizeTo(500, 400);
```

### Security Restrictions

```javascript
// Modern browsers restrict these methods:
// 1. Cannot resize/move the main window
// 2. Can only affect windows opened via window.open()
// 3. User may have browser settings that block these
// 4. Minimum window size enforced

// Best practice: avoid relying on these methods
// Use responsive CSS instead
```

---

## 2.1.5 Opening and Closing Windows

### window.open()

```javascript
// Basic usage
const newWindow = window.open('https://example.com');

// With target (like link target)
window.open('https://example.com', '_blank');   // New tab (usually)
window.open('https://example.com', '_self');    // Current window
window.open('https://example.com', 'myWindow'); // Named window

// With features (creates popup, not tab)
const popup = window.open(
  'https://example.com',
  'popupName',
  'width=800,height=600,left=100,top=100'
);

// Full features string
const popup2 = window.open(
  'page.html',
  'popup',
  'width=600,height=400,menubar=no,toolbar=no,location=no,status=no,scrollbars=yes,resizable=yes'
);
```

### Feature String Options

| Feature | Values | Description |
|---------|--------|-------------|
| `width` | pixels | Window width |
| `height` | pixels | Window height |
| `left` | pixels | X position |
| `top` | pixels | Y position |
| `menubar` | yes/no | Show menu bar |
| `toolbar` | yes/no | Show toolbar |
| `location` | yes/no | Show address bar |
| `status` | yes/no | Show status bar |
| `scrollbars` | yes/no | Show scrollbars |
| `resizable` | yes/no | Allow resize |
| `noopener` | (flag) | No opener reference |
| `noreferrer` | (flag) | No referrer + no opener |

### Popup Blockers

```javascript
// open() may return null if blocked
const newWin = window.open('https://example.com');

if (newWin === null) {
  console.log('Popup was blocked');
  // Show message to user or fallback
  alert('Please allow popups for this site');
}

// Popups are usually allowed if:
// 1. Triggered by user action (click, keypress)
// 2. Not triggered by timers, load events, etc.

// ✅ Works (user-triggered)
button.addEventListener('click', () => {
  window.open('https://example.com');
});

// ❌ Usually blocked (not user-triggered)
setTimeout(() => {
  window.open('https://example.com');  // Blocked!
}, 1000);
```

### window.close()

```javascript
// Close current window
window.close();

// ⚠️ Restrictions:
// - Can only close windows opened by JavaScript
// - Cannot close the main browser window

// Close a popup we opened
const popup = window.open('page.html', 'popup', 'width=400,height=300');

// Later...
popup.close();

// Check if window is closed
if (popup.closed) {
  console.log('Popup was closed');
}
```

### Window References

```javascript
// window.opener — reference to window that opened this one
if (window.opener) {
  // We were opened by another window
  console.log(window.opener.location.href);
  
  // Can communicate back
  window.opener.postMessage('Hello from popup', '*');
}

// Security: use noopener for external links
const external = window.open('https://untrusted.com', '_blank', 'noopener');
// external.opener will be null (safer)
```

---

## 2.1.6 Timers

The window object provides timer functions (see ECMAScript §13 for full details).

### setTimeout and setInterval

```javascript
// Execute once after delay
const timeoutId = setTimeout(() => {
  console.log('Delayed execution');
}, 1000);

// Cancel timeout
clearTimeout(timeoutId);

// Execute repeatedly
const intervalId = setInterval(() => {
  console.log('Repeating...');
}, 1000);

// Cancel interval
clearInterval(intervalId);
```

### requestAnimationFrame

```javascript
// Optimized for animations (syncs with display refresh)
let animationId;

function animate() {
  // Update animation state
  element.style.left = `${position++}px`;
  
  // Schedule next frame
  animationId = requestAnimationFrame(animate);
}

// Start animation
animationId = requestAnimationFrame(animate);

// Stop animation
cancelAnimationFrame(animationId);
```

### requestIdleCallback

```javascript
// Execute when browser is idle
const idleId = requestIdleCallback((deadline) => {
  // deadline.timeRemaining() — ms remaining in idle period
  // deadline.didTimeout — true if callback fired due to timeout
  
  while (deadline.timeRemaining() > 0 && tasks.length > 0) {
    processTask(tasks.shift());
  }
  
  if (tasks.length > 0) {
    // Schedule more work
    requestIdleCallback(processRemainingTasks);
  }
}, { timeout: 2000 });  // Max wait time

// Cancel
cancelIdleCallback(idleId);
```

---

## 2.1.7 Focus and Blur

### window.focus() and window.blur()

```javascript
// Focus the window (bring to front)
window.focus();

// Remove focus from window
window.blur();

// Focus a popup we opened
const popup = window.open('page.html', 'popup');
popup.focus();

// Events for focus changes
window.addEventListener('focus', () => {
  console.log('Window focused');
  document.title = 'Active';
});

window.addEventListener('blur', () => {
  console.log('Window blurred');
  document.title = '[Inactive] Page';
});
```

### Visibility API (Better Alternative)

```javascript
// Preferred way to detect visibility
document.addEventListener('visibilitychange', () => {
  if (document.visibilityState === 'visible') {
    console.log('Tab is visible');
    resumeAnimations();
    reconnectWebSocket();
  } else {
    console.log('Tab is hidden');
    pauseAnimations();
    disconnectWebSocket();
  }
});

// visibilityState: 'visible', 'hidden', 'prerender'
console.log(document.visibilityState);
console.log(document.hidden);  // Boolean shortcut
```

---

## 2.1.8 print()

Trigger the browser's print dialog.

```javascript
// Open print dialog
window.print();

// Common usage: print button
printBtn.addEventListener('click', () => {
  window.print();
});

// Print-specific styling (use CSS)
// @media print {
//   .no-print { display: none; }
//   body { font-size: 12pt; }
// }

// Listen for print events
window.addEventListener('beforeprint', () => {
  // Prepare page for printing
  showPrintableContent();
});

window.addEventListener('afterprint', () => {
  // Restore normal view
  restoreNormalContent();
});
```

---

## 2.1.9 getSelection()

Access the current text selection.

### Reading Selection

```javascript
// Get the Selection object
const selection = window.getSelection();

// Get selected text
const selectedText = selection.toString();
console.log('Selected:', selectedText);

// Selection details
console.log(selection.anchorNode);    // Node where selection started
console.log(selection.focusNode);     // Node where selection ended
console.log(selection.rangeCount);    // Number of ranges (usually 1)
console.log(selection.isCollapsed);   // true if no selection (cursor)

// Get the Range object
if (selection.rangeCount > 0) {
  const range = selection.getRangeAt(0);
  console.log(range.startContainer);
  console.log(range.endContainer);
}
```

### Manipulating Selection

```javascript
// Clear selection
window.getSelection().removeAllRanges();

// Select all text in an element
function selectElement(element) {
  const range = document.createRange();
  range.selectNodeContents(element);
  
  const selection = window.getSelection();
  selection.removeAllRanges();
  selection.addRange(range);
}

// Copy selected text
async function copySelection() {
  const text = window.getSelection().toString();
  await navigator.clipboard.writeText(text);
}
```

### Selection Events

```javascript
// Listen for selection changes
document.addEventListener('selectionchange', () => {
  const selection = window.getSelection();
  if (selection.toString().length > 0) {
    showCopyButton(selection);
  } else {
    hideCopyButton();
  }
});
```

---

## 2.1.10 matchMedia()

Query media features programmatically — the JavaScript equivalent of CSS media queries.

### Basic Usage

```javascript
// Create a MediaQueryList
const darkModeQuery = window.matchMedia('(prefers-color-scheme: dark)');

// Check if query matches
if (darkModeQuery.matches) {
  console.log('User prefers dark mode');
}

// Full media query syntax works
const mobileQuery = matchMedia('(max-width: 768px)');
const landscapeQuery = matchMedia('(orientation: landscape)');
const printQuery = matchMedia('print');
const hoverQuery = matchMedia('(hover: hover)');
const reducedMotionQuery = matchMedia('(prefers-reduced-motion: reduce)');
```

### Listening for Changes

```javascript
const mediaQuery = window.matchMedia('(max-width: 768px)');

// Modern approach: addEventListener
mediaQuery.addEventListener('change', (e) => {
  if (e.matches) {
    console.log('Viewport is now mobile-sized');
    enableMobileUI();
  } else {
    console.log('Viewport is now desktop-sized');
    enableDesktopUI();
  }
});

// Check initial state + listen for changes
function handleMediaChange(e) {
  document.body.classList.toggle('mobile', e.matches);
}
mediaQuery.addEventListener('change', handleMediaChange);
handleMediaChange(mediaQuery);  // Initial check
```

### Common Media Queries

```javascript
// Dark mode preference
const darkMode = matchMedia('(prefers-color-scheme: dark)');

// Reduced motion (accessibility)
const reducedMotion = matchMedia('(prefers-reduced-motion: reduce)');
if (reducedMotion.matches) {
  // Disable animations
  document.documentElement.style.setProperty('--animation-duration', '0');
}

// High contrast
const highContrast = matchMedia('(prefers-contrast: more)');

// Touch device
const touchDevice = matchMedia('(hover: none) and (pointer: coarse)');

// Print
const printMode = matchMedia('print');
printMode.addEventListener('change', (e) => {
  if (e.matches) {
    // Entering print mode
  }
});
```

### Responsive JavaScript

```javascript
// Change behavior based on viewport
class ResponsiveApp {
  constructor() {
    this.breakpoints = {
      mobile: matchMedia('(max-width: 767px)'),
      tablet: matchMedia('(min-width: 768px) and (max-width: 1023px)'),
      desktop: matchMedia('(min-width: 1024px)')
    };
    
    this.setupListeners();
    this.updateForCurrentBreakpoint();
  }
  
  setupListeners() {
    Object.values(this.breakpoints).forEach(mq => {
      mq.addEventListener('change', () => {
        this.updateForCurrentBreakpoint();
      });
    });
  }
  
  updateForCurrentBreakpoint() {
    if (this.breakpoints.mobile.matches) {
      this.enableMobileMode();
    } else if (this.breakpoints.tablet.matches) {
      this.enableTabletMode();
    } else {
      this.enableDesktopMode();
    }
  }
  
  enableMobileMode() {
    // Mobile-specific JS
  }
  
  enableTabletMode() {
    // Tablet-specific JS
  }
  
  enableDesktopMode() {
    // Desktop-specific JS
  }
}
```

---

## 2.1.11 Other Window Properties

### devicePixelRatio

```javascript
// How many physical pixels per CSS pixel
const dpr = window.devicePixelRatio;

console.log(`Device pixel ratio: ${dpr}`);
// 1 = standard displays
// 2 = Retina/HiDPI displays
// Can be fractional (1.5, 2.25, etc.)

// Use for high-resolution images/canvas
function getImageSrc(baseName) {
  if (devicePixelRatio >= 2) {
    return `${baseName}@2x.png`;
  }
  return `${baseName}.png`;
}

// Canvas with high-res support
function setupHiDPICanvas(canvas, width, height) {
  const dpr = devicePixelRatio || 1;
  canvas.width = width * dpr;
  canvas.height = height * dpr;
  canvas.style.width = `${width}px`;
  canvas.style.height = `${height}px`;
  
  const ctx = canvas.getContext('2d');
  ctx.scale(dpr, dpr);
  return ctx;
}
```

### name

```javascript
// Window name (used for targeting)
console.log(window.name);  // "" by default

// Set name
window.name = 'myWindow';

// Used with window.open targeting
window.open('page.html', 'myWindow');  // Opens in this window

// ⚠️ window.name persists across navigations
// Can be a security concern — don't store sensitive data
```

### parent, top, and frames

```javascript
// For frames/iframes

// Reference to parent window
console.log(window.parent);

// Reference to topmost window
console.log(window.top);

// Check if in an iframe
if (window.self !== window.top) {
  console.log('This page is in an iframe');
}

// Frames collection
console.log(window.frames.length);  // Number of iframes
console.log(window.frames[0]);      // First iframe's window
```

### isSecureContext

```javascript
// Check if running in secure context (HTTPS, localhost, etc.)
if (window.isSecureContext) {
  console.log('Secure context — can use secure-only APIs');
  // Crypto, Service Workers, Push API, etc.
} else {
  console.log('Not secure — some APIs unavailable');
}
```

---

## 2.1.12 Summary

| Property/Method | Purpose |
|-----------------|---------|
| `innerWidth/Height` | Viewport dimensions |
| `outerWidth/Height` | Browser window dimensions |
| `scrollX/Y` | Current scroll position |
| `scrollTo()` | Scroll to absolute position |
| `scrollBy()` | Scroll by relative amount |
| `open()` | Open new window/tab |
| `close()` | Close window |
| `focus()/blur()` | Window focus management |
| `print()` | Trigger print dialog |
| `getSelection()` | Get text selection |
| `matchMedia()` | Query media features |
| `devicePixelRatio` | Display density |

### Best Practices

1. **Use `globalThis`** for cross-environment code (browsers, workers, Node.js)
2. **Use `matchMedia`** for responsive JavaScript instead of resize events
3. **Respect `prefers-reduced-motion`** for accessibility
4. **Handle popup blockers** gracefully — check if `open()` returns null
5. **Use `noopener`** with `window.open()` for external links (security)
6. **Prefer Visibility API** over focus/blur for tab visibility
7. **Cache `devicePixelRatio`** — it's a constant for the session

### Common Gotchas

```javascript
// ❌ moveTo/resizeTo don't work on main window
window.resizeTo(800, 600);  // Ignored

// ❌ Popups blocked without user interaction
setTimeout(() => window.open('...'), 1000);  // Blocked

// ❌ innerWidth includes scrollbar, clientWidth doesn't
// Use clientWidth for content area calculations

// ⚠️ window.name persists — can leak between origins
window.name = 'sensitive';  // Don't do this
```

---

**End of Chapter 2.1: Window Object**

Next chapter: **2.2 Location Object** — covers URL manipulation, navigation, and the `assign`, `replace`, and `reload` methods.
# 2.2 Location Object

The `location` object represents the current URL and provides methods for navigating to new pages. It's available as both `window.location` and `document.location` (they reference the same object). Understanding the Location API is essential for SPAs, deep linking, URL parameter handling, and programmatic navigation.

---

## 2.2.1 URL Components

The location object exposes all parts of the current URL.

### URL Anatomy

```javascript
// Example URL:
// https://user:pass@www.example.com:8080/path/page.html?query=1&foo=bar#section

console.log(location.href);      
// "https://user:pass@www.example.com:8080/path/page.html?query=1&foo=bar#section"

console.log(location.protocol);  // "https:"
console.log(location.username);  // "user" (rarely used)
console.log(location.password);  // "pass" (rarely used)
console.log(location.host);      // "www.example.com:8080" (hostname + port)
console.log(location.hostname);  // "www.example.com"
console.log(location.port);      // "8080" (empty string if default)
console.log(location.pathname);  // "/path/page.html"
console.log(location.search);    // "?query=1&foo=bar"
console.log(location.hash);      // "#section"
console.log(location.origin);    // "https://www.example.com:8080" (read-only)
```

### Property Details

| Property | Includes | Writable |
|----------|----------|----------|
| `href` | Complete URL | Yes |
| `protocol` | Protocol with colon | Yes |
| `host` | Hostname + port | Yes |
| `hostname` | Hostname only | Yes |
| `port` | Port number | Yes |
| `pathname` | Path starting with `/` | Yes |
| `search` | Query string with `?` | Yes |
| `hash` | Fragment with `#` | Yes |
| `origin` | Protocol + hostname + port | **No** |

### Reading URL Parts

```javascript
// Current URL: https://shop.example.com/products?category=shoes&size=10#reviews

// Get the query string
const query = location.search;  // "?category=shoes&size=10"

// Parse query parameters
const params = new URLSearchParams(location.search);
console.log(params.get('category'));  // "shoes"
console.log(params.get('size'));      // "10"

// Get hash
const section = location.hash;  // "#reviews"
const sectionId = location.hash.slice(1);  // "reviews" (without #)

// Check protocol
if (location.protocol === 'https:') {
  console.log('Secure connection');
}
```

---

## 2.2.2 Modifying the URL

Setting location properties triggers navigation.

### Setting href

```javascript
// Navigate to new page (creates history entry)
location.href = 'https://example.com/new-page';

// Relative URLs work
location.href = '/another-page';
location.href = '../parent-page';
location.href = 'sibling-page.html';

// Shorthand: assign to location directly
location = 'https://example.com';  // Same as setting href
window.location = '/page';          // Same effect
```

### Modifying Individual Parts

```javascript
// Change just the hash (no page reload!)
location.hash = 'section2';
// URL becomes: current-url#section2

// Change query string (causes reload)
location.search = '?page=2&sort=name';

// Change pathname (causes reload)
location.pathname = '/new-path';

// Change protocol (causes reload)
location.protocol = 'https:';  // Forces HTTPS

// Change host (causes navigation)
location.hostname = 'other-domain.com';
```

### Hash Changes (No Reload)

```javascript
// Changing hash does NOT reload the page
location.hash = 'section1';

// Listen for hash changes
window.addEventListener('hashchange', (e) => {
  console.log('Old URL:', e.oldURL);
  console.log('New URL:', e.newURL);
  console.log('New hash:', location.hash);
  
  // Handle hash-based routing
  handleRoute(location.hash.slice(1));
});

// Useful for SPAs (simple client-side routing)
function navigate(sectionId) {
  location.hash = sectionId;
}
```

---

## 2.2.3 Navigation Methods

### assign()

Navigates to a new URL, adding a history entry.

```javascript
// Navigate (same as setting href)
location.assign('https://example.com/page');

// Adds to browser history
// User can press Back to return

// Equivalent to:
location.href = 'https://example.com/page';
```

### replace()

Navigates to a new URL, replacing the current history entry.

```javascript
// Navigate without adding history entry
location.replace('https://example.com/page');

// Current page is removed from history
// User cannot press Back to return here

// Use cases:
// - Redirect after login (don't want user to go back to login)
// - Redirect after form submission
// - Temporary pages that shouldn't be in history

// Example: Post-login redirect
function handleLoginSuccess() {
  // Don't allow going back to login form
  location.replace('/dashboard');
}

// Example: Language redirect
if (location.pathname === '/') {
  const lang = navigator.language.slice(0, 2);
  location.replace(`/${lang}/home`);
}
```

### reload()

Reloads the current page.

```javascript
// Reload the page
location.reload();

// ⚠️ The forceReload parameter is deprecated
// location.reload(true);  // Don't use

// To force bypass cache, use:
// - Ctrl+Shift+R (user action)
// - Or fetch new content via JavaScript

// Reload after action
function saveAndReload() {
  saveData()
    .then(() => location.reload());
}

// Reload with new query params
function refreshWithParams(newParams) {
  const url = new URL(location.href);
  Object.entries(newParams).forEach(([key, value]) => {
    url.searchParams.set(key, value);
  });
  location.href = url.toString();
}
```

### Method Comparison

| Method | Creates History Entry? | User Can Go Back? |
|--------|------------------------|-------------------|
| `assign()` | Yes | Yes |
| `replace()` | No | No |
| Setting `href` | Yes | Yes |
| Setting `hash` | Yes | Yes (hash only) |
| `reload()` | No | N/A (same page) |

---

## 2.2.4 URL Object

Use the URL constructor for complex URL manipulation.

### Creating URLs

```javascript
// Absolute URL
const url = new URL('https://example.com/path?query=value');

// Relative URL with base
const relative = new URL('/page', 'https://example.com');
console.log(relative.href);  // "https://example.com/page"

// From current location
const current = new URL(location.href);

// With relative path
const nextPage = new URL('../other', location.href);
```

### Manipulating URLs

```javascript
const url = new URL('https://example.com/products');

// Modify parts
url.pathname = '/search';
url.hash = 'results';

// Work with query parameters
url.searchParams.set('category', 'electronics');
url.searchParams.set('page', '1');
url.searchParams.append('tag', 'sale');
url.searchParams.append('tag', 'new');

console.log(url.href);
// "https://example.com/search?category=electronics&page=1&tag=sale&tag=new#results"

// Read parameters
console.log(url.searchParams.get('category'));    // "electronics"
console.log(url.searchParams.getAll('tag'));      // ["sale", "new"]
console.log(url.searchParams.has('page'));        // true

// Remove parameters
url.searchParams.delete('tag');

// Iterate parameters
for (const [key, value] of url.searchParams) {
  console.log(`${key}: ${value}`);
}

// Sort parameters
url.searchParams.sort();
```

### URL vs location

```javascript
// URL is more powerful for manipulation
// location is specific to current page

// Build a URL without navigating
const apiUrl = new URL('/api/users', location.origin);
apiUrl.searchParams.set('limit', '10');

// Use it
fetch(apiUrl)
  .then(response => response.json())
  .then(data => console.log(data));

// Navigate only when ready
function navigate(path, params) {
  const url = new URL(path, location.origin);
  Object.entries(params).forEach(([key, value]) => {
    url.searchParams.set(key, value);
  });
  location.href = url.href;
}
```

---

## 2.2.5 URLSearchParams

The `searchParams` property (on URL) and standalone `URLSearchParams` for working with query strings.

### Creating URLSearchParams

```javascript
// From query string
const params1 = new URLSearchParams('?foo=bar&baz=qux');
const params2 = new URLSearchParams('foo=bar&baz=qux');  // ? is optional

// From current URL
const params3 = new URLSearchParams(location.search);

// From object
const params4 = new URLSearchParams({
  category: 'books',
  sort: 'price',
  page: '1'
});

// From array of pairs
const params5 = new URLSearchParams([
  ['tag', 'javascript'],
  ['tag', 'tutorial'],
  ['level', 'beginner']
]);
```

### Reading Parameters

```javascript
const params = new URLSearchParams('?id=123&name=John&tags=a&tags=b');

// Get single value (first if multiple)
console.log(params.get('id'));      // "123"
console.log(params.get('missing')); // null

// Get all values for a key
console.log(params.getAll('tags')); // ["a", "b"]

// Check existence
console.log(params.has('name'));    // true
console.log(params.has('email'));   // false

// Iterate
for (const [key, value] of params) {
  console.log(`${key}: ${value}`);
}

params.forEach((value, key) => {
  console.log(`${key}: ${value}`);
});

// Get all keys, values, entries
console.log([...params.keys()]);    // ["id", "name", "tags", "tags"]
console.log([...params.values()]);  // ["123", "John", "a", "b"]
console.log([...params.entries()]); // Array of [key, value] pairs
```

### Modifying Parameters

```javascript
const params = new URLSearchParams();

// Set (replaces any existing value)
params.set('page', '1');

// Append (adds, even if key exists)
params.append('tag', 'javascript');
params.append('tag', 'es6');

// Delete all values for key
params.delete('tag');

// Sort alphabetically by key
params.sort();

// Convert to string
console.log(params.toString());  // "page=1"
```

### Practical Patterns

```javascript
// Build query string from form
function formToQueryString(form) {
  const formData = new FormData(form);
  const params = new URLSearchParams(formData);
  return params.toString();
}

// Update URL without reload (with History API)
function updateURLParams(updates) {
  const url = new URL(location.href);
  
  Object.entries(updates).forEach(([key, value]) => {
    if (value === null || value === undefined) {
      url.searchParams.delete(key);
    } else {
      url.searchParams.set(key, value);
    }
  });
  
  history.replaceState(null, '', url);
}

// Parse complex filters from URL
function parseFilters() {
  const params = new URLSearchParams(location.search);
  return {
    category: params.get('category'),
    minPrice: params.has('minPrice') ? Number(params.get('minPrice')) : null,
    maxPrice: params.has('maxPrice') ? Number(params.get('maxPrice')) : null,
    tags: params.getAll('tags'),
    page: Number(params.get('page')) || 1,
    sort: params.get('sort') || 'relevance'
  };
}
```

---

## 2.2.6 Security Considerations

### Open Redirect Vulnerability

```javascript
// ❌ DANGEROUS: User-controlled redirects
const redirect = new URLSearchParams(location.search).get('redirect');
location.href = redirect;  // XSS/phishing risk!

// ✅ SAFE: Validate redirect target
function safeRedirect(url) {
  try {
    const target = new URL(url, location.origin);
    
    // Only allow same-origin redirects
    if (target.origin !== location.origin) {
      console.error('Invalid redirect: different origin');
      return false;
    }
    
    location.href = target.href;
    return true;
  } catch (e) {
    console.error('Invalid redirect URL');
    return false;
  }
}

// Or use an allowlist
const ALLOWED_REDIRECTS = ['/home', '/dashboard', '/profile'];

function safeRedirectFromParam() {
  const redirect = new URLSearchParams(location.search).get('redirect');
  
  if (ALLOWED_REDIRECTS.includes(redirect)) {
    location.href = redirect;
  } else {
    location.href = '/home';  // Default fallback
  }
}
```

### URL Encoding

```javascript
// User input must be encoded
const userInput = 'hello world & special=chars';

// ❌ BAD: Unencoded
const badUrl = `/search?q=${userInput}`;
// "/search?q=hello world & special=chars" (broken URL)

// ✅ GOOD: Use URLSearchParams (auto-encodes)
const params = new URLSearchParams({ q: userInput });
const goodUrl = `/search?${params}`;
// "/search?q=hello+world+%26+special%3Dchars"

// Or encodeURIComponent for individual values
const encoded = encodeURIComponent(userInput);
// "hello%20world%20%26%20special%3Dchars"
```

---

## 2.2.7 Common Patterns

### Single-Page App Routing (Hash-based)

```javascript
// Simple hash router
class HashRouter {
  constructor() {
    this.routes = new Map();
    window.addEventListener('hashchange', () => this.handleRoute());
  }
  
  on(path, handler) {
    this.routes.set(path, handler);
    return this;
  }
  
  handleRoute() {
    const path = location.hash.slice(1) || '/';
    const handler = this.routes.get(path);
    
    if (handler) {
      handler();
    } else {
      // 404 handling
      this.routes.get('*')?.();
    }
  }
  
  navigate(path) {
    location.hash = path;
  }
  
  start() {
    this.handleRoute();
  }
}

// Usage
const router = new HashRouter();
router
  .on('/', () => showHome())
  .on('/about', () => showAbout())
  .on('/contact', () => showContact())
  .on('*', () => show404())
  .start();
```

### Query Parameter Sync

```javascript
// Keep UI state in sync with URL params
class QuerySync {
  constructor(defaults = {}) {
    this.defaults = defaults;
    this.listeners = new Set();
  }
  
  get(key) {
    const params = new URLSearchParams(location.search);
    return params.get(key) ?? this.defaults[key] ?? null;
  }
  
  getAll() {
    const params = new URLSearchParams(location.search);
    const result = { ...this.defaults };
    
    for (const [key, value] of params) {
      result[key] = value;
    }
    
    return result;
  }
  
  set(key, value) {
    const url = new URL(location.href);
    
    if (value === null || value === this.defaults[key]) {
      url.searchParams.delete(key);
    } else {
      url.searchParams.set(key, value);
    }
    
    history.pushState(null, '', url);
    this.notifyListeners();
  }
  
  setAll(values) {
    const url = new URL(location.href);
    
    Object.entries(values).forEach(([key, value]) => {
      if (value === null || value === this.defaults[key]) {
        url.searchParams.delete(key);
      } else {
        url.searchParams.set(key, value);
      }
    });
    
    history.pushState(null, '', url);
    this.notifyListeners();
  }
  
  subscribe(listener) {
    this.listeners.add(listener);
    return () => this.listeners.delete(listener);
  }
  
  notifyListeners() {
    this.listeners.forEach(fn => fn(this.getAll()));
  }
}

// Usage
const querySync = new QuerySync({ page: '1', sort: 'date' });

querySync.subscribe((params) => {
  console.log('URL params changed:', params);
  updateUI(params);
});

querySync.set('page', '2');
```

### Deep Linking

```javascript
// Generate shareable link with current state
function getShareableLink(state) {
  const url = new URL(location.origin + location.pathname);
  
  // Add state to URL
  Object.entries(state).forEach(([key, value]) => {
    if (value != null) {
      url.searchParams.set(key, JSON.stringify(value));
    }
  });
  
  return url.href;
}

// Restore state from URL
function restoreFromURL() {
  const params = new URLSearchParams(location.search);
  const state = {};
  
  for (const [key, value] of params) {
    try {
      state[key] = JSON.parse(value);
    } catch {
      state[key] = value;
    }
  }
  
  return state;
}
```

---

## 2.2.8 Summary

| Property/Method | Purpose | Notes |
|-----------------|---------|-------|
| `href` | Complete URL | Read/write |
| `protocol` | Protocol (with `:`) | `https:`, `http:` |
| `host` | Hostname + port | `example.com:8080` |
| `hostname` | Hostname only | `example.com` |
| `port` | Port number | Empty if default |
| `pathname` | Path | Starts with `/` |
| `search` | Query string | Includes `?` |
| `hash` | Fragment | Includes `#` |
| `origin` | Protocol + host | **Read-only** |
| `assign(url)` | Navigate | Creates history entry |
| `replace(url)` | Navigate | No history entry |
| `reload()` | Refresh page | |

### Best Practices

1. **Use `URL` and `URLSearchParams`** for complex manipulation
2. **Use `replace()`** for redirects that shouldn't be in history
3. **Always encode user input** in URLs
4. **Validate redirect targets** to prevent open redirect attacks
5. **Use `hash` changes** for lightweight client-side routing
6. **Combine with History API** for modern SPAs

### Common Gotchas

```javascript
// ❌ Changing any property except hash causes reload
location.pathname = '/new';  // Page reloads!

// ❌ origin is read-only
location.origin = 'https://other.com';  // Error!

// ⚠️ URLSearchParams.get() returns string or null
const page = params.get('page');  // "1" or null
const pageNum = Number(params.get('page')) || 1;  // Safer

// ⚠️ Multiple values need getAll()
params.set('tag', 'a');
params.append('tag', 'b');
params.get('tag');     // "a" (first only!)
params.getAll('tag');  // ["a", "b"]
```

---

**End of Chapter 2.2: Location Object**

Next chapter: **2.3 History Object** — covers browser history manipulation with `pushState`, `replaceState`, `back`, `forward`, and the `popstate` event.
# 2.3 History Object

The `history` object represents the browser's session history — the stack of pages visited in the current tab. It provides methods to navigate backward and forward, and crucially, the History API lets you manipulate the URL without page reloads. This is the foundation of modern single-page application (SPA) routing.

---

## 2.3.1 History Basics

### The History Stack

```javascript
// The history object manages the session history stack
console.log(history);

// Number of entries in the history stack
console.log(history.length);

// ⚠️ You cannot access the actual URLs in the history
// This is a security restriction — you only know the count
```

### Navigation Methods

```javascript
// Go back one page (like clicking Back button)
history.back();

// Go forward one page (like clicking Forward button)
history.forward();

// Go to specific position relative to current
history.go(-1);   // Same as back()
history.go(1);    // Same as forward()
history.go(-2);   // Go back 2 pages
history.go(0);    // Reload current page

// No argument = reload
history.go();     // Same as location.reload()
```

### Navigation Events

```javascript
// Listen for back/forward navigation
window.addEventListener('popstate', (event) => {
  console.log('Navigation occurred');
  console.log('Current state:', event.state);
  console.log('Current URL:', location.href);
});

// ⚠️ popstate does NOT fire for:
// - Initial page load
// - pushState/replaceState (only manual navigation or back/forward)
```

---

## 2.3.2 pushState()

Add a new entry to the history stack without reloading the page.

### Basic Usage

```javascript
// pushState(stateObject, title, url)
history.pushState(
  { page: 'about' },           // State object (can retrieve later)
  '',                          // Title (largely ignored by browsers)
  '/about'                     // New URL
);

// The URL changes but NO page load occurs!
console.log(location.pathname);  // "/about"

// History length increases
console.log(history.length);     // +1 from before
```

### Parameters Explained

```javascript
// State object: any serializable object
history.pushState({
  page: 'products',
  filters: { category: 'shoes', size: 10 },
  scrollPosition: 500
}, '', '/products');

// Title: second parameter (unused but required)
// Most browsers ignore this
// Pass empty string ''

// URL: the new URL to display
// Must be same-origin (security restriction)
// Can be relative or absolute path
history.pushState(null, '', '/new-path');
history.pushState(null, '', '?query=value');
history.pushState(null, '', '#section');
history.pushState(null, '', '../sibling');
```

### URL Restrictions

```javascript
// ✅ Same-origin URLs work
history.pushState(null, '', '/any/path');
history.pushState(null, '', '?different=params');
history.pushState(null, '', '#new-hash');

// ❌ Cross-origin URLs throw SecurityError
history.pushState(null, '', 'https://other-domain.com');
// DOMException: The operation is insecure

// ✅ Path can change completely (within origin)
// From https://example.com/page1
history.pushState(null, '', '/completely/different/path');
// URL is now https://example.com/completely/different/path
```

### State Object Limits

```javascript
// State objects must be serializable (like JSON)
// ✅ Good
history.pushState({ count: 1, name: 'test' }, '', '/page');

// ❌ Bad - cannot contain functions, DOM elements, etc.
history.pushState({
  element: document.body,      // Error!
  callback: () => {}           // Error!
}, '', '/page');

// Size limit: ~640KB (varies by browser)
// Firefox: 16MB, Chrome: ~2MB, Safari: varies
const largeState = { data: 'x'.repeat(100000) };
history.pushState(largeState, '', '/page');  // Works if under limit
```

---

## 2.3.3 replaceState()

Replace the current history entry without adding a new one.

### Basic Usage

```javascript
// replaceState(stateObject, title, url)
history.replaceState(
  { page: 'home', modified: true },
  '',
  '/home'
);

// URL changes but history.length stays the same
// User cannot go "back" to the previous URL
```

### Use Cases

```javascript
// 1. Update URL without adding history entry
// Useful for pagination, filters, tabs
function updateFilters(filters) {
  const params = new URLSearchParams(filters);
  history.replaceState(
    { filters },
    '',
    `${location.pathname}?${params}`
  );
}

// 2. Normalize URLs
// Redirect /home to / without adding history
if (location.pathname === '/home') {
  history.replaceState(null, '', '/');
}

// 3. Clean up after redirect
// After OAuth callback, remove tokens from URL
if (location.search.includes('access_token')) {
  const token = new URLSearchParams(location.search).get('access_token');
  saveToken(token);
  history.replaceState(null, '', location.pathname);
}

// 4. Save scroll position
window.addEventListener('scroll', () => {
  history.replaceState(
    { ...history.state, scrollY: window.scrollY },
    '',
    location.href
  );
});
```

### pushState vs replaceState

| Aspect | pushState | replaceState |
|--------|-----------|--------------|
| History length | Increases | Unchanged |
| Back button | Returns to previous | Skips replaced entry |
| Use case | Navigation | State updates |

---

## 2.3.4 The State Object

Access the current state via `history.state`.

### Reading State

```javascript
// After pushState/replaceState
history.pushState({ page: 1, data: [1, 2, 3] }, '', '/page1');

// Current state is available
console.log(history.state);  // { page: 1, data: [1, 2, 3] }

// State persists after navigation
history.pushState({ page: 2 }, '', '/page2');
console.log(history.state);  // { page: 2 }

history.back();
// After popstate event fires:
console.log(history.state);  // { page: 1, data: [1, 2, 3] }
```

### State in popstate Event

```javascript
window.addEventListener('popstate', (event) => {
  // event.state contains the state object
  console.log(event.state);
  
  if (event.state) {
    // Handle known state
    renderPage(event.state);
  } else {
    // No state (initial page load or external link)
    handleInitialLoad();
  }
});
```

### Initial State

```javascript
// On page load, history.state is null by default
console.log(history.state);  // null (usually)

// Set initial state to enable restore on back navigation
if (!history.state) {
  history.replaceState({
    page: 'initial',
    loadedAt: Date.now()
  }, '', location.href);
}
```

---

## 2.3.5 The popstate Event

Fires when the user navigates using back/forward buttons.

### Event Details

```javascript
window.addEventListener('popstate', (event) => {
  // Fires when:
  // - User clicks back/forward button
  // - history.back(), history.forward(), history.go() called
  
  // Does NOT fire when:
  // - pushState() is called
  // - replaceState() is called
  // - Location changes via location.href
  
  console.log('Navigated to:', location.href);
  console.log('State:', event.state);
});
```

### Handling popstate

```javascript
// Comprehensive popstate handler
window.addEventListener('popstate', (event) => {
  const state = event.state;
  
  if (!state) {
    // No state means:
    // - Initial page load (some browsers)
    // - Navigation to page without pushState history
    loadDefaultPage();
    return;
  }
  
  // Restore UI from state
  if (state.view) {
    switchView(state.view);
  }
  
  if (state.data) {
    displayData(state.data);
  }
  
  if (state.scrollY !== undefined) {
    window.scrollTo(0, state.scrollY);
  }
});
```

### Common Gotchas

```javascript
// ⚠️ Some browsers fire popstate on initial load
// Safari, older browsers might do this
window.addEventListener('popstate', (event) => {
  // Guard against initial fire
  if (event.state !== null) {
    handleNavigation(event.state);
  }
});

// ⚠️ popstate fires AFTER the URL has changed
// location.href already shows the new URL
window.addEventListener('popstate', () => {
  console.log(location.href);  // Already the new URL
});

// ⚠️ Hash changes also trigger popstate
// If navigating between hash states
window.addEventListener('popstate', (event) => {
  if (location.hash) {
    handleHashChange(location.hash);
  }
});
```

---

## 2.3.6 Scroll Restoration

Control how the browser restores scroll position.

### scrollRestoration Property

```javascript
// Get current mode
console.log(history.scrollRestoration);  // 'auto' or 'manual'

// 'auto' (default): Browser restores scroll position on back/forward
// 'manual': You handle scroll restoration yourself

// Set to manual for SPA control
history.scrollRestoration = 'manual';
```

### Manual Scroll Restoration

```javascript
// 1. Set to manual mode
history.scrollRestoration = 'manual';

// 2. Save scroll position with state
window.addEventListener('scroll', debounce(() => {
  history.replaceState({
    ...history.state,
    scrollY: window.scrollY
  }, '', location.href);
}, 100));

// 3. Restore on popstate
window.addEventListener('popstate', (event) => {
  if (event.state?.scrollY !== undefined) {
    // Delay to let content render
    requestAnimationFrame(() => {
      window.scrollTo(0, event.state.scrollY);
    });
  }
});

// Helper function
function debounce(fn, wait) {
  let timeout;
  return function(...args) {
    clearTimeout(timeout);
    timeout = setTimeout(() => fn.apply(this, args), wait);
  };
}
```

### SPA Considerations

```javascript
// SPAs often want scroll-to-top on navigate
router.navigate = function(path, options = {}) {
  history.pushState({ scrollY: 0 }, '', path);
  
  if (!options.preserveScroll) {
    window.scrollTo(0, 0);
  }
  
  renderRoute(path);
};

// But restore scroll on back
window.addEventListener('popstate', (event) => {
  const scrollY = event.state?.scrollY ?? 0;
  
  renderRoute(location.pathname).then(() => {
    window.scrollTo(0, scrollY);
  });
});
```

---

## 2.3.7 Building a History-Based Router

### Simple SPA Router

```javascript
class Router {
  constructor() {
    this.routes = new Map();
    this.currentRoute = null;
    
    // Handle browser navigation
    window.addEventListener('popstate', (e) => {
      this.handleNavigation(location.pathname, e.state, false);
    });
  }
  
  // Register route handler
  on(path, handler) {
    this.routes.set(path, handler);
    return this;
  }
  
  // Navigate to path
  navigate(path, state = {}, replace = false) {
    const fullState = { path, ...state };
    
    if (replace) {
      history.replaceState(fullState, '', path);
    } else {
      history.pushState(fullState, '', path);
    }
    
    this.handleNavigation(path, fullState, true);
  }
  
  // Handle route change
  handleNavigation(path, state, isForward) {
    // Find matching route
    const handler = this.routes.get(path) || this.routes.get('*');
    
    if (handler) {
      handler({ path, state, isForward });
    }
    
    this.currentRoute = path;
  }
  
  // Initialize with current URL
  start() {
    // Set initial state if needed
    if (!history.state) {
      history.replaceState({ path: location.pathname }, '', location.pathname);
    }
    
    this.handleNavigation(location.pathname, history.state, true);
  }
}

// Usage
const router = new Router();

router
  .on('/', ({ state }) => renderHome(state))
  .on('/about', ({ state }) => renderAbout(state))
  .on('/products', ({ state }) => renderProducts(state))
  .on('/products/:id', ({ state }) => renderProduct(state))
  .on('*', () => render404())
  .start();

// Navigate
document.querySelector('a.internal').addEventListener('click', (e) => {
  e.preventDefault();
  router.navigate(e.target.href);
});
```

### With Route Parameters

```javascript
class AdvancedRouter {
  constructor() {
    this.routes = [];
    
    window.addEventListener('popstate', (e) => {
      this.handleRoute(location.pathname, e.state);
    });
  }
  
  // Convert path pattern to regex
  pathToRegex(path) {
    return new RegExp(
      '^' + path
        .replace(/\//g, '\\/')
        .replace(/:(\w+)/g, '(?<$1>[^/]+)')
        + '$'
    );
  }
  
  on(path, handler) {
    this.routes.push({
      pattern: this.pathToRegex(path),
      handler
    });
    return this;
  }
  
  handleRoute(pathname, state) {
    for (const route of this.routes) {
      const match = pathname.match(route.pattern);
      if (match) {
        route.handler({
          params: match.groups || {},
          state,
          path: pathname
        });
        return;
      }
    }
    
    // No match - 404
    this.routes.find(r => r.pattern.source === '^\\*$')
      ?.handler({ path: pathname });
  }
  
  navigate(path, state = {}) {
    history.pushState(state, '', path);
    this.handleRoute(path, state);
  }
  
  start() {
    this.handleRoute(location.pathname, history.state);
  }
}

// Usage
const router = new AdvancedRouter();

router
  .on('/', () => console.log('Home'))
  .on('/users/:id', ({ params }) => {
    console.log('User ID:', params.id);
  })
  .on('/posts/:postId/comments/:commentId', ({ params }) => {
    console.log('Post:', params.postId, 'Comment:', params.commentId);
  })
  .on('*', () => console.log('404'))
  .start();
```

---

## 2.3.8 Best Practices

### Consistent State Management

```javascript
// Always include identifying info in state
function navigate(path, data = {}) {
  history.pushState({
    path,
    timestamp: Date.now(),
    ...data
  }, '', path);
}

// Validate state exists before using
window.addEventListener('popstate', (e) => {
  const state = e.state || {};
  const path = state.path || location.pathname;
  handleRoute(path, state);
});
```

### Handle Edge Cases

```javascript
// Handle refresh (no popstate, but state might exist)
document.addEventListener('DOMContentLoaded', () => {
  if (history.state) {
    // Restore from state
    restoreFromState(history.state);
  } else {
    // Initialize fresh
    initFromURL(location.pathname);
  }
});

// Handle external links
document.addEventListener('click', (e) => {
  const link = e.target.closest('a');
  if (!link) return;
  
  const url = new URL(link.href);
  
  // Only handle same-origin links
  if (url.origin !== location.origin) return;
  
  // Skip if modifier keys (let browser handle new tab, etc.)
  if (e.metaKey || e.ctrlKey || e.shiftKey) return;
  
  e.preventDefault();
  router.navigate(url.pathname + url.search + url.hash);
});
```

### Server-Side Considerations

```javascript
// For SPAs, server must return index.html for all routes
// Otherwise, direct access to /about returns 404

// Express example:
// app.get('*', (req, res) => {
//   res.sendFile('index.html');
// });

// Or use hash-based routing to avoid this issue
history.pushState(null, '', '/#/about');
// Server always sees / regardless of hash
```

---

## 2.3.9 Summary

| Property/Method | Purpose | Notes |
|-----------------|---------|-------|
| `length` | Number of history entries | Read-only |
| `state` | Current state object | Read-only |
| `scrollRestoration` | Scroll behavior | `'auto'` or `'manual'` |
| `back()` | Go back one page | Same as `go(-1)` |
| `forward()` | Go forward one page | Same as `go(1)` |
| `go(delta)` | Go to relative position | |
| `pushState(state, title, url)` | Add history entry | No page load |
| `replaceState(state, title, url)` | Replace current entry | No page load |

### Events

| Event | When it Fires |
|-------|---------------|
| `popstate` | Back/forward navigation or `go()` |
| Does NOT fire | `pushState()`, `replaceState()` |

### Best Practices

1. **Set initial state** with `replaceState` on page load
2. **Include path in state** for reliable restoration
3. **Handle missing state** gracefully (null check)
4. **Use `scrollRestoration = 'manual'`** for SPAs
5. **Validate state** before using properties
6. **Consider hash routing** for simpler server setup

### Common Gotchas

```javascript
// ❌ pushState doesn't trigger popstate
history.pushState(state, '', '/new');
// popstate does NOT fire!

// ❌ Cross-origin URLs throw error
history.pushState(null, '', 'https://other.com');

// ⚠️ State must be serializable
history.pushState({ fn: () => {} }, '', '/');  // Error!

// ⚠️ State is null on initial load
console.log(history.state);  // null (usually)
```

---

**End of Chapter 2.3: History Object**

Next chapter: **2.4 Navigator Object** — covers browser information, online status, geolocation, clipboard, permissions, and more.
# 2.4 Navigator Object

The `navigator` object provides information about the browser and device, as well as access to various Web APIs. It includes browser detection, online status, geolocation, clipboard access, permissions, service workers, and more. This chapter covers the most important navigator properties and APIs.

---

## 2.4.1 Browser Information

### userAgent

The user agent string identifies the browser. However, it's notoriously unreliable for browser detection.

```javascript
// Get the user agent string
console.log(navigator.userAgent);
// Chrome: "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 
//          (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36"
// Firefox: "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:121.0) 
//           Gecko/20100101 Firefox/121.0"

// ⚠️ User agent parsing is unreliable
// Many browsers include "Mozilla", "Safari", etc. for compatibility
```

### Modern Alternative: User Agent Client Hints

```javascript
// More reliable browser detection (Chromium-based only)
if (navigator.userAgentData) {
  // Available in Chrome, Edge, Opera
  console.log(navigator.userAgentData.brands);
  // [{brand: "Chromium", version: "120"}, {brand: "Google Chrome", version: "120"}]
  
  console.log(navigator.userAgentData.mobile);  // false
  console.log(navigator.userAgentData.platform);  // "Windows"
  
  // Get full details (requires promise)
  navigator.userAgentData.getHighEntropyValues([
    'architecture',
    'bitness',
    'fullVersionList',
    'model',
    'platformVersion'
  ]).then(data => {
    console.log(data);
    // { architecture: "x86", bitness: "64", ... }
  });
}
```

### Feature Detection (Preferred Approach)

```javascript
// ✅ Instead of browser detection, test for features
if ('IntersectionObserver' in window) {
  // Use Intersection Observer
} else {
  // Fall back
}

if ('serviceWorker' in navigator) {
  // Service Workers supported
}

if ('clipboard' in navigator && 'writeText' in navigator.clipboard) {
  // Modern clipboard API available
}

// ❌ Avoid this pattern
if (navigator.userAgent.includes('Chrome')) {
  // This is fragile
}
```

### Other Browser Info Properties

```javascript
// Browser language preferences
console.log(navigator.language);    // "en-US" (primary)
console.log(navigator.languages);   // ["en-US", "en", "es"]

// Platform info
console.log(navigator.platform);    // "Win32", "MacIntel", "Linux x86_64"
// ⚠️ Deprecated but still works

// Number of CPU cores (approximate)
console.log(navigator.hardwareConcurrency);  // 8

// Max touch points
console.log(navigator.maxTouchPoints);  // 0 (no touch), 10, etc.

// Browser engine
console.log(navigator.product);     // "Gecko" (always)
console.log(navigator.vendor);      // "Google Inc.", "Apple Computer, Inc."
```

---

## 2.4.2 Online/Offline Status

### Checking Connection Status

```javascript
// Current status
console.log(navigator.onLine);  // true or false

// ⚠️ onLine only indicates network connection
// Does NOT guarantee internet access
// A connected router without internet shows as online
```

### Listening for Changes

```javascript
// Online event
window.addEventListener('online', () => {
  console.log('Back online');
  showNotification('Connection restored');
  syncPendingData();
});

// Offline event
window.addEventListener('offline', () => {
  console.log('Gone offline');
  showNotification('You are offline. Changes will sync when back online.');
  enableOfflineMode();
});

// Practical implementation
class ConnectionMonitor {
  constructor() {
    this.listeners = new Set();
    this.isOnline = navigator.onLine;
    
    window.addEventListener('online', () => this.setOnline(true));
    window.addEventListener('offline', () => this.setOnline(false));
  }
  
  setOnline(status) {
    const wasOnline = this.isOnline;
    this.isOnline = status;
    
    if (wasOnline !== status) {
      this.notifyListeners(status);
    }
  }
  
  subscribe(callback) {
    this.listeners.add(callback);
    return () => this.listeners.delete(callback);
  }
  
  notifyListeners(isOnline) {
    this.listeners.forEach(fn => fn(isOnline));
  }
}

const connection = new ConnectionMonitor();
connection.subscribe((online) => {
  document.body.classList.toggle('offline-mode', !online);
});
```

### Better Connection Detection

```javascript
// More reliable check: actually test connectivity
async function checkConnectivity() {
  try {
    const response = await fetch('/api/ping', {
      method: 'HEAD',
      cache: 'no-store'
    });
    return response.ok;
  } catch {
    return false;
  }
}

// Network Information API (experimental)
if ('connection' in navigator) {
  const connection = navigator.connection;
  
  console.log(connection.type);          // 'wifi', 'cellular', etc.
  console.log(connection.effectiveType); // '4g', '3g', '2g', 'slow-2g'
  console.log(connection.downlink);      // Mbps
  console.log(connection.rtt);           // Round-trip time in ms
  console.log(connection.saveData);      // User prefers reduced data
  
  connection.addEventListener('change', () => {
    console.log('Connection type changed:', connection.effectiveType);
    if (connection.effectiveType === 'slow-2g') {
      enableLowBandwidthMode();
    }
  });
}
```

---

## 2.4.3 Cookies and Storage

### cookieEnabled

```javascript
// Check if cookies are enabled
console.log(navigator.cookieEnabled);  // true or false

if (!navigator.cookieEnabled) {
  showMessage('Cookies are required for this site to work properly.');
}

// ⚠️ This checks if cookies can be set
// Not whether they are actually working (3rd party blocks, etc.)
```

---

## 2.4.4 Geolocation

Access the user's geographic location (requires permission).

### Getting Current Position

```javascript
// Check if supported
if ('geolocation' in navigator) {
  navigator.geolocation.getCurrentPosition(
    // Success callback
    (position) => {
      console.log('Latitude:', position.coords.latitude);
      console.log('Longitude:', position.coords.longitude);
      console.log('Accuracy:', position.coords.accuracy, 'meters');
      console.log('Altitude:', position.coords.altitude);  // May be null
      console.log('Speed:', position.coords.speed);        // May be null
      console.log('Heading:', position.coords.heading);    // May be null
      console.log('Timestamp:', position.timestamp);
    },
    // Error callback
    (error) => {
      switch (error.code) {
        case error.PERMISSION_DENIED:
          console.log('User denied location access');
          break;
        case error.POSITION_UNAVAILABLE:
          console.log('Location unavailable');
          break;
        case error.TIMEOUT:
          console.log('Request timed out');
          break;
      }
    },
    // Options
    {
      enableHighAccuracy: true,  // GPS vs network location
      timeout: 10000,            // Max wait time (ms)
      maximumAge: 60000          // Accept cached position this old (ms)
    }
  );
}
```

### Watching Position (Continuous)

```javascript
// Start watching
const watchId = navigator.geolocation.watchPosition(
  (position) => {
    updateMap(position.coords.latitude, position.coords.longitude);
  },
  (error) => {
    console.error('Watch error:', error.message);
  },
  {
    enableHighAccuracy: true,
    timeout: 10000,
    maximumAge: 1000  // Frequent updates
  }
);

// Stop watching
navigator.geolocation.clearWatch(watchId);
```

### Promise Wrapper

```javascript
function getCurrentPosition(options = {}) {
  return new Promise((resolve, reject) => {
    if (!('geolocation' in navigator)) {
      reject(new Error('Geolocation not supported'));
      return;
    }
    
    navigator.geolocation.getCurrentPosition(resolve, reject, options);
  });
}

// Usage
async function getLocation() {
  try {
    const position = await getCurrentPosition({
      enableHighAccuracy: true,
      timeout: 5000
    });
    return {
      lat: position.coords.latitude,
      lng: position.coords.longitude
    };
  } catch (error) {
    console.error('Failed to get location:', error);
    return null;
  }
}
```

---

## 2.4.5 Clipboard API

Modern async clipboard access (requires permission for read).

### Writing to Clipboard

```javascript
// Write text (no permission needed)
async function copyText(text) {
  try {
    await navigator.clipboard.writeText(text);
    console.log('Copied to clipboard');
    return true;
  } catch (error) {
    console.error('Copy failed:', error);
    return false;
  }
}

// Usage
copyBtn.addEventListener('click', async () => {
  const success = await copyText('Hello, clipboard!');
  if (success) {
    showToast('Copied!');
  }
});
```

### Reading from Clipboard

```javascript
// Read text (requires permission)
async function pasteText() {
  try {
    const text = await navigator.clipboard.readText();
    console.log('Pasted:', text);
    return text;
  } catch (error) {
    console.error('Paste failed:', error);
    // User denied permission or no clipboard access
    return null;
  }
}

// Read with permission check
pasteBtn.addEventListener('click', async () => {
  const result = await navigator.permissions.query({ name: 'clipboard-read' });
  
  if (result.state === 'denied') {
    showMessage('Clipboard access denied');
    return;
  }
  
  const text = await navigator.clipboard.readText();
  inputField.value = text;
});
```

### Writing Rich Content

```javascript
// Write HTML, images, or other formats
async function copyRichContent() {
  const blob = new Blob(['<b>Bold text</b>'], { type: 'text/html' });
  const textBlob = new Blob(['Bold text'], { type: 'text/plain' });
  
  const item = new ClipboardItem({
    'text/html': blob,
    'text/plain': textBlob
  });
  
  await navigator.clipboard.write([item]);
}

// Copy an image
async function copyImage(canvas) {
  const blob = await new Promise(resolve => {
    canvas.toBlob(resolve, 'image/png');
  });
  
  await navigator.clipboard.write([
    new ClipboardItem({ 'image/png': blob })
  ]);
}
```

### Reading Rich Content

```javascript
async function pasteContent() {
  const items = await navigator.clipboard.read();
  
  for (const item of items) {
    for (const type of item.types) {
      if (type === 'image/png') {
        const blob = await item.getType(type);
        const img = document.createElement('img');
        img.src = URL.createObjectURL(blob);
        document.body.appendChild(img);
      } else if (type === 'text/plain') {
        const blob = await item.getType(type);
        const text = await blob.text();
        console.log('Text:', text);
      }
    }
  }
}
```

### Fallback for Older Browsers

```javascript
async function copyWithFallback(text) {
  // Try modern API first
  if (navigator.clipboard?.writeText) {
    try {
      await navigator.clipboard.writeText(text);
      return true;
    } catch {
      // Fall through to fallback
    }
  }
  
  // Fallback: execCommand (deprecated but works)
  const textarea = document.createElement('textarea');
  textarea.value = text;
  textarea.style.position = 'fixed';
  textarea.style.opacity = '0';
  document.body.appendChild(textarea);
  textarea.select();
  
  try {
    document.execCommand('copy');
    return true;
  } catch {
    return false;
  } finally {
    textarea.remove();
  }
}
```

---

## 2.4.6 Permissions API

Query and request permissions for various features.

### Querying Permission Status

```javascript
// Check a permission
const result = await navigator.permissions.query({ name: 'geolocation' });

console.log(result.state);  // 'granted', 'denied', or 'prompt'

// Listen for changes
result.addEventListener('change', () => {
  console.log('Permission changed to:', result.state);
  updateUI(result.state);
});
```

### Available Permissions

```javascript
// Commonly supported permissions:
const permissions = [
  'geolocation',
  'notifications',
  'camera',
  'microphone',
  'clipboard-read',
  'clipboard-write',
  'persistent-storage'
];

// Check multiple permissions
async function checkPermissions() {
  const results = {};
  
  for (const name of permissions) {
    try {
      const result = await navigator.permissions.query({ name });
      results[name] = result.state;
    } catch {
      results[name] = 'unsupported';
    }
  }
  
  return results;
}
```

### Permission Patterns

```javascript
// Request permission gracefully
async function requestGeolocation() {
  const status = await navigator.permissions.query({ name: 'geolocation' });
  
  if (status.state === 'granted') {
    return getPosition();
  }
  
  if (status.state === 'prompt') {
    // Show explanation before prompting
    const userConsent = await showExplanationDialog(
      'We need your location to show nearby stores.'
    );
    
    if (userConsent) {
      return getPosition();  // This triggers the browser prompt
    }
  }
  
  if (status.state === 'denied') {
    showMessage('Location access is blocked. Please enable in browser settings.');
    return null;
  }
}
```

---

## 2.4.7 Service Worker

Register and manage service workers for offline capability.

### Checking Support

```javascript
if ('serviceWorker' in navigator) {
  console.log('Service Workers supported');
}
```

### Registration

```javascript
// Register a service worker
async function registerServiceWorker() {
  if (!('serviceWorker' in navigator)) return;
  
  try {
    const registration = await navigator.serviceWorker.register('/sw.js', {
      scope: '/'
    });
    
    console.log('SW registered:', registration.scope);
    
    // Check for updates
    registration.addEventListener('updatefound', () => {
      const newWorker = registration.installing;
      
      newWorker.addEventListener('statechange', () => {
        if (newWorker.state === 'installed') {
          if (navigator.serviceWorker.controller) {
            // New version available
            showUpdateNotification();
          }
        }
      });
    });
    
    return registration;
  } catch (error) {
    console.error('SW registration failed:', error);
  }
}
```

### Communicating with Service Worker

```javascript
// Send message to SW
navigator.serviceWorker.controller?.postMessage({
  type: 'CACHE_URLS',
  payload: ['/images/logo.png', '/api/config']
});

// Receive messages from SW
navigator.serviceWorker.addEventListener('message', (event) => {
  console.log('Message from SW:', event.data);
});
```

---

## 2.4.8 Other Navigator APIs

### share() — Web Share API

```javascript
// Share content using native share dialog
async function shareContent(data) {
  if (!navigator.share) {
    // Fallback to custom share dialog
    showCustomShareDialog(data);
    return;
  }
  
  try {
    await navigator.share({
      title: data.title,
      text: data.text,
      url: data.url
    });
    console.log('Shared successfully');
  } catch (error) {
    if (error.name !== 'AbortError') {
      console.error('Share failed:', error);
    }
  }
}

// Share with files
async function shareWithFiles(files) {
  if (!navigator.canShare?.({ files })) {
    console.log('File sharing not supported');
    return;
  }
  
  await navigator.share({
    files,
    title: 'Shared files'
  });
}
```

### vibrate() — Vibration API

```javascript
// Vibrate for duration (mobile devices)
navigator.vibrate(200);  // Vibrate for 200ms

// Pattern: vibrate, pause, vibrate
navigator.vibrate([100, 50, 100]);  // vibrate 100ms, pause 50ms, vibrate 100ms

// Stop vibration
navigator.vibrate(0);

// Check support
if ('vibrate' in navigator) {
  hapticFeedback();
}
```

### getBattery() — Battery API

```javascript
// Get battery status (Chrome/Firefox)
if ('getBattery' in navigator) {
  const battery = await navigator.getBattery();
  
  console.log('Level:', battery.level * 100 + '%');
  console.log('Charging:', battery.charging);
  console.log('Charging time:', battery.chargingTime);
  console.log('Discharging time:', battery.dischargingTime);
  
  // Listen for changes
  battery.addEventListener('levelchange', () => {
    console.log('Battery level:', battery.level);
  });
  
  battery.addEventListener('chargingchange', () => {
    console.log('Charging:', battery.charging);
  });
}
```

### mediaDevices — Camera/Microphone Access

```javascript
// Access camera and microphone
async function getMediaStream() {
  try {
    const stream = await navigator.mediaDevices.getUserMedia({
      video: { width: 1280, height: 720 },
      audio: true
    });
    
    videoElement.srcObject = stream;
    return stream;
  } catch (error) {
    if (error.name === 'NotAllowedError') {
      console.log('Permission denied');
    } else if (error.name === 'NotFoundError') {
      console.log('No camera/microphone found');
    }
    throw error;
  }
}

// List available devices
const devices = await navigator.mediaDevices.enumerateDevices();
const cameras = devices.filter(d => d.kind === 'videoinput');
const mics = devices.filter(d => d.kind === 'audioinput');
```

### credentials — Credential Management

```javascript
// Store credentials
if ('credentials' in navigator) {
  const credential = new PasswordCredential({
    id: 'user@example.com',
    password: 'password123',
    name: 'John Doe'
  });
  
  await navigator.credentials.store(credential);
}

// Retrieve credentials
const credential = await navigator.credentials.get({
  password: true
});

if (credential) {
  // Auto-fill login form
  loginForm.email.value = credential.id;
  loginForm.password.value = credential.password;
}
```

---

## 2.4.9 Summary

| Property/Method | Purpose | Permission Required |
|-----------------|---------|---------------------|
| `userAgent` | Browser identification | No |
| `language`/`languages` | User language preferences | No |
| `onLine` | Network connection status | No |
| `cookieEnabled` | Cookie support check | No |
| `geolocation` | Geographic position | Yes |
| `clipboard` | Read/write clipboard | Read: Yes, Write: No* |
| `permissions` | Check/request permissions | No |
| `serviceWorker` | Offline/background features | No |
| `share()` | Native share dialog | No |
| `vibrate()` | Haptic feedback | No |
| `getBattery()` | Battery status | No |
| `mediaDevices` | Camera/microphone access | Yes |
| `credentials` | Password management | No |

### Best Practices

1. **Use feature detection** instead of browser detection
2. **Check permissions** before requesting sensitive APIs
3. **Provide fallbacks** for unsupported features
4. **Handle errors gracefully** — permissions can be denied
5. **Use secure contexts** (HTTPS) for sensitive APIs
6. **Respect user preferences** (`saveData`, reduced motion, etc.)

### Security Requirements

```javascript
// Many APIs require secure context (HTTPS)
if (window.isSecureContext) {
  // Safe to use: clipboard, geolocation, serviceWorker, etc.
} else {
  // These APIs will fail or not exist
}
```

---

**End of Chapter 2.4: Navigator Object**

Next chapter: **2.5 Screen Object** — covers screen dimensions, orientation, color depth, and multi-monitor detection.
# 2.5 Screen Object

The `screen` object provides information about the user's physical screen. This includes dimensions, color depth, orientation, and available space. While less commonly used than other BOM objects, screen information is valuable for optimizing layouts on different displays, handling multi-monitor setups, and adapting to device capabilities.

---

## 2.5.1 Screen Dimensions

### Total Screen Size

```javascript
// Full screen dimensions (physical resolution)
console.log(screen.width);   // 1920 (pixels)
console.log(screen.height);  // 1080 (pixels)

// ⚠️ These are CSS pixels, not physical pixels
// On a Retina/HiDPI display, physical pixels = CSS pixels × devicePixelRatio

const physicalWidth = screen.width * window.devicePixelRatio;
const physicalHeight = screen.height * window.devicePixelRatio;
console.log(`Physical resolution: ${physicalWidth}x${physicalHeight}`);
```

### Available Screen Size

```javascript
// Available dimensions (excluding OS taskbars, docks, etc.)
console.log(screen.availWidth);   // 1920 (or less if vertical taskbar)
console.log(screen.availHeight);  // 1040 (1080 minus taskbar height)

// The difference tells you about system UI
const taskbarHeight = screen.height - screen.availHeight;
console.log(`Taskbar/dock height: ${taskbarHeight}px`);

// Available area position (where usable space starts)
console.log(screen.availLeft);  // 0 (or offset if monitors arranged)
console.log(screen.availTop);   // 0 (or offset for top menu bar on Mac)
```

### Practical Use Cases

```javascript
// Determine if screen is large enough for a feature
function supportsFullFeatures() {
  return screen.width >= 1024 && screen.height >= 768;
}

// Calculate optimal popup size
function getPopupDimensions(preferredWidth, preferredHeight) {
  return {
    width: Math.min(preferredWidth, screen.availWidth - 50),
    height: Math.min(preferredHeight, screen.availHeight - 50)
  };
}

// Center a popup on screen
function openCenteredPopup(url, width, height) {
  const left = (screen.width - width) / 2;
  const top = (screen.height - height) / 2;
  
  window.open(
    url,
    'popup',
    `width=${width},height=${height},left=${left},top=${top}`
  );
}
```

---

## 2.5.2 Screen vs Window vs Viewport

Understanding the difference between these measurements:

```javascript
// Screen: Physical display
console.log('Screen:', screen.width, 'x', screen.height);

// Window outer: Browser window including chrome
console.log('Window:', window.outerWidth, 'x', window.outerHeight);

// Window inner (viewport): Content area including scrollbar
console.log('Viewport:', window.innerWidth, 'x', window.innerHeight);

// Document client: Content area excluding scrollbar
console.log('Client:', 
  document.documentElement.clientWidth, 'x',
  document.documentElement.clientHeight
);
```

### Visual Comparison

```
+--------------------------------------------------+
| SCREEN (screen.width × screen.height)            |
|  +--------------------------------------------+  |
|  | OS TASKBAR / DOCK                          |  |
|  +--------------------------------------------+  |
|  | BROWSER WINDOW (outerWidth × outerHeight)  |  |
|  | +----------------------------------------+ |  |
|  | | Address bar, tabs, toolbars            | |  |
|  | +----------------------------------------+ |  |
|  | | VIEWPORT (innerWidth × innerHeight)    | |  |
|  | | +------------------------------------+ | |  |
|  | | | DOCUMENT (clientWidth × clientH.)| | | |  |
|  | | |                                    |S| |  |
|  | | |                                    |c| |  |
|  | | |                                    |r| |  |
|  | | |                                    |o| |  |
|  | | |                                    |l| |  |
|  | | |                                    |l| |  |
|  | | +------------------------------------+ | |  |
|  | +----------------------------------------+ |  |
|  +--------------------------------------------+  |
+--------------------------------------------------+
```

---

## 2.5.3 Color Depth

Information about the display's color capabilities.

### colorDepth and pixelDepth

```javascript
// Bits per pixel for color
console.log(screen.colorDepth);  // 24 (typical) or 32
console.log(screen.pixelDepth);  // Usually same as colorDepth

// Common values:
// 24 = 16.7 million colors (8 bits × 3 channels)
// 32 = 24-bit color + 8-bit alpha channel

// ⚠️ Modern displays are almost always 24 or 32 bits
// Lower values are extremely rare now
```

### Use Cases

```javascript
// Adapt for low-color displays (rare but possible)
if (screen.colorDepth < 24) {
  // Use simpler graphics, avoid gradients
  document.body.classList.add('low-color-mode');
}

// Check for HDR-capable display (experimental)
if (window.matchMedia('(dynamic-range: high)').matches) {
  console.log('HDR display detected');
  enableHDRContent();
}
```

---

## 2.5.4 Screen Orientation

The `screen.orientation` API provides information about and control over screen orientation.

### Reading Orientation

```javascript
// Orientation object (modern API)
if (screen.orientation) {
  console.log(screen.orientation.type);
  // "portrait-primary", "portrait-secondary",
  // "landscape-primary", "landscape-secondary"
  
  console.log(screen.orientation.angle);
  // 0, 90, 180, or 270 degrees
}

// Simpler check using media query
if (window.matchMedia('(orientation: portrait)').matches) {
  console.log('Portrait mode');
} else {
  console.log('Landscape mode');
}
```

### Orientation Change Events

```javascript
// Modern event
screen.orientation?.addEventListener('change', () => {
  console.log('Orientation changed to:', screen.orientation.type);
  console.log('Angle:', screen.orientation.angle);
  
  handleOrientationChange(screen.orientation.type);
});

// Alternative: window event (older, more compatible)
window.addEventListener('orientationchange', () => {
  console.log('Orientation:', window.orientation);  // 0, 90, -90, 180
});

// Also works: resize event (fires on orientation change too)
window.addEventListener('resize', () => {
  const isPortrait = window.innerHeight > window.innerWidth;
  updateLayout(isPortrait);
});

// Media query approach (most reliable)
const orientationQuery = window.matchMedia('(orientation: portrait)');
orientationQuery.addEventListener('change', (e) => {
  console.log('Portrait:', e.matches);
});
```

### Locking Orientation

```javascript
// Lock to specific orientation (fullscreen only in most browsers)
async function lockToLandscape() {
  try {
    // Must be in fullscreen for most browsers
    await document.documentElement.requestFullscreen();
    await screen.orientation.lock('landscape');
    console.log('Locked to landscape');
  } catch (error) {
    console.error('Could not lock orientation:', error);
  }
}

// Lock options:
// 'any'              - any orientation
// 'natural'          - device's natural orientation
// 'landscape'        - either landscape
// 'portrait'         - either portrait
// 'portrait-primary' - specific portrait
// 'landscape-primary' - specific landscape

// Unlock
screen.orientation.unlock();
```

### Practical Examples

```javascript
// Responsive behavior based on orientation
class OrientationHandler {
  constructor() {
    this.listeners = new Set();
    this.isPortrait = this.checkPortrait();
    
    // Use matchMedia for reliability
    const mq = window.matchMedia('(orientation: portrait)');
    mq.addEventListener('change', () => {
      this.isPortrait = this.checkPortrait();
      this.notify();
    });
  }
  
  checkPortrait() {
    return window.innerHeight > window.innerWidth;
  }
  
  subscribe(callback) {
    this.listeners.add(callback);
    return () => this.listeners.delete(callback);
  }
  
  notify() {
    this.listeners.forEach(fn => fn(this.isPortrait));
  }
}

const orientation = new OrientationHandler();
orientation.subscribe((isPortrait) => {
  if (isPortrait) {
    showMobileNav();
    stackCards();
  } else {
    showSideNav();
    gridCards();
  }
});
```

---

## 2.5.5 Multi-Monitor Detection

Detecting and working with multiple displays.

### Window Placement API (Experimental)

```javascript
// Modern multi-screen API (requires permission)
if ('getScreenDetails' in window) {
  try {
    const screens = await window.getScreenDetails();
    
    console.log('Number of screens:', screens.screens.length);
    console.log('Current screen:', screens.currentScreen);
    
    screens.screens.forEach((screen, i) => {
      console.log(`Screen ${i}:`, {
        width: screen.width,
        height: screen.height,
        left: screen.left,
        top: screen.top,
        isPrimary: screen.isPrimary,
        isInternal: screen.isInternal,
        label: screen.label
      });
    });
    
    // Listen for screen changes
    screens.addEventListener('screenschange', () => {
      console.log('Screens changed');
    });
  } catch (error) {
    console.log('Multi-screen API not available or denied');
  }
}
```

### Legacy Detection

```javascript
// Check if window is on secondary monitor
function isOnSecondaryMonitor() {
  // If availLeft is non-zero, there might be monitors to the left
  // This is a heuristic, not definitive
  return screen.availLeft !== 0 || screen.availTop !== 0;
}

// Detect potential multi-monitor from screen size vs available
function estimateMultipleMonitors() {
  // If availWidth is much smaller than typical, might be extended desktop
  // This is very unreliable
  const ratio = window.outerWidth / screen.width;
  return ratio < 0.3;  // Window is small portion of screen
}
```

### Opening Windows on Specific Screens

```javascript
// With Window Placement API
async function openOnSecondaryScreen(url) {
  const screens = await window.getScreenDetails();
  const secondaryScreen = screens.screens.find(s => !s.isPrimary);
  
  if (secondaryScreen) {
    window.open(
      url,
      'secondary',
      `left=${secondaryScreen.left},top=${secondaryScreen.top},` +
      `width=${secondaryScreen.availWidth},height=${secondaryScreen.availHeight}`
    );
  } else {
    window.open(url);  // Fallback to default
  }
}
```

---

## 2.5.6 Device Pixel Ratio

While technically on `window`, this is closely related to screen capabilities.

```javascript
// Ratio of physical pixels to CSS pixels
const dpr = window.devicePixelRatio;

console.log('Device Pixel Ratio:', dpr);
// 1    = standard displays
// 1.5  = some Windows laptops
// 2    = Retina, most mobile devices
// 2+   = high-DPI mobile, 4K/5K displays

// Physical screen resolution
const physicalRes = {
  width: screen.width * dpr,
  height: screen.height * dpr
};
console.log('Physical pixels:', physicalRes);
```

### Adapting to DPR

```javascript
// Load appropriate image resolution
function getImageUrl(baseName) {
  if (devicePixelRatio >= 2) {
    return `${baseName}@2x.png`;
  } else if (devicePixelRatio >= 1.5) {
    return `${baseName}@1.5x.png`;
  }
  return `${baseName}.png`;
}

// HiDPI Canvas
function createHiDPICanvas(width, height) {
  const canvas = document.createElement('canvas');
  const ctx = canvas.getContext('2d');
  
  // Set display size
  canvas.style.width = `${width}px`;
  canvas.style.height = `${height}px`;
  
  // Set actual resolution
  canvas.width = width * devicePixelRatio;
  canvas.height = height * devicePixelRatio;
  
  // Scale context to match
  ctx.scale(devicePixelRatio, devicePixelRatio);
  
  return { canvas, ctx };
}
```

---

## 2.5.7 Media Queries for Screen Features

Using CSS media queries in JavaScript for screen detection.

```javascript
// Check for touch capability
const isTouchDevice = matchMedia('(hover: none) and (pointer: coarse)').matches;

// Check for HDR display
const isHDR = matchMedia('(dynamic-range: high)').matches;

// Check for high contrast mode
const highContrast = matchMedia('(prefers-contrast: more)').matches;

// Check display type
const isRetina = matchMedia('(min-resolution: 2dppx)').matches;
const isPrint = matchMedia('print').matches;

// Dark mode preference
const prefersDark = matchMedia('(prefers-color-scheme: dark)').matches;

// Reduced motion preference
const reducedMotion = matchMedia('(prefers-reduced-motion: reduce)').matches;
```

---

## 2.5.8 Summary

| Property | Description | Notes |
|----------|-------------|-------|
| `width`/`height` | Total screen dimensions | CSS pixels |
| `availWidth`/`availHeight` | Usable screen area | Excludes taskbar |
| `availLeft`/`availTop` | Available area offset | Multi-monitor info |
| `colorDepth` | Bits per pixel | Usually 24 or 32 |
| `pixelDepth` | Same as colorDepth | |
| `orientation.type` | Current orientation | portrait/landscape |
| `orientation.angle` | Rotation in degrees | 0, 90, 180, 270 |

### Orientation Types

| Type | Description |
|------|-------------|
| `portrait-primary` | Natural portrait |
| `portrait-secondary` | Inverted portrait |
| `landscape-primary` | Natural landscape |
| `landscape-secondary` | Inverted landscape |

### Best Practices

1. **Prefer media queries** over screen object for responsive design
2. **Use orientation events** for handling rotation
3. **Account for devicePixelRatio** on HiDPI displays
4. **Don't assume single monitor** — screen.width might span displays
5. **Test on actual devices** — emulators may report different values
6. **Consider available vs total** when sizing popups

### Common Gotchas

```javascript
// ❌ screen.width is CSS pixels, not physical
// On 4K display at 200% scaling, screen.width is 1920, not 3840

// ❌ availWidth varies by OS and settings
// Don't hard-code assumptions about taskbar size

// ❌ Orientation lock only works in fullscreen
await screen.orientation.lock('landscape');  // Fails without fullscreen

// ⚠️ Multi-monitor detection is limited
// getScreenDetails() is experimental and requires permission
```

---

**End of Chapter 2.5: Screen Object**

This completes Group 02: Browser Object Model (BOM). Next group: **03 — Events** — starting with **3.1 Event Fundamentals**.
# 3.1 Event Fundamentals

Events are the heartbeat of interactive web applications. They represent things that happen in the browser — user actions, system notifications, and DOM changes. Understanding how events work, flow through the DOM, and can be controlled is fundamental to building responsive, interactive interfaces.

This chapter covers the event model itself — how events propagate, what happens at each phase, and how the browser processes event flow.

---

## 3.1.1 What Are Events?

Events are objects that represent occurrences in the browser. They can be triggered by user actions, browser activities, or programmatically.

### Types of Events

```javascript
// User interaction events
// - click, dblclick, contextmenu
// - mousedown, mouseup, mousemove
// - keydown, keyup
// - focus, blur
// - submit, change, input

// Browser/system events
// - load, DOMContentLoaded
// - resize, scroll
// - online, offline
// - visibilitychange

// DOM mutation events (legacy)
// - DOMNodeInserted, DOMNodeRemoved (deprecated)
// Modern alternative: MutationObserver

// Custom events
// - Any event you define
```

### Event-Driven Programming

```javascript
// Instead of polling (checking repeatedly):
// ❌ Inefficient
setInterval(() => {
  if (button.isClicked) {
    handleClick();
  }
}, 100);

// ✅ Event-driven (react when it happens)
button.addEventListener('click', handleClick);

// Benefits:
// - Efficient (browser notifies you)
// - Responsive (immediate reaction)
// - Decoupled (separation of concerns)
```

---

## 3.1.2 Event Flow: The Three Phases

When an event occurs on an element, it travels through the DOM in three phases.

### Phase 1: Capturing (or Capture)

```javascript
// Event travels DOWN from window to target element
// window → document → html → body → ... → target

// Register for capture phase
element.addEventListener('click', handler, true);
// or
element.addEventListener('click', handler, { capture: true });
```

### Phase 2: Target

```javascript
// Event reaches the element that triggered it
// The handler on the target element fires

// Both capture and bubble handlers on target fire here
// Order depends on registration order
```

### Phase 3: Bubbling

```javascript
// Event travels UP from target back to window
// target → ... → body → html → document → window

// Default event registration is for bubbling phase
element.addEventListener('click', handler);  // Bubbling
element.addEventListener('click', handler, false);  // Explicit bubbling
```

### Visual Representation

```
        CAPTURING PHASE                    BUBBLING PHASE
              │                                  ▲
              ▼                                  │
         ┌─────────────────────────────────────────┐
         │  window                                 │
         │  ┌─────────────────────────────────────┐│
         │  │  document                           ││
         │  │  ┌─────────────────────────────────┐││
         │  │  │  <html>                         │││
         │  │  │  ┌─────────────────────────────┐│││
         │  │  │  │  <body>                     ││││
         │  │  │  │  ┌─────────────────────────┐││││
         │  │  │  │  │  <div>                  │││││
         │  │  │  │  │  ┌─────────────────────┐│││││
         │  │  │  │  │  │  <button> ← TARGET  ││││││
         │  │  │  │  │  └─────────────────────┘│││││
         │  │  │  │  └─────────────────────────┘││││
         │  │  │  └─────────────────────────────┘│││
         │  │  └─────────────────────────────────┘││
         │  └─────────────────────────────────────┘│
         └─────────────────────────────────────────┘
```

### Demonstrating Event Flow

```javascript
const button = document.querySelector('button');
const div = document.querySelector('div');
const body = document.body;

// Capture phase handlers
body.addEventListener('click', () => console.log('1. body capture'), true);
div.addEventListener('click', () => console.log('2. div capture'), true);
button.addEventListener('click', () => console.log('3. button capture'), true);

// Bubble phase handlers
button.addEventListener('click', () => console.log('4. button bubble'));
div.addEventListener('click', () => console.log('5. div bubble'));
body.addEventListener('click', () => console.log('6. body bubble'));

// Click on button outputs:
// 1. body capture
// 2. div capture
// 3. button capture
// 4. button bubble
// 5. div bubble
// 6. body bubble
```

---

## 3.1.3 Event Bubbling

Most events bubble up through the DOM tree after reaching the target.

### How Bubbling Works

```javascript
// HTML:
// <div id="outer">
//   <div id="inner">
//     <button>Click me</button>
//   </div>
// </div>

document.getElementById('outer').addEventListener('click', (e) => {
  console.log('outer clicked, target:', e.target.tagName);
});

document.getElementById('inner').addEventListener('click', (e) => {
  console.log('inner clicked, target:', e.target.tagName);
});

// Click on button:
// inner clicked, target: BUTTON
// outer clicked, target: BUTTON
// (Both handlers fire, target is always the original element)
```

### Events That Don't Bubble

```javascript
// Some events don't bubble (check event.bubbles property)
// - focus, blur (use focusin, focusout for bubbling versions)
// - mouseenter, mouseleave (use mouseover, mouseout for bubbling)
// - load, unload, abort, error (on elements)
// - scroll (doesn't bubble from most elements)

element.addEventListener('blur', handler);  // Doesn't bubble
element.addEventListener('focusout', handler);  // Bubbles!

element.addEventListener('mouseenter', handler);  // Doesn't bubble
element.addEventListener('mouseover', handler);  // Bubbles!
```

### Checking If Event Bubbles

```javascript
element.addEventListener('click', (event) => {
  console.log('Does this event bubble?', event.bubbles);  // true
});

element.addEventListener('focus', (event) => {
  console.log('Does this event bubble?', event.bubbles);  // false
});
```

---

## 3.1.4 Event Capturing

The capture phase happens before bubbling and travels in the opposite direction.

### Why Use Capture?

```javascript
// Capture is useful for:
// 1. Intercepting events before they reach target
// 2. Implementing certain UI patterns
// 3. Event delegation on non-bubbling events

// Example: Global click handler that runs FIRST
document.addEventListener('click', (e) => {
  console.log('Click intercepted before any element handlers');
  
  // Could potentially stop propagation here
  // to prevent the click from reaching elements
}, true);  // ← capture: true
```

### Capture vs Bubble Order

```javascript
const parent = document.getElementById('parent');
const child = document.getElementById('child');

// Same element, different phases
parent.addEventListener('click', () => console.log('parent capture'), true);
parent.addEventListener('click', () => console.log('parent bubble'), false);

child.addEventListener('click', () => console.log('child capture'), true);
child.addEventListener('click', () => console.log('child bubble'), false);

// Click on child:
// parent capture (going down)
// child capture (at target)
// child bubble (at target)
// parent bubble (going up)
```

---

## 3.1.5 Stopping Propagation

You can stop an event from continuing its journey through the DOM.

### stopPropagation()

```javascript
// Stops event from traveling to next element in the phase
element.addEventListener('click', (e) => {
  e.stopPropagation();
  console.log('Event stops here, won\'t reach parent');
});

parent.addEventListener('click', () => {
  console.log('This will NOT fire if child stops propagation');
});
```

### stopImmediatePropagation()

```javascript
// Stops event from:
// 1. Traveling to next element (like stopPropagation)
// 2. Firing other handlers on SAME element

// Two handlers on same element
element.addEventListener('click', (e) => {
  e.stopImmediatePropagation();
  console.log('First handler');
});

element.addEventListener('click', () => {
  console.log('Second handler - WILL NOT FIRE');
});

// With just stopPropagation():
element.addEventListener('click', (e) => {
  e.stopPropagation();
  console.log('First handler');
});

element.addEventListener('click', () => {
  console.log('Second handler - WILL fire');
});
```

### When to Stop Propagation

```javascript
// ✅ Good use: Modal close button shouldn't close modal AND do modal's click action
modalCloseBtn.addEventListener('click', (e) => {
  e.stopPropagation();  // Don't let modal's click handler fire
  closeModal();
});

modal.addEventListener('click', () => {
  // Some action when modal content is clicked
});

// ❌ Bad use: Don't stop propagation just because
// It breaks event delegation and analytics
element.addEventListener('click', (e) => {
  e.stopPropagation();  // This might break parent handlers!
  doSomething();
});

// ✅ Better: Let events bubble, handle appropriately
element.addEventListener('click', (e) => {
  doSomething();
  // Let parent handlers decide what to do
});
```

---

## 3.1.6 Preventing Default Behavior

Many events have default browser behaviors that you can prevent.

### preventDefault()

```javascript
// Prevent link navigation
link.addEventListener('click', (e) => {
  e.preventDefault();
  console.log('Link clicked but not followed');
});

// Prevent form submission
form.addEventListener('submit', (e) => {
  e.preventDefault();
  console.log('Form submitted via JavaScript instead');
  submitViaAjax(form);
});

// Prevent context menu
element.addEventListener('contextmenu', (e) => {
  e.preventDefault();
  showCustomContextMenu(e.clientX, e.clientY);
});

// Prevent keyboard shortcuts
document.addEventListener('keydown', (e) => {
  if (e.key === 's' && e.ctrlKey) {
    e.preventDefault();
    customSave();
  }
});
```

### Checking If Preventable

```javascript
element.addEventListener('click', (e) => {
  // Check if default can be prevented
  if (e.cancelable) {
    e.preventDefault();
  }
  
  // Check if it was already prevented
  console.log('Default prevented?', e.defaultPrevented);
});
```

### preventDefault vs stopPropagation

```javascript
// They do different things!

// preventDefault: Stop default browser behavior
// - Link navigation, form submission, keyboard shortcuts
// - Does NOT stop other event handlers from running

// stopPropagation: Stop event flow through DOM
// - Other handlers on parent/child elements won't fire
// - Does NOT stop default browser behavior

// Example: A link in a card
link.addEventListener('click', (e) => {
  e.preventDefault();       // Don't navigate
  // Event still bubbles to card!
});

card.addEventListener('click', () => {
  console.log('Card clicked');  // This still fires!
});

// To stop both:
link.addEventListener('click', (e) => {
  e.preventDefault();
  e.stopPropagation();
});
```

---

## 3.1.7 Event Target vs Current Target

Understanding which element triggered the event vs which element's handler is running.

### target

```javascript
// e.target: The element that triggered the event (the original source)

parentDiv.addEventListener('click', (e) => {
  console.log('target:', e.target);  // Could be a child element!
});

// Click on child <button> inside parentDiv:
// target: <button>
```

### currentTarget

```javascript
// e.currentTarget: The element that the handler is attached to

parentDiv.addEventListener('click', (e) => {
  console.log('currentTarget:', e.currentTarget);  // Always parentDiv
  console.log('target:', e.target);  // Whatever was clicked
});

// Click on child <button>:
// currentTarget: <div> (the parentDiv)
// target: <button>
```

### Practical Example

```javascript
// Event delegation pattern
const list = document.getElementById('todo-list');

list.addEventListener('click', (e) => {
  // currentTarget: the <ul> we attached the handler to
  console.log(e.currentTarget);  // <ul id="todo-list">
  
  // target: the actual element clicked
  console.log(e.target);  // Could be <li>, <button>, <span>, etc.
  
  // Find the list item
  const item = e.target.closest('li');
  if (item) {
    handleItemClick(item);
  }
});
```

### this vs currentTarget

```javascript
// In a regular function, `this` === `e.currentTarget`
element.addEventListener('click', function(e) {
  console.log(this === e.currentTarget);  // true
});

// In an arrow function, `this` is the outer scope
element.addEventListener('click', (e) => {
  console.log(this);  // Window (or whatever outer scope is)
  console.log(e.currentTarget);  // The element (use this instead)
});
```

---

## 3.1.8 Event Phases Property

The `eventPhase` property tells you which phase the event is currently in.

```javascript
element.addEventListener('click', (e) => {
  switch (e.eventPhase) {
    case Event.NONE:           // 0
      console.log('No event is being processed');
      break;
    case Event.CAPTURING_PHASE: // 1
      console.log('Capturing phase');
      break;
    case Event.AT_TARGET:       // 2
      console.log('At target element');
      break;
    case Event.BUBBLING_PHASE:  // 3
      console.log('Bubbling phase');
      break;
  }
});

// Constants
console.log(Event.CAPTURING_PHASE);  // 1
console.log(Event.AT_TARGET);        // 2
console.log(Event.BUBBLING_PHASE);   // 3
```

---

## 3.1.9 Common Event Flow Patterns

### Pattern: Capture for Global Interception

```javascript
// Track all clicks for analytics
document.addEventListener('click', (e) => {
  analytics.track('click', {
    element: e.target.tagName,
    id: e.target.id,
    classes: e.target.className
  });
}, true);  // Capture phase = runs first

// Individual handlers won't affect this tracking
// (unless they stop propagation in capture phase)
```

### Pattern: Bubble for Event Delegation

```javascript
// Handle clicks on dynamic content
document.addEventListener('click', (e) => {
  // Handle delete buttons
  const deleteBtn = e.target.closest('[data-action="delete"]');
  if (deleteBtn) {
    handleDelete(deleteBtn);
    return;
  }
  
  // Handle edit buttons
  const editBtn = e.target.closest('[data-action="edit"]');
  if (editBtn) {
    handleEdit(editBtn);
    return;
  }
});  // Bubbling phase (default)
```

### Pattern: Stop Propagation for Nested Interactives

```javascript
// Nested interactive elements
// <div class="card" onclick="openCard()">
//   <button class="close">X</button>
// </div>

const card = document.querySelector('.card');
const closeBtn = card.querySelector('.close');

card.addEventListener('click', () => openCard());

closeBtn.addEventListener('click', (e) => {
  e.stopPropagation();  // Don't open card when closing
  closeCard();
});
```

---

## 3.1.10 Summary

| Concept | Description |
|---------|-------------|
| Event | Object representing something that happened |
| Capturing | Event travels DOWN from window to target |
| Target | Event reaches the element that triggered it |
| Bubbling | Event travels UP from target to window |
| `target` | Element that triggered the event |
| `currentTarget` | Element handler is attached to |
| `stopPropagation()` | Stop event from traveling further |
| `stopImmediatePropagation()` | Stop event + remaining handlers on element |
| `preventDefault()` | Stop default browser behavior |
| `eventPhase` | Which phase event is currently in |

### Event Phase Order

1. **Capture phase** — Window → ... → Parent → Target
2. **Target phase** — At the target element
3. **Bubble phase** — Target → Parent → ... → Window

### Best Practices

1. **Use bubbling by default** — it's what most code expects
2. **Use capture sparingly** — for interception or non-bubbling events
3. **Avoid stopping propagation** unless necessary — it breaks delegation
4. **Use `closest()` with bubbling** for event delegation
5. **Check `e.target` vs `e.currentTarget`** for delegated handlers

---

**End of Chapter 3.1: Event Fundamentals**

Next chapter: **3.2 Event Handling** — covers `addEventListener`, `removeEventListener`, handler options, and legacy event patterns.
# 3.2 Event Handling

Event handling is how you connect JavaScript code to events. This chapter covers all the ways to attach, configure, and remove event handlers — from modern `addEventListener` with its rich options to legacy patterns you'll still encounter in older codebases.

---

## 3.2.1 addEventListener

The modern, preferred way to attach event handlers.

### Basic Syntax

```javascript
// addEventListener(type, listener)
// addEventListener(type, listener, options)
// addEventListener(type, listener, useCapture)

element.addEventListener('click', function(event) {
  console.log('Element clicked');
});

// Named function
function handleClick(event) {
  console.log('Clicked!');
}
element.addEventListener('click', handleClick);

// Arrow function
element.addEventListener('click', (e) => {
  console.log('Arrow handler', e.target);
});
```

### Multiple Handlers

```javascript
// You can add multiple handlers for the same event
element.addEventListener('click', handler1);
element.addEventListener('click', handler2);
element.addEventListener('click', handler3);

// All three will fire in registration order
// Click → handler1 → handler2 → handler3

// Same handler added twice is ignored (by reference)
element.addEventListener('click', handleClick);
element.addEventListener('click', handleClick);  // Ignored, same reference

// But different functions are both added
element.addEventListener('click', () => console.log('first'));
element.addEventListener('click', () => console.log('second'));
// Both fire (different arrow function references)
```

### Handler Types

```javascript
// 1. Regular function
element.addEventListener('click', function(e) {
  console.log(this);  // the element
  console.log(e);     // the event
});

// 2. Arrow function
element.addEventListener('click', (e) => {
  console.log(this);  // outer scope (not element!)
  console.log(e);     // the event
});

// 3. Named function (for removal)
function myHandler(e) {
  console.log('Handled');
}
element.addEventListener('click', myHandler);

// 4. Object with handleEvent method
const handler = {
  handleEvent(e) {
    console.log('Handled by object');
    console.log(this);  // the handler object
  }
};
element.addEventListener('click', handler);
```

---

## 3.2.2 Handler Options

The third parameter can be a boolean or an options object.

### capture Option

```javascript
// Boolean shorthand
element.addEventListener('click', handler, true);   // Capture phase
element.addEventListener('click', handler, false);  // Bubble phase (default)

// Options object
element.addEventListener('click', handler, {
  capture: true  // Run during capture phase
});
```

### once Option

```javascript
// Handler fires only once, then auto-removes
element.addEventListener('click', handler, {
  once: true
});

// Equivalent to:
function onceHandler(e) {
  element.removeEventListener('click', onceHandler);
  handler(e);
}
element.addEventListener('click', onceHandler);

// Practical use cases:
// - First interaction tracking
// - Modal first open
// - Animation end cleanup
button.addEventListener('click', () => {
  console.log('This only fires once');
}, { once: true });
```

### passive Option

```javascript
// Promise not to call preventDefault()
// Allows browser to optimize (especially for scroll)
element.addEventListener('scroll', handler, {
  passive: true
});

// Touch events benefit most from passive
element.addEventListener('touchstart', handler, {
  passive: true
});

// If you try to preventDefault in a passive handler:
element.addEventListener('touchstart', (e) => {
  e.preventDefault();  // Warning! Ignored in passive handler
}, { passive: true });

// ⚠️ Some browsers default to passive for touch/wheel
// To explicitly allow preventDefault:
element.addEventListener('touchmove', (e) => {
  e.preventDefault();  // Works
}, { passive: false });
```

### signal Option (AbortController)

```javascript
// Remove listener via AbortController
const controller = new AbortController();

element.addEventListener('click', handler, {
  signal: controller.signal
});

// Later: remove the handler
controller.abort();

// Useful for cleanup
class Component {
  constructor() {
    this.abortController = new AbortController();
  }
  
  mount() {
    window.addEventListener('resize', this.handleResize, {
      signal: this.abortController.signal
    });
    document.addEventListener('click', this.handleClick, {
      signal: this.abortController.signal
    });
  }
  
  unmount() {
    // Remove all listeners at once
    this.abortController.abort();
  }
  
  handleResize = () => { /* ... */ };
  handleClick = () => { /* ... */ };
}
```

### Combining Options

```javascript
// Multiple options together
element.addEventListener('touchstart', handler, {
  capture: true,
  once: true,
  passive: true,
  signal: controller.signal
});
```

---

## 3.2.3 removeEventListener

Remove previously added event handlers.

### Basic Removal

```javascript
// Must use same function reference
function handleClick(e) {
  console.log('Clicked');
}

// Add
element.addEventListener('click', handleClick);

// Remove
element.removeEventListener('click', handleClick);

// ❌ This doesn't work (different function reference)
element.addEventListener('click', function(e) { console.log('hi'); });
element.removeEventListener('click', function(e) { console.log('hi'); });
// The anonymous functions are different objects!
```

### Options Must Match

```javascript
// If you used capture option when adding, must use it when removing
element.addEventListener('click', handler, true);
element.removeEventListener('click', handler, true);  // ✅ Works
element.removeEventListener('click', handler, false); // ❌ Doesn't work

element.addEventListener('click', handler, { capture: true });
element.removeEventListener('click', handler, { capture: true });  // ✅ Works

// once and passive don't matter for removal matching
element.addEventListener('click', handler, { once: true });
element.removeEventListener('click', handler);  // ✅ Works (capture defaults false)
```

### Patterns for Removable Handlers

```javascript
// Pattern 1: Named function
function onScroll() { /* ... */ }
window.addEventListener('scroll', onScroll);
window.removeEventListener('scroll', onScroll);

// Pattern 2: Store reference
const handler = (e) => console.log(e);
element.addEventListener('click', handler);
element.removeEventListener('click', handler);

// Pattern 3: Method binding
class MyClass {
  constructor() {
    this.boundHandler = this.handleClick.bind(this);
  }
  
  attach() {
    element.addEventListener('click', this.boundHandler);
  }
  
  detach() {
    element.removeEventListener('click', this.boundHandler);
  }
  
  handleClick(e) {
    console.log(this);  // MyClass instance
  }
}

// Pattern 4: Arrow function as class property
class MyClass2 {
  handleClick = (e) => {
    console.log(this);  // MyClass2 instance
  }
  
  attach() {
    element.addEventListener('click', this.handleClick);
  }
  
  detach() {
    element.removeEventListener('click', this.handleClick);
  }
}

// Pattern 5: AbortController (best for multiple listeners)
const controller = new AbortController();
element.addEventListener('click', handler, { signal: controller.signal });
// Later:
controller.abort();  // No need to track function reference
```

---

## 3.2.4 Legacy Event Handling

Older patterns you'll encounter in existing code.

### Handler Properties (on* Properties)

```javascript
// Set handler as property
element.onclick = function(e) {
  console.log('Clicked');
};

// Overwriting replaces previous handler
element.onclick = function(e) {
  console.log('New handler');
};
// Only "New handler" fires on click

// Remove handler
element.onclick = null;

// Common handler properties:
element.onclick
element.ondblclick
element.onmouseenter
element.onmouseleave
element.onkeydown
element.onkeyup
element.onfocus
element.onblur
element.onsubmit
element.onchange
window.onload
window.onresize
document.onreadystatechange
```

### Inline HTML Handlers

```html
<!-- Handler in HTML attribute -->
<button onclick="handleClick()">Click</button>
<button onclick="console.log('clicked')">Click</button>
<button onclick="handleClick(event)">Click</button>

<!-- Access element with 'this' -->
<button onclick="handleClick(this)">Click</button>

<!-- Multiple statements -->
<button onclick="first(); second(); third();">Click</button>
```

```javascript
// The inline handler is wrapped in a function:
// function onclick(event) {
//   handleClick()
// }

// 'event' is available
// <button onclick="console.log(event.target)">

// ❌ Inline handlers have drawbacks:
// - Mix HTML and JS
// - Global scope only (or use modules workaround)
// - Security (CSP may block)
// - Harder to maintain
```

### Why Prefer addEventListener

```javascript
// addEventListener advantages over onclick and inline:

// 1. Multiple handlers
element.addEventListener('click', handler1);
element.addEventListener('click', handler2);  // Both work

element.onclick = handler1;
element.onclick = handler2;  // Only handler2 works

// 2. Options (capture, once, passive)
element.addEventListener('click', handler, { once: true });
// Not possible with onclick

// 3. Removal control
element.removeEventListener('click', handler);
// More precise than element.onclick = null

// 4. Works on any EventTarget
// addEventListener works on window, document, elements, etc.
// onclick only on elements with that property

// 5. Capture phase access
element.addEventListener('click', handler, true);  // Capture
// Not possible with onclick
```

---

## 3.2.5 Event Handler Context (this)

What `this` refers to inside event handlers.

### In Regular Functions

```javascript
// 'this' is the element the handler is attached to
element.addEventListener('click', function(e) {
  console.log(this);               // element
  console.log(e.currentTarget);    // element (same)
  console.log(this === e.currentTarget);  // true
});

// Same for onclick
element.onclick = function(e) {
  console.log(this);  // element
};
```

### In Arrow Functions

```javascript
// 'this' is inherited from surrounding scope
element.addEventListener('click', (e) => {
  console.log(this);  // Window (or containing scope)
  console.log(e.currentTarget);  // element (use this instead!)
});

// In a class
class Component {
  constructor() {
    // Arrow function captures 'this' from constructor
    element.addEventListener('click', (e) => {
      console.log(this);  // Component instance
      this.handleClick(e);
    });
  }
}
```

### Method Binding

```javascript
class Component {
  constructor() {
    // Problem: unbound method
    element.addEventListener('click', this.handleClick);
    // 'this' in handleClick will be undefined or element!
  }
  
  handleClick(e) {
    console.log(this);  // undefined in strict mode, or element
  }
}

// Solution 1: bind in constructor
class Component2 {
  constructor() {
    this.handleClick = this.handleClick.bind(this);
    element.addEventListener('click', this.handleClick);
  }
  
  handleClick(e) {
    console.log(this);  // Component2 instance ✅
  }
}

// Solution 2: Arrow function property
class Component3 {
  handleClick = (e) => {
    console.log(this);  // Component3 instance ✅
  }
  
  constructor() {
    element.addEventListener('click', this.handleClick);
  }
}

// Solution 3: Wrapper arrow function
class Component4 {
  constructor() {
    element.addEventListener('click', (e) => this.handleClick(e));
  }
  
  handleClick(e) {
    console.log(this);  // Component4 instance ✅
  }
}
```

### handleEvent Object Method

```javascript
// Object with handleEvent method
const handler = {
  count: 0,
  
  handleEvent(e) {
    console.log(this);  // The handler object
    this.count++;
    console.log(`Clicked ${this.count} times`);
  }
};

element.addEventListener('click', handler);

// 'this' in handleEvent is the object, not the element
// Access element via e.target or e.currentTarget
```

---

## 3.2.6 Common Patterns

### Debouncing Events

```javascript
// Delay handler until events stop
function debounce(fn, delay) {
  let timeoutId;
  return function(...args) {
    clearTimeout(timeoutId);
    timeoutId = setTimeout(() => fn.apply(this, args), delay);
  };
}

const handleResize = debounce(() => {
  console.log('Resize finished');
}, 250);

window.addEventListener('resize', handleResize);
```

### Throttling Events

```javascript
// Limit handler to once per interval
function throttle(fn, limit) {
  let inThrottle;
  return function(...args) {
    if (!inThrottle) {
      fn.apply(this, args);
      inThrottle = true;
      setTimeout(() => inThrottle = false, limit);
    }
  };
}

const handleScroll = throttle(() => {
  console.log('Scroll position:', window.scrollY);
}, 100);

window.addEventListener('scroll', handleScroll);
```

### One-Time Setup

```javascript
// Using once option
element.addEventListener('click', () => {
  console.log('First click - initializing');
  setupComplexFeature();
}, { once: true });

// Manual removal pattern
function initialize(e) {
  element.removeEventListener('click', initialize);
  setupComplexFeature();
}
element.addEventListener('click', initialize);
```

### Cleanup on Page Unload

```javascript
const controller = new AbortController();

function setupListeners() {
  const options = { signal: controller.signal };
  
  window.addEventListener('resize', handleResize, options);
  document.addEventListener('click', handleClick, options);
  element.addEventListener('mousemove', handleMouseMove, options);
}

// Cleanup all at once
window.addEventListener('beforeunload', () => {
  controller.abort();
});
```

---

## 3.2.7 Summary

| Method | Multiple Handlers | Options | Removal |
|--------|-------------------|---------|---------|
| `addEventListener` | ✅ Yes | ✅ capture, once, passive, signal | `removeEventListener` |
| `on*` property | ❌ No | ❌ None | `= null` |
| Inline HTML | ❌ No | ❌ None | Remove attribute |

### addEventListener Options

| Option | Purpose | Default |
|--------|---------|---------|
| `capture` | Run during capture phase | `false` |
| `once` | Auto-remove after first call | `false` |
| `passive` | Promise not to preventDefault | varies |
| `signal` | AbortSignal for removal | - |

### Best Practices

1. **Always use `addEventListener`** — most flexible and powerful
2. **Use named functions** when you need to remove handlers
3. **Use `once: true`** for one-time handlers
4. **Use `passive: true`** for scroll/touch handlers when possible
5. **Use `AbortController`** for cleanup in components
6. **Be careful with `this`** — bind methods or use arrow functions
7. **Debounce/throttle** frequent events (resize, scroll, input)

### Common Gotchas

```javascript
// ❌ Can't remove anonymous functions
element.addEventListener('click', () => console.log('hi'));
element.removeEventListener('click', () => console.log('hi'));  // Different function!

// ❌ Forgot to bind 'this'
element.addEventListener('click', this.method);  // 'this' is wrong

// ❌ Capture option must match for removal
element.addEventListener('click', handler, true);
element.removeEventListener('click', handler);  // Doesn't match!

// ❌ preventDefault in passive handler is ignored
element.addEventListener('scroll', (e) => e.preventDefault(), { passive: true });
```

---

**End of Chapter 3.2: Event Handling**

Next chapter: **3.3 Event Object** — covers event properties like `target`, `type`, `timeStamp`, and methods like `preventDefault` and `stopPropagation`.
# 3.3 Event Object

Every event handler receives an Event object containing information about what happened. The event object provides details like which element triggered the event, what type of event it was, and methods to control event behavior. Different event types extend the base Event interface with additional properties.

---

## 3.3.1 The Event Interface

All events inherit from the base `Event` interface.

### Creating Events Manually

```javascript
// Create a basic event
const event = new Event('click');
console.log(event.type);  // "click"

// Dispatch it
element.dispatchEvent(event);

// With options
const customEvent = new Event('myevent', {
  bubbles: true,      // Does event bubble? (default: false)
  cancelable: true,   // Can preventDefault()? (default: false)
  composed: true      // Crosses shadow DOM? (default: false)
});
```

---

## 3.3.2 Core Event Properties

### type

```javascript
// The event type as a string
element.addEventListener('click', (e) => {
  console.log(e.type);  // "click"
});

element.addEventListener('keydown', (e) => {
  console.log(e.type);  // "keydown"
});

// Useful when sharing handlers
const handler = (e) => {
  switch (e.type) {
    case 'click':
      handleClick(e);
      break;
    case 'keydown':
      handleKeydown(e);
      break;
  }
};

element.addEventListener('click', handler);
element.addEventListener('keydown', handler);
```

### target

```javascript
// The element that triggered the event
document.addEventListener('click', (e) => {
  console.log('You clicked:', e.target);
  console.log('Tag name:', e.target.tagName);
  console.log('ID:', e.target.id);
  console.log('Classes:', e.target.className);
});

// ⚠️ target can be a child element
parentDiv.addEventListener('click', (e) => {
  console.log(e.target);  // Could be any descendant!
});
```

### currentTarget

```javascript
// The element the handler is attached to
parentDiv.addEventListener('click', (e) => {
  console.log('target:', e.target);        // What was clicked
  console.log('currentTarget:', e.currentTarget);  // parentDiv
  
  // currentTarget is always the element with the listener
  console.log(e.currentTarget === parentDiv);  // true
});

// ⚠️ currentTarget is null after async operations
parentDiv.addEventListener('click', async (e) => {
  console.log(e.currentTarget);  // parentDiv
  
  await fetch('/api');
  
  console.log(e.currentTarget);  // null!
  
  // Solution: save reference
  const target = e.currentTarget;
  await fetch('/api');
  console.log(target);  // parentDiv
});
```

### relatedTarget

```javascript
// Secondary element involved in the event
// Used for: focus, blur, mouseenter, mouseleave, dragenter, dragleave

element.addEventListener('mouseenter', (e) => {
  console.log('Mouse came from:', e.relatedTarget);
});

element.addEventListener('mouseleave', (e) => {
  console.log('Mouse going to:', e.relatedTarget);
});

element.addEventListener('focus', (e) => {
  console.log('Focus came from:', e.relatedTarget);  // Previous focused element
});

element.addEventListener('blur', (e) => {
  console.log('Focus going to:', e.relatedTarget);  // Next focused element
});
```

---

## 3.3.3 Event State Properties

### bubbles

```javascript
// Whether the event bubbles up through the DOM
element.addEventListener('click', (e) => {
  console.log(e.bubbles);  // true
});

element.addEventListener('focus', (e) => {
  console.log(e.bubbles);  // false (focus doesn't bubble)
});

// Check before relying on bubbling
if (event.bubbles) {
  // Safe to use event delegation
}
```

### cancelable

```javascript
// Whether preventDefault() will work
element.addEventListener('click', (e) => {
  console.log(e.cancelable);  // true
});

element.addEventListener('scroll', (e) => {
  console.log(e.cancelable);  // false (scroll not cancelable)
});

// Safe prevention pattern
if (e.cancelable) {
  e.preventDefault();
}
```

### defaultPrevented

```javascript
// Whether preventDefault() was called
link.addEventListener('click', (e) => {
  e.preventDefault();
});

// Check elsewhere
document.addEventListener('click', (e) => {
  if (e.defaultPrevented) {
    console.log('Default was prevented');
  }
});
```

### eventPhase

```javascript
// Which phase the event is in (1, 2, or 3)
element.addEventListener('click', (e) => {
  switch (e.eventPhase) {
    case Event.CAPTURING_PHASE:  // 1
      console.log('Capturing');
      break;
    case Event.AT_TARGET:        // 2
      console.log('At target');
      break;
    case Event.BUBBLING_PHASE:   // 3
      console.log('Bubbling');
      break;
  }
});
```

### isTrusted

```javascript
// True if triggered by user action, false if dispatched by script
element.addEventListener('click', (e) => {
  if (e.isTrusted) {
    console.log('User clicked');
  } else {
    console.log('Simulated click via JavaScript');
  }
});

// Triggered by user: isTrusted = true
// User clicks button

// Triggered by code: isTrusted = false
element.click();
element.dispatchEvent(new Event('click'));

// Security consideration
// Some APIs only work with trusted events
```

---

## 3.3.4 Timing Properties

### timeStamp

```javascript
// Milliseconds since page load (or epoch in older browsers)
element.addEventListener('click', (e) => {
  console.log('Event at:', e.timeStamp);  // e.g., 3451.234
});

// Useful for measuring
let lastClick = 0;
element.addEventListener('click', (e) => {
  const timeSinceLastClick = e.timeStamp - lastClick;
  console.log(`${timeSinceLastClick}ms since last click`);
  lastClick = e.timeStamp;
});

// Double-click detection
let lastClickTime = 0;
element.addEventListener('click', (e) => {
  if (e.timeStamp - lastClickTime < 300) {
    console.log('Double click!');
  }
  lastClickTime = e.timeStamp;
});
```

---

## 3.3.5 Event Methods

### preventDefault()

```javascript
// Stop default browser behavior
link.addEventListener('click', (e) => {
  e.preventDefault();
  // Link won't navigate
});

form.addEventListener('submit', (e) => {
  e.preventDefault();
  // Form won't submit to server
});

input.addEventListener('keydown', (e) => {
  if (e.key === 'Enter') {
    e.preventDefault();
    // Won't insert newline or submit form
  }
});

// ⚠️ Only works if cancelable is true
// ⚠️ Doesn't stop event propagation
```

### stopPropagation()

```javascript
// Stop event from traveling to other elements
child.addEventListener('click', (e) => {
  e.stopPropagation();
  // Parent handlers won't fire
});

parent.addEventListener('click', (e) => {
  console.log('This will NOT fire if child stops propagation');
});

// ⚠️ Doesn't affect other handlers on same element
element.addEventListener('click', (e) => {
  e.stopPropagation();
  console.log('First handler');
});

element.addEventListener('click', (e) => {
  console.log('Second handler still fires!');
});
```

### stopImmediatePropagation()

```javascript
// Stop propagation AND remaining handlers on this element
element.addEventListener('click', (e) => {
  e.stopImmediatePropagation();
  console.log('First handler');
});

element.addEventListener('click', (e) => {
  console.log('This will NOT fire');
});

parent.addEventListener('click', (e) => {
  console.log('Parent also will NOT fire');
});
```

### composedPath()

```javascript
// Get array of elements event will pass through
element.addEventListener('click', (e) => {
  const path = e.composedPath();
  console.log(path);
  // [button, div, body, html, document, Window]
  
  // First element is the target
  console.log(path[0] === e.target);  // true
  
  // Includes window
  console.log(path[path.length - 1] === window);  // true
});

// Useful for debugging event flow
// Useful for finding ancestors
const hasModalAncestor = e.composedPath().some(el => 
  el.classList?.contains('modal')
);
```

---

## 3.3.6 Specialized Event Types

Different event categories have extended properties.

### MouseEvent

```javascript
// Click, mousedown, mouseup, mousemove, etc.
element.addEventListener('click', (e) => {
  // Position
  console.log(e.clientX, e.clientY);  // Viewport coordinates
  console.log(e.pageX, e.pageY);      // Page coordinates (including scroll)
  console.log(e.screenX, e.screenY);  // Screen coordinates
  console.log(e.offsetX, e.offsetY);  // Relative to target element
  
  // Button pressed
  console.log(e.button);   // 0=left, 1=middle, 2=right
  console.log(e.buttons);  // Bitmask of all buttons currently held
  
  // Modifier keys
  console.log(e.altKey, e.ctrlKey, e.shiftKey, e.metaKey);
});
```

### KeyboardEvent

```javascript
// keydown, keyup
element.addEventListener('keydown', (e) => {
  console.log(e.key);      // "a", "Enter", "ArrowDown"
  console.log(e.code);     // "KeyA", "Enter", "ArrowDown"
  console.log(e.keyCode);  // 65 (deprecated)
  
  // Modifier state
  console.log(e.altKey, e.ctrlKey, e.shiftKey, e.metaKey);
  
  // Repeat (key held down)
  console.log(e.repeat);   // true if auto-repeating
});
```

### InputEvent

```javascript
// input, beforeinput
input.addEventListener('input', (e) => {
  console.log(e.data);       // Characters inserted
  console.log(e.inputType);  // "insertText", "deleteContentBackward", etc.
  console.log(e.isComposing); // true during IME composition
});
```

### FocusEvent

```javascript
// focus, blur, focusin, focusout
input.addEventListener('focus', (e) => {
  console.log(e.relatedTarget);  // Previous focused element
});

input.addEventListener('blur', (e) => {
  console.log(e.relatedTarget);  // Next focused element
});
```

### WheelEvent

```javascript
// wheel (scroll wheel)
element.addEventListener('wheel', (e) => {
  console.log(e.deltaX);     // Horizontal scroll
  console.log(e.deltaY);     // Vertical scroll
  console.log(e.deltaZ);     // Z-axis scroll (rare)
  console.log(e.deltaMode);  // 0=pixels, 1=lines, 2=pages
});
```

### TouchEvent

```javascript
// touchstart, touchmove, touchend, touchcancel
element.addEventListener('touchstart', (e) => {
  console.log(e.touches);        // All current touches
  console.log(e.targetTouches);  // Touches on this element
  console.log(e.changedTouches); // Touches changed in this event
  
  const touch = e.touches[0];
  console.log(touch.clientX, touch.clientY);
  console.log(touch.identifier);  // Unique touch ID
});
```

---

## 3.3.7 Accessing Event Data

### Getting Position

```javascript
element.addEventListener('click', (e) => {
  // Relative to viewport (visible area)
  const viewportX = e.clientX;
  const viewportY = e.clientY;
  
  // Relative to document (includes scroll)
  const documentX = e.pageX;
  const documentY = e.pageY;
  
  // Relative to target element
  const elementX = e.offsetX;
  const elementY = e.offsetY;
  
  // Relative to target element (alternative)
  const rect = e.target.getBoundingClientRect();
  const relativeX = e.clientX - rect.left;
  const relativeY = e.clientY - rect.top;
});
```

### Getting Modifier Keys

```javascript
element.addEventListener('click', (e) => {
  // Individual checks
  if (e.ctrlKey) console.log('Ctrl held');
  if (e.shiftKey) console.log('Shift held');
  if (e.altKey) console.log('Alt held');
  if (e.metaKey) console.log('Meta (Cmd/Win) held');
  
  // Combinations
  if (e.ctrlKey && e.shiftKey) {
    console.log('Ctrl+Shift+Click');
  }
  
  // Platform-aware (Cmd on Mac, Ctrl elsewhere)
  const isMac = navigator.platform.toUpperCase().includes('MAC');
  const modKey = isMac ? e.metaKey : e.ctrlKey;
  
  if (modKey) {
    console.log('Primary modifier key held');
  }
});
```

---

## 3.3.8 Event Properties Summary

### Base Event Properties

| Property | Type | Description |
|----------|------|-------------|
| `type` | string | Event type name |
| `target` | Element | Element that triggered event |
| `currentTarget` | Element | Element with handler attached |
| `relatedTarget` | Element | Secondary element (focus, mouse) |
| `bubbles` | boolean | Does event bubble? |
| `cancelable` | boolean | Can call preventDefault()? |
| `defaultPrevented` | boolean | Was preventDefault() called? |
| `eventPhase` | number | Current phase (1, 2, 3) |
| `isTrusted` | boolean | User-triggered or script? |
| `timeStamp` | number | When event occurred |

### Event Methods

| Method | Description |
|--------|-------------|
| `preventDefault()` | Stop default behavior |
| `stopPropagation()` | Stop traveling to other elements |
| `stopImmediatePropagation()` | Stop all remaining handlers |
| `composedPath()` | Get element path array |

### Best Practices

1. **Always handle null currentTarget** after async operations
2. **Check `cancelable` before `preventDefault()`** for safety
3. **Use `e.target` for delegation**, `e.currentTarget` for the attached element
4. **Check `isTrusted`** for security-sensitive operations
5. **Save event references** if needed after async operations
6. **Use `composedPath()`** for ancestor checking

---

**End of Chapter 3.3: Event Object**

Next chapter: **3.4 Mouse Events** — covers click, double-click, context menu, mouse movement, and mouse button handling.
# 3.4 Mouse Events

Mouse events are among the most commonly used events in web applications. From simple clicks to complex drag interactions, understanding mouse events enables you to build intuitive, interactive interfaces. This chapter covers all mouse event types, their properties, and common patterns.

---

## 3.4.1 Click Events

### click

```javascript
// Fires when element is clicked (mousedown + mouseup on same element)
element.addEventListener('click', (e) => {
  console.log('Clicked!');
  console.log('Button:', e.button);  // 0 = left click
});

// Click fires AFTER mouseup
element.addEventListener('mousedown', () => console.log('1. mousedown'));
element.addEventListener('mouseup', () => console.log('2. mouseup'));
element.addEventListener('click', () => console.log('3. click'));

// Output: 1. mousedown, 2. mouseup, 3. click
```

### dblclick

```javascript
// Fires on double-click
element.addEventListener('dblclick', (e) => {
  console.log('Double-clicked!');
});

// Event order for double-click:
// mousedown → mouseup → click → mousedown → mouseup → click → dblclick

// ⚠️ If you handle both click and dblclick, click fires first
element.addEventListener('click', () => console.log('click'));
element.addEventListener('dblclick', () => console.log('dblclick'));
// Double-click outputs: click, click, dblclick

// Pattern: Distinguish click from double-click
let clickTimer;
element.addEventListener('click', (e) => {
  if (clickTimer) {
    clearTimeout(clickTimer);
    clickTimer = null;
    // This was a double-click, ignore
    return;
  }
  
  clickTimer = setTimeout(() => {
    clickTimer = null;
    handleSingleClick(e);
  }, 250);
});

element.addEventListener('dblclick', (e) => {
  handleDoubleClick(e);
});
```

### auxclick

```javascript
// Fires for non-primary button clicks (middle, right)
element.addEventListener('auxclick', (e) => {
  console.log('Non-primary click, button:', e.button);
  // 1 = middle, 2 = right
});

// More reliable than checking button in click event
// click only fires for primary button (usually)
```

### contextmenu

```javascript
// Fires on right-click (or context menu key)
element.addEventListener('contextmenu', (e) => {
  e.preventDefault();  // Prevent browser context menu
  showCustomContextMenu(e.clientX, e.clientY);
});

// Works on any element
document.addEventListener('contextmenu', (e) => {
  if (e.target.closest('.no-context-menu')) {
    e.preventDefault();
  }
});
```

---

## 3.4.2 Mouse Button Events

### mousedown

```javascript
// Fires when mouse button is pressed (before release)
element.addEventListener('mousedown', (e) => {
  console.log('Button pressed:', e.button);
  // 0 = left, 1 = middle, 2 = right, 3 = back, 4 = forward
  
  console.log('Buttons held:', e.buttons);
  // Bitmask: 1 = left, 2 = right, 4 = middle
});

// Start tracking for drag
let isDragging = false;
element.addEventListener('mousedown', (e) => {
  if (e.button === 0) {  // Left button only
    isDragging = true;
    startDrag(e);
  }
});
```

### mouseup

```javascript
// Fires when mouse button is released
element.addEventListener('mouseup', (e) => {
  console.log('Button released:', e.button);
});

// End tracking
document.addEventListener('mouseup', (e) => {
  if (isDragging) {
    isDragging = false;
    endDrag(e);
  }
});
```

### Button Values

| e.button | e.buttons (bitmask) | Meaning |
|----------|---------------------|---------|
| 0 | 1 | Primary (usually left) |
| 1 | 4 | Middle (scroll wheel) |
| 2 | 2 | Secondary (usually right) |
| 3 | 8 | Back button |
| 4 | 16 | Forward button |

```javascript
// Check multiple buttons held
element.addEventListener('mousemove', (e) => {
  if (e.buttons & 1) console.log('Left held');
  if (e.buttons & 2) console.log('Right held');
  if (e.buttons & 4) console.log('Middle held');
  
  // Both left and right
  if ((e.buttons & 1) && (e.buttons & 2)) {
    console.log('Left and right held');
  }
});
```

---

## 3.4.3 Mouse Movement Events

### mousemove

```javascript
// Fires when mouse moves over element
element.addEventListener('mousemove', (e) => {
  console.log(`Position: ${e.clientX}, ${e.clientY}`);
});

// ⚠️ Fires very frequently - throttle for performance
const throttledMove = throttle((e) => {
  updatePosition(e.clientX, e.clientY);
}, 16);  // ~60fps

element.addEventListener('mousemove', throttledMove);

// Custom cursor following
document.addEventListener('mousemove', (e) => {
  cursor.style.left = `${e.clientX}px`;
  cursor.style.top = `${e.clientY}px`;
});
```

### mouseenter and mouseleave

```javascript
// mouseenter: mouse enters element (doesn't bubble)
element.addEventListener('mouseenter', (e) => {
  console.log('Mouse entered element');
  element.classList.add('hover');
});

// mouseleave: mouse leaves element (doesn't bubble)
element.addEventListener('mouseleave', (e) => {
  console.log('Mouse left element');
  element.classList.remove('hover');
});

// Key characteristic: doesn't fire for children
// <div id="parent">
//   <span id="child">Text</span>
// </div>

parent.addEventListener('mouseenter', () => {
  console.log('Entered parent');
});
// Only fires when entering parent from outside
// NOT when moving from parent to child
```

### mouseover and mouseout

```javascript
// mouseover: mouse enters element OR any descendant (bubbles)
element.addEventListener('mouseover', (e) => {
  console.log('Over:', e.target);
  console.log('From:', e.relatedTarget);
});

// mouseout: mouse leaves element OR moves to descendant (bubbles)
element.addEventListener('mouseout', (e) => {
  console.log('Left:', e.target);
  console.log('To:', e.relatedTarget);
});

// Fires for EVERY child element entered/left
// <div id="parent">
//   <span>One</span>
//   <span>Two</span>
// </div>

parent.addEventListener('mouseover', () => console.log('over'));
// Fires when entering parent, then again for each span
```

### Comparison: enter/leave vs over/out

| Feature | mouseenter/leave | mouseover/out |
|---------|------------------|---------------|
| Bubbles | No | Yes |
| Child elements | Ignored | Fire events |
| Use case | Simple hover | Delegation |

```javascript
// For simple hover effects, use enter/leave
element.addEventListener('mouseenter', showTooltip);
element.addEventListener('mouseleave', hideTooltip);

// For delegated hover detection, use over/out
list.addEventListener('mouseover', (e) => {
  const item = e.target.closest('li');
  if (item) highlightItem(item);
});
```

---

## 3.4.4 Position Properties

### Client, Page, Screen, and Offset Coordinates

```javascript
element.addEventListener('mousemove', (e) => {
  // CLIENT: Relative to viewport (visible area)
  console.log('clientX:', e.clientX);  // Pixels from left of viewport
  console.log('clientY:', e.clientY);  // Pixels from top of viewport
  
  // PAGE: Relative to document (includes scroll)
  console.log('pageX:', e.pageX);  // clientX + scrollX
  console.log('pageY:', e.pageY);  // clientY + scrollY
  
  // SCREEN: Relative to physical screen
  console.log('screenX:', e.screenX);  // Pixels from left of screen
  console.log('screenY:', e.screenY);  // Pixels from top of screen
  
  // OFFSET: Relative to target element
  console.log('offsetX:', e.offsetX);  // Pixels from left of e.target
  console.log('offsetY:', e.offsetY);  // Pixels from top of e.target
});
```

### Visual Representation

```
┌─────────────────────────────────────────────────────┐
│ SCREEN (screenX, screenY from here)                │
│  ┌───────────────────────────────────────────────┐ │
│  │ BROWSER WINDOW                                │ │
│  │  ┌─────────────────────────────────────────┐ │ │
│  │  │ VIEWPORT (clientX, clientY from here)   │ │ │
│  │  │                                         │ │ │
│  │  │    ┌─────────────────────────────────┐ │ │ │
│  │  │    │ DOCUMENT (pageX, pageY from     │ │ │ │
│  │  │    │    document start, may be       │ │ │ │
│  │  │    │    scrolled)                    │ │ │ │
│  │  │    │    ┌────────────────────────┐  │ │ │ │
│  │  │    │    │ ELEMENT               │  │ │ │ │
│  │  │    │    │ (offsetX, offsetY     │  │ │ │ │
│  │  │    │    │  from element corner) │  │ │ │ │
│  │  │    │    └────────────────────────┘  │ │ │ │
│  │  │    └─────────────────────────────────┘ │ │ │
│  │  └─────────────────────────────────────────┘ │ │
│  └───────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────┘
```

### Calculating Positions

```javascript
// Element-relative from client coordinates
element.addEventListener('click', (e) => {
  const rect = element.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;
  console.log(`Click at (${x}, ${y}) within element`);
});

// Percentage position within element
element.addEventListener('mousemove', (e) => {
  const rect = element.getBoundingClientRect();
  const percentX = (e.clientX - rect.left) / rect.width * 100;
  const percentY = (e.clientY - rect.top) / rect.height * 100;
  console.log(`Position: ${percentX.toFixed(1)}% x ${percentY.toFixed(1)}%`);
});
```

---

## 3.4.5 Wheel Events

### wheel

```javascript
// Fires when scroll wheel is used
element.addEventListener('wheel', (e) => {
  console.log('deltaX:', e.deltaX);  // Horizontal scroll
  console.log('deltaY:', e.deltaY);  // Vertical scroll (most common)
  console.log('deltaZ:', e.deltaZ);  // Z-axis (rare)
  console.log('deltaMode:', e.deltaMode);
  // 0 = pixels, 1 = lines, 2 = pages
});

// Prevent scroll
element.addEventListener('wheel', (e) => {
  e.preventDefault();  // Block scrolling
}, { passive: false });  // Must be non-passive to prevent

// Custom zoom with wheel
element.addEventListener('wheel', (e) => {
  if (e.ctrlKey) {
    e.preventDefault();
    const zoomDelta = e.deltaY > 0 ? -0.1 : 0.1;
    currentZoom = Math.max(0.1, Math.min(5, currentZoom + zoomDelta));
    applyZoom(currentZoom);
  }
}, { passive: false });
```

### Normalize Wheel Delta

```javascript
// Different browsers/devices report different delta values
function normalizeWheel(e) {
  let deltaY = e.deltaY;
  
  // Normalize to pixels
  if (e.deltaMode === 1) {
    deltaY *= 16;  // Lines to pixels
  } else if (e.deltaMode === 2) {
    deltaY *= 100;  // Pages to pixels
  }
  
  return deltaY;
}
```

---

## 3.4.6 Common Patterns

### Drag and Drop (Basic)

```javascript
let isDragging = false;
let startX, startY;
let elementStartX, elementStartY;

element.addEventListener('mousedown', (e) => {
  if (e.button !== 0) return;  // Left button only
  
  isDragging = true;
  startX = e.clientX;
  startY = e.clientY;
  elementStartX = element.offsetLeft;
  elementStartY = element.offsetTop;
  
  e.preventDefault();  // Prevent text selection
});

document.addEventListener('mousemove', (e) => {
  if (!isDragging) return;
  
  const deltaX = e.clientX - startX;
  const deltaY = e.clientY - startY;
  
  element.style.left = `${elementStartX + deltaX}px`;
  element.style.top = `${elementStartY + deltaY}px`;
});

document.addEventListener('mouseup', () => {
  isDragging = false;
});
```

### Click Outside to Close

```javascript
// Close dropdown/modal when clicking outside
function setupClickOutside(element, onClickOutside) {
  const handler = (e) => {
    if (!element.contains(e.target)) {
      onClickOutside();
    }
  };
  
  // Delay to prevent immediate trigger
  setTimeout(() => {
    document.addEventListener('click', handler);
  }, 0);
  
  return () => document.removeEventListener('click', handler);
}

// Usage
const cleanup = setupClickOutside(dropdown, () => {
  dropdown.classList.remove('open');
  cleanup();
});
```

### Hover with Delay

```javascript
// Show tooltip after hovering for 500ms
let hoverTimeout;

element.addEventListener('mouseenter', () => {
  hoverTimeout = setTimeout(() => {
    showTooltip();
  }, 500);
});

element.addEventListener('mouseleave', () => {
  clearTimeout(hoverTimeout);
  hideTooltip();
});
```

### Drawing on Canvas

```javascript
const canvas = document.querySelector('canvas');
const ctx = canvas.getContext('2d');
let isDrawing = false;

canvas.addEventListener('mousedown', (e) => {
  isDrawing = true;
  ctx.beginPath();
  ctx.moveTo(e.offsetX, e.offsetY);
});

canvas.addEventListener('mousemove', (e) => {
  if (!isDrawing) return;
  ctx.lineTo(e.offsetX, e.offsetY);
  ctx.stroke();
});

canvas.addEventListener('mouseup', () => {
  isDrawing = false;
});

canvas.addEventListener('mouseleave', () => {
  isDrawing = false;
});
```

---

## 3.4.7 Summary

### Mouse Events

| Event | Fires When |
|-------|------------|
| `click` | Left button pressed and released |
| `dblclick` | Double click |
| `auxclick` | Non-primary button click |
| `contextmenu` | Right-click / context menu |
| `mousedown` | Any button pressed |
| `mouseup` | Any button released |
| `mousemove` | Mouse moves over element |
| `mouseenter` | Mouse enters element (no bubble) |
| `mouseleave` | Mouse leaves element (no bubble) |
| `mouseover` | Mouse enters element (bubbles) |
| `mouseout` | Mouse leaves element (bubbles) |
| `wheel` | Scroll wheel rotated |

### Position Properties

| Property | Relative To |
|----------|-------------|
| `clientX/Y` | Viewport |
| `pageX/Y` | Document |
| `screenX/Y` | Screen |
| `offsetX/Y` | Target element |

### Best Practices

1. **Use `mouseenter/leave`** for simple hover effects
2. **Use `mouseover/out`** for event delegation
3. **Throttle `mousemove`** handlers for performance
4. **Attach move/up to document** for drag operations
5. **Check `e.button`** to handle specific buttons
6. **Use `{ passive: false }`** when calling preventDefault on wheel

---

**End of Chapter 3.4: Mouse Events**

Next chapter: **3.5 Keyboard Events** — covers keydown, keyup, key identification, shortcuts, and input handling.
# 3.5 Keyboard Events

Keyboard events enable you to respond to user typing, implement keyboard shortcuts, and create accessible interfaces. This chapter covers keyboard event types, key identification, modifier handling, and common patterns for keyboard interaction.

---

## 3.5.1 Keyboard Event Types

### keydown

```javascript
// Fires when any key is pressed
document.addEventListener('keydown', (e) => {
  console.log('Key pressed:', e.key);
});

// Fires repeatedly if key is held (auto-repeat)
document.addEventListener('keydown', (e) => {
  if (e.repeat) {
    console.log('Key held down, auto-repeating');
  }
});

// Most common for handling keyboard input
// Fires BEFORE the character is inserted
input.addEventListener('keydown', (e) => {
  if (e.key === 'Enter') {
    e.preventDefault();  // Can prevent default
    handleSubmit();
  }
});
```

### keyup

```javascript
// Fires when key is released
document.addEventListener('keyup', (e) => {
  console.log('Key released:', e.key);
});

// Does NOT fire repeatedly
// Only fires once when key is released

// Good for toggle states
const pressedKeys = new Set();

document.addEventListener('keydown', (e) => {
  pressedKeys.add(e.key);
});

document.addEventListener('keyup', (e) => {
  pressedKeys.delete(e.key);
});
```

### keypress (Deprecated)

```javascript
// ⚠️ DEPRECATED - do not use
// Only fired for printable characters
// Inconsistent behavior across browsers

element.addEventListener('keypress', (e) => {
  console.log('Character:', e.key);
});

// ✅ Use keydown instead
element.addEventListener('keydown', (e) => {
  if (e.key.length === 1) {
    console.log('Character:', e.key);
  }
});
```

### Event Order

```javascript
// For a single keystroke:
// 1. keydown
// 2. (beforeinput - if it's a text input)
// 3. (input - if it's a text input)
// 4. keyup

// For typing "a":
input.addEventListener('keydown', () => console.log('1. keydown'));
input.addEventListener('beforeinput', () => console.log('2. beforeinput'));
input.addEventListener('input', () => console.log('3. input'));
input.addEventListener('keyup', () => console.log('4. keyup'));
```

---

## 3.5.2 Key Identification

### e.key

```javascript
// Human-readable key value
document.addEventListener('keydown', (e) => {
  console.log(e.key);
  
  // Letters: "a", "A", "b", "B", etc.
  // Numbers: "1", "2", "3", etc.
  // Special: "Enter", "Tab", "Escape", "Backspace"
  // Arrow keys: "ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"
  // Function keys: "F1", "F2", etc.
  // Modifiers: "Shift", "Control", "Alt", "Meta"
});

// Case-sensitive for letters (reflects Shift state)
// Shift + a = "A"
// Just a = "a"
```

### e.code

```javascript
// Physical key location (layout-independent)
document.addEventListener('keydown', (e) => {
  console.log(e.code);
  
  // Letters: "KeyA", "KeyB", "KeyC", etc.
  // Numbers: "Digit1", "Digit2", etc.
  // Numpad: "Numpad0", "NumpadEnter", etc.
  // Special: "Enter", "Tab", "Escape", "Backspace"
  // Arrow keys: "ArrowUp", "ArrowDown", etc.
  // Function keys: "F1", "F2", etc.
  // Modifiers: "ShiftLeft", "ShiftRight", "ControlLeft", etc.
});

// Same code regardless of keyboard layout
// QWERTY "A" key = "KeyA" even on AZERTY keyboard
```

### key vs code

```javascript
// key: what character you get
// code: which physical key was pressed

document.addEventListener('keydown', (e) => {
  console.log(`key: ${e.key}, code: ${e.code}`);
});

// Examples:
// Pressing "A" on QWERTY: key="a", code="KeyA"
// Pressing Shift+"A" on QWERTY: key="A", code="KeyA"
// Pressing "1" above letters: key="1", code="Digit1"
// Pressing "1" on numpad: key="1", code="Numpad1"
// Pressing "Q" on AZERTY: key="a", code="KeyQ"

// Use key for: text input, characters
// Use code for: game controls, keyboard shortcuts (position-based)
```

### e.keyCode (Deprecated)

```javascript
// ⚠️ DEPRECATED - use key or code instead
document.addEventListener('keydown', (e) => {
  console.log(e.keyCode);  // Numeric code
  
  // Common codes:
  // Enter: 13
  // Escape: 27
  // Space: 32
  // Arrow Up: 38
  // Arrow Down: 40
  // A: 65, B: 66, etc.
});

// Still seen in older code
// Legacy support
if (e.keyCode === 13 || e.key === 'Enter') {
  handleEnter();
}
```

---

## 3.5.3 Modifier Keys

### Checking Modifiers

```javascript
document.addEventListener('keydown', (e) => {
  // Boolean properties for modifiers
  console.log('Shift:', e.shiftKey);
  console.log('Ctrl:', e.ctrlKey);
  console.log('Alt:', e.altKey);
  console.log('Meta:', e.metaKey);  // Cmd on Mac, Win key on Windows
  
  // Combinations
  if (e.ctrlKey && e.key === 's') {
    e.preventDefault();
    save();
  }
  
  if (e.ctrlKey && e.shiftKey && e.key === 'Z') {
    e.preventDefault();
    redo();
  }
});
```

### Platform-Aware Modifiers

```javascript
// Mac uses Cmd (metaKey), others use Ctrl
const isMac = navigator.platform.toUpperCase().includes('MAC');

function isPrimaryModifier(e) {
  return isMac ? e.metaKey : e.ctrlKey;
}

document.addEventListener('keydown', (e) => {
  if (isPrimaryModifier(e) && e.key === 's') {
    e.preventDefault();
    save();
  }
});

// Or check both
document.addEventListener('keydown', (e) => {
  if ((e.ctrlKey || e.metaKey) && e.key === 's') {
    e.preventDefault();
    save();
  }
});
```

### getModifierState()

```javascript
// Check if modifier is active
document.addEventListener('keydown', (e) => {
  console.log('CapsLock:', e.getModifierState('CapsLock'));
  console.log('NumLock:', e.getModifierState('NumLock'));
  console.log('ScrollLock:', e.getModifierState('ScrollLock'));
  
  // Also works for regular modifiers
  console.log('Shift:', e.getModifierState('Shift'));
});
```

---

## 3.5.4 Preventing Default Behavior

### Common Defaults to Prevent

```javascript
// Prevent form submission on Enter
input.addEventListener('keydown', (e) => {
  if (e.key === 'Enter') {
    e.preventDefault();
  }
});

// Prevent tab navigation
element.addEventListener('keydown', (e) => {
  if (e.key === 'Tab') {
    e.preventDefault();
    customTabBehavior();
  }
});

// Prevent browser shortcuts
document.addEventListener('keydown', (e) => {
  // Ctrl+S - browser save
  if (e.ctrlKey && e.key === 's') {
    e.preventDefault();
    customSave();
  }
  
  // Ctrl+P - browser print
  if (e.ctrlKey && e.key === 'p') {
    e.preventDefault();
    customPrint();
  }
  
  // F1 - browser help
  if (e.key === 'F1') {
    e.preventDefault();
    showHelp();
  }
});

// ⚠️ Some shortcuts can't be overridden
// Ctrl+W (close tab), Ctrl+N (new window), etc.
```

---

## 3.5.5 Common Patterns

### Keyboard Shortcuts

```javascript
// Simple shortcut handler
const shortcuts = {
  'ctrl+s': save,
  'ctrl+z': undo,
  'ctrl+shift+z': redo,
  'ctrl+c': copy,
  'ctrl+v': paste,
  'escape': closeModal,
  'f1': showHelp,
};

document.addEventListener('keydown', (e) => {
  const modifiers = [];
  if (e.ctrlKey || e.metaKey) modifiers.push('ctrl');
  if (e.shiftKey) modifiers.push('shift');
  if (e.altKey) modifiers.push('alt');
  
  const key = e.key.toLowerCase();
  const combo = [...modifiers, key].join('+');
  
  if (shortcuts[combo]) {
    e.preventDefault();
    shortcuts[combo]();
  }
});

// More robust shortcut system
class KeyboardShortcuts {
  constructor() {
    this.shortcuts = new Map();
    document.addEventListener('keydown', this.handleKeydown.bind(this));
  }
  
  register(combo, handler, options = {}) {
    this.shortcuts.set(combo.toLowerCase(), { handler, ...options });
    return () => this.shortcuts.delete(combo.toLowerCase());
  }
  
  handleKeydown(e) {
    const combo = this.getCombo(e);
    const shortcut = this.shortcuts.get(combo);
    
    if (shortcut) {
      // Skip if in input and not global
      if (!shortcut.global && this.isInInput(e)) {
        return;
      }
      
      e.preventDefault();
      shortcut.handler(e);
    }
  }
  
  getCombo(e) {
    const parts = [];
    if (e.ctrlKey || e.metaKey) parts.push('ctrl');
    if (e.shiftKey) parts.push('shift');
    if (e.altKey) parts.push('alt');
    parts.push(e.key.toLowerCase());
    return parts.join('+');
  }
  
  isInInput(e) {
    const tag = e.target.tagName;
    return tag === 'INPUT' || tag === 'TEXTAREA' || e.target.isContentEditable;
  }
}

const shortcuts = new KeyboardShortcuts();
shortcuts.register('ctrl+s', save, { global: true });
shortcuts.register('escape', closeModal);
```

### Arrow Key Navigation

```javascript
// Navigate list with arrow keys
const items = document.querySelectorAll('.list-item');
let currentIndex = 0;

document.addEventListener('keydown', (e) => {
  if (e.key === 'ArrowDown') {
    e.preventDefault();
    currentIndex = Math.min(currentIndex + 1, items.length - 1);
    items[currentIndex].focus();
  }
  
  if (e.key === 'ArrowUp') {
    e.preventDefault();
    currentIndex = Math.max(currentIndex - 1, 0);
    items[currentIndex].focus();
  }
  
  if (e.key === 'Enter' || e.key === ' ') {
    e.preventDefault();
    selectItem(items[currentIndex]);
  }
});
```

### Text Input Validation

```javascript
// Allow only numbers
input.addEventListener('keydown', (e) => {
  // Allow: backspace, delete, tab, escape, enter, arrows
  const allowed = ['Backspace', 'Delete', 'Tab', 'Escape', 'Enter', 
                   'ArrowLeft', 'ArrowRight', 'Home', 'End'];
  
  if (allowed.includes(e.key)) return;
  
  // Allow: Ctrl+A, Ctrl+C, Ctrl+V, Ctrl+X
  if (e.ctrlKey && ['a', 'c', 'v', 'x'].includes(e.key)) return;
  
  // Block non-numbers
  if (!/^\d$/.test(e.key)) {
    e.preventDefault();
  }
});

// ✅ Better: use input event for validation
input.addEventListener('input', (e) => {
  e.target.value = e.target.value.replace(/\D/g, '');
});
```

### Game Controls (Using code)

```javascript
// Use code for position-based controls
const keys = new Set();

document.addEventListener('keydown', (e) => {
  keys.add(e.code);
});

document.addEventListener('keyup', (e) => {
  keys.delete(e.code);
});

function gameLoop() {
  // WASD controls (works on any keyboard layout)
  if (keys.has('KeyW')) moveForward();
  if (keys.has('KeyA')) moveLeft();
  if (keys.has('KeyS')) moveBackward();
  if (keys.has('KeyD')) moveRight();
  if (keys.has('Space')) jump();
  if (keys.has('ShiftLeft')) run();
  
  requestAnimationFrame(gameLoop);
}
```

### Focus Trap

```javascript
// Keep focus within modal
function trapFocus(element) {
  const focusable = element.querySelectorAll(
    'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
  );
  const first = focusable[0];
  const last = focusable[focusable.length - 1];
  
  element.addEventListener('keydown', (e) => {
    if (e.key !== 'Tab') return;
    
    if (e.shiftKey) {
      // Shift+Tab: if on first, go to last
      if (document.activeElement === first) {
        e.preventDefault();
        last.focus();
      }
    } else {
      // Tab: if on last, go to first
      if (document.activeElement === last) {
        e.preventDefault();
        first.focus();
      }
    }
  });
}
```

---

## 3.5.6 Accessibility Considerations

```javascript
// Make custom elements keyboard accessible
customButton.addEventListener('keydown', (e) => {
  // Activate on Enter or Space (like native buttons)
  if (e.key === 'Enter' || e.key === ' ') {
    e.preventDefault();
    customButton.click();
  }
});

// Ensure element is focusable
customButton.setAttribute('tabindex', '0');
customButton.setAttribute('role', 'button');

// Handle Escape for modals
document.addEventListener('keydown', (e) => {
  if (e.key === 'Escape') {
    closeAnyOpenModal();
  }
});
```

---

## 3.5.7 Summary

### Keyboard Events

| Event | When | Repeats? | Use For |
|-------|------|----------|---------|
| `keydown` | Key pressed | Yes | Shortcuts, navigation |
| `keyup` | Key released | No | Toggle states |
| `keypress` | ⚠️ Deprecated | Yes | Don't use |

### Key Properties

| Property | Returns | Use For |
|----------|---------|---------|
| `key` | Character ("a", "Enter") | Text, shortcuts |
| `code` | Physical key ("KeyA", "Enter") | Games, layout-independent |
| `keyCode` | ⚠️ Deprecated number | Legacy support |

### Modifier Properties

| Property | Meaning |
|----------|---------|
| `shiftKey` | Shift is held |
| `ctrlKey` | Ctrl is held |
| `altKey` | Alt is held |
| `metaKey` | Cmd (Mac) / Win key |
| `repeat` | Key is auto-repeating |

### Best Practices

1. **Use `key` for most cases** — human-readable, handles layout
2. **Use `code` for games/position-based** — physical key location
3. **Handle both Ctrl and Meta** for cross-platform shortcuts
4. **Don't block standard shortcuts** unnecessarily
5. **Make custom elements keyboard accessible**
6. **Use `keydown` for shortcuts**, `keyup` for toggle states

---

**End of Chapter 3.5: Keyboard Events**

Next chapter: **3.6 Form Events** — covers submit, reset, input, change, focus, blur, and form validation events.
# 3.6 Form Events

Form events enable you to respond to user input, validate data, and control form submission. This chapter covers all form-related events, from input changes to submission handling.

---

## 3.6.1 Input Events

### input Event

```javascript
// Fires immediately on every change
const input = document.querySelector('input');

input.addEventListener('input', (e) => {
  console.log('Current value:', e.target.value);
});

// Works on:
// - <input> (text, number, email, etc.)
// - <textarea>
// - <select>
// - contenteditable elements

// Fires for:
// - Typing characters
// - Pasting text
// - Cutting text
// - Speech input
// - Autocomplete
// - Drag and drop text
```

### change Event

```javascript
// Fires when element loses focus AND value changed
// Or immediately for checkboxes/radios/selects

// Text input: fires on blur if value changed
textInput.addEventListener('change', (e) => {
  console.log('Final value:', e.target.value);
});

// Checkbox: fires immediately on change
checkbox.addEventListener('change', (e) => {
  console.log('Checked:', e.target.checked);
});

// Select: fires immediately on selection change
select.addEventListener('change', (e) => {
  console.log('Selected:', e.target.value);
});

// Radio: fires when selection changes
radio.addEventListener('change', (e) => {
  console.log('Selected option:', e.target.value);
});
```

### input vs change

```javascript
// input: real-time updates
// change: committed value

const input = document.querySelector('#search');
const preview = document.querySelector('#preview');
const status = document.querySelector('#status');

// Real-time preview
input.addEventListener('input', (e) => {
  preview.textContent = e.target.value;
});

// Save when done
input.addEventListener('change', (e) => {
  status.textContent = `Saved: "${e.target.value}"`;
  saveToServer(e.target.value);
});
```

### beforeinput Event

```javascript
// Fires before input is modified (can be canceled)
input.addEventListener('beforeinput', (e) => {
  console.log('Input type:', e.inputType);
  console.log('Data to insert:', e.data);
  
  // Prevent certain input
  if (e.inputType === 'insertFromPaste') {
    e.preventDefault();
    // Handle paste manually
    const cleaned = cleanPastedContent(e.data);
    document.execCommand('insertText', false, cleaned);
  }
});

// Common inputType values:
// insertText, insertFromPaste, insertFromDrop
// deleteContentBackward, deleteContentForward
// insertParagraph, insertLineBreak
```

---

## 3.6.2 Focus Events

### focus and blur

```javascript
// focus: element receives focus
input.addEventListener('focus', (e) => {
  e.target.parentElement.classList.add('focused');
});

// blur: element loses focus
input.addEventListener('blur', (e) => {
  e.target.parentElement.classList.remove('focused');
  validateField(e.target);
});

// ⚠️ focus and blur do NOT bubble
// Use focusin/focusout for event delegation
```

### focusin and focusout

```javascript
// These events bubble (unlike focus/blur)
form.addEventListener('focusin', (e) => {
  console.log('Focus moved to:', e.target.name);
  highlightField(e.target);
});

form.addEventListener('focusout', (e) => {
  console.log('Focus left:', e.target.name);
  validateField(e.target);
});

// Use for event delegation
document.addEventListener('focusin', (e) => {
  if (e.target.matches('.validate-on-focus')) {
    showFieldHelp(e.target);
  }
});
```

### relatedTarget

```javascript
// relatedTarget tells you where focus came from/goes to
input.addEventListener('focus', (e) => {
  console.log('Focus came from:', e.relatedTarget);
});

input.addEventListener('blur', (e) => {
  console.log('Focus going to:', e.relatedTarget);
  
  // Check if focus is leaving the form entirely
  if (!form.contains(e.relatedTarget)) {
    validateForm();
  }
});
```

### Controlling Focus

```javascript
// Set focus programmatically
input.focus();

// Remove focus
input.blur();

// Focus with scroll control
input.focus({ preventScroll: true });

// Check if element is focused
const isFocused = document.activeElement === input;

// Get currently focused element
console.log('Active element:', document.activeElement);
```

---

## 3.6.3 Form Submission

### submit Event

```javascript
// Fires when form is submitted
form.addEventListener('submit', (e) => {
  e.preventDefault();  // Prevent page reload
  
  const formData = new FormData(form);
  submitToServer(formData);
});

// Triggers for:
// - Clicking submit button
// - Pressing Enter in text input (if form has submit button)
// - form.submit() does NOT trigger this event!

// ⚠️ form.submit() bypasses submit event
form.submit();  // No event fired!

// ✅ Use requestSubmit() to trigger the event
form.requestSubmit();  // Event fires, validation runs
```

### Validation on Submit

```javascript
form.addEventListener('submit', (e) => {
  const isValid = validateAllFields();
  
  if (!isValid) {
    e.preventDefault();
    showErrors();
    return;
  }
  
  // Continue with submission
  handleSubmit(new FormData(form));
});

// Using built-in validation
form.addEventListener('submit', (e) => {
  if (!form.checkValidity()) {
    e.preventDefault();
    form.reportValidity();  // Show validation messages
    return;
  }
  
  handleSubmit(new FormData(form));
});
```

### reset Event

```javascript
// Fires when form is reset
form.addEventListener('reset', (e) => {
  // Optionally prevent
  if (!confirm('Clear all fields?')) {
    e.preventDefault();
    return;
  }
  
  // Clean up any custom state
  clearErrors();
  resetCustomFields();
});

// Triggers for:
// - Clicking reset button
// - form.reset() method
```

### formdata Event

```javascript
// Fires when FormData is constructed from a form
form.addEventListener('formdata', (e) => {
  // Modify FormData before it's used
  e.formData.append('timestamp', Date.now());
  e.formData.append('source', 'web');
  
  // Remove sensitive data
  e.formData.delete('debug-field');
});

// Useful for adding computed fields
form.addEventListener('submit', (e) => {
  e.preventDefault();
  const formData = new FormData(form);  // formdata event fires here
  sendData(formData);
});
```

---

## 3.6.4 Selection Events

### select Event

```javascript
// Fires when text is selected in input/textarea
input.addEventListener('select', (e) => {
  const selected = e.target.value.substring(
    e.target.selectionStart,
    e.target.selectionEnd
  );
  console.log('Selected:', selected);
});

// Selection properties
console.log('Start:', input.selectionStart);
console.log('End:', input.selectionEnd);
console.log('Direction:', input.selectionDirection);

// Set selection programmatically
input.setSelectionRange(0, 5);  // Select first 5 characters
input.select();  // Select all
```

---

## 3.6.5 Form Validation Events

### invalid Event

```javascript
// Fires when validation fails on submit
input.addEventListener('invalid', (e) => {
  e.preventDefault();  // Prevent default error UI
  showCustomError(e.target, e.target.validationMessage);
});

// Customize validation message
input.addEventListener('invalid', (e) => {
  if (e.target.validity.valueMissing) {
    e.target.setCustomValidity('Please fill in this field');
  } else if (e.target.validity.typeMismatch) {
    e.target.setCustomValidity('Please enter a valid email');
  }
});

// Clear custom message on input
input.addEventListener('input', (e) => {
  e.target.setCustomValidity('');
});
```

### Validation API

```javascript
// Check validity
console.log(input.checkValidity());    // Returns boolean
console.log(form.checkValidity());     // Checks all fields

// Show validation UI
input.reportValidity();
form.reportValidity();

// Validity state object
const validity = input.validity;
console.log({
  valid: validity.valid,
  valueMissing: validity.valueMissing,      // required
  typeMismatch: validity.typeMismatch,      // type="email" etc.
  patternMismatch: validity.patternMismatch, // pattern attr
  tooShort: validity.tooShort,              // minlength
  tooLong: validity.tooLong,                // maxlength
  rangeUnderflow: validity.rangeUnderflow,  // min
  rangeOverflow: validity.rangeOverflow,    // max
  stepMismatch: validity.stepMismatch,      // step
  badInput: validity.badInput,              // unparseable input
  customError: validity.customError         // setCustomValidity
});
```

---

## 3.6.6 Common Patterns

### Real-Time Validation

```javascript
// Validate as user types
input.addEventListener('input', (e) => {
  const value = e.target.value;
  const isValid = validateValue(value);
  
  e.target.classList.toggle('valid', isValid);
  e.target.classList.toggle('invalid', !isValid);
  
  // Update error message
  const error = e.target.nextElementSibling;
  error.textContent = isValid ? '' : getErrorMessage(value);
});

// Debounced validation (for expensive checks)
let timeout;
input.addEventListener('input', (e) => {
  clearTimeout(timeout);
  timeout = setTimeout(() => {
    checkUsernameAvailable(e.target.value);
  }, 300);
});
```

### Character Counter

```javascript
const textarea = document.querySelector('textarea');
const counter = document.querySelector('.counter');
const maxLength = 280;

textarea.addEventListener('input', (e) => {
  const remaining = maxLength - e.target.value.length;
  counter.textContent = remaining;
  counter.classList.toggle('warning', remaining < 20);
  counter.classList.toggle('error', remaining < 0);
});
```

### Auto-Save

```javascript
let saveTimeout;

form.addEventListener('input', (e) => {
  // Debounce saves
  clearTimeout(saveTimeout);
  
  saveTimeout = setTimeout(() => {
    const formData = new FormData(form);
    localStorage.setItem('draft', JSON.stringify(Object.fromEntries(formData)));
    showSaveIndicator();
  }, 1000);
});

// Restore on load
window.addEventListener('load', () => {
  const draft = localStorage.getItem('draft');
  if (draft) {
    const data = JSON.parse(draft);
    Object.entries(data).forEach(([name, value]) => {
      const field = form.elements[name];
      if (field) field.value = value;
    });
  }
});
```

### Multi-Step Form

```javascript
class MultiStepForm {
  constructor(form) {
    this.form = form;
    this.steps = form.querySelectorAll('.step');
    this.currentStep = 0;
    
    form.addEventListener('submit', (e) => this.handleSubmit(e));
  }
  
  showStep(index) {
    this.steps.forEach((step, i) => {
      step.classList.toggle('active', i === index);
    });
    this.currentStep = index;
  }
  
  nextStep() {
    const currentFields = this.steps[this.currentStep].querySelectorAll('input');
    const allValid = [...currentFields].every(f => f.checkValidity());
    
    if (!allValid) {
      currentFields.forEach(f => f.reportValidity());
      return;
    }
    
    if (this.currentStep < this.steps.length - 1) {
      this.showStep(this.currentStep + 1);
    }
  }
  
  prevStep() {
    if (this.currentStep > 0) {
      this.showStep(this.currentStep - 1);
    }
  }
  
  handleSubmit(e) {
    e.preventDefault();
    if (this.currentStep < this.steps.length - 1) {
      this.nextStep();
    } else {
      this.submit();
    }
  }
  
  submit() {
    const formData = new FormData(this.form);
    // Submit logic
  }
}
```

---

## 3.6.7 Gotchas

```javascript
// ❌ form.submit() doesn't trigger submit event
form.submit();

// ✅ Use requestSubmit() to trigger event
form.requestSubmit();

// ❌ Relying on keypress for Enter detection
input.addEventListener('keypress', (e) => {
  if (e.key === 'Enter') submitForm();  // Deprecated event
});

// ✅ Use keydown or form submit event
form.addEventListener('submit', (e) => {
  e.preventDefault();
  submitForm();
});

// ❌ Not clearing custom validity
input.setCustomValidity('Invalid!');
// Field stays invalid even after correction

// ✅ Clear on input
input.addEventListener('input', () => {
  input.setCustomValidity('');
});

// ❌ focus/blur don't bubble
container.addEventListener('focus', handleFocus);  // Won't work

// ✅ Use focusin/focusout for delegation
container.addEventListener('focusin', handleFocus);
```

---

## 3.6.8 Summary

### Form Events

| Event | When | Bubbles |
|-------|------|---------|
| `input` | Value changes (real-time) | Yes |
| `change` | Value committed (blur or select) | Yes |
| `beforeinput` | Before value changes | Yes |
| `submit` | Form submitted | Yes |
| `reset` | Form reset | Yes |
| `formdata` | FormData constructed | Yes |

### Focus Events

| Event | When | Bubbles |
|-------|------|---------|
| `focus` | Element receives focus | No |
| `blur` | Element loses focus | No |
| `focusin` | Element receives focus | Yes |
| `focusout` | Element loses focus | Yes |

### Validation Events

| Event | When | Use For |
|-------|------|---------|
| `invalid` | Validation fails | Custom error UI |

### Best Practices

1. **Use `input` for real-time feedback**, `change` for commits
2. **Use `focusin`/`focusout` for delegation** (they bubble)
3. **Use `requestSubmit()` instead of `submit()`** to trigger validation
4. **Clear `setCustomValidity('')` on input** to reset validation
5. **Debounce expensive operations** (server validation, auto-save)

---

**End of Chapter 3.6: Form Events**

Next chapter: **3.7 Touch Events** — covers touchstart, touchmove, touchend, touch lists, and gesture handling.
# 3.7 Touch Events

Touch events enable you to respond to finger interactions on touch-enabled devices. This chapter covers touch event types, handling multi-touch, touch lists, and common gesture patterns.

---

## 3.7.1 Touch Event Types

### touchstart

```javascript
// Fires when finger touches the screen
element.addEventListener('touchstart', (e) => {
  console.log('Touch started');
  console.log('Touches:', e.touches.length);
});

// Similar to mousedown
// Fires before any mouse emulation events
```

### touchmove

```javascript
// Fires when finger moves on screen
element.addEventListener('touchmove', (e) => {
  const touch = e.touches[0];
  console.log('Position:', touch.clientX, touch.clientY);
});

// ⚠️ Can cause scroll/zoom if not prevented
element.addEventListener('touchmove', (e) => {
  e.preventDefault();  // Prevent scrolling
  handleDrag(e);
}, { passive: false });  // Must be non-passive to prevent
```

### touchend

```javascript
// Fires when finger leaves the screen
element.addEventListener('touchend', (e) => {
  console.log('Touch ended');
  // ⚠️ e.touches is empty at this point
  // Use e.changedTouches for the ending touch
  console.log('Changed touches:', e.changedTouches.length);
});
```

### touchcancel

```javascript
// Fires when touch is interrupted
element.addEventListener('touchcancel', (e) => {
  console.log('Touch cancelled');
  // System took over: alert, phone call, notification
  // Tab switched, element moved, etc.
  
  resetGestureState();
});

// Always handle touchcancel for proper cleanup
```

---

## 3.7.2 Touch Lists

### TouchList Properties

```javascript
element.addEventListener('touchstart', (e) => {
  // e.touches: all current touches on screen
  // e.targetTouches: touches on this element
  // e.changedTouches: touches that changed in this event
  
  console.log('All touches:', e.touches.length);
  console.log('On this element:', e.targetTouches.length);
  console.log('Changed:', e.changedTouches.length);
});

// Access individual touches
element.addEventListener('touchmove', (e) => {
  const touch = e.touches[0];  // First touch
  const touch2 = e.touches[1]; // Second touch (if any)
  
  // Or iterate
  for (const touch of e.touches) {
    console.log(touch.identifier, touch.clientX, touch.clientY);
  }
});
```

### Touch Object Properties

```javascript
element.addEventListener('touchstart', (e) => {
  const touch = e.touches[0];
  
  // Unique identifier for this touch
  console.log('ID:', touch.identifier);
  
  // Position relative to viewport
  console.log('Client:', touch.clientX, touch.clientY);
  
  // Position relative to page
  console.log('Page:', touch.pageX, touch.pageY);
  
  // Position relative to screen
  console.log('Screen:', touch.screenX, touch.screenY);
  
  // Element that touch started on
  console.log('Target:', touch.target);
  
  // Touch dimensions (if supported)
  console.log('Radius:', touch.radiusX, touch.radiusY);
  console.log('Rotation:', touch.rotationAngle);
  console.log('Force:', touch.force);  // 0-1
});
```

### Tracking Individual Touches

```javascript
const activeTouches = new Map();

element.addEventListener('touchstart', (e) => {
  for (const touch of e.changedTouches) {
    activeTouches.set(touch.identifier, {
      startX: touch.clientX,
      startY: touch.clientY,
      currentX: touch.clientX,
      currentY: touch.clientY
    });
  }
});

element.addEventListener('touchmove', (e) => {
  for (const touch of e.changedTouches) {
    const data = activeTouches.get(touch.identifier);
    if (data) {
      data.currentX = touch.clientX;
      data.currentY = touch.clientY;
    }
  }
});

element.addEventListener('touchend', (e) => {
  for (const touch of e.changedTouches) {
    const data = activeTouches.get(touch.identifier);
    if (data) {
      const deltaX = data.currentX - data.startX;
      const deltaY = data.currentY - data.startY;
      console.log(`Touch ${touch.identifier} moved: ${deltaX}, ${deltaY}`);
      activeTouches.delete(touch.identifier);
    }
  }
});
```

---

## 3.7.3 Passive Event Listeners

```javascript
// By default, browsers wait to see if you'll call preventDefault()
// This can delay scrolling

// ⚠️ Non-passive (can cause scroll delay)
element.addEventListener('touchmove', handler);

// ✅ Passive: promises not to prevent default
element.addEventListener('touchmove', handler, { passive: true });

// If you NEED to prevent default:
element.addEventListener('touchmove', (e) => {
  e.preventDefault();  // This will throw error if passive
  handleDrag(e);
}, { passive: false });  // Explicit non-passive

// Modern browsers default touchstart/touchmove on document to passive
// Be explicit when needed
```

---

## 3.7.4 Common Gesture Patterns

### Tap Detection

```javascript
class TapDetector {
  constructor(element) {
    this.element = element;
    this.startTime = 0;
    this.startX = 0;
    this.startY = 0;
    
    element.addEventListener('touchstart', this.onStart.bind(this));
    element.addEventListener('touchend', this.onEnd.bind(this));
  }
  
  onStart(e) {
    if (e.touches.length !== 1) return;
    
    this.startTime = Date.now();
    this.startX = e.touches[0].clientX;
    this.startY = e.touches[0].clientY;
  }
  
  onEnd(e) {
    const touch = e.changedTouches[0];
    const elapsed = Date.now() - this.startTime;
    const deltaX = Math.abs(touch.clientX - this.startX);
    const deltaY = Math.abs(touch.clientY - this.startY);
    
    // Tap: short duration, minimal movement
    if (elapsed < 300 && deltaX < 10 && deltaY < 10) {
      this.element.dispatchEvent(new CustomEvent('tap', {
        detail: { x: touch.clientX, y: touch.clientY }
      }));
    }
  }
}
```

### Long Press

```javascript
class LongPress {
  constructor(element, duration = 500) {
    this.element = element;
    this.duration = duration;
    this.timer = null;
    
    element.addEventListener('touchstart', this.onStart.bind(this));
    element.addEventListener('touchend', this.onEnd.bind(this));
    element.addEventListener('touchmove', this.onMove.bind(this));
    element.addEventListener('touchcancel', this.onEnd.bind(this));
  }
  
  onStart(e) {
    if (e.touches.length !== 1) return;
    
    const touch = e.touches[0];
    this.startX = touch.clientX;
    this.startY = touch.clientY;
    
    this.timer = setTimeout(() => {
      this.element.dispatchEvent(new CustomEvent('longpress', {
        detail: { x: this.startX, y: this.startY }
      }));
    }, this.duration);
  }
  
  onMove(e) {
    const touch = e.touches[0];
    const deltaX = Math.abs(touch.clientX - this.startX);
    const deltaY = Math.abs(touch.clientY - this.startY);
    
    // Cancel if moved too much
    if (deltaX > 10 || deltaY > 10) {
      clearTimeout(this.timer);
    }
  }
  
  onEnd() {
    clearTimeout(this.timer);
  }
}
```

### Swipe Detection

```javascript
class SwipeDetector {
  constructor(element, options = {}) {
    this.element = element;
    this.threshold = options.threshold || 50;
    this.restraint = options.restraint || 100;
    this.maxTime = options.maxTime || 300;
    
    element.addEventListener('touchstart', this.onStart.bind(this));
    element.addEventListener('touchend', this.onEnd.bind(this));
  }
  
  onStart(e) {
    const touch = e.touches[0];
    this.startX = touch.clientX;
    this.startY = touch.clientY;
    this.startTime = Date.now();
  }
  
  onEnd(e) {
    const touch = e.changedTouches[0];
    const deltaX = touch.clientX - this.startX;
    const deltaY = touch.clientY - this.startY;
    const elapsed = Date.now() - this.startTime;
    
    if (elapsed > this.maxTime) return;
    
    let direction = null;
    
    if (Math.abs(deltaX) > this.threshold && Math.abs(deltaY) < this.restraint) {
      direction = deltaX > 0 ? 'right' : 'left';
    } else if (Math.abs(deltaY) > this.threshold && Math.abs(deltaX) < this.restraint) {
      direction = deltaY > 0 ? 'down' : 'up';
    }
    
    if (direction) {
      this.element.dispatchEvent(new CustomEvent('swipe', {
        detail: { direction, deltaX, deltaY }
      }));
    }
  }
}

// Usage
const swipe = new SwipeDetector(element);
element.addEventListener('swipe', (e) => {
  console.log('Swiped:', e.detail.direction);
});
```

### Pinch Zoom

```javascript
class PinchZoom {
  constructor(element) {
    this.element = element;
    this.initialDistance = 0;
    this.currentScale = 1;
    
    element.addEventListener('touchstart', this.onStart.bind(this));
    element.addEventListener('touchmove', this.onMove.bind(this));
    element.addEventListener('touchend', this.onEnd.bind(this));
  }
  
  getDistance(touches) {
    const dx = touches[0].clientX - touches[1].clientX;
    const dy = touches[0].clientY - touches[1].clientY;
    return Math.sqrt(dx * dx + dy * dy);
  }
  
  getCenter(touches) {
    return {
      x: (touches[0].clientX + touches[1].clientX) / 2,
      y: (touches[0].clientY + touches[1].clientY) / 2
    };
  }
  
  onStart(e) {
    if (e.touches.length === 2) {
      this.initialDistance = this.getDistance(e.touches);
      this.initialScale = this.currentScale;
    }
  }
  
  onMove(e) {
    if (e.touches.length === 2) {
      e.preventDefault();
      
      const distance = this.getDistance(e.touches);
      const scale = (distance / this.initialDistance) * this.initialScale;
      const center = this.getCenter(e.touches);
      
      this.currentScale = Math.min(Math.max(scale, 0.5), 3);
      
      this.element.dispatchEvent(new CustomEvent('pinch', {
        detail: {
          scale: this.currentScale,
          center
        }
      }));
    }
  }
  
  onEnd(e) {
    if (e.touches.length < 2) {
      this.initialDistance = 0;
    }
  }
}
```

### Drag and Pan

```javascript
class TouchDrag {
  constructor(element) {
    this.element = element;
    this.isDragging = false;
    this.startX = 0;
    this.startY = 0;
    this.offsetX = 0;
    this.offsetY = 0;
    
    element.addEventListener('touchstart', this.onStart.bind(this), { passive: false });
    element.addEventListener('touchmove', this.onMove.bind(this), { passive: false });
    element.addEventListener('touchend', this.onEnd.bind(this));
    element.addEventListener('touchcancel', this.onEnd.bind(this));
  }
  
  onStart(e) {
    if (e.touches.length !== 1) return;
    
    e.preventDefault();
    this.isDragging = true;
    
    const touch = e.touches[0];
    this.startX = touch.clientX - this.offsetX;
    this.startY = touch.clientY - this.offsetY;
    
    this.element.classList.add('dragging');
  }
  
  onMove(e) {
    if (!this.isDragging) return;
    
    e.preventDefault();
    const touch = e.touches[0];
    
    this.offsetX = touch.clientX - this.startX;
    this.offsetY = touch.clientY - this.startY;
    
    this.element.style.transform = `translate(${this.offsetX}px, ${this.offsetY}px)`;
  }
  
  onEnd() {
    this.isDragging = false;
    this.element.classList.remove('dragging');
  }
}
```

---

## 3.7.5 Touch and Mouse Compatibility

### Unified Event Handling

```javascript
// Handle both touch and mouse
function addUnifiedListeners(element, handlers) {
  element.addEventListener('touchstart', (e) => {
    e.preventDefault();  // Prevent mouse emulation
    handlers.start?.(e.touches[0]);
  }, { passive: false });
  
  element.addEventListener('touchmove', (e) => {
    handlers.move?.(e.touches[0]);
  }, { passive: false });
  
  element.addEventListener('touchend', (e) => {
    handlers.end?.(e.changedTouches[0]);
  });
  
  element.addEventListener('mousedown', (e) => {
    handlers.start?.(e);
  });
  
  element.addEventListener('mousemove', (e) => {
    if (e.buttons === 1) {
      handlers.move?.(e);
    }
  });
  
  element.addEventListener('mouseup', (e) => {
    handlers.end?.(e);
  });
}

// ✅ Better: use Pointer Events (see chapter 3.8)
```

### Detecting Touch Support

```javascript
// Check for touch support
const hasTouch = 'ontouchstart' in window || 
                 navigator.maxTouchPoints > 0;

// But devices can have both touch AND mouse
// Better to respond to actual events
element.addEventListener('touchstart', handleTouch);
element.addEventListener('mousedown', handleMouse);
```

### 300ms Click Delay

```javascript
// Older mobile browsers had 300ms delay for double-tap zoom

// Solutions:
// 1. Use touch-action CSS
// touch-action: manipulation;  /* Disable double-tap zoom */

// 2. Use viewport meta tag
// <meta name="viewport" content="width=device-width">

// 3. Modern browsers have eliminated the delay
// when viewport is properly configured
```

---

## 3.7.6 Gotchas

```javascript
// ❌ e.touches is empty in touchend
element.addEventListener('touchend', (e) => {
  const touch = e.touches[0];  // undefined!
});

// ✅ Use changedTouches for ending touches
element.addEventListener('touchend', (e) => {
  const touch = e.changedTouches[0];
});

// ❌ Forgetting touchcancel
element.addEventListener('touchstart', startDrag);
element.addEventListener('touchend', endDrag);
// Touch can be cancelled without touchend!

// ✅ Always handle touchcancel
element.addEventListener('touchcancel', endDrag);

// ❌ Not using passive: false when preventing default
element.addEventListener('touchmove', (e) => {
  e.preventDefault();  // Error in passive listener!
});

// ✅ Explicit passive: false
element.addEventListener('touchmove', (e) => {
  e.preventDefault();
}, { passive: false });

// ❌ Mixing touch and mouse without preventing double events
// Touch devices fire: touchstart → touchend → mousedown → click

// ✅ Prevent mouse emulation
element.addEventListener('touchstart', (e) => {
  e.preventDefault();
  handleInteraction(e.touches[0]);
});
```

---

## 3.7.7 Summary

### Touch Events

| Event | When | TouchLists Available |
|-------|------|---------------------|
| `touchstart` | Finger touches screen | touches, targetTouches, changedTouches |
| `touchmove` | Finger moves | touches, targetTouches, changedTouches |
| `touchend` | Finger leaves screen | targetTouches, changedTouches (no touches) |
| `touchcancel` | Touch interrupted | changedTouches |

### TouchList Types

| Property | Contains |
|----------|----------|
| `touches` | All current touches on screen |
| `targetTouches` | Touches on this element |
| `changedTouches` | Touches changed in this event |

### Touch Object Properties

| Property | Description |
|----------|-------------|
| `identifier` | Unique ID for tracking |
| `clientX/Y` | Position relative to viewport |
| `pageX/Y` | Position relative to page |
| `target` | Element touch started on |
| `force` | Pressure (0-1) |

### Best Practices

1. **Always handle `touchcancel`** for cleanup
2. **Use `changedTouches` in `touchend`** (touches is empty)
3. **Use `{ passive: false }` when preventing default**
4. **Consider Pointer Events** for unified touch/mouse handling
5. **Track touches by identifier** for multi-touch

---

**End of Chapter 3.7: Touch Events**

Next chapter: **3.8 Pointer Events** — covers unified mouse, touch, and pen input with the modern Pointer Events API.
# 3.8 Pointer Events

Pointer Events provide a unified API for handling mouse, touch, and pen input. This chapter covers the Pointer Events model, pointer types, capture, and migrating from separate touch/mouse handling.

---

## 3.8.1 Why Pointer Events?

```javascript
// ❌ Old approach: separate handlers for each input type
element.addEventListener('mousedown', handleStart);
element.addEventListener('mousemove', handleMove);
element.addEventListener('mouseup', handleEnd);
element.addEventListener('touchstart', handleStart);
element.addEventListener('touchmove', handleMove);
element.addEventListener('touchend', handleEnd);

// ✅ Pointer Events: one API for all input types
element.addEventListener('pointerdown', handleStart);
element.addEventListener('pointermove', handleMove);
element.addEventListener('pointerup', handleEnd);

// Benefits:
// - Single code path for mouse, touch, and pen
// - Consistent event properties
// - Built-in pointer capture
// - Better pressure/tilt support
```

---

## 3.8.2 Pointer Event Types

### Basic Events

```javascript
// pointerdown: input begins (finger, mouse button, pen)
element.addEventListener('pointerdown', (e) => {
  console.log('Pointer down:', e.pointerId, e.pointerType);
});

// pointermove: pointer moves
element.addEventListener('pointermove', (e) => {
  console.log('Position:', e.clientX, e.clientY);
});

// pointerup: input ends
element.addEventListener('pointerup', (e) => {
  console.log('Pointer up:', e.pointerId);
});

// pointercancel: pointer cancelled (similar to touchcancel)
element.addEventListener('pointercancel', (e) => {
  console.log('Pointer cancelled');
  cleanup();
});
```

### Enter/Leave Events

```javascript
// pointerenter: pointer enters element (doesn't bubble)
element.addEventListener('pointerenter', (e) => {
  element.classList.add('hover');
});

// pointerleave: pointer leaves element (doesn't bubble)
element.addEventListener('pointerleave', (e) => {
  element.classList.remove('hover');
});

// pointerover: pointer over element (bubbles)
element.addEventListener('pointerover', (e) => {
  console.log('Over:', e.target);
});

// pointerout: pointer out of element (bubbles)
element.addEventListener('pointerout', (e) => {
  console.log('Out:', e.target);
});
```

### gotpointercapture / lostpointercapture

```javascript
// Fires when pointer capture is acquired
element.addEventListener('gotpointercapture', (e) => {
  console.log('Captured pointer:', e.pointerId);
});

// Fires when pointer capture is released
element.addEventListener('lostpointercapture', (e) => {
  console.log('Released pointer:', e.pointerId);
});
```

---

## 3.8.3 Pointer Event Properties

### Basic Properties

```javascript
element.addEventListener('pointerdown', (e) => {
  // Unique identifier for this pointer
  console.log('ID:', e.pointerId);
  
  // Type: "mouse", "touch", or "pen"
  console.log('Type:', e.pointerType);
  
  // Is this the primary pointer?
  console.log('Primary:', e.isPrimary);
  
  // Position (inherited from MouseEvent)
  console.log('Client:', e.clientX, e.clientY);
  console.log('Page:', e.pageX, e.pageY);
  console.log('Screen:', e.screenX, e.screenY);
  
  // Button info (inherited from MouseEvent)
  console.log('Button:', e.button);
  console.log('Buttons:', e.buttons);
});
```

### Pressure and Geometry

```javascript
element.addEventListener('pointermove', (e) => {
  // Pressure (0-1, 0.5 for mouse without pressure)
  console.log('Pressure:', e.pressure);
  
  // Tangential pressure (like airbrush wheel)
  console.log('Tangential:', e.tangentialPressure);
  
  // Contact dimensions
  console.log('Width:', e.width);   // Contact width
  console.log('Height:', e.height); // Contact height
  
  // Pen tilt angles (-90 to 90 degrees)
  console.log('Tilt X:', e.tiltX);
  console.log('Tilt Y:', e.tiltY);
  
  // Pen rotation (0-359 degrees)
  console.log('Twist:', e.twist);
});
```

### Predicted and Coalesced Events

```javascript
// High-frequency moves are coalesced for performance
// getCoalescedEvents() retrieves all intermediate positions

element.addEventListener('pointermove', (e) => {
  // All moves since last event (for smooth drawing)
  const coalesced = e.getCoalescedEvents();
  
  for (const event of coalesced) {
    drawLine(event.clientX, event.clientY);
  }
});

// Predicted future positions (for reduced latency)
element.addEventListener('pointermove', (e) => {
  const predicted = e.getPredictedEvents();
  
  // Draw predicted position with transparency
  for (const event of predicted) {
    drawGhost(event.clientX, event.clientY);
  }
});
```

---

## 3.8.4 Pointer Capture

### What Is Pointer Capture?

```javascript
// Pointer capture redirects all events for a pointer to one element
// Even when pointer moves outside that element

// Without capture: events go to element under pointer
// With capture: events always go to capturing element

// Essential for drag operations
element.addEventListener('pointerdown', (e) => {
  element.setPointerCapture(e.pointerId);
  // Now all pointer events go to this element until release
});
```

### Using Pointer Capture

```javascript
class Draggable {
  constructor(element) {
    this.element = element;
    this.isDragging = false;
    
    element.addEventListener('pointerdown', this.onDown.bind(this));
    element.addEventListener('pointermove', this.onMove.bind(this));
    element.addEventListener('pointerup', this.onUp.bind(this));
    element.addEventListener('pointercancel', this.onUp.bind(this));
  }
  
  onDown(e) {
    this.isDragging = true;
    
    // Capture this pointer
    this.element.setPointerCapture(e.pointerId);
    
    this.startX = e.clientX;
    this.startY = e.clientY;
    
    // Prevent text selection
    e.preventDefault();
  }
  
  onMove(e) {
    if (!this.isDragging) return;
    
    // Events continue even outside element (due to capture)
    const dx = e.clientX - this.startX;
    const dy = e.clientY - this.startY;
    
    this.element.style.transform = `translate(${dx}px, ${dy}px)`;
  }
  
  onUp(e) {
    if (!this.isDragging) return;
    
    this.isDragging = false;
    
    // Release capture (usually automatic on pointerup)
    this.element.releasePointerCapture(e.pointerId);
  }
}
```

### Checking Capture Status

```javascript
// Check if element has capture for a pointer
const hasCapture = element.hasPointerCapture(pointerId);

// Get capture events
element.addEventListener('gotpointercapture', (e) => {
  console.log('Got capture for:', e.pointerId);
});

element.addEventListener('lostpointercapture', (e) => {
  console.log('Lost capture for:', e.pointerId);
  // Cleanup drag state
});
```

---

## 3.8.5 Touch Action CSS

```css
/* Control how browser handles touch input */

/* Disable all browser handling (full control in JS) */
.custom-control {
  touch-action: none;
}

/* Allow only horizontal panning */
.horizontal-slider {
  touch-action: pan-x;
}

/* Allow only vertical scrolling */
.vertical-list {
  touch-action: pan-y;
}

/* Allow panning but disable zoom */
.map {
  touch-action: pan-x pan-y;
}

/* Allow panning and pinch-zoom (default) */
.normal {
  touch-action: manipulation;
}

/* Default behavior */
.default {
  touch-action: auto;
}
```

```javascript
// touch-action determines which gestures the browser handles
// vs which ones fire pointer events to your code

// touch-action: none → all input goes to your code
// touch-action: auto → browser handles scrolling/zooming first

// Set via JavaScript
element.style.touchAction = 'none';
```

---

## 3.8.6 Common Patterns

### Drawing Application

```javascript
class DrawingCanvas {
  constructor(canvas) {
    this.canvas = canvas;
    this.ctx = canvas.getContext('2d');
    this.isDrawing = false;
    
    // Disable browser touch handling
    canvas.style.touchAction = 'none';
    
    canvas.addEventListener('pointerdown', this.startStroke.bind(this));
    canvas.addEventListener('pointermove', this.draw.bind(this));
    canvas.addEventListener('pointerup', this.endStroke.bind(this));
    canvas.addEventListener('pointerleave', this.endStroke.bind(this));
  }
  
  startStroke(e) {
    this.isDrawing = true;
    this.canvas.setPointerCapture(e.pointerId);
    
    this.ctx.beginPath();
    this.ctx.moveTo(e.offsetX, e.offsetY);
    
    // Set line width based on pressure
    this.ctx.lineWidth = e.pressure * 10 || 2;
  }
  
  draw(e) {
    if (!this.isDrawing) return;
    
    // Use coalesced events for smooth lines
    const events = e.getCoalescedEvents();
    
    for (const point of events) {
      this.ctx.lineTo(point.offsetX, point.offsetY);
      // Vary width with pressure
      this.ctx.lineWidth = point.pressure * 10 || 2;
    }
    
    this.ctx.stroke();
  }
  
  endStroke(e) {
    if (this.isDrawing) {
      this.isDrawing = false;
      this.ctx.closePath();
    }
  }
}
```

### Multi-Touch Support

```javascript
class MultiTouchHandler {
  constructor(element) {
    this.element = element;
    this.activePointers = new Map();
    
    element.style.touchAction = 'none';
    
    element.addEventListener('pointerdown', this.onDown.bind(this));
    element.addEventListener('pointermove', this.onMove.bind(this));
    element.addEventListener('pointerup', this.onUp.bind(this));
    element.addEventListener('pointercancel', this.onUp.bind(this));
  }
  
  onDown(e) {
    this.activePointers.set(e.pointerId, {
      x: e.clientX,
      y: e.clientY,
      type: e.pointerType
    });
    
    element.setPointerCapture(e.pointerId);
    
    console.log('Active pointers:', this.activePointers.size);
    
    if (this.activePointers.size === 2) {
      this.startPinch();
    }
  }
  
  onMove(e) {
    const pointer = this.activePointers.get(e.pointerId);
    if (!pointer) return;
    
    pointer.x = e.clientX;
    pointer.y = e.clientY;
    
    if (this.activePointers.size === 2) {
      this.handlePinch();
    } else if (this.activePointers.size === 1) {
      this.handleDrag();
    }
  }
  
  onUp(e) {
    this.activePointers.delete(e.pointerId);
    
    if (this.activePointers.size < 2) {
      this.endPinch();
    }
  }
  
  startPinch() {
    const [p1, p2] = [...this.activePointers.values()];
    this.initialDistance = Math.hypot(p2.x - p1.x, p2.y - p1.y);
  }
  
  handlePinch() {
    const [p1, p2] = [...this.activePointers.values()];
    const distance = Math.hypot(p2.x - p1.x, p2.y - p1.y);
    const scale = distance / this.initialDistance;
    
    console.log('Pinch scale:', scale);
  }
  
  handleDrag() { /* ... */ }
  endPinch() { /* ... */ }
}
```

### Hover Preview (Pen/Mouse Only)

```javascript
// Show preview for hover-capable devices
element.addEventListener('pointerenter', (e) => {
  // Only mouse and pen support hover
  if (e.pointerType === 'mouse' || e.pointerType === 'pen') {
    showPreview();
  }
});

element.addEventListener('pointerleave', (e) => {
  if (e.pointerType !== 'touch') {
    hidePreview();
  }
});
```

---

## 3.8.7 Migration from Touch/Mouse Events

```javascript
// From touch events:
// touchstart → pointerdown
// touchmove → pointermove
// touchend → pointerup
// touchcancel → pointercancel
// e.touches[0] → e (single property access)
// e.changedTouches[0] → e (single property access)

// From mouse events:
// mousedown → pointerdown
// mousemove → pointermove
// mouseup → pointerup
// mouseenter → pointerenter
// mouseleave → pointerleave

// Key differences:
// 1. Must handle pointercancel (like touchcancel)
// 2. Use pointer capture instead of document listeners
// 3. Set touch-action CSS for proper behavior
// 4. Check pointerType if you need type-specific handling
```

---

## 3.8.8 Browser Support and Polyfills

```javascript
// Check for Pointer Events support
if (window.PointerEvent) {
  element.addEventListener('pointerdown', handler);
} else {
  // Fallback to touch/mouse events
  element.addEventListener('touchstart', handler);
  element.addEventListener('mousedown', handler);
}

// Or use feature detection
const supportsPointerEvents = 'onpointerdown' in window;
```

---

## 3.8.9 Gotchas

```javascript
// ❌ Forgetting touch-action CSS
element.addEventListener('pointermove', (e) => {
  e.preventDefault();  // Won't prevent scrolling!
});

// ✅ Use touch-action CSS
// CSS: touch-action: none;
element.addEventListener('pointermove', handler);

// ❌ Not handling pointercancel
element.addEventListener('pointerup', cleanup);
// Pointer can be cancelled without pointerup!

// ✅ Handle both
element.addEventListener('pointerup', cleanup);
element.addEventListener('pointercancel', cleanup);

// ❌ Using document listeners for drag
document.addEventListener('pointermove', dragHandler);
// Doesn't work well across elements/iframes

// ✅ Use pointer capture
element.setPointerCapture(e.pointerId);
element.addEventListener('pointermove', dragHandler);

// ❌ Assuming primary pointer
// On touch, first finger is primary
// Additional fingers are not primary

// ✅ Track all pointers or check isPrimary
if (e.isPrimary || this.trackAllPointers) {
  handlePointer(e);
}
```

---

## 3.8.10 Summary

### Pointer Events

| Event | When | Equivalent |
|-------|------|------------|
| `pointerdown` | Input begins | mousedown, touchstart |
| `pointermove` | Pointer moves | mousemove, touchmove |
| `pointerup` | Input ends | mouseup, touchend |
| `pointercancel` | Input cancelled | touchcancel |
| `pointerenter` | Enter element | mouseenter |
| `pointerleave` | Leave element | mouseleave |

### Key Properties

| Property | Description |
|----------|-------------|
| `pointerId` | Unique identifier |
| `pointerType` | "mouse", "touch", "pen" |
| `isPrimary` | Primary pointer for this type |
| `pressure` | Input pressure (0-1) |
| `tiltX/tiltY` | Pen tilt angles |
| `width/height` | Contact dimensions |

### Pointer Capture Methods

| Method | Description |
|--------|-------------|
| `setPointerCapture(id)` | Capture pointer events |
| `releasePointerCapture(id)` | Release capture |
| `hasPointerCapture(id)` | Check if capturing |

### Best Practices

1. **Use Pointer Events** instead of separate touch/mouse handlers
2. **Set `touch-action` CSS** to control browser gesture handling
3. **Use pointer capture** for drag operations
4. **Handle `pointercancel`** for proper cleanup
5. **Use `getCoalescedEvents()`** for smooth drawing
6. **Check `pointerType`** only when input-specific behavior needed

---

**End of Chapter 3.8: Pointer Events**

Next chapter: **3.9 Drag and Drop Events** — covers the native drag and drop API with DataTransfer.
# 3.9 Drag and Drop Events

The native HTML5 Drag and Drop API enables dragging elements and data between applications. This chapter covers drag events, DataTransfer, drop zones, and common drag and drop patterns.

---

## 3.9.1 Making Elements Draggable

### The draggable Attribute

```html
<!-- Make any element draggable -->
<div draggable="true">Drag me!</div>

<!-- Default draggable elements -->
<img src="photo.jpg">  <!-- Images are draggable by default -->
<a href="/link">Link</a>  <!-- Links are draggable by default -->
<div>Not draggable</div>  <!-- Other elements need draggable="true" -->
```

```javascript
// Enable draggability via JavaScript
element.draggable = true;

// Check if element is draggable
console.log(element.draggable);
```

---

## 3.9.2 Drag Events

### Events on Draggable Elements

```javascript
// dragstart: dragging begins
element.addEventListener('dragstart', (e) => {
  console.log('Started dragging');
  // Set the data being dragged
  e.dataTransfer.setData('text/plain', element.id);
});

// drag: fires continuously while dragging
element.addEventListener('drag', (e) => {
  // ⚠️ Fires frequently - use sparingly
  console.log('Dragging...');
});

// dragend: dragging ends (success or cancel)
element.addEventListener('dragend', (e) => {
  console.log('Drag ended');
  console.log('Drop effect:', e.dataTransfer.dropEffect);
  
  if (e.dataTransfer.dropEffect === 'none') {
    console.log('Drag was cancelled');
  } else {
    console.log('Drop was successful');
  }
});
```

### Events on Drop Targets

```javascript
// dragenter: dragged item enters drop zone
dropZone.addEventListener('dragenter', (e) => {
  e.preventDefault();  // Allow drop
  dropZone.classList.add('drag-over');
});

// dragover: dragged item is over drop zone
// Must call preventDefault() to allow drop!
dropZone.addEventListener('dragover', (e) => {
  e.preventDefault();  // REQUIRED to allow drop
  e.dataTransfer.dropEffect = 'move';
});

// dragleave: dragged item leaves drop zone
dropZone.addEventListener('dragleave', (e) => {
  dropZone.classList.remove('drag-over');
});

// drop: item is dropped
dropZone.addEventListener('drop', (e) => {
  e.preventDefault();  // Prevent default handling
  dropZone.classList.remove('drag-over');
  
  const data = e.dataTransfer.getData('text/plain');
  console.log('Dropped:', data);
});
```

### Event Flow

```javascript
// Complete drag and drop flow:
// 1. User starts dragging → dragstart (on draggable)
// 2. While dragging → drag (on draggable, continuous)
// 3. Enter drop zone → dragenter (on drop zone)
// 4. Over drop zone → dragover (on drop zone, continuous)
// 5. Leave drop zone → dragleave (on drop zone)
// 6. Drop on target → drop (on drop zone)
// 7. End drag → dragend (on draggable)
```

---

## 3.9.3 DataTransfer Object

### Setting Data

```javascript
element.addEventListener('dragstart', (e) => {
  // Set text data
  e.dataTransfer.setData('text/plain', 'Hello World');
  
  // Set HTML data
  e.dataTransfer.setData('text/html', '<b>Hello</b> World');
  
  // Set URL
  e.dataTransfer.setData('text/uri-list', 'https://example.com');
  
  // Set custom data
  e.dataTransfer.setData('application/json', JSON.stringify({
    id: element.id,
    type: 'card',
    data: { title: 'Task 1' }
  }));
  
  // Multiple types can be set
  // Drop target chooses which to use
});
```

### Getting Data

```javascript
dropZone.addEventListener('drop', (e) => {
  e.preventDefault();
  
  // Get text data
  const text = e.dataTransfer.getData('text/plain');
  
  // Get HTML
  const html = e.dataTransfer.getData('text/html');
  
  // Get custom data
  const json = e.dataTransfer.getData('application/json');
  if (json) {
    const data = JSON.parse(json);
    console.log('Dropped:', data);
  }
  
  // Check available types
  console.log('Types:', e.dataTransfer.types);
});
```

### Checking Available Types

```javascript
dropZone.addEventListener('dragover', (e) => {
  // Check what types are available
  const types = e.dataTransfer.types;
  
  if (types.includes('application/json')) {
    e.preventDefault();  // Accept this drop
    e.dataTransfer.dropEffect = 'move';
  }
});
```

### Drop Effect and Effect Allowed

```javascript
// On dragstart: specify what operations are allowed
element.addEventListener('dragstart', (e) => {
  // Options: "none", "copy", "move", "link", 
  // "copyMove", "copyLink", "linkMove", "all"
  e.dataTransfer.effectAllowed = 'copyMove';
});

// On dragover: specify what will happen
dropZone.addEventListener('dragover', (e) => {
  e.preventDefault();
  // Options: "none", "copy", "move", "link"
  e.dataTransfer.dropEffect = 'move';
  // Cursor changes to indicate effect
});

// On dragend: check what happened
element.addEventListener('dragend', (e) => {
  if (e.dataTransfer.dropEffect === 'move') {
    // Remove element from source
    element.remove();
  }
});
```

---

## 3.9.4 Dragging Files

### Detecting File Drops

```javascript
dropZone.addEventListener('dragover', (e) => {
  e.preventDefault();
  
  // Check for files
  if (e.dataTransfer.types.includes('Files')) {
    e.dataTransfer.dropEffect = 'copy';
  }
});

dropZone.addEventListener('drop', (e) => {
  e.preventDefault();
  
  // Access dropped files
  const files = e.dataTransfer.files;
  
  for (const file of files) {
    console.log('File:', file.name);
    console.log('Type:', file.type);
    console.log('Size:', file.size);
    
    // Process file
    handleFile(file);
  }
});

async function handleFile(file) {
  if (file.type.startsWith('image/')) {
    const url = URL.createObjectURL(file);
    showImage(url);
  } else if (file.type === 'application/json') {
    const text = await file.text();
    const data = JSON.parse(text);
    processData(data);
  }
}
```

### File Drop Zone Pattern

```javascript
class FileDropZone {
  constructor(element, options = {}) {
    this.element = element;
    this.accept = options.accept || '*/*';
    this.onDrop = options.onDrop || (() => {});
    
    this.setup();
  }
  
  setup() {
    // Prevent default drag behavior on document
    ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(event => {
      document.body.addEventListener(event, e => e.preventDefault());
    });
    
    this.element.addEventListener('dragenter', this.highlight.bind(this));
    this.element.addEventListener('dragover', this.highlight.bind(this));
    this.element.addEventListener('dragleave', this.unhighlight.bind(this));
    this.element.addEventListener('drop', this.handleDrop.bind(this));
  }
  
  highlight(e) {
    e.preventDefault();
    this.element.classList.add('drag-active');
  }
  
  unhighlight(e) {
    this.element.classList.remove('drag-active');
  }
  
  handleDrop(e) {
    e.preventDefault();
    this.unhighlight(e);
    
    const files = [...e.dataTransfer.files].filter(file => {
      if (this.accept === '*/*') return true;
      return this.accept.split(',').some(type => {
        type = type.trim();
        if (type.endsWith('/*')) {
          return file.type.startsWith(type.slice(0, -1));
        }
        return file.type === type;
      });
    });
    
    if (files.length > 0) {
      this.onDrop(files);
    }
  }
}

// Usage
new FileDropZone(document.querySelector('.drop-zone'), {
  accept: 'image/*,application/pdf',
  onDrop: (files) => {
    files.forEach(uploadFile);
  }
});
```

---

## 3.9.5 Custom Drag Image

```javascript
element.addEventListener('dragstart', (e) => {
  // Create custom drag image
  const dragImage = document.createElement('div');
  dragImage.textContent = 'Dragging...';
  dragImage.style.cssText = `
    position: absolute;
    top: -1000px;
    background: #333;
    color: white;
    padding: 8px 16px;
    border-radius: 4px;
  `;
  document.body.appendChild(dragImage);
  
  // Set as drag image (element, offsetX, offsetY)
  e.dataTransfer.setDragImage(dragImage, 50, 25);
  
  // Clean up
  setTimeout(() => dragImage.remove(), 0);
});

// Using an existing image
element.addEventListener('dragstart', (e) => {
  const img = new Image();
  img.src = 'drag-icon.png';
  e.dataTransfer.setDragImage(img, 25, 25);
});
```

---

## 3.9.6 Common Patterns

### Sortable List

```javascript
class SortableList {
  constructor(container) {
    this.container = container;
    this.draggedItem = null;
    
    container.querySelectorAll('.sortable-item').forEach(item => {
      item.draggable = true;
      this.addDragListeners(item);
    });
  }
  
  addDragListeners(item) {
    item.addEventListener('dragstart', (e) => {
      this.draggedItem = item;
      item.classList.add('dragging');
      e.dataTransfer.effectAllowed = 'move';
      e.dataTransfer.setData('text/plain', '');
    });
    
    item.addEventListener('dragend', () => {
      this.draggedItem = null;
      item.classList.remove('dragging');
    });
    
    item.addEventListener('dragover', (e) => {
      e.preventDefault();
      if (item === this.draggedItem) return;
      
      const rect = item.getBoundingClientRect();
      const midY = rect.top + rect.height / 2;
      
      if (e.clientY < midY) {
        item.parentNode.insertBefore(this.draggedItem, item);
      } else {
        item.parentNode.insertBefore(this.draggedItem, item.nextSibling);
      }
    });
  }
}
```

### Kanban Board

```javascript
class KanbanBoard {
  constructor(board) {
    this.board = board;
    this.draggedCard = null;
    
    // Setup columns
    board.querySelectorAll('.column').forEach(column => {
      column.addEventListener('dragover', this.handleDragOver.bind(this));
      column.addEventListener('drop', this.handleDrop.bind(this));
    });
    
    // Setup cards
    board.querySelectorAll('.card').forEach(card => {
      this.setupCard(card);
    });
  }
  
  setupCard(card) {
    card.draggable = true;
    
    card.addEventListener('dragstart', (e) => {
      this.draggedCard = card;
      card.classList.add('dragging');
      e.dataTransfer.setData('application/json', JSON.stringify({
        id: card.dataset.id
      }));
    });
    
    card.addEventListener('dragend', () => {
      this.draggedCard = null;
      card.classList.remove('dragging');
    });
  }
  
  handleDragOver(e) {
    e.preventDefault();
    e.dataTransfer.dropEffect = 'move';
    
    const column = e.currentTarget;
    const afterCard = this.getCardAfterDrag(column, e.clientY);
    
    if (afterCard) {
      column.insertBefore(this.draggedCard, afterCard);
    } else {
      column.appendChild(this.draggedCard);
    }
  }
  
  handleDrop(e) {
    e.preventDefault();
    const column = e.currentTarget;
    const cardId = this.draggedCard.dataset.id;
    const newStatus = column.dataset.status;
    
    // Update backend
    this.updateCardStatus(cardId, newStatus);
  }
  
  getCardAfterDrag(column, y) {
    const cards = [...column.querySelectorAll('.card:not(.dragging)')];
    
    return cards.reduce((closest, card) => {
      const rect = card.getBoundingClientRect();
      const offset = y - rect.top - rect.height / 2;
      
      if (offset < 0 && offset > closest.offset) {
        return { offset, element: card };
      }
      return closest;
    }, { offset: Number.NEGATIVE_INFINITY }).element;
  }
  
  updateCardStatus(cardId, status) {
    // API call to update card
  }
}
```

### Drag Between Lists

```javascript
class DragBetweenLists {
  constructor(lists) {
    this.lists = lists;
    this.draggedItem = null;
    this.sourceList = null;
    
    lists.forEach(list => this.setupList(list));
  }
  
  setupList(list) {
    list.addEventListener('dragover', (e) => {
      e.preventDefault();
      e.dataTransfer.dropEffect = 'move';
      list.classList.add('drop-target');
    });
    
    list.addEventListener('dragleave', () => {
      list.classList.remove('drop-target');
    });
    
    list.addEventListener('drop', (e) => {
      e.preventDefault();
      list.classList.remove('drop-target');
      
      if (this.draggedItem) {
        list.appendChild(this.draggedItem);
        this.onMove(this.draggedItem, this.sourceList, list);
      }
    });
    
    list.querySelectorAll('.item').forEach(item => {
      this.setupItem(item);
    });
  }
  
  setupItem(item) {
    item.draggable = true;
    
    item.addEventListener('dragstart', (e) => {
      this.draggedItem = item;
      this.sourceList = item.parentElement;
      item.classList.add('dragging');
    });
    
    item.addEventListener('dragend', () => {
      this.draggedItem = null;
      this.sourceList = null;
      item.classList.remove('dragging');
    });
  }
  
  onMove(item, from, to) {
    console.log(`Moved ${item.textContent} from ${from.id} to ${to.id}`);
  }
}
```

---

## 3.9.7 Accessibility Considerations

```javascript
// Native drag and drop is NOT keyboard accessible
// Provide keyboard alternatives

class AccessibleDragDrop {
  constructor(container) {
    this.container = container;
    this.selectedItem = null;
    
    container.querySelectorAll('.item').forEach(item => {
      item.setAttribute('tabindex', '0');
      item.setAttribute('role', 'option');
      item.setAttribute('aria-grabbed', 'false');
      
      item.addEventListener('keydown', this.handleKeydown.bind(this));
    });
    
    container.setAttribute('role', 'listbox');
    container.setAttribute('aria-label', 'Sortable list');
  }
  
  handleKeydown(e) {
    const item = e.target;
    
    switch (e.key) {
      case ' ':
      case 'Enter':
        e.preventDefault();
        this.toggleSelection(item);
        break;
        
      case 'ArrowUp':
        e.preventDefault();
        if (this.selectedItem) {
          this.moveUp(this.selectedItem);
        } else {
          this.focusPrevious(item);
        }
        break;
        
      case 'ArrowDown':
        e.preventDefault();
        if (this.selectedItem) {
          this.moveDown(this.selectedItem);
        } else {
          this.focusNext(item);
        }
        break;
        
      case 'Escape':
        if (this.selectedItem) {
          this.deselect();
        }
        break;
    }
  }
  
  toggleSelection(item) {
    if (this.selectedItem === item) {
      this.deselect();
    } else {
      if (this.selectedItem) {
        this.deselect();
      }
      this.selectedItem = item;
      item.setAttribute('aria-grabbed', 'true');
      item.classList.add('selected');
    }
  }
  
  deselect() {
    if (this.selectedItem) {
      this.selectedItem.setAttribute('aria-grabbed', 'false');
      this.selectedItem.classList.remove('selected');
      this.selectedItem = null;
    }
  }
  
  moveUp(item) {
    const prev = item.previousElementSibling;
    if (prev) {
      item.parentNode.insertBefore(item, prev);
      item.focus();
    }
  }
  
  moveDown(item) {
    const next = item.nextElementSibling;
    if (next) {
      item.parentNode.insertBefore(next, item);
      item.focus();
    }
  }
  
  focusPrevious(item) {
    const prev = item.previousElementSibling;
    if (prev) prev.focus();
  }
  
  focusNext(item) {
    const next = item.nextElementSibling;
    if (next) next.focus();
  }
}
```

---

## 3.9.8 Gotchas

```javascript
// ❌ Forgetting preventDefault on dragover
dropZone.addEventListener('dragover', handler);
// Drop will NOT work without preventDefault!

// ✅ Always prevent default on dragover
dropZone.addEventListener('dragover', (e) => {
  e.preventDefault();
});

// ❌ Trying to access dataTransfer data in dragover
dropZone.addEventListener('dragover', (e) => {
  const data = e.dataTransfer.getData('text');
  // Returns empty string! (security restriction)
});

// ✅ Only access data in drop event
dropZone.addEventListener('drop', (e) => {
  const data = e.dataTransfer.getData('text');
  // Works here
});

// ❌ dragleave fires when entering child elements
dropZone.addEventListener('dragleave', (e) => {
  dropZone.classList.remove('active');
  // Flickers when moving over children!
});

// ✅ Check if actually leaving the drop zone
dropZone.addEventListener('dragleave', (e) => {
  if (!dropZone.contains(e.relatedTarget)) {
    dropZone.classList.remove('active');
  }
});

// ❌ Not preventing default on drop
dropZone.addEventListener('drop', (e) => {
  // Browser may navigate to dropped URL or open file!
});

// ✅ Always prevent default on drop
dropZone.addEventListener('drop', (e) => {
  e.preventDefault();
  handleDrop(e);
});
```

---

## 3.9.9 Summary

### Drag Events

| Event | Target | When |
|-------|--------|------|
| `dragstart` | Draggable | Drag begins |
| `drag` | Draggable | While dragging |
| `dragend` | Draggable | Drag ends |
| `dragenter` | Drop zone | Enter drop zone |
| `dragover` | Drop zone | Over drop zone |
| `dragleave` | Drop zone | Leave drop zone |
| `drop` | Drop zone | Item dropped |

### DataTransfer Properties

| Property | Description |
|----------|-------------|
| `setData(type, data)` | Set drag data |
| `getData(type)` | Get drag data (drop only) |
| `types` | Array of data types |
| `files` | FileList for file drops |
| `effectAllowed` | Allowed operations |
| `dropEffect` | Current operation |
| `setDragImage()` | Custom drag image |

### Best Practices

1. **Always `preventDefault` on `dragover`** to enable drops
2. **Always `preventDefault` on `drop`** to prevent browser defaults
3. **Handle `dragleave` carefully** — use `relatedTarget` check
4. **Set data in `dragstart`** — only accessible in `drop`
5. **Provide keyboard alternatives** for accessibility
6. **Use `effectAllowed` and `dropEffect`** for visual feedback

---

**End of Chapter 3.9: Drag and Drop Events**

Next chapter: **3.10 Window Events** — covers load, resize, scroll, beforeunload, and other window-level events.
# 3.10 Window Events

Window events handle page lifecycle, viewport changes, and user departure. This chapter covers load events, resize, scroll, visibility, and beforeunload for exit confirmation.

---

## 3.10.1 Load Events

### load Event

```javascript
// Fires when entire page is loaded (including images, stylesheets, etc.)
window.addEventListener('load', () => {
  console.log('Page fully loaded');
  console.log('All images loaded');
  console.log('All stylesheets applied');
  
  // Safe to interact with images
  const img = document.querySelector('img');
  console.log('Image dimensions:', img.naturalWidth, img.naturalHeight);
});

// Also fires on individual elements
const img = document.querySelector('img');
img.addEventListener('load', () => {
  console.log('This image loaded');
});
```

### DOMContentLoaded vs load

```javascript
// DOMContentLoaded: HTML parsed, DOM ready
// (Fires BEFORE images and stylesheets finish loading)
document.addEventListener('DOMContentLoaded', () => {
  console.log('DOM ready!');
  // Safe to query DOM
  // Images may still be loading
});

// load: Everything finished
window.addEventListener('load', () => {
  console.log('Everything loaded!');
  // All resources ready
});

// Typical order:
// 1. DOMContentLoaded
// 2. Images load
// 3. Stylesheets load
// 4. window.load
```

### error Event

```javascript
// Handle resource loading errors
const img = document.querySelector('img');

img.addEventListener('error', () => {
  console.log('Image failed to load');
  img.src = 'fallback.png';
});

// Global error handler
window.addEventListener('error', (e) => {
  if (e.target !== window) {
    // Resource loading error
    console.log('Resource failed:', e.target.src || e.target.href);
  } else {
    // JavaScript error
    console.log('JS error:', e.message);
  }
});
```

---

## 3.10.2 Resize Event

### Basic Usage

```javascript
window.addEventListener('resize', () => {
  console.log('Window resized');
  console.log('New size:', window.innerWidth, window.innerHeight);
});

// ⚠️ Fires frequently during resize
// Debounce for performance
let resizeTimeout;
window.addEventListener('resize', () => {
  clearTimeout(resizeTimeout);
  resizeTimeout = setTimeout(() => {
    handleResize();
  }, 100);
});
```

### Window Dimensions

```javascript
// Viewport size (excluding scrollbars)
console.log('Inner:', window.innerWidth, window.innerHeight);

// Outer window size (including chrome)
console.log('Outer:', window.outerWidth, window.outerHeight);

// Screen size
console.log('Screen:', screen.width, screen.height);

// Available screen (minus taskbar)
console.log('Available:', screen.availWidth, screen.availHeight);
```

### ResizeObserver Alternative

```javascript
// For element resizing (more efficient than window resize)
const observer = new ResizeObserver((entries) => {
  for (const entry of entries) {
    console.log('Element resized:', entry.contentRect.width);
  }
});

observer.observe(document.querySelector('.container'));
```

---

## 3.10.3 Scroll Events

### Basic Scroll Handling

```javascript
window.addEventListener('scroll', () => {
  console.log('Scroll position:', window.scrollX, window.scrollY);
});

// ⚠️ Fires very frequently
// Use passive listener for performance
window.addEventListener('scroll', handleScroll, { passive: true });
```

### Throttling Scroll

```javascript
// Throttle scroll handler
let ticking = false;

window.addEventListener('scroll', () => {
  if (!ticking) {
    requestAnimationFrame(() => {
      handleScroll();
      ticking = false;
    });
    ticking = true;
  }
}, { passive: true });

function handleScroll() {
  const scrollY = window.scrollY;
  // Handle scroll
}
```

### Scroll Position

```javascript
// Current scroll position
const scrollX = window.scrollX;  // or pageXOffset
const scrollY = window.scrollY;  // or pageYOffset

// Document dimensions
const docHeight = document.documentElement.scrollHeight;
const docWidth = document.documentElement.scrollWidth;

// Viewport dimensions
const viewHeight = window.innerHeight;
const viewWidth = window.innerWidth;

// Scroll progress (0 to 1)
const progress = scrollY / (docHeight - viewHeight);
```

### Scroll-Based Animations

```javascript
// Progress bar
const progressBar = document.querySelector('.progress');

window.addEventListener('scroll', () => {
  const scrollable = document.documentElement.scrollHeight - window.innerHeight;
  const progress = window.scrollY / scrollable;
  progressBar.style.width = `${progress * 100}%`;
}, { passive: true });

// Reveal on scroll
const observer = new IntersectionObserver((entries) => {
  entries.forEach(entry => {
    if (entry.isIntersecting) {
      entry.target.classList.add('visible');
    }
  });
}, { threshold: 0.1 });

document.querySelectorAll('.reveal').forEach(el => observer.observe(el));
```

---

## 3.10.4 Page Lifecycle Events

### beforeunload

```javascript
// Prompt before leaving (for unsaved changes)
window.addEventListener('beforeunload', (e) => {
  if (hasUnsavedChanges) {
    // Modern browsers ignore custom messages
    e.preventDefault();
    // Some browsers require returnValue
    e.returnValue = '';
    return '';
  }
});

// Only attach when needed
function markUnsaved() {
  hasUnsavedChanges = true;
  window.addEventListener('beforeunload', handleBeforeUnload);
}

function markSaved() {
  hasUnsavedChanges = false;
  window.removeEventListener('beforeunload', handleBeforeUnload);
}
```

### unload (Deprecated)

```javascript
// ⚠️ Deprecated - avoid using
// Prevents back-forward cache (bfcache)
window.addEventListener('unload', () => {
  // Don't use this!
});

// ✅ Use pagehide instead
window.addEventListener('pagehide', (e) => {
  if (e.persisted) {
    // Page is being cached
  } else {
    // Page is being unloaded
  }
  
  // Send analytics
  navigator.sendBeacon('/analytics', data);
});
```

### visibilitychange

```javascript
// Fires when page becomes visible/hidden
document.addEventListener('visibilitychange', () => {
  if (document.visibilityState === 'visible') {
    console.log('Page is visible');
    resumeVideo();
    reconnectWebSocket();
  } else {
    console.log('Page is hidden');
    pauseVideo();
    // visibilityState can be: "visible", "hidden"
  }
});

// Check current state
console.log('Hidden:', document.hidden);
console.log('State:', document.visibilityState);
```

### pageshow and pagehide

```javascript
// Better alternatives to load/unload for bfcache compatibility

window.addEventListener('pageshow', (e) => {
  if (e.persisted) {
    // Restored from bfcache
    console.log('Page restored from cache');
    refreshData();
  } else {
    // Fresh page load
    console.log('Fresh page load');
  }
});

window.addEventListener('pagehide', (e) => {
  if (e.persisted) {
    // Being put in bfcache
    console.log('Page may be cached');
  }
});
```

---

## 3.10.5 Online/Offline Events

```javascript
// Detect connection changes
window.addEventListener('online', () => {
  console.log('Back online');
  syncData();
  showNotification('Connection restored');
});

window.addEventListener('offline', () => {
  console.log('Gone offline');
  showNotification('You are offline');
});

// Check current state
console.log('Online:', navigator.onLine);
```

---

## 3.10.6 Print Events

```javascript
// Before print dialog opens
window.addEventListener('beforeprint', () => {
  console.log('Preparing to print');
  expandAllSections();
  showPrintStyles();
});

// After print dialog closes
window.addEventListener('afterprint', () => {
  console.log('Print finished/cancelled');
  restoreNormalView();
});

// Alternative: matchMedia
const printQuery = window.matchMedia('print');
printQuery.addEventListener('change', (e) => {
  if (e.matches) {
    // Entering print mode
  } else {
    // Exiting print mode
  }
});
```

---

## 3.10.7 Focus Events

```javascript
// Window gains focus
window.addEventListener('focus', () => {
  console.log('Window focused');
  document.title = 'My App';
});

// Window loses focus
window.addEventListener('blur', () => {
  console.log('Window blurred');
  document.title = '(Paused) My App';
});

// Check if window has focus
console.log('Has focus:', document.hasFocus());
```

---

## 3.10.8 Common Patterns

### Sticky Header

```javascript
const header = document.querySelector('header');
const headerTop = header.offsetTop;

window.addEventListener('scroll', () => {
  if (window.scrollY >= headerTop) {
    header.classList.add('sticky');
  } else {
    header.classList.remove('sticky');
  }
}, { passive: true });
```

### Infinite Scroll

```javascript
function setupInfiniteScroll() {
  let loading = false;
  
  window.addEventListener('scroll', async () => {
    if (loading) return;
    
    const scrollBottom = window.scrollY + window.innerHeight;
    const docHeight = document.documentElement.scrollHeight;
    
    // Load more when near bottom
    if (docHeight - scrollBottom < 200) {
      loading = true;
      await loadMoreContent();
      loading = false;
    }
  }, { passive: true });
}
```

### Unsaved Changes Warning

```javascript
class UnsavedChangesGuard {
  constructor(form) {
    this.form = form;
    this.hasChanges = false;
    
    form.addEventListener('input', () => {
      this.hasChanges = true;
    });
    
    form.addEventListener('submit', () => {
      this.hasChanges = false;
    });
    
    window.addEventListener('beforeunload', (e) => {
      if (this.hasChanges) {
        e.preventDefault();
        e.returnValue = '';
      }
    });
  }
}
```

### Responsive Breakpoints

```javascript
class BreakpointWatcher {
  constructor(breakpoints) {
    this.breakpoints = breakpoints;
    this.current = this.getCurrent();
    
    window.addEventListener('resize', this.checkBreakpoint.bind(this));
  }
  
  getCurrent() {
    const width = window.innerWidth;
    for (const [name, minWidth] of Object.entries(this.breakpoints)) {
      if (width >= minWidth) return name;
    }
    return 'xs';
  }
  
  checkBreakpoint() {
    const newBreakpoint = this.getCurrent();
    if (newBreakpoint !== this.current) {
      this.current = newBreakpoint;
      this.onChange(newBreakpoint);
    }
  }
  
  onChange(breakpoint) {
    document.body.dataset.breakpoint = breakpoint;
  }
}

new BreakpointWatcher({
  xl: 1200,
  lg: 992,
  md: 768,
  sm: 576
});
```

---

## 3.10.9 Gotchas

```javascript
// ❌ Using unload event (breaks bfcache)
window.addEventListener('unload', sendAnalytics);

// ✅ Use pagehide or sendBeacon
window.addEventListener('pagehide', () => {
  navigator.sendBeacon('/analytics', data);
});

// ❌ Not throttling scroll/resize handlers
window.addEventListener('scroll', heavyComputation);

// ✅ Throttle with requestAnimationFrame
let ticking = false;
window.addEventListener('scroll', () => {
  if (!ticking) {
    requestAnimationFrame(() => {
      heavyComputation();
      ticking = false;
    });
    ticking = true;
  }
}, { passive: true });

// ❌ Using passive: false on scroll without needing preventDefault
window.addEventListener('scroll', handler);  // Non-passive by default

// ✅ Use passive: true when not preventing default
window.addEventListener('scroll', handler, { passive: true });

// ❌ Relying on navigator.onLine for actual connectivity
if (navigator.onLine) {
  // Might be online but server unreachable!
}

// ✅ Actually test connectivity
async function isOnline() {
  try {
    await fetch('/ping', { method: 'HEAD' });
    return true;
  } catch {
    return false;
  }
}
```

---

## 3.10.10 Summary

### Window Events

| Event | When |
|-------|------|
| `load` | Page fully loaded (all resources) |
| `DOMContentLoaded` | DOM parsed (document event) |
| `beforeunload` | Before leaving page |
| `pagehide` | Page is being hidden/unloaded |
| `pageshow` | Page is shown (including bfcache) |

### Viewport Events

| Event | When |
|-------|------|
| `resize` | Window size changes |
| `scroll` | Page is scrolled |

### Visibility Events

| Event | When |
|-------|------|
| `visibilitychange` | Page visibility changes (document event) |
| `focus` | Window gains focus |
| `blur` | Window loses focus |
| `online` | Connection restored |
| `offline` | Connection lost |

### Best Practices

1. **Use `DOMContentLoaded`** for DOM manipulation, `load` for resources
2. **Use `pagehide`** instead of `unload` (bfcache friendly)
3. **Throttle scroll/resize** with `requestAnimationFrame`
4. **Use `passive: true`** for scroll handlers when possible
5. **Use `sendBeacon`** for analytics on page leave
6. **Only attach `beforeunload`** when actually needed

---

**End of Chapter 3.10: Window Events**

Next chapter: **3.11 Document Events** — covers DOMContentLoaded, readystatechange, visibilitychange, and fullscreen events.
# 3.11 Document Events

Document events handle DOM readiness, document state changes, and full-screen mode. This chapter covers DOMContentLoaded, readyState, clipboard events on document, and fullscreen API events.

---

## 3.11.1 DOM Ready Events

### DOMContentLoaded

```javascript
// Fires when HTML is parsed and DOM tree is ready
// Does NOT wait for stylesheets, images, or subframes
document.addEventListener('DOMContentLoaded', () => {
  console.log('DOM is ready');
  
  // Safe to query DOM
  const app = document.querySelector('#app');
  initializeApp(app);
});

// If script is at end of body, DOM is already ready
// But DOMContentLoaded is still useful for:
// - Scripts in <head> with defer
// - Dynamic script loading
// - Ensuring all DOM is parsed
```

### readystatechange

```javascript
// Fires when document.readyState changes
document.addEventListener('readystatechange', () => {
  console.log('State:', document.readyState);
});

// readyState values:
// "loading" - Document is loading
// "interactive" - DOM parsed (DOMContentLoaded fires here)
// "complete" - All resources loaded (load fires here)

// Wait for specific state
function waitForReady() {
  return new Promise((resolve) => {
    if (document.readyState === 'complete') {
      resolve();
    } else {
      document.addEventListener('readystatechange', () => {
        if (document.readyState === 'complete') {
          resolve();
        }
      });
    }
  });
}
```

### Checking if DOM is Ready

```javascript
// Pattern for scripts that might load at any time
function onReady(callback) {
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', callback);
  } else {
    // DOM is already ready
    callback();
  }
}

// Usage
onReady(() => {
  initializeApp();
});

// jQuery-style ready function
function $(callback) {
  if (document.readyState !== 'loading') {
    callback();
  } else {
    document.addEventListener('DOMContentLoaded', callback);
  }
}

$(() => {
  console.log('Ready!');
});
```

---

## 3.11.2 Visibility Events

### visibilitychange

```javascript
// Fires when page visibility changes
// More reliable than window focus/blur for tab switching
document.addEventListener('visibilitychange', () => {
  if (document.visibilityState === 'visible') {
    console.log('Page is now visible');
    resumeAnimations();
    checkForUpdates();
  } else if (document.visibilityState === 'hidden') {
    console.log('Page is now hidden');
    pauseAnimations();
    saveProgress();
  }
});

// Check current visibility
console.log('Hidden:', document.hidden);
console.log('State:', document.visibilityState);
// visibilityState: "visible", "hidden"
```

### Use Cases

```javascript
// Pause video when tab is hidden
const video = document.querySelector('video');

document.addEventListener('visibilitychange', () => {
  if (document.hidden) {
    video.pause();
  } else {
    video.play();
  }
});

// Pause game loop
let animationId;

document.addEventListener('visibilitychange', () => {
  if (document.hidden) {
    cancelAnimationFrame(animationId);
  } else {
    animationId = requestAnimationFrame(gameLoop);
  }
});

// Refresh data when page becomes visible
document.addEventListener('visibilitychange', () => {
  if (document.visibilityState === 'visible') {
    fetchLatestData();
  }
});
```

---

## 3.11.3 Selection Events

### selectionchange

```javascript
// Fires when text selection changes
document.addEventListener('selectionchange', () => {
  const selection = document.getSelection();
  
  if (selection.toString()) {
    console.log('Selected text:', selection.toString());
    showSelectionToolbar(selection);
  } else {
    hideSelectionToolbar();
  }
});

// Get selection details
function getSelectionDetails() {
  const selection = document.getSelection();
  
  return {
    text: selection.toString(),
    rangeCount: selection.rangeCount,
    anchorNode: selection.anchorNode,
    focusNode: selection.focusNode,
    isCollapsed: selection.isCollapsed
  };
}
```

### selectstart

```javascript
// Fires when selection starts
document.addEventListener('selectstart', (e) => {
  console.log('Selection starting on:', e.target);
  
  // Prevent selection on certain elements
  if (e.target.classList.contains('no-select')) {
    e.preventDefault();
  }
});

// CSS alternative for preventing selection
// user-select: none;
```

---

## 3.11.4 Fullscreen Events

### Entering/Exiting Fullscreen

```javascript
// Request fullscreen on an element
const element = document.querySelector('.player');

async function enterFullscreen() {
  try {
    await element.requestFullscreen();
  } catch (err) {
    console.error('Fullscreen failed:', err);
  }
}

// Exit fullscreen
async function exitFullscreen() {
  if (document.fullscreenElement) {
    await document.exitFullscreen();
  }
}

// Toggle fullscreen
async function toggleFullscreen() {
  if (document.fullscreenElement) {
    await document.exitFullscreen();
  } else {
    await element.requestFullscreen();
  }
}
```

### fullscreenchange Event

```javascript
// Fires when fullscreen state changes
document.addEventListener('fullscreenchange', () => {
  if (document.fullscreenElement) {
    console.log('Entered fullscreen:', document.fullscreenElement);
    showFullscreenUI();
  } else {
    console.log('Exited fullscreen');
    showNormalUI();
  }
});

// Check current state
console.log('Fullscreen element:', document.fullscreenElement);
console.log('Is fullscreen:', !!document.fullscreenElement);
console.log('Fullscreen enabled:', document.fullscreenEnabled);
```

### fullscreenerror Event

```javascript
// Fires if fullscreen request fails
document.addEventListener('fullscreenerror', (e) => {
  console.error('Fullscreen error on:', e.target);
  showError('Fullscreen not available');
});

// Common failure reasons:
// - No user gesture
// - iframe without allowfullscreen
// - Browser restrictions
```

### Fullscreen CSS

```css
/* Style fullscreen element */
:fullscreen {
  background: black;
}

/* Style backdrop (empty space) */
::backdrop {
  background: rgba(0, 0, 0, 0.9);
}

/* Different fullscreen states */
.player:fullscreen .controls {
  position: fixed;
  bottom: 20px;
}
```

---

## 3.11.5 Clipboard Events on Document

```javascript
// Document-level clipboard events
// (See chapter 3.6 for form-level clipboard events)

document.addEventListener('copy', (e) => {
  console.log('Copy event on document');
  
  // Modify copied content
  const selection = document.getSelection().toString();
  const modified = `${selection}\n\nCopied from MyApp`;
  
  e.clipboardData.setData('text/plain', modified);
  e.preventDefault();
});

document.addEventListener('cut', (e) => {
  console.log('Cut event');
});

document.addEventListener('paste', (e) => {
  const text = e.clipboardData.getData('text/plain');
  console.log('Pasted:', text);
  
  // Check for images
  const items = e.clipboardData.items;
  for (const item of items) {
    if (item.type.startsWith('image/')) {
      const file = item.getAsFile();
      handlePastedImage(file);
    }
  }
});
```

---

## 3.11.6 Scroll-Related Document Properties

```javascript
// Document scroll dimensions
const scrollHeight = document.documentElement.scrollHeight;
const scrollWidth = document.documentElement.scrollWidth;

// Client dimensions (viewport)
const clientHeight = document.documentElement.clientHeight;
const clientWidth = document.documentElement.clientWidth;

// Scroll position
const scrollTop = document.documentElement.scrollTop;
const scrollLeft = document.documentElement.scrollLeft;

// Scroll to position
document.documentElement.scrollTo({
  top: 0,
  behavior: 'smooth'
});

// Scroll by amount
document.documentElement.scrollBy({
  top: 100,
  behavior: 'smooth'
});
```

---

## 3.11.7 Common Patterns

### Loading Indicator

```javascript
class LoadingIndicator {
  constructor() {
    this.indicator = this.createIndicator();
    document.body.appendChild(this.indicator);
    
    // Show until DOM ready
    document.addEventListener('DOMContentLoaded', () => {
      this.hide();
    });
    
    // Or until fully loaded
    window.addEventListener('load', () => {
      this.indicator.remove();
    });
  }
  
  createIndicator() {
    const div = document.createElement('div');
    div.className = 'loading-overlay';
    div.innerHTML = '<div class="spinner"></div>';
    return div;
  }
  
  hide() {
    this.indicator.classList.add('fade-out');
  }
}
```

### Copy-to-Clipboard Feature

```javascript
async function copyToClipboard(text) {
  try {
    await navigator.clipboard.writeText(text);
    showToast('Copied!');
  } catch (err) {
    // Fallback for older browsers
    const textarea = document.createElement('textarea');
    textarea.value = text;
    textarea.style.position = 'fixed';
    textarea.style.opacity = '0';
    document.body.appendChild(textarea);
    textarea.select();
    document.execCommand('copy');
    textarea.remove();
    showToast('Copied!');
  }
}
```

### Idle Detection

```javascript
class IdleDetector {
  constructor(timeout = 60000) {
    this.timeout = timeout;
    this.timer = null;
    this.isIdle = false;
    
    const events = ['mousemove', 'keydown', 'scroll', 'touchstart'];
    events.forEach(event => {
      document.addEventListener(event, () => this.reset(), { passive: true });
    });
    
    document.addEventListener('visibilitychange', () => {
      if (document.hidden) {
        this.goIdle();
      } else {
        this.reset();
      }
    });
    
    this.reset();
  }
  
  reset() {
    if (this.isIdle) {
      this.isIdle = false;
      this.onActive();
    }
    clearTimeout(this.timer);
    this.timer = setTimeout(() => this.goIdle(), this.timeout);
  }
  
  goIdle() {
    this.isIdle = true;
    this.onIdle();
  }
  
  onIdle() {
    console.log('User is idle');
  }
  
  onActive() {
    console.log('User is active');
  }
}
```

---

## 3.11.8 Gotchas

```javascript
// ❌ Waiting for DOMContentLoaded when DOM is already ready
document.addEventListener('DOMContentLoaded', init);
// If script runs after DOM is ready, callback never fires!

// ✅ Check readyState first
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', init);
} else {
  init();
}

// ❌ Using document.body before it exists
// In <head>, document.body is null
console.log(document.body);  // null in <head>

// ✅ Wait for DOMContentLoaded or use documentElement
document.addEventListener('DOMContentLoaded', () => {
  console.log(document.body);  // Now exists
});

// ❌ Fullscreen without user gesture
requestFullscreen();  // Will fail!

// ✅ Trigger from user interaction
button.addEventListener('click', () => {
  element.requestFullscreen();
});

// ❌ Forgetting vendor prefixes for older browsers
element.requestFullscreen();  // May not work

// ✅ Use with fallbacks
function requestFullscreen(element) {
  if (element.requestFullscreen) {
    return element.requestFullscreen();
  } else if (element.webkitRequestFullscreen) {
    return element.webkitRequestFullscreen();
  } else if (element.msRequestFullscreen) {
    return element.msRequestFullscreen();
  }
}
```

---

## 3.11.9 Summary

### Document Ready Events

| Event | When | Target |
|-------|------|--------|
| `DOMContentLoaded` | DOM parsed | document |
| `readystatechange` | readyState changes | document |
| `load` | All resources loaded | window |

### Document States

| readyState | Meaning |
|------------|---------|
| `"loading"` | Document loading |
| `"interactive"` | DOM ready |
| `"complete"` | Fully loaded |

### Fullscreen Events

| Event | When |
|-------|------|
| `fullscreenchange` | Enter/exit fullscreen |
| `fullscreenerror` | Fullscreen request failed |

### Key Properties

| Property | Description |
|----------|-------------|
| `document.readyState` | Current loading state |
| `document.hidden` | Page visibility boolean |
| `document.visibilityState` | "visible" or "hidden" |
| `document.fullscreenElement` | Current fullscreen element |
| `document.fullscreenEnabled` | Fullscreen supported |

### Best Practices

1. **Check `readyState` before adding `DOMContentLoaded`**
2. **Use `visibilitychange` for pausing/resuming**
3. **Fullscreen requires user gesture**
4. **Use `selectionchange` for custom selection UI**
5. **Handle both DOM ready and full load as needed**

---

**End of Chapter 3.11: Document Events**

Next chapter: **3.12 Custom Events** — covers creating and dispatching CustomEvent with detail data.
# 3.12 Custom Events

Custom events enable components to communicate without tight coupling. This chapter covers creating events with CustomEvent, dispatching them, passing data, and building event-driven architectures.

---

## 3.12.1 Creating Custom Events

### CustomEvent Constructor

```javascript
// Basic custom event
const event = new CustomEvent('myevent');

// Custom event with data
const eventWithData = new CustomEvent('userlogin', {
  detail: {
    userId: 123,
    username: 'alice',
    timestamp: Date.now()
  }
});

// Full options
const fullEvent = new CustomEvent('notification', {
  detail: { message: 'Hello!' },
  bubbles: true,       // Event bubbles up the DOM
  cancelable: true,    // Can be prevented with preventDefault()
  composed: true       // Crosses shadow DOM boundaries
});
```

### Event Constructor (Generic)

```javascript
// Basic Event (no detail property)
const event = new Event('customevent');

const bubblingEvent = new Event('customevent', {
  bubbles: true,
  cancelable: true
});

// Use CustomEvent when you need to pass data
// Use Event for simple notifications
```

---

## 3.12.2 Dispatching Events

### dispatchEvent

```javascript
// Dispatch on any element
const element = document.querySelector('#myComponent');

element.addEventListener('myevent', (e) => {
  console.log('Event received!');
});

element.dispatchEvent(new CustomEvent('myevent'));

// Dispatch with data
element.dispatchEvent(new CustomEvent('datachange', {
  detail: { newValue: 42 }
}));

// Dispatch returns false if event was cancelled
const event = new CustomEvent('action', { cancelable: true });
const wasNotCancelled = element.dispatchEvent(event);

if (!wasNotCancelled) {
  console.log('Event was cancelled');
}
```

### Dispatching on Document or Window

```javascript
// Global events often dispatch on document or window
document.dispatchEvent(new CustomEvent('app:ready', {
  detail: { version: '1.0.0' }
}));

window.dispatchEvent(new CustomEvent('theme:change', {
  detail: { theme: 'dark' }
}));

// Listeners
document.addEventListener('app:ready', (e) => {
  console.log('App version:', e.detail.version);
});
```

---

## 3.12.3 Accessing Event Data

### The detail Property

```javascript
// Sender
element.dispatchEvent(new CustomEvent('productselected', {
  detail: {
    product: {
      id: 'prod-123',
      name: 'Widget',
      price: 29.99
    },
    quantity: 2
  },
  bubbles: true
}));

// Receiver
document.addEventListener('productselected', (e) => {
  const { product, quantity } = e.detail;
  
  console.log(`Selected: ${quantity}x ${product.name}`);
  console.log(`Total: $${product.price * quantity}`);
});
```

### Event Properties

```javascript
element.addEventListener('myevent', (e) => {
  // Standard event properties
  console.log('Type:', e.type);
  console.log('Target:', e.target);
  console.log('Current Target:', e.currentTarget);
  console.log('Bubbles:', e.bubbles);
  console.log('Cancelable:', e.cancelable);
  console.log('Timestamp:', e.timeStamp);
  
  // Custom data
  console.log('Detail:', e.detail);
});
```

---

## 3.12.4 Bubbling and Propagation

### Bubbling Custom Events

```javascript
// Child dispatches event
child.dispatchEvent(new CustomEvent('itemclick', {
  bubbles: true,
  detail: { itemId: 42 }
}));

// Parent can listen
parent.addEventListener('itemclick', (e) => {
  console.log('Item clicked:', e.detail.itemId);
  console.log('Event came from:', e.target);
});

// This is event delegation with custom events
```

### Stopping Propagation

```javascript
// Stop bubbling
element.addEventListener('myevent', (e) => {
  e.stopPropagation();
  // Event won't reach parent listeners
});

// Stop all handlers
element.addEventListener('myevent', (e) => {
  e.stopImmediatePropagation();
  // No more handlers, including on same element
});
```

### Cancelable Events

```javascript
// Make event cancelable
const event = new CustomEvent('beforeaction', {
  cancelable: true,
  detail: { action: 'delete' }
});

// Listener can prevent default
element.addEventListener('beforeaction', (e) => {
  if (!confirm(`Are you sure you want to ${e.detail.action}?`)) {
    e.preventDefault();
  }
});

// Check if cancelled
const result = element.dispatchEvent(event);

if (result) {
  // Event was not cancelled, proceed
  performAction();
} else {
  // Event was cancelled
  console.log('Action cancelled');
}
```

---

## 3.12.5 Common Patterns

### Event Emitter Component

```javascript
class EventEmitter {
  constructor() {
    this.target = document.createDocumentFragment();
  }
  
  on(type, listener) {
    this.target.addEventListener(type, listener);
  }
  
  off(type, listener) {
    this.target.removeEventListener(type, listener);
  }
  
  emit(type, detail = {}) {
    const event = new CustomEvent(type, { detail });
    this.target.dispatchEvent(event);
  }
  
  once(type, listener) {
    this.target.addEventListener(type, listener, { once: true });
  }
}

// Usage
const emitter = new EventEmitter();

emitter.on('message', (e) => {
  console.log('Message:', e.detail);
});

emitter.emit('message', { text: 'Hello!' });
```

### Component Communication

```javascript
// Cart Component
class CartComponent {
  constructor(element) {
    this.element = element;
    this.items = [];
  }
  
  addItem(product, quantity = 1) {
    this.items.push({ product, quantity });
    
    // Notify parent/other components
    this.element.dispatchEvent(new CustomEvent('cart:update', {
      bubbles: true,
      detail: {
        action: 'add',
        product,
        quantity,
        total: this.getTotal()
      }
    }));
  }
  
  getTotal() {
    return this.items.reduce((sum, item) => 
      sum + item.product.price * item.quantity, 0
    );
  }
}

// Header Component (listens for cart updates)
class HeaderComponent {
  constructor(element) {
    this.element = element;
    this.cartBadge = element.querySelector('.cart-badge');
    
    // Listen for cart events from anywhere in document
    document.addEventListener('cart:update', (e) => {
      this.updateCartBadge(e.detail);
    });
  }
  
  updateCartBadge({ total }) {
    this.cartBadge.textContent = `$${total.toFixed(2)}`;
  }
}
```

### Before/After Events

```javascript
class DataLoader {
  constructor(element) {
    this.element = element;
  }
  
  async load(url) {
    // Before event (cancelable)
    const beforeEvent = new CustomEvent('load:before', {
      cancelable: true,
      bubbles: true,
      detail: { url }
    });
    
    if (!this.element.dispatchEvent(beforeEvent)) {
      console.log('Load cancelled');
      return null;
    }
    
    try {
      const response = await fetch(url);
      const data = await response.json();
      
      // Success event
      this.element.dispatchEvent(new CustomEvent('load:success', {
        bubbles: true,
        detail: { url, data }
      }));
      
      return data;
    } catch (error) {
      // Error event
      this.element.dispatchEvent(new CustomEvent('load:error', {
        bubbles: true,
        detail: { url, error }
      }));
      
      throw error;
    } finally {
      // After event (always fires)
      this.element.dispatchEvent(new CustomEvent('load:after', {
        bubbles: true,
        detail: { url }
      }));
    }
  }
}
```

### Pub/Sub System

```javascript
class PubSub {
  constructor() {
    this.channel = new EventTarget();
  }
  
  subscribe(topic, callback) {
    const handler = (e) => callback(e.detail);
    this.channel.addEventListener(topic, handler);
    
    // Return unsubscribe function
    return () => this.channel.removeEventListener(topic, handler);
  }
  
  publish(topic, data) {
    this.channel.dispatchEvent(new CustomEvent(topic, {
      detail: data
    }));
  }
}

// Global pub/sub
const pubsub = new PubSub();

// Subscribe
const unsubscribe = pubsub.subscribe('user:login', (user) => {
  console.log('User logged in:', user.name);
});

// Publish
pubsub.publish('user:login', { id: 1, name: 'Alice' });

// Unsubscribe when done
unsubscribe();
```

### Event-Driven State Management

```javascript
class Store {
  constructor(initialState = {}) {
    this.state = initialState;
    this.channel = new EventTarget();
  }
  
  getState() {
    return { ...this.state };
  }
  
  setState(updates) {
    const prevState = this.state;
    this.state = { ...this.state, ...updates };
    
    // Emit change event with diff
    const changed = Object.keys(updates).filter(
      key => prevState[key] !== this.state[key]
    );
    
    this.channel.dispatchEvent(new CustomEvent('change', {
      detail: {
        state: this.getState(),
        prevState,
        changed
      }
    }));
  }
  
  subscribe(callback) {
    const handler = (e) => callback(e.detail);
    this.channel.addEventListener('change', handler);
    return () => this.channel.removeEventListener('change', handler);
  }
}

// Usage
const store = new Store({ count: 0, user: null });

store.subscribe(({ state, changed }) => {
  console.log('State changed:', changed);
  console.log('New state:', state);
});

store.setState({ count: 1 });
store.setState({ user: { name: 'Alice' } });
```

---

## 3.12.6 Shadow DOM and composed

```javascript
// Events and shadow DOM
class MyComponent extends HTMLElement {
  constructor() {
    super();
    this.attachShadow({ mode: 'open' });
    this.shadowRoot.innerHTML = `
      <button id="inner">Click me</button>
    `;
    
    this.shadowRoot.querySelector('#inner').addEventListener('click', () => {
      // composed: true allows event to cross shadow boundary
      this.dispatchEvent(new CustomEvent('inner-click', {
        bubbles: true,
        composed: true,
        detail: { source: 'inner button' }
      }));
    });
  }
}

customElements.define('my-component', MyComponent);

// External listener can receive the event
document.querySelector('my-component').addEventListener('inner-click', (e) => {
  console.log('Received:', e.detail);
});
```

---

## 3.12.7 Gotchas

```javascript
// ❌ Forgetting to set bubbles: true
element.dispatchEvent(new CustomEvent('myevent', {
  detail: { data: 123 }
}));
// Parent listeners won't receive this!

// ✅ Set bubbles: true for event delegation
element.dispatchEvent(new CustomEvent('myevent', {
  bubbles: true,
  detail: { data: 123 }
}));

// ❌ Modifying detail object after dispatch
const detail = { value: 1 };
element.dispatchEvent(new CustomEvent('event', { detail }));
detail.value = 2;  // Might affect listeners still processing!

// ✅ Consider detail immutable
const detail = Object.freeze({ value: 1 });

// ❌ Using Event instead of CustomEvent for data
const event = new Event('myevent');
event.detail = { data: 123 };  // Won't work as expected

// ✅ Use CustomEvent for detail
const event = new CustomEvent('myevent', {
  detail: { data: 123 }
});

// ❌ Expecting sync behavior with async handlers
element.dispatchEvent(new CustomEvent('fetch', { cancelable: true }));
// If handler is async, dispatchEvent returns before handler completes

// ✅ Use before/after pattern or promises
const event = new CustomEvent('beforefetch', { cancelable: true });
if (element.dispatchEvent(event)) {
  await doFetch();
  element.dispatchEvent(new CustomEvent('afterfetch'));
}
```

---

## 3.12.8 Summary

### CustomEvent Options

| Option | Default | Description |
|--------|---------|-------------|
| `detail` | `null` | Custom data to pass |
| `bubbles` | `false` | Event bubbles up DOM |
| `cancelable` | `false` | Can use `preventDefault()` |
| `composed` | `false` | Crosses shadow DOM |

### Key Methods

| Method | Description |
|--------|-------------|
| `new CustomEvent(type, options)` | Create event |
| `element.dispatchEvent(event)` | Fire event |
| `event.preventDefault()` | Cancel (if cancelable) |
| `event.stopPropagation()` | Stop bubbling |

### Event Data Access

| Property | Description |
|----------|-------------|
| `event.type` | Event name |
| `event.target` | Element that dispatched |
| `event.detail` | Custom data object |

### Best Practices

1. **Use `bubbles: true`** for event delegation
2. **Use `cancelable: true`** for before-action events
3. **Namespace event names** (`app:event`, `cart:update`)
4. **Use CustomEvent for data**, Event for simple signals
5. **Consider detail immutable** after dispatch
6. **Use `composed: true`** for shadow DOM crossing

---

**End of Chapter 3.12: Custom Events**

Next chapter: **3.13 Event Delegation** — covers efficient event handling patterns for dynamic content.
# 3.13 Event Delegation

Event delegation uses event bubbling to handle events on multiple elements with a single listener. This chapter covers delegation patterns, performance benefits, and handling dynamic content.

---

## 3.13.1 What Is Event Delegation?

### The Problem

```javascript
// ❌ Without delegation: listener per element
const buttons = document.querySelectorAll('.btn');

buttons.forEach(button => {
  button.addEventListener('click', handleClick);
});

// Problems:
// - Memory: 1000 buttons = 1000 listeners
// - Dynamic content: new buttons need manual listener attachment
// - Cleanup: must remove 1000 listeners on cleanup
```

### The Solution

```javascript
// ✅ With delegation: one listener on parent
const container = document.querySelector('.button-container');

container.addEventListener('click', (e) => {
  if (e.target.matches('.btn')) {
    handleClick(e);
  }
});

// Benefits:
// - Memory: 1 listener regardless of button count
// - Dynamic content: new buttons work automatically
// - Cleanup: remove 1 listener
```

---

## 3.13.2 Basic Delegation Pattern

### Using matches()

```javascript
// Check if clicked element matches selector
document.addEventListener('click', (e) => {
  // Handle button clicks
  if (e.target.matches('.btn')) {
    handleButton(e.target);
  }
  
  // Handle link clicks
  if (e.target.matches('a[data-ajax]')) {
    e.preventDefault();
    handleAjaxLink(e.target);
  }
  
  // Handle delete buttons
  if (e.target.matches('.delete-btn')) {
    e.preventDefault();
    handleDelete(e.target);
  }
});
```

### Using closest() for Nested Elements

```javascript
// Handle clicks on buttons OR their children
// <button class="btn"><span class="icon">✓</span> Submit</button>

document.addEventListener('click', (e) => {
  // ❌ Fails when clicking the icon
  if (e.target.matches('.btn')) {
    handleButton(e.target);
  }
  
  // ✅ Works for button or any child
  const button = e.target.closest('.btn');
  if (button) {
    handleButton(button);
  }
});

// closest() returns the element itself or nearest ancestor matching selector
```

---

## 3.13.3 Data Attributes with Delegation

### Using data-action

```javascript
// HTML
// <button data-action="save">Save</button>
// <button data-action="delete">Delete</button>
// <button data-action="cancel">Cancel</button>

const actions = {
  save: () => saveDocument(),
  delete: () => deleteDocument(),
  cancel: () => cancelEdit()
};

document.addEventListener('click', (e) => {
  const button = e.target.closest('[data-action]');
  
  if (button) {
    const action = button.dataset.action;
    
    if (actions[action]) {
      actions[action](button);
    }
  }
});
```

### Using data-id

```javascript
// HTML
// <li data-id="1">Item 1 <button class="edit">Edit</button></li>
// <li data-id="2">Item 2 <button class="edit">Edit</button></li>

list.addEventListener('click', (e) => {
  const editBtn = e.target.closest('.edit');
  
  if (editBtn) {
    const item = editBtn.closest('[data-id]');
    const id = item.dataset.id;
    
    editItem(id);
  }
});
```

---

## 3.13.4 Delegation for Dynamic Content

### Why It Works

```javascript
// Container exists when page loads
const list = document.querySelector('#todo-list');

// Single listener handles all items, even future ones
list.addEventListener('click', (e) => {
  const deleteBtn = e.target.closest('.delete');
  if (deleteBtn) {
    deleteBtn.closest('li').remove();
  }
  
  const checkbox = e.target.closest('input[type="checkbox"]');
  if (checkbox) {
    toggleComplete(checkbox);
  }
});

// Adding new items - they work immediately!
function addTodo(text) {
  const li = document.createElement('li');
  li.innerHTML = `
    <input type="checkbox">
    <span>${text}</span>
    <button class="delete">×</button>
  `;
  list.appendChild(li);
  // No need to add event listeners!
}
```

### Framework-like Component Pattern

```javascript
class TodoList {
  constructor(container) {
    this.container = container;
    this.items = [];
    
    // One listener for all interactions
    container.addEventListener('click', (e) => this.handleClick(e));
    container.addEventListener('change', (e) => this.handleChange(e));
  }
  
  handleClick(e) {
    const target = e.target;
    
    if (target.closest('.delete')) {
      const item = target.closest('[data-id]');
      this.deleteItem(item.dataset.id);
    }
    
    if (target.closest('.edit')) {
      const item = target.closest('[data-id]');
      this.editItem(item.dataset.id);
    }
    
    if (target.closest('.add')) {
      this.addItem();
    }
  }
  
  handleChange(e) {
    if (e.target.matches('input[type="checkbox"]')) {
      const item = e.target.closest('[data-id]');
      this.toggleItem(item.dataset.id, e.target.checked);
    }
  }
  
  render() {
    this.container.innerHTML = this.items.map(item => `
      <li data-id="${item.id}">
        <input type="checkbox" ${item.done ? 'checked' : ''}>
        <span>${item.text}</span>
        <button class="edit">Edit</button>
        <button class="delete">Delete</button>
      </li>
    `).join('');
  }
  
  deleteItem(id) { /* ... */ }
  editItem(id) { /* ... */ }
  addItem() { /* ... */ }
  toggleItem(id, done) { /* ... */ }
}
```

---

## 3.13.5 Delegation Scope

### Document-Level Delegation

```javascript
// Handle all clicks on the page
document.addEventListener('click', (e) => {
  // Modals
  if (e.target.closest('.modal-close')) {
    closeModal(e.target.closest('.modal'));
  }
  
  // Dropdowns
  if (!e.target.closest('.dropdown')) {
    closeAllDropdowns();
  }
  
  // Links
  if (e.target.closest('a[href^="#"]')) {
    e.preventDefault();
    smoothScrollTo(e.target.closest('a').hash);
  }
});
```

### Scoped Delegation

```javascript
// Limit scope to reduce unnecessary checks
const sidebar = document.querySelector('.sidebar');
const main = document.querySelector('.main-content');

// Sidebar-specific events
sidebar.addEventListener('click', (e) => {
  if (e.target.closest('.nav-link')) {
    handleNavigation(e.target.closest('.nav-link'));
  }
});

// Main content events
main.addEventListener('click', (e) => {
  if (e.target.closest('.card')) {
    handleCardClick(e.target.closest('.card'));
  }
});
```

---

## 3.13.6 Multiple Event Types

### Combined Delegation

```javascript
class InteractiveList {
  constructor(element) {
    this.element = element;
    
    // Multiple event types
    element.addEventListener('click', (e) => this.onClick(e));
    element.addEventListener('dblclick', (e) => this.onDblClick(e));
    element.addEventListener('keydown', (e) => this.onKeydown(e));
    element.addEventListener('focusin', (e) => this.onFocus(e));
    element.addEventListener('focusout', (e) => this.onBlur(e));
  }
  
  onClick(e) {
    const item = e.target.closest('.item');
    if (item) this.selectItem(item);
  }
  
  onDblClick(e) {
    const item = e.target.closest('.item');
    if (item) this.editItem(item);
  }
  
  onKeydown(e) {
    const item = e.target.closest('.item');
    if (!item) return;
    
    switch (e.key) {
      case 'Enter':
        this.activateItem(item);
        break;
      case 'Delete':
        this.deleteItem(item);
        break;
      case 'ArrowDown':
        this.focusNext(item);
        e.preventDefault();
        break;
      case 'ArrowUp':
        this.focusPrevious(item);
        e.preventDefault();
        break;
    }
  }
  
  onFocus(e) {
    const item = e.target.closest('.item');
    if (item) item.classList.add('focused');
  }
  
  onBlur(e) {
    const item = e.target.closest('.item');
    if (item) item.classList.remove('focused');
  }
  
  // ...methods
}
```

---

## 3.13.7 Performance Considerations

### When Delegation Helps

```javascript
// ✅ Many similar elements
const list = document.querySelector('#user-list');
list.addEventListener('click', handleUserClick);

// ✅ Frequently added/removed elements
const chat = document.querySelector('#chat-messages');
chat.addEventListener('click', handleMessageClick);

// ✅ Memory-constrained environments
// 1 listener vs thousands
```

### When Direct Listeners Are Fine

```javascript
// ✅ Few static elements
const submitBtn = document.querySelector('#submit');
submitBtn.addEventListener('click', handleSubmit);

// ✅ Unique handlers
const playBtn = document.querySelector('#play');
const pauseBtn = document.querySelector('#pause');

playBtn.addEventListener('click', play);
pauseBtn.addEventListener('click', pause);

// ✅ Complex event handling needing specific options
element.addEventListener('scroll', handler, { passive: true });
```

### Avoiding Over-Delegation

```javascript
// ❌ Too generic - checks every click
document.addEventListener('click', (e) => {
  // Inefficient if most clicks aren't handled
  if (e.target.closest('.specific-component .specific-button')) {
    // ...
  }
});

// ✅ Scope to relevant container
const component = document.querySelector('.specific-component');
component.addEventListener('click', (e) => {
  if (e.target.closest('.specific-button')) {
    // ...
  }
});
```

---

## 3.13.8 Common Patterns

### Table Row Actions

```javascript
const table = document.querySelector('table');

table.addEventListener('click', (e) => {
  const row = e.target.closest('tr');
  if (!row) return;
  
  const rowId = row.dataset.id;
  
  if (e.target.closest('.edit-btn')) {
    editRow(rowId);
  } else if (e.target.closest('.delete-btn')) {
    deleteRow(rowId);
  } else if (e.target.closest('.view-btn')) {
    viewRow(rowId);
  } else {
    // Click on row itself
    selectRow(row);
  }
});
```

### Accordion

```javascript
const accordion = document.querySelector('.accordion');

accordion.addEventListener('click', (e) => {
  const header = e.target.closest('.accordion-header');
  if (!header) return;
  
  const item = header.closest('.accordion-item');
  const content = item.querySelector('.accordion-content');
  
  // Close others (optional)
  accordion.querySelectorAll('.accordion-item.open').forEach(other => {
    if (other !== item) {
      other.classList.remove('open');
    }
  });
  
  // Toggle this one
  item.classList.toggle('open');
});
```

### Tab Panel

```javascript
const tabContainer = document.querySelector('.tabs');

tabContainer.addEventListener('click', (e) => {
  const tab = e.target.closest('[role="tab"]');
  if (!tab) return;
  
  // Update tab states
  tabContainer.querySelectorAll('[role="tab"]').forEach(t => {
    t.setAttribute('aria-selected', t === tab);
  });
  
  // Show corresponding panel
  const panelId = tab.getAttribute('aria-controls');
  const panels = document.querySelectorAll('[role="tabpanel"]');
  
  panels.forEach(panel => {
    panel.hidden = panel.id !== panelId;
  });
});
```

### Form Validation

```javascript
const form = document.querySelector('form');

form.addEventListener('focusout', (e) => {
  const input = e.target.closest('input, textarea, select');
  if (!input) return;
  
  validateField(input);
});

form.addEventListener('input', (e) => {
  const input = e.target.closest('input, textarea');
  if (!input) return;
  
  // Clear error on input
  clearError(input);
});
```

---

## 3.13.9 Gotchas

```javascript
// ❌ Stopping propagation breaks delegation
button.addEventListener('click', (e) => {
  e.stopPropagation();  // Parent delegation won't work!
});

// ✅ Be careful with stopPropagation
// Only use when intentionally blocking bubbling

// ❌ Forgetting to check with closest()
list.addEventListener('click', (e) => {
  if (e.target.classList.contains('item')) {  // Misses child clicks
    handleItem(e.target);
  }
});

// ✅ Use closest() for nested elements
list.addEventListener('click', (e) => {
  const item = e.target.closest('.item');
  if (item) {
    handleItem(item);
  }
});

// ❌ Events that don't bubble
container.addEventListener('focus', handler);  // Won't catch children!
container.addEventListener('blur', handler);

// ✅ Use focusin/focusout (they bubble)
container.addEventListener('focusin', handler);
container.addEventListener('focusout', handler);

// ❌ Relying on currentTarget in async code
container.addEventListener('click', async (e) => {
  await someAsyncOperation();
  console.log(e.currentTarget);  // Might be null!
});

// ✅ Store reference before async
container.addEventListener('click', async (e) => {
  const container = e.currentTarget;
  await someAsyncOperation();
  console.log(container);  // Safe
});
```

---

## 3.13.10 Summary

### Core Pattern

```javascript
// 1. Listen on parent/container
container.addEventListener('click', (e) => {
  // 2. Check what was clicked
  const target = e.target.closest('.selector');
  
  // 3. Handle if match found
  if (target) {
    handleElement(target);
  }
});
```

### Key Methods

| Method | Description |
|--------|-------------|
| `element.matches(selector)` | Check if element matches |
| `element.closest(selector)` | Find nearest matching ancestor |

### Events That Bubble

| Bubbles | Doesn't Bubble |
|---------|----------------|
| `click`, `dblclick` | `focus`, `blur` |
| `keydown`, `keyup` | `mouseenter`, `mouseleave` |
| `input`, `change` | `load`, `error` (on elements) |
| `submit`, `reset` | |
| `focusin`, `focusout` | |

### Best Practices

1. **Use `closest()` for nested elements** — handles child clicks
2. **Use `data-*` attributes** for action/id identification
3. **Scope to relevant container** — not always document
4. **Use `focusin`/`focusout`** instead of `focus`/`blur` for delegation
5. **Don't over-delegate** — balance with direct listeners
6. **Be careful with `stopPropagation`** — breaks parent delegation

### When to Delegate

| Delegate | Direct Listener |
|----------|-----------------|
| Many similar elements | Few static elements |
| Dynamic content | Unique handlers per element |
| Memory constrained | Special event options needed |

---

**End of Chapter 3.13: Event Delegation**

**End of Group 3: Events**

Next group: **4. Forms** — covers form elements, validation, FormData, and submission handling.
# 4.1 Form Elements

HTML form elements provide the foundation for user input in web applications. This chapter covers form controls, their properties, states, and how to interact with them via JavaScript.

---

## 4.1.1 The Form Element

### Basic Form Structure

```html
<!-- HTML form structure -->
<form id="contactForm" action="/submit" method="POST">
  <input type="text" name="username" id="username">
  <input type="email" name="email" id="email">
  <textarea name="message" id="message"></textarea>
  <button type="submit">Send</button>
</form>
```

```javascript
// Accessing forms
const form = document.getElementById('contactForm');
const formByName = document.forms['contactForm'];
const firstForm = document.forms[0];

// Form properties
console.log('Action:', form.action);
console.log('Method:', form.method);
console.log('Encoding:', form.enctype);
console.log('Name:', form.name);

// Modify form properties
form.action = '/new-endpoint';
form.method = 'GET';
```

### Form Attributes

```javascript
// Common form attributes
form.autocomplete = 'on';   // or 'off'
form.noValidate = true;     // Disable HTML5 validation
form.target = '_blank';     // Where to display response

// Check attributes
console.log(form.hasAttribute('novalidate'));
```

---

## 4.1.2 Input Elements

### Input Types

```javascript
// Get input element
const input = document.querySelector('input[name="username"]');

// Common input types and their special properties
const textInput = document.querySelector('input[type="text"]');
textInput.value = 'Hello';
textInput.placeholder = 'Enter your name';
textInput.maxLength = 50;
textInput.minLength = 2;
textInput.pattern = '[A-Za-z]+';

// Number input
const numberInput = document.querySelector('input[type="number"]');
numberInput.value = '42';
numberInput.min = '0';
numberInput.max = '100';
numberInput.step = '1';
console.log(numberInput.valueAsNumber);  // 42 (actual number)

// Date input
const dateInput = document.querySelector('input[type="date"]');
dateInput.value = '2024-01-15';
console.log(dateInput.valueAsDate);  // Date object
dateInput.min = '2024-01-01';
dateInput.max = '2024-12-31';

// Range input
const rangeInput = document.querySelector('input[type="range"]');
rangeInput.value = '50';
rangeInput.min = '0';
rangeInput.max = '100';
console.log(rangeInput.valueAsNumber);

// Color input
const colorInput = document.querySelector('input[type="color"]');
colorInput.value = '#ff0000';

// File input
const fileInput = document.querySelector('input[type="file"]');
console.log(fileInput.files);        // FileList
console.log(fileInput.accept);       // Accepted types
console.log(fileInput.multiple);     // Multiple files allowed?
```

### Checkbox and Radio

```javascript
// Checkbox
const checkbox = document.querySelector('input[type="checkbox"]');
console.log(checkbox.checked);       // true or false
checkbox.checked = true;             // Check it
checkbox.indeterminate = true;       // Set indeterminate state

// Listen for changes
checkbox.addEventListener('change', (e) => {
  console.log('Checked:', e.target.checked);
});

// Radio buttons
const radios = document.querySelectorAll('input[name="option"]');

radios.forEach(radio => {
  radio.addEventListener('change', (e) => {
    if (e.target.checked) {
      console.log('Selected:', e.target.value);
    }
  });
});

// Get selected radio value
function getSelectedRadio(name) {
  const checked = document.querySelector(`input[name="${name}"]:checked`);
  return checked ? checked.value : null;
}
```

### Hidden Input

```javascript
// Hidden inputs for form data
const hiddenInput = document.querySelector('input[type="hidden"]');
hiddenInput.value = 'secret-token';

// Create hidden input dynamically
const token = document.createElement('input');
token.type = 'hidden';
token.name = 'csrf_token';
token.value = generateToken();
form.appendChild(token);
```

---

## 4.1.3 Textarea Element

```javascript
// Textarea properties
const textarea = document.querySelector('textarea');

// Value
textarea.value = 'Initial content';
console.log(textarea.value);

// Size
textarea.rows = 10;
textarea.cols = 50;

// Length limits
textarea.maxLength = 1000;
textarea.minLength = 10;

// Wrapping
textarea.wrap = 'soft';  // or 'hard', 'off'

// Placeholder
textarea.placeholder = 'Enter your message...';

// Selection
console.log(textarea.selectionStart);
console.log(textarea.selectionEnd);
textarea.setSelectionRange(0, 5);  // Select first 5 chars

// Text manipulation
textarea.select();  // Select all
```

### Character Counter

```javascript
const textarea = document.querySelector('textarea');
const counter = document.querySelector('.char-count');
const maxLength = 280;

textarea.maxLength = maxLength;

textarea.addEventListener('input', (e) => {
  const remaining = maxLength - e.target.value.length;
  counter.textContent = `${remaining} characters remaining`;
  counter.classList.toggle('warning', remaining < 20);
});
```

---

## 4.1.4 Select Element

### Basic Select

```javascript
const select = document.querySelector('select');

// Access selected value
console.log(select.value);                  // Value of selected option
console.log(select.selectedIndex);          // Index of selected option
console.log(select.selectedOptions);        // HTMLCollection of selected

// Change selection
select.value = 'option2';
select.selectedIndex = 1;

// Access options
console.log(select.options);                // HTMLCollection of all options
console.log(select.options.length);
console.log(select.options[0].value);
console.log(select.options[0].text);
console.log(select.options[0].selected);

// Listen for changes
select.addEventListener('change', (e) => {
  console.log('Selected:', e.target.value);
});
```

### Multiple Select

```html
<select id="fruits" multiple>
  <option value="apple">Apple</option>
  <option value="banana">Banana</option>
  <option value="cherry">Cherry</option>
</select>
```

```javascript
const multiSelect = document.querySelector('#fruits');

// Get all selected values
function getSelectedValues(select) {
  return Array.from(select.selectedOptions).map(opt => opt.value);
}

multiSelect.addEventListener('change', (e) => {
  const selected = getSelectedValues(e.target);
  console.log('Selected:', selected);  // ['apple', 'cherry']
});

// Set multiple selections
function setSelectedValues(select, values) {
  Array.from(select.options).forEach(opt => {
    opt.selected = values.includes(opt.value);
  });
}
```

### Managing Options

```javascript
const select = document.querySelector('select');

// Add option
const newOption = document.createElement('option');
newOption.value = 'new';
newOption.text = 'New Option';
select.add(newOption);

// Or using Option constructor
select.add(new Option('Another Option', 'another'));

// Add at specific index
select.add(new Option('First', 'first'), 0);

// Remove option
select.remove(0);  // Remove first option

// Remove all options
select.length = 0;
// Or
while (select.options.length > 0) {
  select.remove(0);
}

// Populate from array
const data = [
  { value: 'us', text: 'United States' },
  { value: 'uk', text: 'United Kingdom' },
  { value: 'ca', text: 'Canada' }
];

data.forEach(item => {
  select.add(new Option(item.text, item.value));
});
```

### Optgroup

```html
<select id="car">
  <optgroup label="Swedish Cars">
    <option value="volvo">Volvo</option>
    <option value="saab">Saab</option>
  </optgroup>
  <optgroup label="German Cars">
    <option value="mercedes">Mercedes</option>
    <option value="audi">Audi</option>
  </optgroup>
</select>
```

```javascript
// Access optgroups
const select = document.querySelector('#car');

Array.from(select.options).forEach(opt => {
  if (opt.parentElement.tagName === 'OPTGROUP') {
    console.log(`${opt.text} (${opt.parentElement.label})`);
  }
});

// Create optgroup programmatically
const group = document.createElement('optgroup');
group.label = 'Japanese Cars';
group.appendChild(new Option('Toyota', 'toyota'));
group.appendChild(new Option('Honda', 'honda'));
select.appendChild(group);
```

---

## 4.1.5 Button Elements

### Button Types

```html
<button type="submit">Submit</button>
<button type="reset">Reset</button>
<button type="button">Click Me</button>
```

```javascript
// Submit button - triggers form submission
const submitBtn = document.querySelector('button[type="submit"]');

// Reset button - resets form to initial values
const resetBtn = document.querySelector('button[type="reset"]');

// Button - no default behavior
const btn = document.querySelector('button[type="button"]');

// Check button type
console.log(submitBtn.type);  // 'submit'

// Associated form
console.log(submitBtn.form);  // Parent form element

// Disable button
submitBtn.disabled = true;
```

### Button with Form Attribute

```html
<!-- Button outside form can target it -->
<form id="myForm">
  <input type="text" name="data">
</form>
<button type="submit" form="myForm">Submit</button>
```

```javascript
// Override form attributes
const submitBtn = document.querySelector('button[type="submit"]');
submitBtn.formAction = '/different-endpoint';
submitBtn.formMethod = 'GET';
submitBtn.formNoValidate = true;
submitBtn.formTarget = '_blank';
```

---

## 4.1.6 Common Element Properties

### Value Property

```javascript
// Getting and setting values
const input = document.querySelector('input');
const currentValue = input.value;
input.value = 'New value';

// Clear value
input.value = '';

// Default value (from HTML)
console.log(input.defaultValue);
input.value = input.defaultValue;  // Reset to default
```

### Disabled and Readonly

```javascript
const input = document.querySelector('input');

// Disabled - can't interact or submit
input.disabled = true;
console.log(input.disabled);  // true

// Readonly - can't edit but submits
input.readOnly = true;
console.log(input.readOnly);  // true

// Disable entire fieldset
const fieldset = document.querySelector('fieldset');
fieldset.disabled = true;  // Disables all contained elements
```

### Required and Autofocus

```javascript
const input = document.querySelector('input');

// Required
input.required = true;
console.log(input.required);

// Autofocus
input.autofocus = true;

// Programmatic focus
input.focus();
input.blur();

// Focus options
input.focus({ preventScroll: true });
```

### Name and ID

```javascript
const input = document.querySelector('input');

// Name (for form submission)
console.log(input.name);
input.name = 'newName';

// ID (for DOM access)
console.log(input.id);
input.id = 'newId';

// Access by name via form
const form = document.querySelector('form');
console.log(form.elements['username']);
console.log(form.elements.username);  // Same thing
```

---

## 4.1.7 Label Association

```html
<!-- Explicit association -->
<label for="email">Email:</label>
<input type="email" id="email">

<!-- Implicit association -->
<label>
  <input type="checkbox"> Remember me
</label>
```

```javascript
const input = document.querySelector('#email');

// Get associated labels
const labels = input.labels;  // NodeList of labels
console.log(labels[0].textContent);

// Get input from label
const label = document.querySelector('label[for="email"]');
const control = label.control;  // Associated input

// Create association programmatically
const newLabel = document.createElement('label');
newLabel.htmlFor = 'email';
newLabel.textContent = 'Email Address:';
```

---

## 4.1.8 Form Element Collection

### Accessing Form Elements

```javascript
const form = document.querySelector('form');

// All form elements
const elements = form.elements;  // HTMLFormControlsCollection
console.log(elements.length);

// Access by index
console.log(elements[0]);

// Access by name or id
console.log(elements['username']);
console.log(elements.username);

// Iterate
for (const element of elements) {
  console.log(element.name, element.value);
}

// Convert to array
const elementsArray = Array.from(elements);
const inputsOnly = elementsArray.filter(el => el.tagName === 'INPUT');
```

### Named Access

```javascript
const form = document.querySelector('form');

// When multiple elements have same name (radios)
const radios = form.elements['gender'];  // RadioNodeList

// RadioNodeList has .value property
console.log(radios.value);  // Value of selected radio

// Set by value
radios.value = 'female';  // Selects the radio with this value
```

---

## 4.1.9 Gotchas

```javascript
// ❌ Using innerHTML to change input value
input.innerHTML = 'New value';  // Wrong!

// ✅ Use value property
input.value = 'New value';

// ❌ Confusing value and defaultValue
input.value = 'Changed';
console.log(input.value);         // 'Changed'
console.log(input.defaultValue);  // Still original from HTML

// ❌ Checkbox checked vs value
const checkbox = document.querySelector('input[type="checkbox"]');
console.log(checkbox.value);    // Always returns 'on' or custom value
console.log(checkbox.checked);  // true/false - what you usually want

// ❌ Select value when no option selected
const select = document.querySelector('select');
// If no option is selected, value is empty string

// ✅ Handle empty case
const value = select.value || select.options[0]?.value;

// ❌ Forgetting form doesn't include disabled elements
const formData = new FormData(form);
// Disabled inputs are NOT included!

// ✅ Use readonly if you want value included but not editable
input.readOnly = true;  // Value will be in FormData
```

---

## 4.1.10 Summary

### Element Types

| Element | Key Properties |
|---------|---------------|
| `<form>` | `action`, `method`, `elements`, `submit()`, `reset()` |
| `<input>` | `type`, `value`, `checked`, `files`, `valueAsNumber` |
| `<textarea>` | `value`, `rows`, `cols`, `selectionStart/End` |
| `<select>` | `value`, `selectedIndex`, `options`, `selectedOptions` |
| `<button>` | `type`, `form`, `disabled`, `formAction` |

### State Properties

| Property | Description |
|----------|-------------|
| `value` | Current value |
| `defaultValue` | Initial value from HTML |
| `checked` | Checkbox/radio state |
| `selected` | Option selection state |
| `disabled` | Can't interact or submit |
| `readOnly` | Can't edit but submits |
| `required` | Must have value |

### Best Practices

1. **Use `.value` for input values**, not innerHTML
2. **Use `.checked` for checkboxes/radios**, not value
3. **Use `readonly` over `disabled`** if value should submit
4. **Use labels** with `for` attribute for accessibility
5. **Use `form.elements`** to access form controls by name
6. **Handle multiple select** with `selectedOptions`

---

**End of Chapter 4.1: Form Elements**

Next chapter: **4.2 Form API** — covers form methods, submission, reset, and focus management.
# 4.2 Form API

The Form API provides methods and properties for programmatic form control, submission handling, and element management. This chapter covers form methods, programmatic submission, reset functionality, and focus management.

---

## 4.2.1 Accessing Form Elements

### form.elements

```javascript
const form = document.querySelector('form');

// HTMLFormControlsCollection of all controls
const elements = form.elements;

console.log(elements.length);           // Number of controls
console.log(elements[0]);               // First element
console.log(elements['username']);      // By name
console.log(elements.username);         // Same thing
console.log(elements.namedItem('email')); // Explicit method

// Iterate over elements
for (const element of elements) {
  if (element.name) {
    console.log(`${element.name}: ${element.value}`);
  }
}

// Filter to specific types
const inputs = Array.from(elements).filter(
  el => el.tagName === 'INPUT'
);
```

### Named Elements

```javascript
// Access elements by name attribute
const form = document.querySelector('form');

// Single element with unique name
const username = form.elements['username'];

// Multiple elements with same name (radios)
const genderRadios = form.elements['gender'];
// Returns RadioNodeList

console.log(genderRadios.value);  // Value of selected radio

// Iterate over radio group
for (const radio of genderRadios) {
  console.log(radio.value, radio.checked);
}
```

---

## 4.2.2 Form Submission

### submit() Method

```javascript
const form = document.querySelector('form');

// Programmatic submission
form.submit();

// ⚠️ submit() does NOT trigger 'submit' event
// ⚠️ submit() does NOT run HTML5 validation

// Use case: submitting after async validation
async function handleSubmit() {
  const isValid = await validateOnServer();
  if (isValid) {
    form.submit();  // Direct submission
  }
}
```

### requestSubmit() Method

```javascript
const form = document.querySelector('form');

// Triggers submit event and validation
form.requestSubmit();

// Optionally specify submitter button
const submitBtn = form.querySelector('button[type="submit"]');
form.requestSubmit(submitBtn);

// ✅ requestSubmit() DOES trigger 'submit' event
// ✅ requestSubmit() DOES run HTML5 validation
form.addEventListener('submit', (e) => {
  e.preventDefault();
  console.log('Submit event fired');
});

// Difference summary:
// submit() - bypasses events and validation
// requestSubmit() - triggers events and validation
```

### Handling Submission

```javascript
const form = document.querySelector('form');

form.addEventListener('submit', async (e) => {
  e.preventDefault();  // Prevent page reload
  
  const formData = new FormData(form);
  const submitButton = e.submitter;  // Which button was clicked
  
  // Disable form during submission
  const elements = form.elements;
  for (const el of elements) {
    el.disabled = true;
  }
  
  try {
    const response = await fetch(form.action, {
      method: form.method,
      body: formData
    });
    
    if (response.ok) {
      showSuccess();
    } else {
      showError('Submission failed');
    }
  } catch (error) {
    showError(error.message);
  } finally {
    // Re-enable form
    for (const el of elements) {
      el.disabled = false;
    }
  }
});
```

### The submitter Property

```javascript
// HTML
// <form>
//   <button type="submit" name="action" value="save">Save</button>
//   <button type="submit" name="action" value="publish">Publish</button>
// </form>

form.addEventListener('submit', (e) => {
  e.preventDefault();
  
  // Which button triggered submission?
  const submitter = e.submitter;
  
  if (submitter) {
    console.log('Submitter:', submitter.name, submitter.value);
    // 'action', 'save' or 'action', 'publish'
  }
  
  // Include submitter value in FormData
  const formData = new FormData(form, submitter);
});
```

---

## 4.2.3 Form Reset

### reset() Method

```javascript
const form = document.querySelector('form');

// Reset all fields to default values
form.reset();

// ⚠️ Resets to defaultValue/defaultChecked, not empty

// Listen for reset
form.addEventListener('reset', (e) => {
  console.log('Form was reset');
  
  // Optionally prevent
  if (!confirm('Clear all fields?')) {
    e.preventDefault();
  }
});
```

### Custom Reset

```javascript
// Clear all values (not just reset to defaults)
function clearForm(form) {
  for (const element of form.elements) {
    switch (element.type) {
      case 'text':
      case 'email':
      case 'password':
      case 'textarea':
      case 'tel':
      case 'url':
      case 'search':
      case 'number':
        element.value = '';
        break;
        
      case 'checkbox':
      case 'radio':
        element.checked = false;
        break;
        
      case 'select-one':
      case 'select-multiple':
        element.selectedIndex = -1;
        break;
        
      case 'file':
        element.value = '';
        break;
    }
  }
}

// Restore form to server state
async function resetToServerState(form) {
  const response = await fetch(`/api/forms/${form.dataset.id}`);
  const data = await response.json();
  
  for (const [name, value] of Object.entries(data)) {
    const element = form.elements[name];
    if (element) {
      if (element.type === 'checkbox') {
        element.checked = value;
      } else {
        element.value = value;
      }
    }
  }
}
```

---

## 4.2.4 Focus Management

### focus() and blur()

```javascript
const input = document.querySelector('input');

// Give focus
input.focus();

// Focus with options
input.focus({
  preventScroll: true  // Don't scroll to element
});

// Remove focus
input.blur();

// Check focus state
console.log(document.activeElement);  // Currently focused element
console.log(document.activeElement === input);  // Is this focused?
```

### Focus Events

```javascript
const input = document.querySelector('input');

// Element receives focus
input.addEventListener('focus', (e) => {
  console.log('Input focused');
  e.target.classList.add('focused');
});

// Element loses focus
input.addEventListener('blur', (e) => {
  console.log('Input blurred');
  e.target.classList.remove('focused');
  validateField(e.target);
});

// Bubbling versions (for delegation)
form.addEventListener('focusin', (e) => {
  console.log('Focus moved to:', e.target.name);
});

form.addEventListener('focusout', (e) => {
  console.log('Focus left:', e.target.name);
});
```

### Auto-Focus First Invalid

```javascript
function focusFirstInvalid(form) {
  for (const element of form.elements) {
    if (!element.validity.valid) {
      element.focus();
      element.scrollIntoView({ behavior: 'smooth', block: 'center' });
      return element;
    }
  }
  return null;
}

form.addEventListener('submit', (e) => {
  if (!form.checkValidity()) {
    e.preventDefault();
    focusFirstInvalid(form);
  }
});
```

### Tab Order

```javascript
// Control tab order with tabindex
const inputs = document.querySelectorAll('input');

// tabindex="0" - normal order
// tabindex="1+" - before normal elements, lower numbers first
// tabindex="-1" - skip in tab order, but focusable via JS

// Make element focusable but skip tab order
const div = document.querySelector('.custom-widget');
div.tabIndex = -1;
div.focus();  // Works

// Set programmatic tab order
inputs[0].tabIndex = 2;
inputs[1].tabIndex = 1;  // This will be focused first

// Manage focus within custom widget
class FocusTrap {
  constructor(container) {
    this.container = container;
    this.focusable = container.querySelectorAll(
      'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
    );
    this.first = this.focusable[0];
    this.last = this.focusable[this.focusable.length - 1];
  }
  
  activate() {
    this.container.addEventListener('keydown', this.handleKeydown.bind(this));
    this.first?.focus();
  }
  
  handleKeydown(e) {
    if (e.key !== 'Tab') return;
    
    if (e.shiftKey && document.activeElement === this.first) {
      e.preventDefault();
      this.last?.focus();
    } else if (!e.shiftKey && document.activeElement === this.last) {
      e.preventDefault();
      this.first?.focus();
    }
  }
}
```

---

## 4.2.5 Selection Methods

### select()

```javascript
const input = document.querySelector('input[type="text"]');

// Select all text
input.select();

// Triggered on text selection
input.addEventListener('select', (e) => {
  const selected = e.target.value.substring(
    e.target.selectionStart,
    e.target.selectionEnd
  );
  console.log('Selected:', selected);
});
```

### setSelectionRange()

```javascript
const input = document.querySelector('input[type="text"]');
input.value = 'Hello World';

// Select specific range
input.setSelectionRange(0, 5);  // Selects "Hello"
input.focus();  // Must focus to show selection

// Selection properties
console.log(input.selectionStart);      // 0
console.log(input.selectionEnd);        // 5
console.log(input.selectionDirection);  // 'forward' or 'backward'

// Set cursor position (collapsed selection)
input.setSelectionRange(5, 5);  // Cursor after "Hello"

// Select with direction
input.setSelectionRange(0, 5, 'backward');
```

### setRangeText()

```javascript
const input = document.querySelector('input[type="text"]');
input.value = 'Hello World';

// Replace selection (or insert at cursor)
input.setSelectionRange(0, 5);
input.setRangeText('Hi');  // 'Hi World'

// Replace specific range
input.setRangeText('Goodbye', 0, 5);  // 'Goodbye World'

// With selection mode
input.setRangeText('inserted', 6, 6, 'end');
// 'Hello insertedWorld', cursor at end of inserted text

// Selection modes:
// 'select' - select the newly inserted text
// 'start' - cursor at start of inserted text
// 'end' - cursor at end of inserted text
// 'preserve' - attempt to preserve existing selection
```

---

## 4.2.6 Disabled and Readonly States

### Managing Disabled State

```javascript
const input = document.querySelector('input');
const form = document.querySelector('form');

// Disable individual element
input.disabled = true;
console.log(input.disabled);  // true

// Disabled elements:
// - Can't be focused
// - Don't respond to events
// - NOT included in FormData
// - Grayed out appearance

// Enable
input.disabled = false;

// Disable entire fieldset
const fieldset = document.querySelector('fieldset');
fieldset.disabled = true;
// All contained inputs are now disabled

// Disable whole form
function disableForm(form, disabled = true) {
  for (const element of form.elements) {
    element.disabled = disabled;
  }
}
```

### Readonly State

```javascript
const input = document.querySelector('input');

// Readonly
input.readOnly = true;

// Readonly elements:
// - Can be focused
// - Respond to events (but not input)
// - ARE included in FormData
// - No visual change (must style manually)

// Use readonly for:
// - Display-only fields that should submit
// - Computed values

// Use disabled for:
// - Truly inactive fields
// - Fields that shouldn't submit
```

---

## 4.2.7 Form State Management

### Tracking Dirty State

```javascript
class FormState {
  constructor(form) {
    this.form = form;
    this.initialState = this.captureState();
    this.isDirty = false;
    
    form.addEventListener('input', () => this.checkDirty());
    form.addEventListener('change', () => this.checkDirty());
  }
  
  captureState() {
    const state = {};
    
    for (const element of this.form.elements) {
      if (!element.name) continue;
      
      if (element.type === 'checkbox') {
        state[element.name] = element.checked;
      } else if (element.type === 'radio') {
        if (element.checked) {
          state[element.name] = element.value;
        }
      } else {
        state[element.name] = element.value;
      }
    }
    
    return state;
  }
  
  checkDirty() {
    const currentState = this.captureState();
    this.isDirty = JSON.stringify(currentState) !== JSON.stringify(this.initialState);
    
    // Optionally warn before leaving
    if (this.isDirty) {
      window.onbeforeunload = () => '';
    } else {
      window.onbeforeunload = null;
    }
  }
  
  reset() {
    this.form.reset();
    this.isDirty = false;
  }
  
  markClean() {
    this.initialState = this.captureState();
    this.isDirty = false;
    window.onbeforeunload = null;
  }
}

// Usage
const formState = new FormState(form);

form.addEventListener('submit', async (e) => {
  e.preventDefault();
  await submitForm();
  formState.markClean();
});
```

---

## 4.2.8 Common Patterns

### Dynamic Form Fields

```javascript
class DynamicFieldList {
  constructor(container, template) {
    this.container = container;
    this.template = template;
    this.fieldCount = 0;
    
    this.addButton = container.querySelector('.add-field');
    this.addButton.addEventListener('click', () => this.addField());
    
    container.addEventListener('click', (e) => {
      if (e.target.matches('.remove-field')) {
        this.removeField(e.target.closest('.field-row'));
      }
    });
  }
  
  addField() {
    const field = this.template.cloneNode(true);
    const index = this.fieldCount++;
    
    // Update names with index
    field.querySelectorAll('[name]').forEach(el => {
      el.name = el.name.replace('[]', `[${index}]`);
    });
    
    this.container.insertBefore(field, this.addButton);
  }
  
  removeField(row) {
    row.remove();
  }
}
```

### Conditional Fields

```javascript
// Show/hide fields based on selection
const typeSelect = document.querySelector('#type');
const conditionalSections = {
  business: document.querySelector('.business-fields'),
  personal: document.querySelector('.personal-fields')
};

typeSelect.addEventListener('change', (e) => {
  const selectedType = e.target.value;
  
  Object.entries(conditionalSections).forEach(([type, section]) => {
    const shouldShow = type === selectedType;
    section.hidden = !shouldShow;
    
    // Disable hidden fields so they don't submit
    section.querySelectorAll('input, select, textarea').forEach(field => {
      field.disabled = !shouldShow;
    });
  });
});
```

---

## 4.2.9 Gotchas

```javascript
// ❌ submit() triggers submit event
form.submit();  // Event NOT fired, validation NOT run

// ✅ Use requestSubmit() to trigger event and validation
form.requestSubmit();

// ❌ Expecting reset() to clear fields
form.reset();  // Resets to DEFAULT values, not empty

// ✅ Clear manually if needed
for (const el of form.elements) {
  if (el.type !== 'submit') el.value = '';
}

// ❌ Disabled elements in FormData
input.disabled = true;
const data = new FormData(form);
// disabled input NOT in data!

// ✅ Use readonly if value must submit
input.readOnly = true;
// Value IS in FormData

// ❌ Missing focus() after setSelectionRange()
input.setSelectionRange(0, 5);  // Selection set but not visible

// ✅ Focus to show selection
input.setSelectionRange(0, 5);
input.focus();

// ❌ Relying on form.elements index order
const first = form.elements[0];  // Might change with DOM changes

// ✅ Use name access
const username = form.elements['username'];
```

---

## 4.2.10 Summary

### Form Methods

| Method | Description |
|--------|-------------|
| `submit()` | Submit without event/validation |
| `requestSubmit()` | Submit with event/validation |
| `reset()` | Reset to default values |
| `checkValidity()` | Check all fields valid |
| `reportValidity()` | Check and show validation UI |

### Element Methods

| Method | Description |
|--------|-------------|
| `focus()` | Give focus to element |
| `blur()` | Remove focus |
| `select()` | Select all text |
| `setSelectionRange()` | Select specific range |
| `setRangeText()` | Replace text range |

### Properties

| Property | Description |
|----------|-------------|
| `form.elements` | All form controls |
| `element.form` | Parent form |
| `element.disabled` | Can't interact, won't submit |
| `element.readOnly` | Can't edit, will submit |
| `e.submitter` | Button that triggered submit |

### Best Practices

1. **Use `requestSubmit()` over `submit()`** for proper events
2. **Handle both `disabled` and `readonly`** appropriately
3. **Track dirty state** for unsaved changes warning
4. **Focus first invalid field** on validation failure
5. **Disable form during async submission**
6. **Use `focusin`/`focusout`** for event delegation

---

**End of Chapter 4.2: Form API**

Next chapter: **4.3 Form Validation** — covers HTML5 validation, Constraint Validation API, and custom validation.
# 4.3 Form Validation

Form validation ensures user input meets requirements before submission. This chapter covers HTML5 built-in validation, the Constraint Validation API, custom validation logic, and validation UX patterns.

---

## 4.3.1 HTML5 Validation Attributes

### Required

```html
<input type="text" name="username" required>
<select name="country" required>
  <option value="">Select country</option>
  <option value="us">United States</option>
</select>
<textarea name="message" required></textarea>
```

```javascript
const input = document.querySelector('input');

// Check/set required programmatically
console.log(input.required);  // true
input.required = false;

// Validation state
console.log(input.validity.valueMissing);  // true if empty and required
```

### Pattern

```html
<!-- Regular expression validation -->
<input type="text" name="username" pattern="[A-Za-z0-9]{3,16}"
       title="3-16 alphanumeric characters">

<input type="text" name="phone" pattern="\d{3}-\d{3}-\d{4}"
       title="Format: 123-456-7890">
```

```javascript
const input = document.querySelector('input');

// Set pattern programmatically
input.pattern = '^[A-Z]{2}\\d{6}$';  // Note escaped backslash

// Check validation state
console.log(input.validity.patternMismatch);  // true if doesn't match
```

### Length Constraints

```html
<input type="text" name="bio" minlength="10" maxlength="100">
<textarea minlength="50" maxlength="500"></textarea>
```

```javascript
const input = document.querySelector('input');

input.minLength = 5;
input.maxLength = 20;

// Validation states
console.log(input.validity.tooShort);  // true if < minlength
console.log(input.validity.tooLong);   // true if > maxlength (rare, usually prevented)
```

### Number Constraints

```html
<input type="number" min="0" max="100" step="5">
<input type="date" min="2024-01-01" max="2024-12-31">
<input type="time" min="09:00" max="17:00">
```

```javascript
const numberInput = document.querySelector('input[type="number"]');

numberInput.min = '0';
numberInput.max = '100';
numberInput.step = '5';

// Validation states
console.log(numberInput.validity.rangeUnderflow);  // true if < min
console.log(numberInput.validity.rangeOverflow);   // true if > max
console.log(numberInput.validity.stepMismatch);    // true if not multiple of step

// Step up/down methods
numberInput.stepUp();    // Increase by step
numberInput.stepUp(2);   // Increase by step * 2
numberInput.stepDown();
```

### Type Validation

```html
<!-- Built-in type validation -->
<input type="email" name="email">
<input type="url" name="website">
<input type="tel" name="phone">  <!-- Note: tel has no built-in validation -->
```

```javascript
const emailInput = document.querySelector('input[type="email"]');

// Check validation
console.log(emailInput.validity.typeMismatch);  // true if invalid email format

// Type validation is automatic for:
// - email: checks for @ and domain
// - url: checks for protocol and valid format
// - number: checks for numeric value
```

---

## 4.3.2 Constraint Validation API

### ValidityState Object

```javascript
const input = document.querySelector('input');

// Access validity state
const validity = input.validity;

console.log({
  // Overall validity
  valid: validity.valid,
  
  // Specific validity flags
  valueMissing: validity.valueMissing,       // required but empty
  typeMismatch: validity.typeMismatch,       // wrong type (email, url)
  patternMismatch: validity.patternMismatch, // doesn't match pattern
  tooShort: validity.tooShort,               // shorter than minlength
  tooLong: validity.tooLong,                 // longer than maxlength
  rangeUnderflow: validity.rangeUnderflow,   // less than min
  rangeOverflow: validity.rangeOverflow,     // greater than max
  stepMismatch: validity.stepMismatch,       // not multiple of step
  badInput: validity.badInput,               // unparseable (e.g., letters in number)
  customError: validity.customError          // setCustomValidity was called
});
```

### checkValidity() and reportValidity()

```javascript
const form = document.querySelector('form');
const input = document.querySelector('input');

// Check validity silently
const inputValid = input.checkValidity();   // Returns boolean
const formValid = form.checkValidity();     // Checks all fields

// Check validity and show browser UI
const inputShown = input.reportValidity();  // Shows error if invalid
const formShown = form.reportValidity();    // Shows first error

// Difference:
// checkValidity() - just returns true/false
// reportValidity() - returns true/false AND shows browser validation message
```

### validationMessage

```javascript
const input = document.querySelector('input');

// Get browser's validation message
console.log(input.validationMessage);
// e.g., "Please fill out this field."
// e.g., "Please enter an email address."

// Message is empty string if valid
if (input.validationMessage) {
  console.log('Invalid:', input.validationMessage);
}
```

### setCustomValidity()

```javascript
const input = document.querySelector('input');

// Set custom error message
input.setCustomValidity('Username is already taken');
console.log(input.validity.customError);  // true
console.log(input.validationMessage);     // 'Username is already taken'

// Clear custom error (IMPORTANT!)
input.setCustomValidity('');
console.log(input.validity.valid);  // Now checks other constraints

// Pattern: validate on input
input.addEventListener('input', async (e) => {
  const value = e.target.value;
  
  // Clear any previous custom error
  e.target.setCustomValidity('');
  
  // Check custom validation
  if (value && !isValidUsername(value)) {
    e.target.setCustomValidity('Username must start with a letter');
  } else if (value && await isUsernameTaken(value)) {
    e.target.setCustomValidity('This username is already taken');
  }
});
```

---

## 4.3.3 Handling Validation Events

### invalid Event

```javascript
const input = document.querySelector('input');

// Fires when validation fails
input.addEventListener('invalid', (e) => {
  console.log('Input is invalid:', e.target.validationMessage);
  
  // Prevent browser's default error UI
  e.preventDefault();
  
  // Show custom error UI
  showCustomError(e.target);
});

// invalid fires when:
// - form.submit() or form.requestSubmit() is called
// - form.checkValidity() or form.reportValidity() is called
// - input.checkValidity() or input.reportValidity() is called
```

### Form-Level Validation

```javascript
const form = document.querySelector('form');

form.addEventListener('submit', (e) => {
  // Prevent if invalid
  if (!form.checkValidity()) {
    e.preventDefault();
    
    // Handle invalid fields
    const firstInvalid = form.querySelector(':invalid');
    firstInvalid.focus();
    
    return;
  }
  
  // Form is valid, proceed
  handleSubmit();
});

// Custom validation before submit
form.addEventListener('submit', async (e) => {
  e.preventDefault();
  
  // Run async validations
  const errors = await validateAsync(form);
  
  if (errors.length > 0) {
    displayErrors(errors);
    return;
  }
  
  // Submit
  form.submit();
});
```

### Disabling Browser Validation

```html
<!-- Disable validation on form -->
<form novalidate>
  <input type="email" name="email">
  <button type="submit">Submit</button>
</form>
```

```javascript
const form = document.querySelector('form');

// Disable validation programmatically
form.noValidate = true;

// Re-enable
form.noValidate = false;

// With novalidate, browser won't:
// - Show validation messages
// - Prevent invalid submission
// You handle everything manually
```

---

## 4.3.4 Custom Validation

### Synchronous Validation

```javascript
function validatePassword(input) {
  const value = input.value;
  
  if (value.length < 8) {
    input.setCustomValidity('Password must be at least 8 characters');
    return false;
  }
  
  if (!/[A-Z]/.test(value)) {
    input.setCustomValidity('Password must contain uppercase letter');
    return false;
  }
  
  if (!/[a-z]/.test(value)) {
    input.setCustomValidity('Password must contain lowercase letter');
    return false;
  }
  
  if (!/[0-9]/.test(value)) {
    input.setCustomValidity('Password must contain number');
    return false;
  }
  
  // Clear error
  input.setCustomValidity('');
  return true;
}

password.addEventListener('input', (e) => {
  validatePassword(e.target);
});
```

### Asynchronous Validation

```javascript
const usernameInput = document.querySelector('#username');
let validationTimeout;

usernameInput.addEventListener('input', (e) => {
  const input = e.target;
  const value = input.value;
  
  // Clear previous timeout
  clearTimeout(validationTimeout);
  
  // Clear previous error
  input.setCustomValidity('');
  
  // Basic validation first
  if (value.length < 3) {
    input.setCustomValidity('Username must be at least 3 characters');
    return;
  }
  
  // Debounce async check
  validationTimeout = setTimeout(async () => {
    try {
      const response = await fetch(`/api/check-username?username=${value}`);
      const { available } = await response.json();
      
      if (!available) {
        input.setCustomValidity('This username is already taken');
      }
      
      // Optionally update UI
      updateValidationUI(input);
    } catch (error) {
      console.error('Validation failed:', error);
    }
  }, 300);
});
```

### Cross-Field Validation

```javascript
const form = document.querySelector('form');
const password = document.querySelector('#password');
const confirmPassword = document.querySelector('#confirmPassword');

// Validate confirm matches password
function validatePasswordMatch() {
  if (confirmPassword.value !== password.value) {
    confirmPassword.setCustomValidity('Passwords do not match');
  } else {
    confirmPassword.setCustomValidity('');
  }
}

password.addEventListener('input', validatePasswordMatch);
confirmPassword.addEventListener('input', validatePasswordMatch);

// Start/end date validation
const startDate = document.querySelector('#startDate');
const endDate = document.querySelector('#endDate');

function validateDates() {
  if (startDate.value && endDate.value) {
    if (new Date(endDate.value) <= new Date(startDate.value)) {
      endDate.setCustomValidity('End date must be after start date');
    } else {
      endDate.setCustomValidity('');
    }
  }
}

startDate.addEventListener('change', validateDates);
endDate.addEventListener('change', validateDates);
```

---

## 4.3.5 Custom Validation UI

### Replacing Browser UI

```javascript
const form = document.querySelector('form');

// Disable browser validation UI
form.noValidate = true;

form.addEventListener('submit', (e) => {
  e.preventDefault();
  
  // Clear previous errors
  clearErrors();
  
  let isValid = true;
  
  for (const element of form.elements) {
    if (!element.name) continue;
    
    if (!element.checkValidity()) {
      isValid = false;
      showError(element, element.validationMessage);
    }
  }
  
  if (isValid) {
    submitForm(form);
  } else {
    // Focus first invalid
    form.querySelector('.error')?.focus();
  }
});

function showError(element, message) {
  element.classList.add('error');
  
  const errorDiv = document.createElement('div');
  errorDiv.className = 'error-message';
  errorDiv.textContent = message;
  errorDiv.id = `${element.name}-error`;
  
  element.setAttribute('aria-describedby', errorDiv.id);
  element.after(errorDiv);
}

function clearErrors() {
  document.querySelectorAll('.error').forEach(el => {
    el.classList.remove('error');
    el.removeAttribute('aria-describedby');
  });
  
  document.querySelectorAll('.error-message').forEach(el => {
    el.remove();
  });
}
```

### Real-Time Validation UI

```javascript
class FormValidator {
  constructor(form) {
    this.form = form;
    form.noValidate = true;
    
    form.addEventListener('submit', (e) => this.handleSubmit(e));
    form.addEventListener('blur', (e) => this.handleBlur(e), true);
    form.addEventListener('input', (e) => this.handleInput(e));
  }
  
  handleSubmit(e) {
    e.preventDefault();
    
    let firstInvalid = null;
    
    for (const element of this.form.elements) {
      if (element.name) {
        const isValid = this.validateElement(element);
        if (!isValid && !firstInvalid) {
          firstInvalid = element;
        }
      }
    }
    
    if (firstInvalid) {
      firstInvalid.focus();
    } else {
      this.submitForm();
    }
  }
  
  handleBlur(e) {
    const element = e.target;
    if (element.name && element.value) {
      this.validateElement(element);
    }
  }
  
  handleInput(e) {
    const element = e.target;
    // Only clear errors on input if already shown
    if (element.classList.contains('invalid')) {
      this.validateElement(element);
    }
  }
  
  validateElement(element) {
    const isValid = element.checkValidity();
    
    element.classList.toggle('invalid', !isValid);
    element.classList.toggle('valid', isValid);
    
    const errorContainer = this.getErrorContainer(element);
    errorContainer.textContent = isValid ? '' : element.validationMessage;
    
    return isValid;
  }
  
  getErrorContainer(element) {
    let container = element.parentElement.querySelector('.error-text');
    if (!container) {
      container = document.createElement('span');
      container.className = 'error-text';
      element.after(container);
    }
    return container;
  }
  
  submitForm() {
    // Submit logic
  }
}
```

---

## 4.3.6 Accessibility

### ARIA Attributes

```javascript
function setFieldError(element, message) {
  const errorId = `${element.id}-error`;
  
  // Mark as invalid
  element.setAttribute('aria-invalid', 'true');
  element.setAttribute('aria-describedby', errorId);
  
  // Create/update error message
  let errorEl = document.getElementById(errorId);
  if (!errorEl) {
    errorEl = document.createElement('div');
    errorEl.id = errorId;
    errorEl.className = 'error-message';
    errorEl.setAttribute('aria-live', 'polite');
    element.after(errorEl);
  }
  errorEl.textContent = message;
}

function clearFieldError(element) {
  element.removeAttribute('aria-invalid');
  
  const errorId = `${element.id}-error`;
  const errorEl = document.getElementById(errorId);
  
  if (errorEl) {
    errorEl.textContent = '';
  }
}
```

### Form Validation Pattern

```html
<form novalidate>
  <div class="field">
    <label for="email">Email *</label>
    <input type="email" id="email" name="email" required
           aria-describedby="email-hint email-error">
    <span id="email-hint" class="hint">We'll never share your email</span>
    <span id="email-error" class="error" aria-live="polite"></span>
  </div>
</form>
```

---

## 4.3.7 Validation Patterns

### On Submit Only

```javascript
form.addEventListener('submit', (e) => {
  if (!form.checkValidity()) {
    e.preventDefault();
    form.reportValidity();
  }
});
```

### On Blur

```javascript
form.addEventListener('blur', (e) => {
  if (e.target.matches('input, textarea, select')) {
    if (e.target.value) {  // Only validate non-empty
      validateField(e.target);
    }
  }
}, true);
```

### On Input (Eager)

```javascript
form.addEventListener('input', (e) => {
  validateField(e.target);
});
```

### Hybrid (Recommended)

```javascript
// Show errors on blur, clear on input
const touchedFields = new Set();

form.addEventListener('blur', (e) => {
  if (e.target.name) {
    touchedFields.add(e.target.name);
    validateField(e.target);
  }
}, true);

form.addEventListener('input', (e) => {
  if (touchedFields.has(e.target.name)) {
    validateField(e.target);
  }
});
```

---

## 4.3.8 Gotchas

```javascript
// ❌ Not clearing custom validity
input.setCustomValidity('Error!');
// Later...
input.value = 'valid value';
// Still shows as invalid! customError is still set

// ✅ Clear on input
input.addEventListener('input', () => {
  input.setCustomValidity('');
});

// ❌ Using only HTML5 validation for security
// Client-side validation can be bypassed!

// ✅ Always validate server-side too
// Client validation is for UX only

// ❌ Checking validity before input
if (input.validity.valueMissing) {
  // True before user touches field
}

// ✅ Only validate after interaction
input.addEventListener('blur', () => {
  if (input.value && !input.validity.valid) {
    showError(input);
  }
});

// ❌ novalidate disables checkValidity()
// Actually it doesn't! It only disables browser UI

form.noValidate = true;
console.log(form.checkValidity());  // Still works!

// ❌ Expecting immediate validity update
input.value = 'invalid email';
// validity.typeMismatch is already true (synchronous)
```

---

## 4.3.9 Summary

### Validation Attributes

| Attribute | Description |
|-----------|-------------|
| `required` | Must have value |
| `pattern` | Must match regex |
| `minlength`/`maxlength` | String length limits |
| `min`/`max` | Number/date range |
| `step` | Number increment |
| `type` | Email, URL validation |

### ValidityState Flags

| Flag | When True |
|------|-----------|
| `valid` | All validations pass |
| `valueMissing` | Required but empty |
| `typeMismatch` | Wrong type (email/url) |
| `patternMismatch` | Doesn't match pattern |
| `tooShort`/`tooLong` | Length constraints |
| `rangeUnderflow`/`rangeOverflow` | Range constraints |
| `stepMismatch` | Not multiple of step |
| `badInput` | Unparseable input |
| `customError` | Custom validation set |

### Methods

| Method | Description |
|--------|-------------|
| `checkValidity()` | Check silently |
| `reportValidity()` | Check and show UI |
| `setCustomValidity()` | Set custom error |

### Best Practices

1. **Always clear custom validity on input**
2. **Use novalidate for custom UI** but still use Constraint API
3. **Validate server-side too** — client validation is UX only
4. **Show errors on blur**, clear on input
5. **Use ARIA attributes** for accessibility
6. **Focus first invalid field** on submit failure

---

**End of Chapter 4.3: Form Validation**

Next chapter: **4.4 FormData API** — covers creating, reading, and sending form data with fetch.
# 4.4 FormData API

The FormData API provides a way to construct and manipulate form data for submission. This chapter covers creating FormData, modifying entries, handling files, and sending data with fetch.

---

## 4.4.1 Creating FormData

### From a Form Element

```javascript
const form = document.querySelector('form');

// Create FormData from form
const formData = new FormData(form);

// Automatically includes all named form controls:
// - Input values (text, number, etc.)
// - Textarea values
// - Select values
// - Checked checkboxes/radios
// - File inputs

// Does NOT include:
// - Disabled elements
// - Elements without name attribute
// - Unchecked checkboxes/radios
// - Submit buttons (unless specified)
```

### With Submitter

```javascript
// Include submit button value
form.addEventListener('submit', (e) => {
  e.preventDefault();
  
  // e.submitter is the button that was clicked
  const formData = new FormData(form, e.submitter);
  
  // If submitter has name/value, it's included
  // <button type="submit" name="action" value="save">Save</button>
  console.log(formData.get('action'));  // 'save'
});
```

### Empty FormData

```javascript
// Create empty FormData
const formData = new FormData();

// Add entries manually
formData.append('username', 'john');
formData.append('email', 'john@example.com');
```

---

## 4.4.2 Reading FormData

### get() and getAll()

```javascript
const formData = new FormData(form);

// Get single value
const username = formData.get('username');
console.log(username);  // 'john' or null if not present

// Get all values (for multi-value fields)
const interests = formData.getAll('interests');
console.log(interests);  // ['sports', 'music', 'travel']

// Useful for:
// - Multiple checkboxes with same name
// - Multiple file inputs
// - Select multiple
```

### has()

```javascript
const formData = new FormData(form);

// Check if field exists
if (formData.has('username')) {
  console.log('Username provided');
}

if (formData.has('newsletter')) {
  console.log('Newsletter checkbox was checked');
}
```

### Iterating

```javascript
const formData = new FormData(form);

// Iterate over entries
for (const [key, value] of formData) {
  console.log(`${key}: ${value}`);
}

// Using entries()
for (const [key, value] of formData.entries()) {
  console.log(key, value);
}

// Keys only
for (const key of formData.keys()) {
  console.log(key);
}

// Values only
for (const value of formData.values()) {
  console.log(value);
}

// forEach
formData.forEach((value, key) => {
  console.log(key, value);
});
```

### Converting to Object

```javascript
const formData = new FormData(form);

// Simple conversion (loses multiple values)
const obj = Object.fromEntries(formData);

// Handle multiple values
function formDataToObject(formData) {
  const obj = {};
  
  for (const [key, value] of formData) {
    if (obj[key] !== undefined) {
      // Convert to array if multiple values
      if (!Array.isArray(obj[key])) {
        obj[key] = [obj[key]];
      }
      obj[key].push(value);
    } else {
      obj[key] = value;
    }
  }
  
  return obj;
}

// Or use getAll for known multi-value fields
const data = {
  ...Object.fromEntries(formData),
  interests: formData.getAll('interests')
};
```

---

## 4.4.3 Modifying FormData

### append()

```javascript
const formData = new FormData();

// Add string value
formData.append('username', 'john');

// Add number (converted to string)
formData.append('age', 25);

// Append another value with same key
formData.append('tag', 'javascript');
formData.append('tag', 'web');
console.log(formData.getAll('tag'));  // ['javascript', 'web']

// Append file
const fileInput = document.querySelector('input[type="file"]');
formData.append('avatar', fileInput.files[0]);

// Append Blob with filename
const blob = new Blob(['Hello'], { type: 'text/plain' });
formData.append('file', blob, 'hello.txt');
```

### set()

```javascript
const formData = new FormData();

// Set value (replaces if exists)
formData.set('username', 'john');
formData.set('username', 'jane');  // Replaces 'john'

console.log(formData.get('username'));  // 'jane'
console.log(formData.getAll('username'));  // ['jane']

// Difference from append:
// append() adds, even if key exists (creates array)
// set() replaces any existing values
```

### delete()

```javascript
const formData = new FormData(form);

// Remove field
formData.delete('password');

// Removes ALL values for that key
formData.append('tag', 'js');
formData.append('tag', 'web');
formData.delete('tag');
console.log(formData.has('tag'));  // false
```

---

## 4.4.4 Working with Files

### File Inputs

```javascript
// HTML: <input type="file" name="avatar">
const formData = new FormData(form);

// Single file
const file = formData.get('avatar');
console.log(file.name);
console.log(file.size);
console.log(file.type);

// Multiple files: <input type="file" name="photos" multiple>
const files = formData.getAll('photos');
files.forEach(file => {
  console.log(file.name);
});
```

### Appending Files Manually

```javascript
const formData = new FormData();

// From file input
const fileInput = document.querySelector('input[type="file"]');
for (const file of fileInput.files) {
  formData.append('files', file);
}

// From drag and drop
dropZone.addEventListener('drop', (e) => {
  e.preventDefault();
  
  const formData = new FormData();
  for (const file of e.dataTransfer.files) {
    formData.append('uploads', file);
  }
  
  uploadFiles(formData);
});

// From clipboard
document.addEventListener('paste', (e) => {
  const items = e.clipboardData.items;
  const formData = new FormData();
  
  for (const item of items) {
    if (item.type.startsWith('image/')) {
      const file = item.getAsFile();
      formData.append('image', file, `paste-${Date.now()}.png`);
    }
  }
});
```

### Creating Files from Blobs

```javascript
const formData = new FormData();

// Text file from string
const textBlob = new Blob(['Hello, World!'], { type: 'text/plain' });
formData.append('textFile', textBlob, 'hello.txt');

// JSON file
const jsonData = JSON.stringify({ name: 'John', age: 30 });
const jsonBlob = new Blob([jsonData], { type: 'application/json' });
formData.append('data', jsonBlob, 'data.json');

// Canvas to file
const canvas = document.querySelector('canvas');
canvas.toBlob((blob) => {
  formData.append('drawing', blob, 'drawing.png');
});

// Or with async/await
const blob = await new Promise(resolve => canvas.toBlob(resolve));
formData.append('image', blob, 'canvas.png');
```

---

## 4.4.5 Sending with Fetch

### Basic POST

```javascript
const form = document.querySelector('form');

form.addEventListener('submit', async (e) => {
  e.preventDefault();
  
  const formData = new FormData(form);
  
  const response = await fetch('/api/submit', {
    method: 'POST',
    body: formData
    // Don't set Content-Type header!
    // Fetch sets it automatically with boundary
  });
  
  if (response.ok) {
    const result = await response.json();
    console.log('Success:', result);
  }
});
```

### Why Not Set Content-Type

```javascript
// ❌ Don't do this
fetch('/api/upload', {
  method: 'POST',
  headers: {
    'Content-Type': 'multipart/form-data'  // Wrong!
  },
  body: formData
});

// ✅ Let browser set it
fetch('/api/upload', {
  method: 'POST',
  body: formData
  // Browser sets: Content-Type: multipart/form-data; boundary=----WebKitFormBoundary...
});

// The boundary is required for parsing
// Browser generates unique boundary automatically
```

### Converting to JSON

```javascript
// If API expects JSON instead of FormData
const formData = new FormData(form);
const jsonData = Object.fromEntries(formData);

fetch('/api/submit', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json'
  },
  body: JSON.stringify(jsonData)
});

// ⚠️ This loses files!
// Files cannot be sent as JSON
```

### Sending as URL-Encoded

```javascript
const formData = new FormData(form);

// Convert to URLSearchParams
const params = new URLSearchParams();
for (const [key, value] of formData) {
  if (typeof value === 'string') {
    params.append(key, value);
  }
}

fetch('/api/submit', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/x-www-form-urlencoded'
  },
  body: params
});
```

---

## 4.4.6 Upload Progress

```javascript
// FormData with XMLHttpRequest for progress
function uploadWithProgress(formData, onProgress) {
  return new Promise((resolve, reject) => {
    const xhr = new XMLHttpRequest();
    
    xhr.upload.addEventListener('progress', (e) => {
      if (e.lengthComputable) {
        const percent = (e.loaded / e.total) * 100;
        onProgress(percent);
      }
    });
    
    xhr.addEventListener('load', () => {
      if (xhr.status >= 200 && xhr.status < 300) {
        resolve(JSON.parse(xhr.responseText));
      } else {
        reject(new Error(`Upload failed: ${xhr.status}`));
      }
    });
    
    xhr.addEventListener('error', () => reject(new Error('Upload failed')));
    xhr.addEventListener('abort', () => reject(new Error('Upload cancelled')));
    
    xhr.open('POST', '/api/upload');
    xhr.send(formData);
  });
}

// Usage
const formData = new FormData(form);

await uploadWithProgress(formData, (percent) => {
  progressBar.style.width = `${percent}%`;
  progressText.textContent = `${Math.round(percent)}%`;
});
```

---

## 4.4.7 Common Patterns

### Form Submission Handler

```javascript
class FormHandler {
  constructor(form, options = {}) {
    this.form = form;
    this.url = options.url || form.action;
    this.method = options.method || form.method || 'POST';
    this.onSuccess = options.onSuccess || (() => {});
    this.onError = options.onError || (() => {});
    
    form.addEventListener('submit', (e) => this.handleSubmit(e));
  }
  
  async handleSubmit(e) {
    e.preventDefault();
    
    const formData = new FormData(this.form, e.submitter);
    const submitBtn = e.submitter || this.form.querySelector('[type="submit"]');
    
    try {
      submitBtn.disabled = true;
      submitBtn.textContent = 'Submitting...';
      
      const response = await fetch(this.url, {
        method: this.method,
        body: formData
      });
      
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}`);
      }
      
      const result = await response.json();
      this.onSuccess(result);
    } catch (error) {
      this.onError(error);
    } finally {
      submitBtn.disabled = false;
      submitBtn.textContent = 'Submit';
    }
  }
}
```

### Multipart File Upload

```javascript
async function uploadFiles(files, additionalData = {}) {
  const formData = new FormData();
  
  // Add files
  for (const file of files) {
    formData.append('files', file);
  }
  
  // Add other data
  for (const [key, value] of Object.entries(additionalData)) {
    formData.append(key, value);
  }
  
  const response = await fetch('/api/upload', {
    method: 'POST',
    body: formData
  });
  
  return response.json();
}

// Usage
const result = await uploadFiles(fileInput.files, {
  folder: 'images',
  public: 'true'
});
```

### FormData Event

```javascript
// Modify FormData before submission
form.addEventListener('formdata', (e) => {
  // e.formData is the FormData being constructed
  
  // Add computed fields
  e.formData.append('timestamp', Date.now());
  e.formData.append('timezone', Intl.DateTimeFormat().resolvedOptions().timeZone);
  
  // Modify existing fields
  const username = e.formData.get('username');
  e.formData.set('username', username.toLowerCase());
  
  // Remove unwanted fields
  e.formData.delete('debug');
});

// formdata event fires when:
// new FormData(form) is called
```

---

## 4.4.8 Gotchas

```javascript
// ❌ Setting Content-Type header manually
fetch(url, {
  method: 'POST',
  headers: { 'Content-Type': 'multipart/form-data' },
  body: formData
});
// Missing boundary! Server can't parse.

// ✅ Let browser set it
fetch(url, {
  method: 'POST',
  body: formData
});

// ❌ Expecting disabled fields in FormData
input.disabled = true;
const formData = new FormData(form);
console.log(formData.has('inputName'));  // false!

// ✅ Use readonly if you need value in FormData
input.readOnly = true;

// ❌ Checking for empty values
if (!formData.get('field')) {
  // Empty string '' is falsy but exists!
}

// ✅ Use has() to check existence
if (!formData.has('field')) {
  // Field truly doesn't exist
}

// ❌ Expecting files to survive JSON conversion
const obj = Object.fromEntries(formData);
// obj.file is "[object File]" string!

// ✅ Handle files separately
const files = formData.getAll('files');
const data = Object.fromEntries(formData);
delete data.files;
```

---

## 4.4.9 Summary

### Creating FormData

| Method | Description |
|--------|-------------|
| `new FormData(form)` | From form element |
| `new FormData(form, submitter)` | Include submit button |
| `new FormData()` | Empty, build manually |

### Reading Methods

| Method | Returns |
|--------|---------|
| `get(name)` | First value or null |
| `getAll(name)` | Array of all values |
| `has(name)` | Boolean |
| `entries()` | Iterator of [key, value] |
| `keys()` | Iterator of keys |
| `values()` | Iterator of values |

### Modifying Methods

| Method | Description |
|--------|-------------|
| `append(name, value)` | Add value (keeps existing) |
| `set(name, value)` | Replace value |
| `delete(name)` | Remove all values for key |

### Sending

| Scenario | Content-Type |
|----------|--------------|
| FormData body | Auto (multipart/form-data) |
| JSON body | application/json |
| URLSearchParams | x-www-form-urlencoded |

### Best Practices

1. **Don't set Content-Type header** — let browser add boundary
2. **Use `has()` to check existence**, not falsy check
3. **Handle disabled vs readonly** — disabled fields excluded
4. **Use `getAll()` for multi-value fields**
5. **Use XHR for upload progress** — fetch doesn't support it
6. **Listen to `formdata` event** for last-minute modifications

---

**End of Chapter 4.4: FormData API**

**End of Group 4: Forms**

Next group: **5. Storage APIs** — covers Web Storage, Cookies, IndexedDB, Cache API, and Storage Manager.
# 5.1 Web Storage

Web Storage provides synchronous key-value storage in the browser. This chapter covers localStorage for persistent storage, sessionStorage for session-scoped data, and the storage event for cross-tab synchronization.

---

## 5.1.1 localStorage vs sessionStorage

### localStorage

```javascript
// Persists across browser sessions
// Data survives browser close and reopen

// Set item
localStorage.setItem('username', 'john');

// Get item
const username = localStorage.getItem('username');
console.log(username);  // 'john'

// Remove item
localStorage.removeItem('username');

// Clear all
localStorage.clear();

// Scope: same origin (protocol + domain + port)
// All tabs/windows share localStorage for same origin
```

### sessionStorage

```javascript
// Data persists only for the session (tab lifetime)
// Cleared when tab/window is closed

// Same API as localStorage
sessionStorage.setItem('tempData', 'value');
sessionStorage.getItem('tempData');
sessionStorage.removeItem('tempData');
sessionStorage.clear();

// Scope: same origin AND same tab
// Each tab has its own sessionStorage
// Opening link in new tab copies sessionStorage once, then they're independent
```

### Key Differences

| Feature | localStorage | sessionStorage |
|---------|-------------|----------------|
| Persistence | Until manually cleared | Until tab closes |
| Scope | All tabs, same origin | Single tab only |
| Survives browser close | Yes | No |
| Survives page refresh | Yes | Yes |
| Duplicated to new tab | Yes (shared) | Yes (copied once) |

---

## 5.1.2 Basic Operations

### setItem() and getItem()

```javascript
// Set item
localStorage.setItem('key', 'value');

// Get item
const value = localStorage.getItem('key');

// Returns null if key doesn't exist
const missing = localStorage.getItem('nonexistent');
console.log(missing);  // null

// All values are strings!
localStorage.setItem('number', 42);  // Stored as '42'
console.log(localStorage.getItem('number'));  // '42' (string)
console.log(typeof localStorage.getItem('number'));  // 'string'
```

### removeItem()

```javascript
// Remove single item
localStorage.removeItem('key');

// Does nothing if key doesn't exist (no error)
localStorage.removeItem('nonexistent');
```

### clear()

```javascript
// Remove ALL items
localStorage.clear();

// ⚠️ Affects entire origin
// Other scripts/tabs using localStorage will lose data
```

### key() and length

```javascript
// Get number of items
console.log(localStorage.length);  // e.g., 3

// Get key by index
console.log(localStorage.key(0));  // First key
console.log(localStorage.key(1));  // Second key

// Iterate over all items
for (let i = 0; i < localStorage.length; i++) {
  const key = localStorage.key(i);
  const value = localStorage.getItem(key);
  console.log(`${key}: ${value}`);
}

// Better: use Object.keys()
Object.keys(localStorage).forEach(key => {
  console.log(`${key}: ${localStorage.getItem(key)}`);
});
```

### Direct Property Access

```javascript
// Direct property access (shorthand)
localStorage.username = 'john';
console.log(localStorage.username);
delete localStorage.username;

// ⚠️ Not recommended for several reasons:
// 1. Can't access keys named like built-in properties
// 2. Less explicit
// 3. undefined vs null semantics differ

// ❌ Problem with built-in property names
localStorage.length = '100';  // This won't work as expected!
console.log(localStorage.length);  // Returns count, not '100'

// ✅ Always use setItem/getItem methods
localStorage.setItem('length', '100');
```

---

## 5.1.3 Storing Complex Data

### JSON Serialization

```javascript
// Store objects/arrays as JSON
const user = {
  id: 1,
  name: 'John',
  email: 'john@example.com',
  preferences: {
    theme: 'dark',
    notifications: true
  }
};

// Serialize to JSON
localStorage.setItem('user', JSON.stringify(user));

// Parse back to object
const storedUser = JSON.parse(localStorage.getItem('user'));
console.log(storedUser.name);  // 'John'
console.log(storedUser.preferences.theme);  // 'dark'
```

### Handling Parse Errors

```javascript
// Safe parsing function
function getJSON(key, defaultValue = null) {
  try {
    const item = localStorage.getItem(key);
    return item ? JSON.parse(item) : defaultValue;
  } catch (error) {
    console.error(`Error parsing ${key}:`, error);
    return defaultValue;
  }
}

// Safe setting function
function setJSON(key, value) {
  try {
    localStorage.setItem(key, JSON.stringify(value));
    return true;
  } catch (error) {
    console.error(`Error storing ${key}:`, error);
    return false;
  }
}

// Usage
setJSON('settings', { theme: 'dark' });
const settings = getJSON('settings', { theme: 'light' });
```

### Storage Wrapper

```javascript
class Storage {
  constructor(storage = localStorage) {
    this.storage = storage;
  }
  
  get(key, defaultValue = null) {
    try {
      const item = this.storage.getItem(key);
      if (item === null) return defaultValue;
      return JSON.parse(item);
    } catch {
      return defaultValue;
    }
  }
  
  set(key, value) {
    try {
      this.storage.setItem(key, JSON.stringify(value));
      return true;
    } catch (error) {
      if (error.name === 'QuotaExceededError') {
        console.error('Storage quota exceeded');
      }
      return false;
    }
  }
  
  remove(key) {
    this.storage.removeItem(key);
  }
  
  clear() {
    this.storage.clear();
  }
  
  has(key) {
    return this.storage.getItem(key) !== null;
  }
  
  keys() {
    return Object.keys(this.storage);
  }
}

// Usage
const store = new Storage(localStorage);
store.set('user', { name: 'John' });
const user = store.get('user');
```

---

## 5.1.4 Storage Event

### Cross-Tab Communication

```javascript
// Fires when localStorage changes in ANOTHER tab/window
window.addEventListener('storage', (e) => {
  console.log('Storage changed!');
  console.log('Key:', e.key);
  console.log('Old value:', e.oldValue);
  console.log('New value:', e.newValue);
  console.log('URL:', e.url);
  console.log('Storage area:', e.storageArea);
});

// ⚠️ Does NOT fire in the tab that made the change
// Only fires in OTHER tabs/windows with same origin
```

### Event Properties

```javascript
window.addEventListener('storage', (e) => {
  // Key that was changed (null if clear() was called)
  if (e.key === null) {
    console.log('Storage was cleared');
    return;
  }
  
  if (e.key === 'user') {
    const newUser = e.newValue ? JSON.parse(e.newValue) : null;
    updateUserUI(newUser);
  }
});
```

### Syncing State Across Tabs

```javascript
// Update UI when settings change in another tab
window.addEventListener('storage', (e) => {
  if (e.key === 'theme') {
    applyTheme(e.newValue);
  }
  
  if (e.key === 'authToken') {
    if (e.newValue === null) {
      // Logged out in another tab
      redirectToLogin();
    } else if (e.oldValue === null) {
      // Logged in from another tab
      refreshUserState();
    }
  }
});
```

### Broadcasting Messages

```javascript
// Simple cross-tab messaging
function broadcast(type, data) {
  localStorage.setItem('broadcast', JSON.stringify({
    type,
    data,
    timestamp: Date.now()
  }));
  // Remove immediately (the event already fired)
  localStorage.removeItem('broadcast');
}

// Listen for broadcasts
window.addEventListener('storage', (e) => {
  if (e.key === 'broadcast' && e.newValue) {
    const message = JSON.parse(e.newValue);
    handleBroadcast(message);
  }
});

// Usage
broadcast('logout', { userId: 123 });
```

---

## 5.1.5 Storage Limits

### Quota

```javascript
// Typical limits:
// - 5MB per origin (varies by browser)
// - Each character in a string = 2 bytes (UTF-16)

// Check if storage is available
function storageAvailable(type) {
  try {
    const storage = window[type];
    const x = '__storage_test__';
    storage.setItem(x, x);
    storage.removeItem(x);
    return true;
  } catch (e) {
    return e instanceof DOMException && (
      e.code === 22 ||
      e.code === 1014 ||
      e.name === 'QuotaExceededError' ||
      e.name === 'NS_ERROR_DOM_QUOTA_REACHED'
    ) && storage && storage.length !== 0;
  }
}

if (storageAvailable('localStorage')) {
  // Use localStorage
} else {
  // Fall back to other storage or warn user
}
```

### Handling QuotaExceededError

```javascript
function safeSetItem(key, value) {
  try {
    localStorage.setItem(key, value);
    return true;
  } catch (error) {
    if (error.name === 'QuotaExceededError') {
      // Storage is full
      console.error('Storage quota exceeded');
      
      // Option 1: Clear old items
      cleanupOldItems();
      
      // Option 2: Warn user
      showStorageWarning();
      
      return false;
    }
    throw error;
  }
}

function cleanupOldItems() {
  // Example: remove items with timestamps older than 7 days
  const oneWeekAgo = Date.now() - (7 * 24 * 60 * 60 * 1000);
  
  Object.keys(localStorage).forEach(key => {
    try {
      const item = JSON.parse(localStorage.getItem(key));
      if (item.timestamp && item.timestamp < oneWeekAgo) {
        localStorage.removeItem(key);
      }
    } catch {
      // Not JSON, skip
    }
  });
}
```

### Estimating Usage

```javascript
// Rough estimate of storage usage
function getStorageSize(storage = localStorage) {
  let total = 0;
  
  for (let i = 0; i < storage.length; i++) {
    const key = storage.key(i);
    const value = storage.getItem(key);
    // Each char is 2 bytes in JS strings (UTF-16)
    total += (key.length + value.length) * 2;
  }
  
  return {
    bytes: total,
    kb: (total / 1024).toFixed(2),
    mb: (total / (1024 * 1024)).toFixed(4)
  };
}

console.log(getStorageSize());
// { bytes: 10240, kb: '10.00', mb: '0.0098' }
```

---

## 5.1.6 Common Patterns

### User Preferences

```javascript
const defaults = {
  theme: 'light',
  fontSize: 16,
  notifications: true,
  language: 'en'
};

function getPreferences() {
  const stored = localStorage.getItem('preferences');
  if (stored) {
    return { ...defaults, ...JSON.parse(stored) };
  }
  return defaults;
}

function setPreference(key, value) {
  const prefs = getPreferences();
  prefs[key] = value;
  localStorage.setItem('preferences', JSON.stringify(prefs));
}

// Usage
const prefs = getPreferences();
setPreference('theme', 'dark');
```

### Draft Auto-Save

```javascript
const form = document.querySelector('form');
const storageKey = `draft-${form.id}`;

// Save draft on input
form.addEventListener('input', () => {
  const data = Object.fromEntries(new FormData(form));
  localStorage.setItem(storageKey, JSON.stringify({
    data,
    timestamp: Date.now()
  }));
});

// Restore draft on load
function restoreDraft() {
  const draft = localStorage.getItem(storageKey);
  if (!draft) return;
  
  const { data, timestamp } = JSON.parse(draft);
  
  // Check if draft is recent (within 24 hours)
  if (Date.now() - timestamp > 24 * 60 * 60 * 1000) {
    localStorage.removeItem(storageKey);
    return;
  }
  
  // Restore values
  Object.entries(data).forEach(([name, value]) => {
    const field = form.elements[name];
    if (field) field.value = value;
  });
}

// Clear draft on submit
form.addEventListener('submit', () => {
  localStorage.removeItem(storageKey);
});
```

### Cache with Expiry

```javascript
function setWithExpiry(key, value, ttlMs) {
  const item = {
    value,
    expiry: Date.now() + ttlMs
  };
  localStorage.setItem(key, JSON.stringify(item));
}

function getWithExpiry(key) {
  const item = localStorage.getItem(key);
  if (!item) return null;
  
  const { value, expiry } = JSON.parse(item);
  
  if (Date.now() > expiry) {
    localStorage.removeItem(key);
    return null;
  }
  
  return value;
}

// Usage
setWithExpiry('cache:api-data', apiResponse, 5 * 60 * 1000);  // 5 minutes
const cached = getWithExpiry('cache:api-data');
```

---

## 5.1.7 Gotchas

```javascript
// ❌ Storing non-strings directly
localStorage.setItem('obj', { a: 1 });
console.log(localStorage.getItem('obj'));  // "[object Object]"

// ✅ Use JSON.stringify
localStorage.setItem('obj', JSON.stringify({ a: 1 }));

// ❌ Not handling null for missing keys
const value = localStorage.getItem('missing').toLowerCase();
// TypeError: Cannot read property 'toLowerCase' of null

// ✅ Check for null
const value = localStorage.getItem('missing');
if (value !== null) {
  console.log(value.toLowerCase());
}

// ❌ Storing sensitive data
localStorage.setItem('password', 'secret123');
// Accessible via DevTools, XSS attacks, extensions

// ✅ Never store sensitive data in localStorage
// Use secure, httpOnly cookies for tokens

// ❌ Relying on localStorage in private/incognito mode
// Some browsers: localStorage throws in private mode
// Safari: localStorage works but is cleared on exit

// ✅ Always check availability
if (typeof localStorage !== 'undefined') {
  try {
    localStorage.setItem('test', 'test');
    localStorage.removeItem('test');
    // localStorage is available
  } catch (e) {
    // localStorage not available
  }
}
```

---

## 5.1.8 Summary

### Methods

| Method | Description |
|--------|-------------|
| `setItem(key, value)` | Store value |
| `getItem(key)` | Retrieve value (or null) |
| `removeItem(key)` | Delete key |
| `clear()` | Delete all keys |
| `key(index)` | Get key by index |
| `length` | Number of items |

### localStorage vs sessionStorage

| Feature | localStorage | sessionStorage |
|---------|-------------|----------------|
| Lifetime | Permanent | Session (tab) |
| Scope | All tabs | Single tab |
| Storage event | Yes | Yes |

### Storage Event Properties

| Property | Description |
|----------|-------------|
| `key` | Changed key (null if clear) |
| `oldValue` | Previous value |
| `newValue` | New value |
| `url` | Page URL |
| `storageArea` | Storage object |

### Best Practices

1. **Always use JSON** for objects/arrays
2. **Handle QuotaExceededError** for large data
3. **Never store sensitive data** (passwords, tokens)
4. **Check availability** before using
5. **Use storage event** for cross-tab sync
6. **Implement expiry** for cached data

---

**End of Chapter 5.1: Web Storage**

Next chapter: **5.2 Cookies** — covers reading, writing, and managing cookies with JavaScript.
# 5.2 Cookies

Cookies provide small pieces of data stored by the browser and sent with every HTTP request to the same domain. This chapter covers reading, writing, and managing cookies via JavaScript, including security attributes and best practices.

---

## 5.2.1 What Are Cookies?

### Cookie Basics

```javascript
// Cookies are:
// - Small text strings (up to ~4KB)
// - Sent with every HTTP request to the origin
// - Accessible via document.cookie
// - Set by server (Set-Cookie header) or client (document.cookie)

// Reading all cookies
console.log(document.cookie);
// "username=john; theme=dark; sessionId=abc123"

// Cookies are name=value pairs separated by "; "
```

### Cookies vs Web Storage

| Feature | Cookies | localStorage | sessionStorage |
|---------|---------|--------------|----------------|
| Size limit | ~4KB | ~5MB | ~5MB |
| Sent with requests | Yes | No | No |
| Server access | Yes | No | No |
| Expiration | Configurable | None | Session |
| API | String-based | Key-value | Key-value |

---

## 5.2.2 Reading Cookies

### Basic Reading

```javascript
// All cookies as single string
const allCookies = document.cookie;
// "name=value; name2=value2"

// Parse to object
function getCookies() {
  const cookies = {};
  
  document.cookie.split(';').forEach(cookie => {
    const [name, value] = cookie.split('=').map(s => s.trim());
    if (name) {
      cookies[name] = decodeURIComponent(value);
    }
  });
  
  return cookies;
}

// Get single cookie
function getCookie(name) {
  const cookies = getCookies();
  return cookies[name] || null;
}

// Usage
const username = getCookie('username');
```

### Regex Approach

```javascript
function getCookie(name) {
  const match = document.cookie.match(
    new RegExp('(^| )' + name + '=([^;]+)')
  );
  return match ? decodeURIComponent(match[2]) : null;
}

// More robust regex
function getCookie(name) {
  const value = `; ${document.cookie}`;
  const parts = value.split(`; ${name}=`);
  if (parts.length === 2) {
    return decodeURIComponent(parts.pop().split(';').shift());
  }
  return null;
}
```

---

## 5.2.3 Writing Cookies

### Basic Cookie

```javascript
// Set a simple cookie
document.cookie = "username=john";

// ⚠️ This doesn't replace all cookies!
// It only adds or updates this specific cookie

// With value encoding (important for special characters)
document.cookie = `username=${encodeURIComponent('John Doe')}`;
```

### Cookie Attributes

```javascript
// Full cookie with attributes
document.cookie = [
  `token=${encodeURIComponent(value)}`,
  'max-age=3600',          // Expires in 1 hour
  'path=/',                // Available to entire site
  'secure',                // HTTPS only
  'samesite=strict'        // CSRF protection
].join('; ');

// Using expires (date string)
const date = new Date();
date.setTime(date.getTime() + (7 * 24 * 60 * 60 * 1000)); // 7 days
document.cookie = `username=john; expires=${date.toUTCString()}`;

// Using max-age (seconds)
document.cookie = "username=john; max-age=604800";  // 7 days in seconds
```

### Cookie Helper Function

```javascript
function setCookie(name, value, options = {}) {
  const {
    days,
    maxAge,
    path = '/',
    domain,
    secure = false,
    sameSite = 'Lax',
    httpOnly // Can't be set via JS, included for completeness
  } = options;
  
  let cookie = `${name}=${encodeURIComponent(value)}`;
  
  if (days !== undefined) {
    const date = new Date();
    date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));
    cookie += `; expires=${date.toUTCString()}`;
  }
  
  if (maxAge !== undefined) {
    cookie += `; max-age=${maxAge}`;
  }
  
  cookie += `; path=${path}`;
  
  if (domain) {
    cookie += `; domain=${domain}`;
  }
  
  if (secure || sameSite === 'None') {
    cookie += '; secure';
  }
  
  cookie += `; samesite=${sameSite}`;
  
  document.cookie = cookie;
}

// Usage
setCookie('theme', 'dark', { days: 30 });
setCookie('token', 'abc123', { maxAge: 3600, secure: true });
```

---

## 5.2.4 Cookie Attributes

### expires

```javascript
// Absolute expiration date
const date = new Date('2025-12-31T23:59:59');
document.cookie = `promo=summer; expires=${date.toUTCString()}`;

// If no expires or max-age: session cookie (deleted on browser close)
document.cookie = "session=temp";  // Session cookie
```

### max-age

```javascript
// Seconds until expiration
document.cookie = "cache=data; max-age=3600";     // 1 hour
document.cookie = "cache=data; max-age=86400";    // 1 day
document.cookie = "cache=data; max-age=604800";   // 1 week

// max-age=0 or negative: delete cookie
document.cookie = "cache=; max-age=0";
```

### path

```javascript
// Restrict cookie to specific path
document.cookie = "data=value; path=/admin";
// Cookie only sent for requests to /admin/*

// Default: current path
// path=/ makes cookie available site-wide
document.cookie = "data=value; path=/";
```

### domain

```javascript
// Default: exact domain only
document.cookie = "data=value";
// Only sent to exact origin domain

// Include subdomains
document.cookie = "data=value; domain=.example.com";
// Sent to example.com, www.example.com, api.example.com

// Can only set for current domain or parent
// Can't set cookies for different domains
```

### secure

```javascript
// Only send over HTTPS
document.cookie = "token=secret; secure";

// Required for SameSite=None
document.cookie = "tracking=id; secure; samesite=none";

// ⚠️ In development (http://localhost), secure might be ignored
```

### samesite

```javascript
// SameSite=Strict: only same-site requests
document.cookie = "csrf=token; samesite=strict";
// Won't be sent when clicking link from another site

// SameSite=Lax (default): same-site + top-level navigation
document.cookie = "session=abc; samesite=lax";
// Sent when clicking link from another site, but not for POST

// SameSite=None: always sent (requires secure)
document.cookie = "tracking=id; samesite=none; secure";
// Sent on all cross-site requests
```

### httpOnly

```javascript
// ⚠️ Can only be set by server (Set-Cookie header)
// Not accessible via document.cookie
// Protects against XSS attacks

// Set-Cookie: sessionId=abc123; HttpOnly
// JavaScript cannot read this cookie
```

---

## 5.2.5 Deleting Cookies

```javascript
// Delete by setting expired date
document.cookie = "username=; expires=Thu, 01 Jan 1970 00:00:00 UTC";

// Or use max-age
document.cookie = "username=; max-age=0";

// Must match path and domain!
document.cookie = "username=; max-age=0; path=/; domain=.example.com";

// Helper function
function deleteCookie(name, path = '/', domain) {
  let cookie = `${name}=; max-age=0; path=${path}`;
  if (domain) {
    cookie += `; domain=${domain}`;
  }
  document.cookie = cookie;
}
```

---

## 5.2.6 Cookie Class

```javascript
class CookieManager {
  static get(name) {
    const value = `; ${document.cookie}`;
    const parts = value.split(`; ${name}=`);
    if (parts.length === 2) {
      return decodeURIComponent(parts.pop().split(';').shift());
    }
    return null;
  }
  
  static set(name, value, options = {}) {
    const {
      days,
      maxAge,
      path = '/',
      domain,
      secure = location.protocol === 'https:',
      sameSite = 'Lax'
    } = options;
    
    let cookie = `${name}=${encodeURIComponent(value)}`;
    
    if (days) {
      const date = new Date();
      date.setTime(date.getTime() + days * 24 * 60 * 60 * 1000);
      cookie += `; expires=${date.toUTCString()}`;
    }
    
    if (maxAge) cookie += `; max-age=${maxAge}`;
    cookie += `; path=${path}`;
    if (domain) cookie += `; domain=${domain}`;
    if (secure) cookie += '; secure';
    cookie += `; samesite=${sameSite}`;
    
    document.cookie = cookie;
  }
  
  static delete(name, options = {}) {
    this.set(name, '', { ...options, maxAge: 0 });
  }
  
  static getAll() {
    const cookies = {};
    document.cookie.split(';').forEach(cookie => {
      const [name, value] = cookie.split('=').map(s => s.trim());
      if (name) cookies[name] = decodeURIComponent(value);
    });
    return cookies;
  }
  
  static has(name) {
    return this.get(name) !== null;
  }
}

// Usage
CookieManager.set('theme', 'dark', { days: 30 });
const theme = CookieManager.get('theme');
CookieManager.delete('theme');
```

---

## 5.2.7 Security Considerations

### XSS Protection

```javascript
// ❌ HttpOnly cookies cannot be read by JavaScript
// This is good for session tokens!

// ❌ Don't store sensitive data in JS-accessible cookies
document.cookie = "password=secret123";  // Never do this!

// ✅ Use HttpOnly for session tokens (server-side)
// Set-Cookie: sessionId=abc123; HttpOnly; Secure

// ✅ Sanitize any cookie values before using
const userInput = getCookie('data');
const sanitized = sanitizeHTML(userInput);
```

### CSRF Protection

```javascript
// SameSite attribute helps prevent CSRF
document.cookie = "csrfToken=abc; samesite=strict; secure";

// For forms, include CSRF token
const csrfToken = getCookie('csrfToken');
fetch('/api/action', {
  method: 'POST',
  headers: {
    'X-CSRF-Token': csrfToken
  },
  body: data
});
```

### Secure Flag

```javascript
// Always use Secure for sensitive cookies
document.cookie = "auth=token; secure; samesite=strict";

// Only exception: development on localhost
// (though modern browsers often treat localhost as secure context)
```

---

## 5.2.8 Common Patterns

### Consent Banner

```javascript
function hasConsentCookie() {
  return CookieManager.has('cookie_consent');
}

function setConsent(accepted) {
  CookieManager.set('cookie_consent', accepted ? 'accepted' : 'declined', {
    days: 365,
    sameSite: 'Lax'
  });
}

// Show banner if no consent
if (!hasConsentCookie()) {
  showConsentBanner({
    onAccept: () => {
      setConsent(true);
      enableAnalytics();
    },
    onDecline: () => {
      setConsent(false);
    }
  });
}
```

### Remember Me

```javascript
// Login with remember me
async function login(username, password, rememberMe) {
  const response = await fetch('/api/login', {
    method: 'POST',
    body: JSON.stringify({ username, password }),
    credentials: 'include'  // Include cookies
  });
  
  if (response.ok && rememberMe) {
    CookieManager.set('remember_user', username, { days: 30 });
  }
}

// Auto-fill on load
const rememberedUser = CookieManager.get('remember_user');
if (rememberedUser) {
  document.querySelector('#username').value = rememberedUser;
}
```

### Theme Preference

```javascript
// Set theme and remember
function setTheme(theme) {
  document.body.dataset.theme = theme;
  CookieManager.set('theme', theme, { days: 365 });
}

// Apply saved theme
const savedTheme = CookieManager.get('theme') || 'light';
setTheme(savedTheme);
```

---

## 5.2.9 Gotchas

```javascript
// ❌ Forgetting to encode special characters
document.cookie = "name=John Doe; age=30";
// This creates TWO cookies! (space and ; are special)

// ✅ Always encode values
document.cookie = `name=${encodeURIComponent('John Doe; age=30')}`;

// ❌ Expecting document.cookie = "..." to replace all cookies
document.cookie = "new=value";
// This adds/updates ONE cookie, doesn't clear others

// ❌ Setting cookies for different domain
document.cookie = "data=value; domain=google.com";
// Won't work - can only set for current domain or parent

// ❌ Deleting cookie without matching path/domain
document.cookie = "token=; max-age=0";  // Might not work!
// If cookie was set with path=/admin, must delete with same path
document.cookie = "token=; max-age=0; path=/admin";

// ❌ Trying to read HttpOnly cookies
const session = getCookie('sessionId');  // Returns null
// HttpOnly cookies are invisible to JavaScript

// ❌ SameSite=None without Secure
document.cookie = "cross=site; samesite=none";
// Will be rejected by browser - requires secure flag
```

---

## 5.2.10 Summary

### Cookie Attributes

| Attribute | Description |
|-----------|-------------|
| `expires` | Expiration date (GMT) |
| `max-age` | Seconds until expiration |
| `path` | URL path scope |
| `domain` | Domain scope (includes subdomains) |
| `secure` | HTTPS only |
| `samesite` | CSRF protection (Strict/Lax/None) |
| `httponly` | Server-only (can't set via JS) |

### SameSite Values

| Value | Behavior |
|-------|----------|
| `Strict` | Same-site requests only |
| `Lax` | Same-site + navigation (default) |
| `None` | All requests (requires Secure) |

### Best Practices

1. **Always encode values** with `encodeURIComponent`
2. **Use Secure flag** for sensitive cookies
3. **Use HttpOnly** for session tokens (server-side)
4. **Use SameSite** for CSRF protection
5. **Match path/domain** when deleting
6. **Don't store sensitive data** in JS-accessible cookies

---

**End of Chapter 5.2: Cookies**

Next chapter: **5.3 IndexedDB** — covers the indexed database API for structured client-side storage.
# 5.3 IndexedDB

IndexedDB is a low-level API for client-side storage of significant amounts of structured data. This chapter covers databases, object stores, transactions, indexes, and common patterns for working with IndexedDB.

---

## 5.3.1 IndexedDB Overview

### What Is IndexedDB?

```javascript
// IndexedDB is:
// - A transactional database in the browser
// - Key-value store with indexes
// - Supports large amounts of data (no fixed limit)
// - Asynchronous (event-based API)
// - Same-origin policy (data private to origin)

// When to use IndexedDB:
// - Large datasets (>5MB)
// - Structured data with queries
// - Offline-first applications
// - Complex data relationships
```

### IndexedDB vs Other Storage

| Feature | localStorage | IndexedDB |
|---------|-------------|-----------|
| Size limit | ~5MB | No fixed limit |
| Data types | Strings only | Structured data |
| Async | No | Yes |
| Indexes | No | Yes |
| Transactions | No | Yes |
| Queries | No | Yes |

---

## 5.3.2 Opening a Database

### Basic Open

```javascript
// Open database (creates if doesn't exist)
const request = indexedDB.open('myDatabase', 1);

request.onerror = (event) => {
  console.error('Database error:', event.target.error);
};

request.onsuccess = (event) => {
  const db = event.target.result;
  console.log('Database opened:', db.name);
};

// Called when database is created or version increases
request.onupgradeneeded = (event) => {
  const db = event.target.result;
  // Create object stores here
};
```

### Version Management

```javascript
// Version number determines schema
const request = indexedDB.open('myDatabase', 2);  // Version 2

request.onupgradeneeded = (event) => {
  const db = event.target.result;
  const oldVersion = event.oldVersion;
  const newVersion = event.newVersion;
  
  console.log(`Upgrading from v${oldVersion} to v${newVersion}`);
  
  // Migration logic
  if (oldVersion < 1) {
    // Initial setup
    db.createObjectStore('users', { keyPath: 'id' });
  }
  
  if (oldVersion < 2) {
    // Add new store or index
    const store = db.createObjectStore('posts', { keyPath: 'id', autoIncrement: true });
    store.createIndex('userId', 'userId', { unique: false });
  }
};
```

---

## 5.3.3 Object Stores

### Creating Object Stores

```javascript
request.onupgradeneeded = (event) => {
  const db = event.target.result;
  
  // With explicit key path
  const usersStore = db.createObjectStore('users', { 
    keyPath: 'id' 
  });
  
  // With auto-increment key
  const logsStore = db.createObjectStore('logs', { 
    autoIncrement: true 
  });
  
  // With key generator and key path
  const postsStore = db.createObjectStore('posts', { 
    keyPath: 'id', 
    autoIncrement: true 
  });
  
  // Add indexes
  usersStore.createIndex('email', 'email', { unique: true });
  usersStore.createIndex('name', 'name', { unique: false });
  postsStore.createIndex('userId', 'userId', { unique: false });
  postsStore.createIndex('createdAt', 'createdAt', { unique: false });
};
```

### Deleting Object Stores

```javascript
request.onupgradeneeded = (event) => {
  const db = event.target.result;
  
  // Delete existing store
  if (db.objectStoreNames.contains('oldStore')) {
    db.deleteObjectStore('oldStore');
  }
};
```

---

## 5.3.4 Basic CRUD Operations

### Create (Add/Put)

```javascript
// Add new record (fails if key exists)
function addUser(db, user) {
  return new Promise((resolve, reject) => {
    const tx = db.transaction('users', 'readwrite');
    const store = tx.objectStore('users');
    
    const request = store.add(user);
    
    request.onsuccess = () => resolve(request.result);
    request.onerror = () => reject(request.error);
  });
}

// Put record (adds or updates)
function putUser(db, user) {
  return new Promise((resolve, reject) => {
    const tx = db.transaction('users', 'readwrite');
    const store = tx.objectStore('users');
    
    const request = store.put(user);
    
    request.onsuccess = () => resolve(request.result);
    request.onerror = () => reject(request.error);
  });
}

// Usage
await addUser(db, { id: 1, name: 'John', email: 'john@example.com' });
await putUser(db, { id: 1, name: 'John Doe', email: 'john@example.com' });
```

### Read (Get/GetAll)

```javascript
// Get single record by key
function getUser(db, id) {
  return new Promise((resolve, reject) => {
    const tx = db.transaction('users', 'readonly');
    const store = tx.objectStore('users');
    
    const request = store.get(id);
    
    request.onsuccess = () => resolve(request.result);
    request.onerror = () => reject(request.error);
  });
}

// Get all records
function getAllUsers(db) {
  return new Promise((resolve, reject) => {
    const tx = db.transaction('users', 'readonly');
    const store = tx.objectStore('users');
    
    const request = store.getAll();
    
    request.onsuccess = () => resolve(request.result);
    request.onerror = () => reject(request.error);
  });
}

// Get with limit
function getUsers(db, limit) {
  return new Promise((resolve, reject) => {
    const tx = db.transaction('users', 'readonly');
    const store = tx.objectStore('users');
    
    const request = store.getAll(null, limit);
    
    request.onsuccess = () => resolve(request.result);
    request.onerror = () => reject(request.error);
  });
}
```

### Update

```javascript
// Update = get + modify + put
async function updateUser(db, id, updates) {
  const user = await getUser(db, id);
  if (!user) throw new Error('User not found');
  
  const updated = { ...user, ...updates };
  await putUser(db, updated);
  
  return updated;
}
```

### Delete

```javascript
// Delete single record
function deleteUser(db, id) {
  return new Promise((resolve, reject) => {
    const tx = db.transaction('users', 'readwrite');
    const store = tx.objectStore('users');
    
    const request = store.delete(id);
    
    request.onsuccess = () => resolve();
    request.onerror = () => reject(request.error);
  });
}

// Clear all records
function clearUsers(db) {
  return new Promise((resolve, reject) => {
    const tx = db.transaction('users', 'readwrite');
    const store = tx.objectStore('users');
    
    const request = store.clear();
    
    request.onsuccess = () => resolve();
    request.onerror = () => reject(request.error);
  });
}
```

---

## 5.3.5 Indexes

### Creating Indexes

```javascript
request.onupgradeneeded = (event) => {
  const db = event.target.result;
  const store = db.createObjectStore('products', { keyPath: 'id' });
  
  // Single property index
  store.createIndex('category', 'category', { unique: false });
  
  // Unique index
  store.createIndex('sku', 'sku', { unique: true });
  
  // Compound index
  store.createIndex('category_price', ['category', 'price'], { unique: false });
  
  // Multi-entry index (for arrays)
  store.createIndex('tags', 'tags', { unique: false, multiEntry: true });
};
```

### Querying by Index

```javascript
// Get by index
function getProductsByCategory(db, category) {
  return new Promise((resolve, reject) => {
    const tx = db.transaction('products', 'readonly');
    const store = tx.objectStore('products');
    const index = store.index('category');
    
    const request = index.getAll(category);
    
    request.onsuccess = () => resolve(request.result);
    request.onerror = () => reject(request.error);
  });
}

// Get one by index
function getProductBySku(db, sku) {
  return new Promise((resolve, reject) => {
    const tx = db.transaction('products', 'readonly');
    const store = tx.objectStore('products');
    const index = store.index('sku');
    
    const request = index.get(sku);
    
    request.onsuccess = () => resolve(request.result);
    request.onerror = () => reject(request.error);
  });
}
```

---

## 5.3.6 Cursors

### Basic Cursor

```javascript
// Iterate with cursor
function iterateUsers(db, callback) {
  return new Promise((resolve, reject) => {
    const tx = db.transaction('users', 'readonly');
    const store = tx.objectStore('users');
    
    const request = store.openCursor();
    
    request.onsuccess = (event) => {
      const cursor = event.target.result;
      
      if (cursor) {
        callback(cursor.value, cursor.key);
        cursor.continue();  // Move to next
      } else {
        resolve();  // No more results
      }
    };
    
    request.onerror = () => reject(request.error);
  });
}

// Usage
await iterateUsers(db, (user, key) => {
  console.log(key, user.name);
});
```

### Cursor Direction

```javascript
// Forward (default)
store.openCursor(null, 'next');

// Backward
store.openCursor(null, 'prev');

// Forward, skip duplicates
store.openCursor(null, 'nextunique');

// Backward, skip duplicates
store.openCursor(null, 'prevunique');
```

### Cursor with Range

```javascript
// Key ranges
const range = IDBKeyRange.bound(1, 100);      // 1 <= key <= 100
const rangeOpen = IDBKeyRange.bound(1, 100, true, true);  // 1 < key < 100
const rangeOnly = IDBKeyRange.only(5);        // key === 5
const rangeLower = IDBKeyRange.lowerBound(10);  // key >= 10
const rangeUpper = IDBKeyRange.upperBound(50);  // key <= 50

// Use with cursor
store.openCursor(IDBKeyRange.lowerBound(10));

// Get all in range
store.getAll(IDBKeyRange.bound(1, 100));
```

---

## 5.3.7 Transactions

### Transaction Modes

```javascript
// Readonly - multiple stores, concurrent
const readTx = db.transaction(['users', 'posts'], 'readonly');

// Readwrite - multiple stores, exclusive
const writeTx = db.transaction(['users', 'posts'], 'readwrite');

// Transaction auto-completes when all requests finish
writeTx.oncomplete = () => console.log('Transaction completed');
writeTx.onerror = (event) => console.error('Transaction failed:', event.target.error);
writeTx.onabort = () => console.log('Transaction aborted');

// Abort transaction manually
writeTx.abort();
```

### Multi-Store Transaction

```javascript
async function transferPost(db, postId, fromUserId, toUserId) {
  return new Promise((resolve, reject) => {
    const tx = db.transaction(['users', 'posts'], 'readwrite');
    
    tx.oncomplete = () => resolve();
    tx.onerror = () => reject(tx.error);
    
    const usersStore = tx.objectStore('users');
    const postsStore = tx.objectStore('posts');
    
    // Get post
    const getPost = postsStore.get(postId);
    getPost.onsuccess = () => {
      const post = getPost.result;
      
      if (post.userId !== fromUserId) {
        tx.abort();
        return;
      }
      
      // Update post
      post.userId = toUserId;
      postsStore.put(post);
    };
  });
}
```

---

## 5.3.8 Promise Wrapper

```javascript
class IndexedDBStore {
  constructor(dbName, version, onUpgrade) {
    this.dbName = dbName;
    this.version = version;
    this.onUpgrade = onUpgrade;
    this.db = null;
  }
  
  async open() {
    return new Promise((resolve, reject) => {
      const request = indexedDB.open(this.dbName, this.version);
      
      request.onerror = () => reject(request.error);
      request.onsuccess = () => {
        this.db = request.result;
        resolve(this.db);
      };
      request.onupgradeneeded = (event) => {
        this.onUpgrade(event.target.result, event);
      };
    });
  }
  
  async get(storeName, key) {
    return this._request(storeName, 'readonly', store => store.get(key));
  }
  
  async getAll(storeName, query, count) {
    return this._request(storeName, 'readonly', store => store.getAll(query, count));
  }
  
  async add(storeName, value) {
    return this._request(storeName, 'readwrite', store => store.add(value));
  }
  
  async put(storeName, value) {
    return this._request(storeName, 'readwrite', store => store.put(value));
  }
  
  async delete(storeName, key) {
    return this._request(storeName, 'readwrite', store => store.delete(key));
  }
  
  async clear(storeName) {
    return this._request(storeName, 'readwrite', store => store.clear());
  }
  
  async getByIndex(storeName, indexName, value) {
    return this._request(storeName, 'readonly', store => 
      store.index(indexName).getAll(value)
    );
  }
  
  async _request(storeName, mode, operation) {
    return new Promise((resolve, reject) => {
      const tx = this.db.transaction(storeName, mode);
      const store = tx.objectStore(storeName);
      const request = operation(store);
      
      request.onsuccess = () => resolve(request.result);
      request.onerror = () => reject(request.error);
    });
  }
  
  close() {
    if (this.db) {
      this.db.close();
      this.db = null;
    }
  }
}

// Usage
const store = new IndexedDBStore('myApp', 1, (db) => {
  db.createObjectStore('users', { keyPath: 'id' });
});

await store.open();
await store.add('users', { id: 1, name: 'John' });
const users = await store.getAll('users');
```

---

## 5.3.9 Common Patterns

### Offline Data Sync

```javascript
class OfflineSync {
  constructor(db, storeName) {
    this.db = db;
    this.storeName = storeName;
    this.pendingStore = `${storeName}_pending`;
  }
  
  async save(item) {
    // Save locally
    await this.db.put(this.storeName, item);
    
    // Queue for sync
    await this.db.add(this.pendingStore, {
      id: Date.now(),
      action: 'update',
      item
    });
    
    // Try to sync
    this.sync();
  }
  
  async sync() {
    if (!navigator.onLine) return;
    
    const pending = await this.db.getAll(this.pendingStore);
    
    for (const action of pending) {
      try {
        await fetch('/api/sync', {
          method: 'POST',
          body: JSON.stringify(action)
        });
        
        await this.db.delete(this.pendingStore, action.id);
      } catch (error) {
        // Will retry on next sync
        console.error('Sync failed:', error);
      }
    }
  }
}
```

---

## 5.3.10 Gotchas

```javascript
// ❌ Forgetting onupgradeneeded for new stores
// Stores can only be created in onupgradeneeded

// ❌ Using transaction after it completes
const tx = db.transaction('users', 'readwrite');
const store = tx.objectStore('users');
await someAsyncOperation();  // Transaction is now complete!
store.add(user);  // Error: transaction inactive

// ✅ Keep transaction active or create new one
const tx = db.transaction('users', 'readwrite');
store.add(user);
// All operations must be synchronous within transaction

// ❌ Not handling version conflicts
// If another tab has DB open at old version, upgrade blocks

// ✅ Handle blocked event
request.onblocked = () => {
  alert('Please close other tabs with this app');
};

// ❌ Storing non-cloneable objects
store.add({ fn: () => {} });  // Error: functions can't be cloned

// ✅ Only store cloneable data
store.add({ data: 'serializable' });
```

---

## 5.3.11 Summary

### Key Concepts

| Concept | Description |
|---------|-------------|
| Database | Container for object stores |
| Object Store | Table-like collection |
| Index | Secondary lookup key |
| Transaction | Atomic operation group |
| Cursor | Iterator for records |

### Transaction Modes

| Mode | Description |
|------|-------------|
| `readonly` | Read-only, allows concurrency |
| `readwrite` | Read/write, exclusive access |

### Key Range Methods

| Method | Range |
|--------|-------|
| `only(value)` | Exact match |
| `lowerBound(x)` | `>= x` |
| `upperBound(x)` | `<= x` |
| `bound(x, y)` | `x <= key <= y` |

### Best Practices

1. **Always handle errors** on requests and transactions
2. **Use version numbers** for schema migrations
3. **Keep transactions short** - they auto-complete
4. **Use indexes** for querying non-key properties
5. **Wrap in Promises** for easier async/await usage
6. **Handle `blocked` event** for multi-tab scenarios

---

**End of Chapter 5.3: IndexedDB**

Next chapter: **5.4 Cache API** — covers the Cache API for storing request/response pairs.
# 5.4 Cache API

The Cache API provides a mechanism for storing HTTP request/response pairs, designed primarily for Service Workers but also available in the main thread. This chapter covers cache operations, caching strategies, and integration with Service Workers.

---

## 5.4.1 Cache API Overview

### What Is the Cache API?

```javascript
// The Cache API:
// - Stores Request/Response pairs
// - Designed for offline-first applications
// - Works in main thread and Service Workers
// - Part of the Service Worker spec
// - Promise-based asynchronous API

// Primary use cases:
// - Caching static assets (HTML, CSS, JS, images)
// - Offline support for web apps
// - Performance optimization
// - Network fallback strategies
```

### Cache API vs Other Storage

| Feature | Cache API | IndexedDB | localStorage |
|---------|-----------|-----------|--------------|
| Data type | Request/Response | Any cloneable | Strings |
| Size limit | Large | Large | ~5MB |
| Use case | HTTP caching | Structured data | Simple data |
| Async | Yes | Yes | No |

---

## 5.4.2 Opening Caches

### caches.open()

```javascript
// Open (or create) a named cache
const cache = await caches.open('my-cache-v1');

// Returns a Cache object
console.log(cache);  // Cache {}
```

### caches.keys()

```javascript
// List all cache names
const cacheNames = await caches.keys();
console.log(cacheNames);  // ['my-cache-v1', 'my-cache-v2']
```

### caches.has()

```javascript
// Check if cache exists
const exists = await caches.has('my-cache-v1');
console.log(exists);  // true or false
```

### caches.delete()

```javascript
// Delete a cache
const deleted = await caches.delete('my-cache-v1');
console.log(deleted);  // true if existed and deleted
```

---

## 5.4.3 Cache Operations

### cache.add()

```javascript
// Fetch and cache a single request
const cache = await caches.open('static-v1');

// Add by URL
await cache.add('/styles/main.css');

// Add by Request object
await cache.add(new Request('/api/data'));

// Fails if fetch fails or non-2xx response
```

### cache.addAll()

```javascript
// Cache multiple resources at once
const cache = await caches.open('static-v1');

await cache.addAll([
  '/',
  '/index.html',
  '/styles/main.css',
  '/scripts/app.js',
  '/images/logo.png'
]);

// ⚠️ Fails entirely if any request fails
// All-or-nothing operation
```

### cache.put()

```javascript
// Manually add request/response pair
const cache = await caches.open('dynamic-v1');

// Fetch then put
const response = await fetch('/api/data');
await cache.put('/api/data', response);

// ⚠️ Response can only be used once!
// Clone if you need to use it elsewhere
const response = await fetch('/api/data');
await cache.put('/api/data', response.clone());
return response;

// Create custom response
const customResponse = new Response(
  JSON.stringify({ cached: true }),
  { headers: { 'Content-Type': 'application/json' } }
);
await cache.put('/api/cached', customResponse);
```

### cache.match()

```javascript
// Find matching response
const cache = await caches.open('static-v1');

// Match by URL
const response = await cache.match('/styles/main.css');

if (response) {
  console.log('Cache hit!');
  return response;
} else {
  console.log('Cache miss');
}

// Match by Request
const request = new Request('/api/data');
const response = await cache.match(request);
```

### caches.match()

```javascript
// Search ALL caches for match
const response = await caches.match('/styles/main.css');

// Returns first match found
// More convenient but less explicit
```

### cache.matchAll()

```javascript
// Get all matching responses
const responses = await cache.matchAll('/api/data');

// Useful when multiple versions might exist
console.log(responses.length);
```

### cache.keys()

```javascript
// List all cached requests
const cache = await caches.open('static-v1');
const requests = await cache.keys();

requests.forEach(request => {
  console.log(request.url);
});
```

### cache.delete()

```javascript
// Remove item from cache
const cache = await caches.open('static-v1');

// Delete by URL
const deleted = await cache.delete('/old-file.js');
console.log(deleted);  // true if existed

// Delete by Request
await cache.delete(new Request('/api/data'));
```

---

## 5.4.4 Match Options

### ignoreSearch

```javascript
// Ignore query string when matching
const cache = await caches.open('pages-v1');
await cache.put('/page?v=1', response1);

// Default: won't match different query
const miss = await cache.match('/page?v=2');  // undefined

// With ignoreSearch: matches
const hit = await cache.match('/page?v=2', { ignoreSearch: true });
```

### ignoreMethod

```javascript
// Ignore HTTP method
// Default: GET requests match GET cached responses

// Match POST with cached GET
const response = await cache.match(
  new Request('/api/data', { method: 'POST' }),
  { ignoreMethod: true }
);
```

### ignoreVary

```javascript
// Ignore Vary header
// Default: respects Vary header for cache matching

const response = await cache.match('/api/data', { ignoreVary: true });
```

---

## 5.4.5 Service Worker Integration

### Precaching on Install

```javascript
// In service-worker.js
const CACHE_NAME = 'static-v1';
const PRECACHE_URLS = [
  '/',
  '/index.html',
  '/styles/main.css',
  '/scripts/app.js'
];

self.addEventListener('install', (event) => {
  event.waitUntil(
    caches.open(CACHE_NAME)
      .then(cache => cache.addAll(PRECACHE_URLS))
      .then(() => self.skipWaiting())
  );
});
```

### Cache-First Strategy

```javascript
self.addEventListener('fetch', (event) => {
  event.respondWith(
    caches.match(event.request)
      .then(cachedResponse => {
        // Return cache if found
        if (cachedResponse) {
          return cachedResponse;
        }
        // Otherwise fetch from network
        return fetch(event.request);
      })
  );
});
```

### Network-First Strategy

```javascript
self.addEventListener('fetch', (event) => {
  event.respondWith(
    fetch(event.request)
      .then(response => {
        // Clone response before caching
        const responseClone = response.clone();
        
        caches.open('dynamic-v1')
          .then(cache => cache.put(event.request, responseClone));
        
        return response;
      })
      .catch(() => {
        // Network failed, try cache
        return caches.match(event.request);
      })
  );
});
```

### Stale-While-Revalidate

```javascript
self.addEventListener('fetch', (event) => {
  event.respondWith(
    caches.open('dynamic-v1').then(cache => {
      return cache.match(event.request).then(cachedResponse => {
        // Start network fetch regardless
        const fetchPromise = fetch(event.request).then(networkResponse => {
          cache.put(event.request, networkResponse.clone());
          return networkResponse;
        });
        
        // Return cached immediately, update in background
        return cachedResponse || fetchPromise;
      });
    })
  );
});
```

---

## 5.4.6 Cache Versioning

### Managing Cache Versions

```javascript
const CACHE_VERSION = 'v2';
const CACHE_NAME = `static-${CACHE_VERSION}`;

// On activate, clean up old caches
self.addEventListener('activate', (event) => {
  event.waitUntil(
    caches.keys().then(cacheNames => {
      return Promise.all(
        cacheNames
          .filter(name => name.startsWith('static-'))
          .filter(name => name !== CACHE_NAME)
          .map(name => caches.delete(name))
      );
    })
  );
});
```

### Multiple Named Caches

```javascript
const CACHES = {
  static: 'static-v2',
  dynamic: 'dynamic-v1',
  images: 'images-v1'
};

// Use appropriate cache for each resource type
self.addEventListener('fetch', (event) => {
  const url = new URL(event.request.url);
  
  if (url.pathname.match(/\.(jpg|png|gif|svg)$/)) {
    event.respondWith(imageStrategy(event.request, CACHES.images));
  } else if (url.pathname.startsWith('/api/')) {
    event.respondWith(apiStrategy(event.request, CACHES.dynamic));
  } else {
    event.respondWith(staticStrategy(event.request, CACHES.static));
  }
});
```

---

## 5.4.7 Common Patterns

### Offline Fallback

```javascript
const OFFLINE_URL = '/offline.html';

self.addEventListener('install', (event) => {
  event.waitUntil(
    caches.open('offline-v1')
      .then(cache => cache.add(OFFLINE_URL))
  );
});

self.addEventListener('fetch', (event) => {
  if (event.request.mode === 'navigate') {
    event.respondWith(
      fetch(event.request)
        .catch(() => caches.match(OFFLINE_URL))
    );
  }
});
```

### Cache with Size Limit

```javascript
async function cacheLimited(cacheName, request, response, maxItems = 50) {
  const cache = await caches.open(cacheName);
  const keys = await cache.keys();
  
  // Remove oldest if at limit
  if (keys.length >= maxItems) {
    await cache.delete(keys[0]);
  }
  
  await cache.put(request, response);
}
```

### Main Thread Usage

```javascript
// Cache API works in main thread too
async function preCacheResources() {
  const cache = await caches.open('prefetch-v1');
  
  // Prefetch resources user might need
  await cache.addAll([
    '/next-page.html',
    '/heavy-image.jpg'
  ]);
}

// Check cache before fetching
async function getFromCacheOrNetwork(url) {
  const cached = await caches.match(url);
  if (cached) return cached;
  
  const response = await fetch(url);
  const cache = await caches.open('dynamic-v1');
  cache.put(url, response.clone());
  
  return response;
}
```

---

## 5.4.8 Gotchas

```javascript
// ❌ Using response without cloning
const response = await fetch('/api/data');
cache.put('/api/data', response);
return response;  // Error: body already used!

// ✅ Clone before caching
const response = await fetch('/api/data');
cache.put('/api/data', response.clone());
return response;

// ❌ Caching opaque responses carelessly
// Cross-origin responses without CORS have opaque type
// They report status 0, can't read body, but CAN be cached
const response = await fetch('https://other-site.com/image.jpg', { mode: 'no-cors' });
// This caches even if response was an error!
cache.put('/fallback', response);

// ✅ Check response status for same-origin
if (response.ok) {
  cache.put(request, response.clone());
}

// ❌ Assuming cache.addAll is partial
await cache.addAll(['/a', '/b', '/c']);
// If /b fails, NOTHING is cached

// ✅ Cache individually if partial success needed
for (const url of urls) {
  try {
    await cache.add(url);
  } catch (e) {
    console.log(`Failed to cache ${url}`);
  }
}

// ❌ Not versioning caches
// Old cached content persists forever

// ✅ Use versioned cache names and cleanup
const CACHE_NAME = 'static-v2';
// Clean old versions on activate
```

---

## 5.4.9 Summary

### CacheStorage Methods

| Method | Description |
|--------|-------------|
| `caches.open(name)` | Open/create cache |
| `caches.match(request)` | Search all caches |
| `caches.has(name)` | Check if cache exists |
| `caches.keys()` | List cache names |
| `caches.delete(name)` | Delete cache |

### Cache Methods

| Method | Description |
|--------|-------------|
| `add(request)` | Fetch and cache |
| `addAll(requests)` | Fetch and cache multiple |
| `put(request, response)` | Store pair directly |
| `match(request)` | Find response |
| `matchAll(request)` | Find all responses |
| `keys()` | List cached requests |
| `delete(request)` | Remove from cache |

### Caching Strategies

| Strategy | Use Case |
|----------|----------|
| Cache-first | Static assets, offline-first |
| Network-first | API data, fresh content |
| Stale-while-revalidate | Balance freshness/speed |
| Network-only | Never cache |
| Cache-only | Pre-cached content only |

### Best Practices

1. **Version your caches** and clean old versions
2. **Clone responses** before caching
3. **Handle failures** in addAll
4. **Use appropriate strategies** for different resources
5. **Limit cache size** for dynamic content

---

**End of Chapter 5.4: Cache API**

Next chapter: **5.5 Storage Manager** — covers the Storage Manager API for checking and managing storage quota.
# 5.5 Storage Manager

The Storage Manager API provides methods to check storage quota, estimate usage, and request persistent storage. This chapter covers querying storage capacity, requesting persistence, and managing storage across different browser storage mechanisms.

---

## 5.5.1 Storage Manager Overview

### What Is Storage Manager?

```javascript
// Storage Manager API (navigator.storage):
// - Estimate storage quota and usage
// - Request persistent storage
// - Check persistence status
// - Unified across all storage types

// Covers all storage:
// - IndexedDB
// - Cache API
// - Service Worker registrations
// - Cookies (conceptually)
// - Web Storage (localStorage/sessionStorage)

// Access the API
const storage = navigator.storage;
```

### Browser Support

```javascript
// Check if Storage Manager is available
if ('storage' in navigator && 'estimate' in navigator.storage) {
  // Use Storage Manager API
  const estimate = await navigator.storage.estimate();
} else {
  // Fallback for older browsers
  console.log('Storage Manager not supported');
}
```

---

## 5.5.2 Estimating Storage

### navigator.storage.estimate()

```javascript
// Get storage quota and usage
const estimate = await navigator.storage.estimate();

console.log('Quota:', estimate.quota);           // Total available bytes
console.log('Usage:', estimate.usage);           // Currently used bytes
console.log('Available:', estimate.quota - estimate.usage);

// Format for display
function formatBytes(bytes) {
  const units = ['B', 'KB', 'MB', 'GB'];
  let i = 0;
  
  while (bytes >= 1024 && i < units.length - 1) {
    bytes /= 1024;
    i++;
  }
  
  return `${bytes.toFixed(2)} ${units[i]}`;
}

console.log(`Used: ${formatBytes(estimate.usage)} of ${formatBytes(estimate.quota)}`);
// "Used: 15.50 MB of 2.00 GB"
```

### Usage Breakdown

```javascript
// Some browsers provide usage breakdown
const estimate = await navigator.storage.estimate();

if (estimate.usageDetails) {
  console.log('IndexedDB:', formatBytes(estimate.usageDetails.indexedDB || 0));
  console.log('Cache API:', formatBytes(estimate.usageDetails.caches || 0));
  console.log('Service Workers:', formatBytes(estimate.usageDetails.serviceWorkerRegistrations || 0));
}

// Example output:
// IndexedDB: 10.25 MB
// Cache API: 5.10 MB
// Service Workers: 0.15 MB
```

### Usage Percentage

```javascript
async function getStorageUsage() {
  const estimate = await navigator.storage.estimate();
  
  return {
    quota: estimate.quota,
    usage: estimate.usage,
    available: estimate.quota - estimate.usage,
    percentUsed: (estimate.usage / estimate.quota) * 100,
    percentAvailable: ((estimate.quota - estimate.usage) / estimate.quota) * 100
  };
}

const usage = await getStorageUsage();
console.log(`${usage.percentUsed.toFixed(2)}% used`);  // "0.75% used"
```

---

## 5.5.3 Persistent Storage

### Understanding Persistence

```javascript
// Browser storage is by default "best-effort"
// Browser may clear it under storage pressure:
// - Low disk space
// - User hasn't visited in a while
// - Storage quota exceeded

// Persistent storage survives storage pressure
// Only cleared by user action or explicit code

// Benefits of persistence:
// - Data won't be evicted automatically
// - More reliable for important data
// - User has more control
```

### Checking Persistence

```javascript
// Check if storage is persistent
const isPersisted = await navigator.storage.persisted();

if (isPersisted) {
  console.log('Storage is persistent');
} else {
  console.log('Storage may be cleared by browser');
}
```

### Requesting Persistence

```javascript
// Request persistent storage
const granted = await navigator.storage.persist();

if (granted) {
  console.log('Persistence granted!');
} else {
  console.log('Persistence denied');
}
```

### Persistence Criteria

```javascript
// Browsers decide persistence based on various factors:
// Chrome: 
// - Site is bookmarked
// - Has high engagement
// - Has push notifications enabled
// - Added to homescreen

// Firefox:
// - Prompts user

// Safari:
// - Limited persistence support

// Example: Request after user action
async function enablePersistence() {
  // First check if already persisted
  if (await navigator.storage.persisted()) {
    return true;
  }
  
  // Request persistence
  const granted = await navigator.storage.persist();
  
  if (!granted) {
    // Notify user they might lose data
    showWarning('Your data may be cleared by the browser under low storage conditions.');
  }
  
  return granted;
}
```

---

## 5.5.4 Storage Quota Management

### Handling Quota Exceeded

```javascript
async function safeStore(key, data) {
  try {
    await storeData(key, data);
    return true;
  } catch (error) {
    if (error.name === 'QuotaExceededError') {
      // Try to free up space
      await cleanupOldData();
      
      // Retry
      try {
        await storeData(key, data);
        return true;
      } catch (retryError) {
        console.error('Still quota exceeded after cleanup');
        return false;
      }
    }
    throw error;
  }
}
```

### Proactive Quota Management

```javascript
async function checkAndManageStorage() {
  const { usage, quota } = await navigator.storage.estimate();
  const percentUsed = (usage / quota) * 100;
  
  if (percentUsed > 80) {
    console.warn('Storage over 80% - consider cleanup');
    await cleanupCaches();
  }
  
  if (percentUsed > 95) {
    console.error('Storage critical - performing emergency cleanup');
    await emergencyCleanup();
  }
}

async function cleanupCaches() {
  const cacheNames = await caches.keys();
  
  // Delete old versioned caches
  for (const name of cacheNames) {
    if (name.includes('-old') || name.includes('-v1')) {
      await caches.delete(name);
    }
  }
}
```

---

## 5.5.5 Storage Buckets API (Emerging)

### Storage Buckets Overview

```javascript
// Storage Buckets API (Chrome 122+)
// Provides more granular storage management

// Check support
if ('storageBuckets' in navigator) {
  // Use Storage Buckets API
}

// Create a bucket
const bucket = await navigator.storageBuckets.open('user-data', {
  persisted: true,  // Request persistence
  durability: 'strict',  // Prioritize durability
  quota: 500 * 1024 * 1024  // Request 500MB
});

// Use bucket's storage
const indexedDB = bucket.indexedDB;
const caches = bucket.caches;
```

### Bucket Properties

```javascript
// Get bucket information
const bucket = await navigator.storageBuckets.open('app-data');

// Check estimated usage
const estimate = await bucket.estimate();
console.log('Bucket usage:', estimate.usage);
console.log('Bucket quota:', estimate.quota);

// Check persistence
const persisted = await bucket.persisted();

// Check durability
const durability = bucket.durability;  // 'strict' or 'relaxed'

// Get expiration
const expiration = await bucket.expires();  // Date or null
```

### Managing Buckets

```javascript
// List all buckets
const buckets = await navigator.storageBuckets.keys();
console.log(buckets);  // ['user-data', 'app-cache', ...]

// Delete a bucket (and all its data!)
await navigator.storageBuckets.delete('old-bucket');

// Set expiration
const bucket = await navigator.storageBuckets.open('session-data', {
  expires: Date.now() + (24 * 60 * 60 * 1000)  // 24 hours
});
```

---

## 5.5.6 Common Patterns

### Storage Status Component

```javascript
class StorageStatus {
  constructor() {
    this.update();
    
    // Update every minute
    setInterval(() => this.update(), 60000);
  }
  
  async update() {
    if (!navigator.storage?.estimate) {
      this.status = { supported: false };
      return;
    }
    
    const estimate = await navigator.storage.estimate();
    const persisted = await navigator.storage.persisted();
    
    this.status = {
      supported: true,
      quota: estimate.quota,
      usage: estimate.usage,
      available: estimate.quota - estimate.usage,
      percentUsed: (estimate.usage / estimate.quota) * 100,
      persisted,
      usageDetails: estimate.usageDetails || null
    };
    
    this.render();
  }
  
  render() {
    const el = document.getElementById('storage-status');
    if (!el) return;
    
    const { status } = this;
    if (!status.supported) {
      el.textContent = 'Storage API not supported';
      return;
    }
    
    el.innerHTML = `
      <div>Storage: ${this.formatBytes(status.usage)} / ${this.formatBytes(status.quota)}</div>
      <div>Available: ${this.formatBytes(status.available)}</div>
      <div>Persistent: ${status.persisted ? '✅' : '❌'}</div>
      <progress value="${status.percentUsed}" max="100"></progress>
    `;
  }
  
  formatBytes(bytes) {
    const units = ['B', 'KB', 'MB', 'GB'];
    let i = 0;
    while (bytes >= 1024 && i < units.length - 1) {
      bytes /= 1024;
      i++;
    }
    return `${bytes.toFixed(1)} ${units[i]}`;
  }
}
```

### Request Persistence on Important Action

```javascript
async function saveImportantDocument(doc) {
  // Ensure persistence for important data
  if (navigator.storage) {
    const persisted = await navigator.storage.persisted();
    
    if (!persisted) {
      const granted = await navigator.storage.persist();
      
      if (!granted) {
        // Warn user but don't block
        showToast('Note: Your browser may clear offline data');
      }
    }
  }
  
  // Save the document
  await saveToIndexedDB(doc);
}
```

### Storage Monitor

```javascript
class StorageMonitor {
  constructor(thresholds = { warning: 80, critical: 95 }) {
    this.thresholds = thresholds;
    this.listeners = [];
  }
  
  addListener(callback) {
    this.listeners.push(callback);
  }
  
  async check() {
    const estimate = await navigator.storage.estimate();
    const percent = (estimate.usage / estimate.quota) * 100;
    
    let level = 'ok';
    if (percent >= this.thresholds.critical) {
      level = 'critical';
    } else if (percent >= this.thresholds.warning) {
      level = 'warning';
    }
    
    const event = {
      level,
      percent,
      usage: estimate.usage,
      quota: estimate.quota
    };
    
    this.listeners.forEach(cb => cb(event));
    return event;
  }
  
  startMonitoring(intervalMs = 60000) {
    this.check();  // Initial check
    this.interval = setInterval(() => this.check(), intervalMs);
  }
  
  stopMonitoring() {
    if (this.interval) {
      clearInterval(this.interval);
    }
  }
}

// Usage
const monitor = new StorageMonitor();
monitor.addListener(event => {
  if (event.level === 'critical') {
    performEmergencyCleanup();
  } else if (event.level === 'warning') {
    showStorageWarning();
  }
});
monitor.startMonitoring();
```

---

## 5.5.7 Gotchas

```javascript
// ❌ Assuming exact quota numbers
// estimate() returns estimates, not exact values
const { quota } = await navigator.storage.estimate();
// Don't rely on this for exact calculations

// ❌ Expecting persistence to always succeed
const granted = await navigator.storage.persist();
// May return false - always have fallback strategy

// ✅ Handle denied persistence gracefully
if (!granted) {
  // Continue but warn user
  // Or store less critical data only
}

// ❌ Not checking browser support
navigator.storage.estimate();  // Might throw

// ✅ Feature detection first
if (navigator.storage && navigator.storage.estimate) {
  // Safe to use
}

// ❌ Blocking on persistence request
// Some browsers prompt user - may take time
await navigator.storage.persist();  // Could wait for user

// ✅ Non-blocking persistence request
navigator.storage.persist().then(granted => {
  // Update UI accordingly
});

// ❌ Assuming usageDetails is always available
const { usageDetails } = await navigator.storage.estimate();
console.log(usageDetails.indexedDB);  // Might be undefined!

// ✅ Check before accessing
if (usageDetails?.indexedDB) {
  console.log(usageDetails.indexedDB);
}
```

---

## 5.5.8 Summary

### Storage Manager Methods

| Method | Description |
|--------|-------------|
| `estimate()` | Get quota and usage |
| `persisted()` | Check persistence status |
| `persist()` | Request persistence |

### estimate() Return Value

| Property | Description |
|----------|-------------|
| `quota` | Total available bytes |
| `usage` | Currently used bytes |
| `usageDetails` | Breakdown by storage type (optional) |

### Persistence Factors (Chrome)

| Factor | Impact |
|--------|--------|
| Site bookmarked | Increases chance |
| High engagement | Increases chance |
| Push notifications | Increases chance |
| Added to homescreen | Increases chance |

### Best Practices

1. **Check quota before large operations**
2. **Request persistence for important data**
3. **Handle persistence denial gracefully**
4. **Monitor storage usage over time**
5. **Implement cleanup strategies**
6. **Feature-detect before using API**

---

**End of Chapter 5.5: Storage Manager**

This completes the Storage APIs group. Next section: **Group 06 — Fetch and AJAX** — covers making HTTP requests from the browser.
# 6.1 XMLHttpRequest

XMLHttpRequest (XHR) is the original API for making HTTP requests from JavaScript. While largely superseded by the Fetch API, understanding XHR remains important for legacy code, upload progress tracking, and certain specific use cases.

---

## 6.1.1 XHR Overview

### What Is XMLHttpRequest?

```javascript
// XMLHttpRequest:
// - Original AJAX API (since IE5)
// - Makes HTTP requests from JavaScript
// - Event-based, asynchronous API
// - Name is historical - works with any data, not just XML

// When to use XHR over Fetch:
// - Upload progress tracking (native support)
// - Legacy browser support
// - Request timeout configuration
// - Synchronous requests (not recommended)
```

### Basic XHR Flow

```javascript
// 1. Create XHR object
const xhr = new XMLHttpRequest();

// 2. Configure request
xhr.open('GET', '/api/data');

// 3. Set up event handlers
xhr.onload = function() {
  if (xhr.status === 200) {
    console.log(xhr.responseText);
  }
};

// 4. Send request
xhr.send();
```

---

## 6.1.2 Creating and Sending Requests

### GET Request

```javascript
const xhr = new XMLHttpRequest();
xhr.open('GET', '/api/users');

xhr.onload = function() {
  if (xhr.status === 200) {
    const users = JSON.parse(xhr.responseText);
    console.log(users);
  }
};

xhr.onerror = function() {
  console.error('Network error');
};

xhr.send();
```

### POST Request with JSON

```javascript
const xhr = new XMLHttpRequest();
xhr.open('POST', '/api/users');

// Set Content-Type header
xhr.setRequestHeader('Content-Type', 'application/json');

xhr.onload = function() {
  if (xhr.status === 201) {
    const newUser = JSON.parse(xhr.responseText);
    console.log('Created:', newUser);
  }
};

// Send JSON body
xhr.send(JSON.stringify({
  name: 'John Doe',
  email: 'john@example.com'
}));
```

### POST with FormData

```javascript
const formData = new FormData();
formData.append('name', 'John');
formData.append('email', 'john@example.com');
formData.append('avatar', fileInput.files[0]);

const xhr = new XMLHttpRequest();
xhr.open('POST', '/api/users');

// Don't set Content-Type - browser sets it with boundary
xhr.onload = function() {
  console.log(xhr.status, xhr.responseText);
};

xhr.send(formData);
```

### Other HTTP Methods

```javascript
// PUT
xhr.open('PUT', '/api/users/123');
xhr.send(JSON.stringify(updatedData));

// DELETE
xhr.open('DELETE', '/api/users/123');
xhr.send();

// PATCH
xhr.open('PATCH', '/api/users/123');
xhr.send(JSON.stringify({ status: 'active' }));
```

---

## 6.1.3 Ready State and Status

### readyState Values

```javascript
const xhr = new XMLHttpRequest();

xhr.onreadystatechange = function() {
  console.log('readyState:', xhr.readyState);
  
  // 0 - UNSENT: XHR created, open() not called
  // 1 - OPENED: open() called
  // 2 - HEADERS_RECEIVED: send() called, headers received
  // 3 - LOADING: receiving response body
  // 4 - DONE: operation complete
  
  if (xhr.readyState === XMLHttpRequest.DONE) {
    if (xhr.status === 200) {
      console.log('Success:', xhr.responseText);
    }
  }
};

xhr.open('GET', '/api/data');
xhr.send();
```

### Status Codes

```javascript
xhr.onload = function() {
  console.log('Status:', xhr.status);        // 200, 404, 500, etc.
  console.log('Status text:', xhr.statusText);  // "OK", "Not Found", etc.
  
  if (xhr.status >= 200 && xhr.status < 300) {
    // Success
  } else if (xhr.status === 404) {
    // Not found
  } else if (xhr.status >= 500) {
    // Server error
  }
};
```

---

## 6.1.4 Event Handlers

### Load Events

```javascript
const xhr = new XMLHttpRequest();

// Fired when request completes successfully
xhr.onload = function() {
  console.log('Loaded:', xhr.status);
};

// Fired when request fails (network error)
xhr.onerror = function() {
  console.error('Network error');
};

// Fired when request times out
xhr.ontimeout = function() {
  console.error('Request timed out');
};

// Fired when request is aborted
xhr.onabort = function() {
  console.log('Request aborted');
};

// Fired when request completes (success or failure)
xhr.onloadend = function() {
  console.log('Request finished (any outcome)');
};

xhr.open('GET', '/api/data');
xhr.send();
```

### Progress Events

```javascript
const xhr = new XMLHttpRequest();

// Download progress
xhr.onprogress = function(event) {
  if (event.lengthComputable) {
    const percent = (event.loaded / event.total) * 100;
    console.log(`Downloaded: ${percent.toFixed(2)}%`);
  } else {
    console.log(`Downloaded: ${event.loaded} bytes`);
  }
};

xhr.onloadstart = function() {
  console.log('Download started');
};

xhr.open('GET', '/large-file.zip');
xhr.send();
```

### Upload Progress

```javascript
const xhr = new XMLHttpRequest();

// Upload progress (via xhr.upload)
xhr.upload.onprogress = function(event) {
  if (event.lengthComputable) {
    const percent = (event.loaded / event.total) * 100;
    updateProgressBar(percent);
  }
};

xhr.upload.onloadstart = function() {
  console.log('Upload started');
};

xhr.upload.onload = function() {
  console.log('Upload complete');
};

xhr.upload.onerror = function() {
  console.error('Upload failed');
};

xhr.open('POST', '/api/upload');
xhr.send(formData);
```

---

## 6.1.5 Response Handling

### responseText and responseXML

```javascript
// Text response
xhr.onload = function() {
  console.log(xhr.responseText);  // Raw text
};

// XML response
xhr.onload = function() {
  const xmlDoc = xhr.responseXML;  // DOM Document
  const items = xmlDoc.getElementsByTagName('item');
};
```

### responseType

```javascript
// Set expected response type
xhr.responseType = 'json';  // Parse JSON automatically
xhr.responseType = 'blob';  // Binary data as Blob
xhr.responseType = 'arraybuffer';  // Binary data as ArrayBuffer
xhr.responseType = 'document';  // HTML/XML as Document
xhr.responseType = 'text';  // Text (default)

// Example: JSON response
const xhr = new XMLHttpRequest();
xhr.open('GET', '/api/users');
xhr.responseType = 'json';

xhr.onload = function() {
  // xhr.response is already parsed JSON
  const users = xhr.response;
  console.log(users[0].name);
};

xhr.send();

// Example: Blob response
const xhr = new XMLHttpRequest();
xhr.open('GET', '/image.png');
xhr.responseType = 'blob';

xhr.onload = function() {
  const blob = xhr.response;
  const url = URL.createObjectURL(blob);
  img.src = url;
};

xhr.send();
```

---

## 6.1.6 Headers

### Setting Request Headers

```javascript
const xhr = new XMLHttpRequest();
xhr.open('POST', '/api/data');

// Set headers AFTER open() but BEFORE send()
xhr.setRequestHeader('Content-Type', 'application/json');
xhr.setRequestHeader('Authorization', 'Bearer token123');
xhr.setRequestHeader('X-Custom-Header', 'value');

xhr.send(JSON.stringify(data));
```

### Reading Response Headers

```javascript
xhr.onload = function() {
  // Get single header
  const contentType = xhr.getResponseHeader('Content-Type');
  console.log(contentType);  // "application/json; charset=utf-8"
  
  // Get all headers as string
  const allHeaders = xhr.getAllResponseHeaders();
  console.log(allHeaders);
  // "content-type: application/json\r\ncache-control: no-cache\r\n..."
  
  // Parse all headers to object
  const headers = {};
  allHeaders.trim().split('\r\n').forEach(line => {
    const [name, value] = line.split(': ');
    headers[name.toLowerCase()] = value;
  });
};
```

---

## 6.1.7 Timeout and Abort

### Setting Timeout

```javascript
const xhr = new XMLHttpRequest();
xhr.open('GET', '/api/slow-endpoint');

// Set timeout in milliseconds
xhr.timeout = 5000;  // 5 seconds

xhr.ontimeout = function() {
  console.error('Request timed out after 5 seconds');
};

xhr.send();
```

### Aborting Requests

```javascript
const xhr = new XMLHttpRequest();
xhr.open('GET', '/api/data');

xhr.onabort = function() {
  console.log('Request was aborted');
};

xhr.send();

// Later... cancel the request
document.getElementById('cancel').onclick = function() {
  xhr.abort();
};
```

---

## 6.1.8 Credentials and CORS

### Sending Cookies Cross-Origin

```javascript
const xhr = new XMLHttpRequest();
xhr.open('GET', 'https://other-domain.com/api/data');

// Include cookies and HTTP auth
xhr.withCredentials = true;

xhr.onload = function() {
  console.log(xhr.response);
};

xhr.send();

// Server must respond with:
// Access-Control-Allow-Credentials: true
// Access-Control-Allow-Origin: https://your-domain.com (not *)
```

---

## 6.1.9 Promise Wrapper

```javascript
function request(method, url, data = null, options = {}) {
  return new Promise((resolve, reject) => {
    const xhr = new XMLHttpRequest();
    xhr.open(method, url);
    
    // Set response type
    if (options.responseType) {
      xhr.responseType = options.responseType;
    }
    
    // Set timeout
    if (options.timeout) {
      xhr.timeout = options.timeout;
    }
    
    // Set headers
    if (options.headers) {
      Object.entries(options.headers).forEach(([key, value]) => {
        xhr.setRequestHeader(key, value);
      });
    }
    
    // Handle credentials
    if (options.withCredentials) {
      xhr.withCredentials = true;
    }
    
    // Progress callback
    if (options.onProgress) {
      xhr.onprogress = options.onProgress;
    }
    
    if (options.onUploadProgress) {
      xhr.upload.onprogress = options.onUploadProgress;
    }
    
    xhr.onload = function() {
      if (xhr.status >= 200 && xhr.status < 300) {
        resolve({
          status: xhr.status,
          statusText: xhr.statusText,
          data: xhr.response,
          headers: parseHeaders(xhr.getAllResponseHeaders())
        });
      } else {
        reject({
          status: xhr.status,
          statusText: xhr.statusText,
          data: xhr.response
        });
      }
    };
    
    xhr.onerror = () => reject(new Error('Network error'));
    xhr.ontimeout = () => reject(new Error('Request timeout'));
    xhr.onabort = () => reject(new Error('Request aborted'));
    
    // Send
    if (data && typeof data === 'object' && !(data instanceof FormData)) {
      xhr.setRequestHeader('Content-Type', 'application/json');
      xhr.send(JSON.stringify(data));
    } else {
      xhr.send(data);
    }
  });
}

function parseHeaders(headerString) {
  const headers = {};
  headerString.trim().split('\r\n').forEach(line => {
    const [name, value] = line.split(': ');
    if (name) headers[name.toLowerCase()] = value;
  });
  return headers;
}

// Usage
const response = await request('GET', '/api/users', null, {
  responseType: 'json',
  timeout: 5000
});
console.log(response.data);
```

---

## 6.1.10 Gotchas

```javascript
// ❌ Setting headers before open()
xhr.setRequestHeader('Content-Type', 'application/json');
xhr.open('POST', '/api/data');
// Error: setRequestHeader must come after open()

// ✅ Set headers after open()
xhr.open('POST', '/api/data');
xhr.setRequestHeader('Content-Type', 'application/json');

// ❌ Using responseText with non-text responseType
xhr.responseType = 'json';
xhr.onload = function() {
  console.log(xhr.responseText);  // Error!
};

// ✅ Use response property
xhr.onload = function() {
  console.log(xhr.response);  // Parsed JSON
};

// ❌ Not handling status in onload
xhr.onload = function() {
  console.log(xhr.responseText);  // Could be error response!
};

// ✅ Check status
xhr.onload = function() {
  if (xhr.status >= 200 && xhr.status < 300) {
    console.log(xhr.responseText);
  } else {
    console.error('Error:', xhr.status);
  }
};

// ❌ Using synchronous XHR
xhr.open('GET', '/api/data', false);  // third param = async
// Blocks main thread - deprecated!

// ✅ Always use async
xhr.open('GET', '/api/data', true);  // or just omit third param
```

---

## 6.1.11 Summary

### XHR Lifecycle

| Method/Event | Description |
|-------------|-------------|
| `new XMLHttpRequest()` | Create XHR object |
| `open(method, url)` | Configure request |
| `setRequestHeader()` | Set headers |
| `send(body)` | Send request |
| `onload` | Response received |
| `onerror` | Network error |

### readyState Values

| Value | Constant | Meaning |
|-------|----------|---------|
| 0 | UNSENT | Created |
| 1 | OPENED | open() called |
| 2 | HEADERS_RECEIVED | Headers received |
| 3 | LOADING | Downloading body |
| 4 | DONE | Complete |

### responseType Values

| Value | Response Type |
|-------|--------------|
| `''` | String (default) |
| `'text'` | String |
| `'json'` | Parsed JSON |
| `'blob'` | Blob |
| `'arraybuffer'` | ArrayBuffer |
| `'document'` | HTML/XML Document |

### Best Practices

1. **Use Fetch API** for new code when possible
2. **Always handle errors** with onerror and status checks
3. **Use async mode** - never synchronous
4. **Set responseType** to avoid manual parsing
5. **Use XHR for upload progress** if needed

---

**End of Chapter 6.1: XMLHttpRequest**

Next chapter: **6.2 Fetch API** — covers the modern promise-based API for HTTP requests.
# 6.2 Fetch API

The Fetch API is the modern, promise-based API for making HTTP requests. This chapter covers request configuration, response handling, common patterns, and best practices for using fetch in modern web applications.

---

## 6.2.1 Fetch Overview

### What Is the Fetch API?

```javascript
// Fetch API:
// - Modern replacement for XMLHttpRequest
// - Promise-based, clean async/await syntax
// - Built on Request/Response objects
// - Works with Service Workers

// Basic fetch
const response = await fetch('/api/users');
const data = await response.json();

// Compared to XHR - much simpler
```

### Basic Usage

```javascript
// Simple GET request
fetch('/api/users')
  .then(response => response.json())
  .then(data => console.log(data))
  .catch(error => console.error('Error:', error));

// With async/await
async function getUsers() {
  try {
    const response = await fetch('/api/users');
    const data = await response.json();
    return data;
  } catch (error) {
    console.error('Error:', error);
  }
}
```

---

## 6.2.2 Request Configuration

### GET Requests

```javascript
// Simple GET
const response = await fetch('/api/users');

// GET with query parameters
const params = new URLSearchParams({
  page: 1,
  limit: 10,
  sort: 'name'
});
const response = await fetch(`/api/users?${params}`);

// Explicit GET with options
const response = await fetch('/api/users', {
  method: 'GET',
  headers: {
    'Accept': 'application/json'
  }
});
```

### POST Requests

```javascript
// POST with JSON body
const response = await fetch('/api/users', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json'
  },
  body: JSON.stringify({
    name: 'John Doe',
    email: 'john@example.com'
  })
});

const newUser = await response.json();
```

### Other HTTP Methods

```javascript
// PUT
await fetch('/api/users/123', {
  method: 'PUT',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify(updatedUser)
});

// PATCH
await fetch('/api/users/123', {
  method: 'PATCH',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify({ status: 'active' })
});

// DELETE
await fetch('/api/users/123', {
  method: 'DELETE'
});
```

### Request Options

```javascript
const response = await fetch('/api/data', {
  // HTTP method
  method: 'POST',
  
  // Headers
  headers: {
    'Content-Type': 'application/json',
    'Authorization': 'Bearer token123',
    'X-Custom-Header': 'value'
  },
  
  // Request body
  body: JSON.stringify(data),
  
  // Request mode
  mode: 'cors',  // cors, no-cors, same-origin
  
  // Credentials handling
  credentials: 'same-origin',  // omit, same-origin, include
  
  // Cache mode
  cache: 'default',  // default, no-store, reload, no-cache, force-cache
  
  // Redirect handling
  redirect: 'follow',  // follow, error, manual
  
  // Referrer policy
  referrerPolicy: 'no-referrer-when-downgrade',
  
  // AbortController signal
  signal: controller.signal
});
```

---

## 6.2.3 Headers

### Working with Headers

```javascript
// Create Headers object
const headers = new Headers();
headers.append('Content-Type', 'application/json');
headers.append('Authorization', 'Bearer token');

// Or use object literal
const headers = {
  'Content-Type': 'application/json',
  'Authorization': 'Bearer token'
};

// Headers methods
const h = new Headers();
h.set('Content-Type', 'application/json');
h.get('Content-Type');  // 'application/json'
h.has('Authorization');  // false
h.delete('Content-Type');
h.append('Accept', 'text/html');
h.append('Accept', 'application/json');  // Appends, doesn't replace

// Iterate headers
for (const [name, value] of h.entries()) {
  console.log(`${name}: ${value}`);
}
```

### Response Headers

```javascript
const response = await fetch('/api/data');

// Get specific header
const contentType = response.headers.get('Content-Type');

// Iterate all headers
for (const [name, value] of response.headers) {
  console.log(`${name}: ${value}`);
}

// Check if header exists
if (response.headers.has('X-Custom-Header')) {
  console.log(response.headers.get('X-Custom-Header'));
}
```

---

## 6.2.4 Request Object

### Creating Request Objects

```javascript
// Create Request directly
const request = new Request('/api/users', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json'
  },
  body: JSON.stringify({ name: 'John' })
});

// Use with fetch
const response = await fetch(request);

// Clone and modify
const newRequest = new Request(request, {
  method: 'GET',
  body: null
});
```

### Request Properties

```javascript
const request = new Request('/api/users', {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify({ name: 'John' })
});

console.log(request.url);         // Full URL
console.log(request.method);      // 'POST'
console.log(request.headers);     // Headers object
console.log(request.mode);        // 'cors'
console.log(request.credentials); // 'same-origin'
console.log(request.cache);       // 'default'
console.log(request.redirect);    // 'follow'

// Read body (can only be done once!)
const body = await request.json();
```

---

## 6.2.5 Sending Different Body Types

### JSON

```javascript
await fetch('/api/data', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json'
  },
  body: JSON.stringify({ key: 'value' })
});
```

### FormData

```javascript
const formData = new FormData();
formData.append('name', 'John');
formData.append('file', fileInput.files[0]);

// Don't set Content-Type - browser sets it with boundary
await fetch('/api/upload', {
  method: 'POST',
  body: formData
});
```

### URLSearchParams

```javascript
const params = new URLSearchParams();
params.append('name', 'John');
params.append('email', 'john@example.com');

await fetch('/api/submit', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/x-www-form-urlencoded'
  },
  body: params
});
```

### Blob / File

```javascript
const blob = new Blob(['Hello, World!'], { type: 'text/plain' });

await fetch('/api/upload', {
  method: 'POST',
  headers: {
    'Content-Type': 'text/plain'
  },
  body: blob
});

// File upload
const file = fileInput.files[0];
await fetch('/api/upload', {
  method: 'POST',
  headers: {
    'Content-Type': file.type
  },
  body: file
});
```

### ArrayBuffer / TypedArray

```javascript
const buffer = new ArrayBuffer(8);
const view = new Uint8Array(buffer);
view.set([0, 1, 2, 3, 4, 5, 6, 7]);

await fetch('/api/binary', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/octet-stream'
  },
  body: buffer
});
```

---

## 6.2.6 Credentials and CORS

### Credentials Mode

```javascript
// Don't send cookies (default for cross-origin)
await fetch('https://api.example.com/data', {
  credentials: 'omit'
});

// Send cookies only if same-origin (default for same-origin)
await fetch('/api/data', {
  credentials: 'same-origin'
});

// Always send cookies, even cross-origin
await fetch('https://api.example.com/data', {
  credentials: 'include'
});
```

### CORS Mode

```javascript
// Standard CORS request (default)
await fetch('https://api.example.com/data', {
  mode: 'cors'
});

// No CORS - limited functionality
// Only HEAD, GET, POST; limited headers; opaque response
await fetch('https://api.example.com/image.jpg', {
  mode: 'no-cors'
});

// Same-origin only
await fetch('/api/data', {
  mode: 'same-origin'  // Fails for cross-origin
});
```

---

## 6.2.7 Common Patterns

### Generic Fetch Wrapper

```javascript
async function api(endpoint, options = {}) {
  const baseURL = 'https://api.example.com';
  
  const config = {
    ...options,
    headers: {
      'Content-Type': 'application/json',
      ...options.headers
    }
  };
  
  // Add auth token
  const token = getAuthToken();
  if (token) {
    config.headers.Authorization = `Bearer ${token}`;
  }
  
  // Stringify body if object
  if (config.body && typeof config.body === 'object') {
    config.body = JSON.stringify(config.body);
  }
  
  const response = await fetch(`${baseURL}${endpoint}`, config);
  
  // Check for errors
  if (!response.ok) {
    const error = await response.json().catch(() => ({}));
    throw new ApiError(response.status, error.message || response.statusText);
  }
  
  // Return JSON or null
  const contentType = response.headers.get('Content-Type');
  if (contentType?.includes('application/json')) {
    return response.json();
  }
  return null;
}

class ApiError extends Error {
  constructor(status, message) {
    super(message);
    this.status = status;
  }
}

// Usage
const users = await api('/users');
const newUser = await api('/users', {
  method: 'POST',
  body: { name: 'John' }
});
```

### Retry with Backoff

```javascript
async function fetchWithRetry(url, options = {}, retries = 3) {
  for (let i = 0; i < retries; i++) {
    try {
      const response = await fetch(url, options);
      
      if (response.ok) {
        return response;
      }
      
      // Don't retry client errors
      if (response.status >= 400 && response.status < 500) {
        throw new Error(`Client error: ${response.status}`);
      }
      
    } catch (error) {
      if (i === retries - 1) throw error;
      
      // Exponential backoff
      const delay = Math.pow(2, i) * 1000;
      await new Promise(resolve => setTimeout(resolve, delay));
    }
  }
}
```

### Parallel Requests

```javascript
// Fetch multiple resources in parallel
const [users, posts, comments] = await Promise.all([
  fetch('/api/users').then(r => r.json()),
  fetch('/api/posts').then(r => r.json()),
  fetch('/api/comments').then(r => r.json())
]);

// With error handling
const results = await Promise.allSettled([
  fetch('/api/users').then(r => r.json()),
  fetch('/api/posts').then(r => r.json())
]);

results.forEach((result, i) => {
  if (result.status === 'fulfilled') {
    console.log(`Request ${i} succeeded:`, result.value);
  } else {
    console.error(`Request ${i} failed:`, result.reason);
  }
});
```

---

## 6.2.8 Gotchas

```javascript
// ❌ Not checking response.ok
const response = await fetch('/api/data');
const data = await response.json();  // May be error response!

// ✅ Check response status
const response = await fetch('/api/data');
if (!response.ok) {
  throw new Error(`HTTP error! status: ${response.status}`);
}
const data = await response.json();

// ❌ fetch doesn't reject on HTTP errors
try {
  const response = await fetch('/api/404');  // Won't throw!
} catch (error) {
  // Only catches network errors, not 404
}

// ✅ Manually throw on error status
const response = await fetch('/api/404');
if (!response.ok) {
  throw new Error('Not found');
}

// ❌ Reading body twice
const response = await fetch('/api/data');
const text = await response.text();
const json = await response.json();  // Error! Body already consumed

// ✅ Clone if you need to read multiple times
const response = await fetch('/api/data');
const clone = response.clone();
const text = await response.text();
const json = await clone.json();

// ❌ Setting Content-Type for FormData
await fetch('/api/upload', {
  method: 'POST',
  headers: { 'Content-Type': 'multipart/form-data' },  // Wrong!
  body: formData
});

// ✅ Let browser set it with boundary
await fetch('/api/upload', {
  method: 'POST',
  body: formData
});
```

---

## 6.2.9 Summary

### fetch() Options

| Option | Values | Default |
|--------|--------|---------|
| `method` | GET, POST, PUT, DELETE, etc. | GET |
| `headers` | Headers object or plain object | {} |
| `body` | String, FormData, Blob, etc. | null |
| `mode` | cors, no-cors, same-origin | cors |
| `credentials` | omit, same-origin, include | same-origin |
| `cache` | default, no-store, reload, etc. | default |
| `redirect` | follow, error, manual | follow |
| `signal` | AbortSignal | null |

### Body Types

| Type | Content-Type |
|------|-------------|
| JSON string | application/json |
| FormData | multipart/form-data (auto) |
| URLSearchParams | application/x-www-form-urlencoded |
| Blob/File | As specified |
| ArrayBuffer | application/octet-stream |

### Best Practices

1. **Always check response.ok** before processing
2. **Use async/await** for cleaner code
3. **Don't set Content-Type** for FormData
4. **Clone response** if reading body multiple times
5. **Handle both network errors and HTTP errors**
6. **Use AbortController** for cancellation

---

**End of Chapter 6.2: Fetch API**

Next chapter: **6.3 Response Handling** — covers parsing responses, streaming, and error handling.
# 6.3 Response Handling

The Response object represents the response to a request. This chapter covers parsing different response types, working with response metadata, streaming responses, and handling errors effectively.

---

## 6.3.1 Response Object

### Response Properties

```javascript
const response = await fetch('/api/data');

// Status information
console.log(response.status);       // 200
console.log(response.statusText);   // "OK"
console.log(response.ok);           // true (status 200-299)

// Response type
console.log(response.type);         // "basic", "cors", "opaque", etc.

// URL (after redirects)
console.log(response.url);          // "https://api.example.com/data"

// Was there a redirect?
console.log(response.redirected);   // false

// Headers
console.log(response.headers);      // Headers object
```

### Response Types

```javascript
// basic: same-origin response, all headers accessible
// cors: cross-origin, limited headers visible
// opaque: no-cors cross-origin, no body/headers access
// opaqueredirect: redirect with redirect: 'manual'
// error: network error

const response = await fetch(url);
switch (response.type) {
  case 'basic':
    // Full access to response
    break;
  case 'cors':
    // Can read body, limited headers
    break;
  case 'opaque':
    // Can't read body or headers
    // status is always 0
    break;
}
```

---

## 6.3.2 Parsing Response Bodies

### JSON Response

```javascript
const response = await fetch('/api/users');
const users = await response.json();

// Type-safe parsing (TypeScript)
interface User {
  id: number;
  name: string;
}

const users: User[] = await response.json();
```

### Text Response

```javascript
const response = await fetch('/page.html');
const html = await response.text();
document.body.innerHTML = html;
```

### Blob Response

```javascript
const response = await fetch('/image.png');
const blob = await response.blob();

// Create URL for image
const url = URL.createObjectURL(blob);
img.src = url;

// Download file
const a = document.createElement('a');
a.href = url;
a.download = 'image.png';
a.click();

// Clean up
URL.revokeObjectURL(url);
```

### ArrayBuffer Response

```javascript
const response = await fetch('/binary-data');
const buffer = await response.arrayBuffer();

// Work with binary data
const view = new DataView(buffer);
const firstInt = view.getInt32(0);

// Or typed array
const bytes = new Uint8Array(buffer);
```

### FormData Response

```javascript
const response = await fetch('/api/form-data');
const formData = await response.formData();

// Iterate form data
for (const [key, value] of formData) {
  console.log(key, value);
}
```

---

## 6.3.3 Streaming Responses

### Reading Response Stream

```javascript
const response = await fetch('/api/large-data');

// Get readable stream
const reader = response.body.getReader();

// Read chunks
while (true) {
  const { done, value } = await reader.read();
  
  if (done) break;
  
  // value is Uint8Array chunk
  console.log(`Received ${value.length} bytes`);
}
```

### Progress Tracking

```javascript
async function fetchWithProgress(url, onProgress) {
  const response = await fetch(url);
  
  // Get total size if available
  const contentLength = response.headers.get('Content-Length');
  const total = contentLength ? parseInt(contentLength, 10) : 0;
  
  const reader = response.body.getReader();
  let received = 0;
  const chunks = [];
  
  while (true) {
    const { done, value } = await reader.read();
    
    if (done) break;
    
    chunks.push(value);
    received += value.length;
    
    if (total) {
      onProgress(received / total * 100);
    }
  }
  
  // Combine chunks
  const body = new Uint8Array(received);
  let position = 0;
  for (const chunk of chunks) {
    body.set(chunk, position);
    position += chunk.length;
  }
  
  return body;
}

// Usage
const data = await fetchWithProgress('/large-file', (percent) => {
  console.log(`Downloaded: ${percent.toFixed(2)}%`);
});
```

### Text Decoder for Streaming

```javascript
async function streamText(url) {
  const response = await fetch(url);
  const reader = response.body.getReader();
  const decoder = new TextDecoder();
  
  let result = '';
  
  while (true) {
    const { done, value } = await reader.read();
    
    if (done) break;
    
    // Decode chunk, stream: true handles multi-byte chars
    result += decoder.decode(value, { stream: true });
  }
  
  // Final decode
  result += decoder.decode();
  
  return result;
}
```

### Processing Line by Line

```javascript
async function* readLines(url) {
  const response = await fetch(url);
  const reader = response.body.getReader();
  const decoder = new TextDecoder();
  
  let buffer = '';
  
  while (true) {
    const { done, value } = await reader.read();
    
    if (done) break;
    
    buffer += decoder.decode(value, { stream: true });
    
    // Process complete lines
    const lines = buffer.split('\n');
    buffer = lines.pop();  // Keep incomplete line
    
    for (const line of lines) {
      yield line;
    }
  }
  
  // Yield remaining buffer
  if (buffer) {
    yield buffer;
  }
}

// Usage
for await (const line of readLines('/api/log')) {
  console.log(line);
}
```

---

## 6.3.4 Server-Sent Events Pattern

### Streaming JSON Lines

```javascript
async function streamJSON(url, onData) {
  const response = await fetch(url);
  const reader = response.body.getReader();
  const decoder = new TextDecoder();
  
  let buffer = '';
  
  while (true) {
    const { done, value } = await reader.read();
    
    if (done) break;
    
    buffer += decoder.decode(value, { stream: true });
    
    // Parse complete JSON objects (newline-delimited)
    const lines = buffer.split('\n');
    buffer = lines.pop();
    
    for (const line of lines) {
      if (line.trim()) {
        try {
          const data = JSON.parse(line);
          onData(data);
        } catch (e) {
          console.error('Invalid JSON:', line);
        }
      }
    }
  }
}

// Usage with streaming API
await streamJSON('/api/stream', (data) => {
  console.log('Received:', data);
});
```

---

## 6.3.5 Response Cloning

### Why Clone Responses

```javascript
// Response body can only be read once
const response = await fetch('/api/data');
const text = await response.text();
const json = await response.json();  // Error! Body already consumed

// Clone to read multiple times
const response = await fetch('/api/data');
const clone = response.clone();

const text = await response.text();  // Original
const json = await clone.json();     // Clone
```

### Caching Cloned Responses

```javascript
// In Service Worker
self.addEventListener('fetch', (event) => {
  event.respondWith(
    fetch(event.request).then(response => {
      // Clone before caching
      const clone = response.clone();
      
      caches.open('dynamic').then(cache => {
        cache.put(event.request, clone);
      });
      
      return response;
    })
  );
});
```

---

## 6.3.6 Creating Responses

### Constructing Response Objects

```javascript
// Simple text response
const response = new Response('Hello, World!');

// JSON response
const response = new Response(JSON.stringify({ success: true }), {
  headers: {
    'Content-Type': 'application/json'
  }
});

// With status code
const response = new Response('Not Found', {
  status: 404,
  statusText: 'Not Found'
});

// Blob response
const blob = new Blob(['data'], { type: 'application/octet-stream' });
const response = new Response(blob);
```

### Static Response Methods

```javascript
// Error response
const response = Response.error();
// type: "error", status: 0

// Redirect response
const response = Response.redirect('https://example.com', 301);
// status: 301, Location header set

// JSON response (convenience)
const response = Response.json({ success: true });
// Content-Type: application/json, body stringified
```

---

## 6.3.7 Error Handling

### Network vs HTTP Errors

```javascript
async function safeFetch(url) {
  try {
    const response = await fetch(url);
    
    // HTTP errors don't throw - check manually
    if (!response.ok) {
      // 4xx, 5xx errors
      throw new HTTPError(response.status, response.statusText);
    }
    
    return await response.json();
    
  } catch (error) {
    if (error instanceof TypeError) {
      // Network error, CORS error, etc.
      console.error('Network error:', error.message);
    } else if (error instanceof HTTPError) {
      // HTTP error
      console.error('HTTP error:', error.status);
    }
    throw error;
  }
}

class HTTPError extends Error {
  constructor(status, statusText) {
    super(`HTTP ${status}: ${statusText}`);
    this.status = status;
  }
}
```

### Handling Different Status Codes

```javascript
async function handleResponse(response) {
  if (response.ok) {
    return response.json();
  }
  
  switch (response.status) {
    case 400:
      const errors = await response.json();
      throw new ValidationError(errors);
      
    case 401:
      redirectToLogin();
      throw new AuthError('Not authenticated');
      
    case 403:
      throw new AuthError('Not authorized');
      
    case 404:
      throw new NotFoundError('Resource not found');
      
    case 429:
      const retryAfter = response.headers.get('Retry-After');
      throw new RateLimitError(retryAfter);
      
    case 500:
    case 502:
    case 503:
      throw new ServerError('Server error, please try again');
      
    default:
      throw new Error(`Unexpected error: ${response.status}`);
  }
}
```

### Error Response Bodies

```javascript
async function parseError(response) {
  const contentType = response.headers.get('Content-Type');
  
  if (contentType?.includes('application/json')) {
    const error = await response.json();
    return {
      message: error.message || error.error || 'Unknown error',
      code: error.code,
      details: error.details || error.errors
    };
  }
  
  if (contentType?.includes('text/')) {
    const text = await response.text();
    return { message: text };
  }
  
  return { message: response.statusText };
}

// Usage
if (!response.ok) {
  const error = await parseError(response);
  throw new Error(error.message);
}
```

---

## 6.3.8 Common Patterns

### Response Interceptor

```javascript
async function fetchWithInterceptors(url, options = {}) {
  // Request interceptor
  const modifiedOptions = requestInterceptor(options);
  
  let response = await fetch(url, modifiedOptions);
  
  // Response interceptor
  response = await responseInterceptor(response);
  
  return response;
}

function requestInterceptor(options) {
  return {
    ...options,
    headers: {
      ...options.headers,
      'Authorization': `Bearer ${getToken()}`
    }
  };
}

async function responseInterceptor(response) {
  // Refresh token on 401
  if (response.status === 401) {
    const newToken = await refreshToken();
    // Retry request with new token
  }
  
  return response;
}
```

### Response Cache

```javascript
const cache = new Map();

async function cachedFetch(url, options = {}) {
  const cacheKey = `${options.method || 'GET'}:${url}`;
  
  if (cache.has(cacheKey)) {
    const { data, timestamp } = cache.get(cacheKey);
    const age = Date.now() - timestamp;
    
    if (age < 60000) {  // 1 minute cache
      return data;
    }
  }
  
  const response = await fetch(url, options);
  const data = await response.json();
  
  cache.set(cacheKey, {
    data,
    timestamp: Date.now()
  });
  
  return data;
}
```

---

## 6.3.9 Summary

### Response Body Methods

| Method | Returns | Use Case |
|--------|---------|----------|
| `json()` | Promise<any> | JSON data |
| `text()` | Promise<string> | Plain text, HTML |
| `blob()` | Promise<Blob> | Files, images |
| `arrayBuffer()` | Promise<ArrayBuffer> | Binary data |
| `formData()` | Promise<FormData> | Form submissions |

### Response Properties

| Property | Type | Description |
|----------|------|-------------|
| `status` | number | HTTP status code |
| `statusText` | string | Status message |
| `ok` | boolean | Status 200-299 |
| `headers` | Headers | Response headers |
| `url` | string | Final URL |
| `type` | string | Response type |
| `redirected` | boolean | Was redirected |
| `body` | ReadableStream | Response body stream |

### Best Practices

1. **Always check response.ok** before parsing
2. **Handle different error types** separately
3. **Clone response** if reading body multiple times
4. **Use streaming** for large responses
5. **Parse errors** to get meaningful messages
6. **Consider response type** for cross-origin requests

---

**End of Chapter 6.3: Response Handling**

Next chapter: **6.4 Request Cancellation** — covers AbortController and timeout handling.
# 6.4 Request Cancellation

Request cancellation allows you to abort in-flight HTTP requests. This chapter covers the AbortController API, timeout implementation, and patterns for managing cancellable requests in various scenarios.

---

## 6.4.1 AbortController Overview

### What Is AbortController?

```javascript
// AbortController provides a way to abort:
// - Fetch requests
// - DOM operations
// - Any async operation that accepts an AbortSignal

// Basic structure
const controller = new AbortController();
const signal = controller.signal;

// Later... abort!
controller.abort();
```

### Basic Usage

```javascript
const controller = new AbortController();

// Pass signal to fetch
const fetchPromise = fetch('/api/data', {
  signal: controller.signal
});

// Abort after 5 seconds
setTimeout(() => controller.abort(), 5000);

try {
  const response = await fetchPromise;
  const data = await response.json();
} catch (error) {
  if (error.name === 'AbortError') {
    console.log('Request was aborted');
  } else {
    throw error;
  }
}
```

---

## 6.4.2 Timeout Implementation

### Simple Timeout

```javascript
async function fetchWithTimeout(url, options = {}, timeoutMs = 5000) {
  const controller = new AbortController();
  
  // Set timeout
  const timeoutId = setTimeout(() => {
    controller.abort();
  }, timeoutMs);
  
  try {
    const response = await fetch(url, {
      ...options,
      signal: controller.signal
    });
    
    clearTimeout(timeoutId);
    return response;
    
  } catch (error) {
    clearTimeout(timeoutId);
    
    if (error.name === 'AbortError') {
      throw new Error(`Request timed out after ${timeoutMs}ms`);
    }
    throw error;
  }
}

// Usage
try {
  const response = await fetchWithTimeout('/api/data', {}, 3000);
} catch (error) {
  console.error(error.message);
}
```

### AbortSignal.timeout() (Modern)

```javascript
// Built-in timeout (Chrome 103+, Firefox 100+)
try {
  const response = await fetch('/api/data', {
    signal: AbortSignal.timeout(5000)  // 5 second timeout
  });
} catch (error) {
  if (error.name === 'TimeoutError') {
    console.log('Request timed out');
  } else if (error.name === 'AbortError') {
    console.log('Request aborted');
  }
}
```

### Combining Timeout and Manual Abort

```javascript
function fetchWithTimeoutAndAbort(url, options = {}, timeoutMs = 5000) {
  const controller = new AbortController();
  
  // Combine with timeout signal
  const timeoutSignal = AbortSignal.timeout(timeoutMs);
  
  // Use AbortSignal.any() to combine signals (if supported)
  const combinedSignal = AbortSignal.any([
    controller.signal,
    timeoutSignal
  ]);
  
  const promise = fetch(url, {
    ...options,
    signal: combinedSignal
  });
  
  // Return both the promise and the abort function
  return {
    promise,
    abort: () => controller.abort()
  };
}

// Usage
const { promise, abort } = fetchWithTimeoutAndAbort('/api/data', {}, 5000);

// Can abort manually
cancelButton.onclick = () => abort();

const response = await promise;
```

---

## 6.4.3 User-Initiated Cancellation

### Cancel Button Pattern

```javascript
let currentController = null;

async function search(query) {
  // Abort previous request
  if (currentController) {
    currentController.abort();
  }
  
  currentController = new AbortController();
  
  try {
    const response = await fetch(`/api/search?q=${query}`, {
      signal: currentController.signal
    });
    
    return await response.json();
    
  } catch (error) {
    if (error.name === 'AbortError') {
      // Ignore - request was intentionally cancelled
      return null;
    }
    throw error;
  }
}

// Input handler - cancels previous search on new input
searchInput.addEventListener('input', async (e) => {
  const results = await search(e.target.value);
  if (results) {
    displayResults(results);
  }
});
```

### Cancel on Component Unmount (React Pattern)

```javascript
function UserProfile({ userId }) {
  const [user, setUser] = useState(null);
  
  useEffect(() => {
    const controller = new AbortController();
    
    async function loadUser() {
      try {
        const response = await fetch(`/api/users/${userId}`, {
          signal: controller.signal
        });
        const data = await response.json();
        setUser(data);
      } catch (error) {
        if (error.name !== 'AbortError') {
          console.error('Failed to load user:', error);
        }
      }
    }
    
    loadUser();
    
    // Cleanup: abort on unmount or userId change
    return () => controller.abort();
  }, [userId]);
  
  return user ? <div>{user.name}</div> : <div>Loading...</div>;
}
```

---

## 6.4.4 AbortSignal Methods

### signal.aborted

```javascript
const controller = new AbortController();

console.log(controller.signal.aborted);  // false

controller.abort();

console.log(controller.signal.aborted);  // true

// Check before starting work
if (signal.aborted) {
  return;  // Don't start if already aborted
}
```

### signal.reason

```javascript
const controller = new AbortController();

// Abort with reason
controller.abort('User cancelled');

console.log(controller.signal.reason);  // 'User cancelled'

// Or with error
controller.abort(new Error('Custom error'));
```

### signal.throwIfAborted()

```javascript
const controller = new AbortController();

async function longOperation(signal) {
  for (let i = 0; i < 100; i++) {
    // Check if aborted at each step
    signal.throwIfAborted();
    
    await doSomeWork(i);
  }
}

try {
  await longOperation(controller.signal);
} catch (error) {
  if (error.name === 'AbortError') {
    console.log('Operation aborted');
  }
}
```

### abort Event

```javascript
const controller = new AbortController();

controller.signal.addEventListener('abort', () => {
  console.log('Abort signal received');
  console.log('Reason:', controller.signal.reason);
});

controller.abort('Cleanup');
// Logs: "Abort signal received"
// Logs: "Reason: Cleanup"
```

---

## 6.4.5 Multiple Request Cancellation

### Abort Multiple Requests

```javascript
const controller = new AbortController();

// Multiple parallel requests sharing same signal
const results = await Promise.all([
  fetch('/api/users', { signal: controller.signal }),
  fetch('/api/posts', { signal: controller.signal }),
  fetch('/api/comments', { signal: controller.signal })
]);

// Abort all at once
controller.abort();
```

### Race Pattern

```javascript
async function fetchWithRace(urls, timeout = 5000) {
  const controller = new AbortController();
  
  const fetchPromises = urls.map(url =>
    fetch(url, { signal: controller.signal })
  );
  
  const timeoutPromise = new Promise((_, reject) => {
    setTimeout(() => {
      controller.abort();
      reject(new Error('Timeout'));
    }, timeout);
  });
  
  try {
    // Race all fetches against timeout
    const response = await Promise.race([
      Promise.any(fetchPromises),
      timeoutPromise
    ]);
    
    // Abort remaining requests
    controller.abort();
    
    return response;
    
  } catch (error) {
    controller.abort();
    throw error;
  }
}
```

---

## 6.4.6 Custom Abortable Operations

### Making Your Functions Abortable

```javascript
function delay(ms, signal) {
  return new Promise((resolve, reject) => {
    // Check if already aborted
    if (signal?.aborted) {
      return reject(new DOMException('Aborted', 'AbortError'));
    }
    
    const timeoutId = setTimeout(resolve, ms);
    
    // Listen for abort
    signal?.addEventListener('abort', () => {
      clearTimeout(timeoutId);
      reject(new DOMException('Aborted', 'AbortError'));
    });
  });
}

// Usage
const controller = new AbortController();

try {
  await delay(5000, controller.signal);
  console.log('Delay completed');
} catch (error) {
  if (error.name === 'AbortError') {
    console.log('Delay cancelled');
  }
}

// Cancel after 2 seconds
setTimeout(() => controller.abort(), 2000);
```

### Abortable Generator

```javascript
async function* fetchPaginated(baseUrl, signal) {
  let page = 1;
  
  while (true) {
    signal?.throwIfAborted();
    
    const response = await fetch(`${baseUrl}?page=${page}`, { signal });
    const data = await response.json();
    
    if (data.length === 0) break;
    
    yield data;
    page++;
  }
}

// Usage
const controller = new AbortController();

for await (const page of fetchPaginated('/api/items', controller.signal)) {
  console.log('Got page:', page);
  
  if (shouldStop()) {
    controller.abort();
    break;
  }
}
```

---

## 6.4.7 Common Patterns

### Debounced Search with Cancellation

```javascript
function createDebouncedSearch(delay = 300) {
  let timeoutId;
  let controller;
  
  return async function search(query) {
    // Clear previous timeout
    clearTimeout(timeoutId);
    
    // Abort previous request
    controller?.abort();
    controller = new AbortController();
    
    return new Promise((resolve, reject) => {
      timeoutId = setTimeout(async () => {
        try {
          const response = await fetch(`/api/search?q=${query}`, {
            signal: controller.signal
          });
          resolve(await response.json());
        } catch (error) {
          if (error.name !== 'AbortError') {
            reject(error);
          }
        }
      }, delay);
    });
  };
}

const debouncedSearch = createDebouncedSearch();

// Automatically cancels previous requests
input.addEventListener('input', async (e) => {
  const results = await debouncedSearch(e.target.value);
  displayResults(results);
});
```

### Request Queue with Cancellation

```javascript
class RequestQueue {
  constructor() {
    this.queue = [];
    this.controller = null;
  }
  
  async add(url, options = {}) {
    // Store in queue with unique id
    const id = Date.now();
    const item = { id, url, options };
    this.queue.push(item);
    
    try {
      const response = await fetch(url, {
        ...options,
        signal: this.controller?.signal
      });
      return response;
    } finally {
      // Remove from queue
      this.queue = this.queue.filter(i => i.id !== id);
    }
  }
  
  cancelAll() {
    this.controller?.abort();
    this.controller = new AbortController();
    this.queue = [];
  }
  
  get pending() {
    return this.queue.length;
  }
}
```

---

## 6.4.8 Gotchas

```javascript
// ❌ Reusing aborted controller
const controller = new AbortController();
controller.abort();

// This will fail immediately!
await fetch('/api/data', { signal: controller.signal });

// ✅ Create new controller for each request
const newController = new AbortController();
await fetch('/api/data', { signal: newController.signal });

// ❌ Not catching AbortError
try {
  await fetch('/api/data', { signal: controller.signal });
} catch (error) {
  console.error(error);  // Logs AbortError even for intentional abort
}

// ✅ Handle AbortError separately
try {
  await fetch('/api/data', { signal: controller.signal });
} catch (error) {
  if (error.name === 'AbortError') {
    // Intentional abort - ignore or handle gracefully
    return;
  }
  console.error(error);  // Real error
}

// ❌ Memory leak - not removing abort listener
signal.addEventListener('abort', handler);
// Handler stays in memory even after operation completes

// ✅ Clean up listener
const handler = () => { /* ... */ };
signal.addEventListener('abort', handler);
// Later...
signal.removeEventListener('abort', handler);

// Or use { once: true }
signal.addEventListener('abort', handler, { once: true });
```

---

## 6.4.9 Summary

### AbortController API

| Property/Method | Description |
|----------------|-------------|
| `new AbortController()` | Create controller |
| `controller.signal` | Get AbortSignal |
| `controller.abort(reason)` | Abort with optional reason |

### AbortSignal Properties

| Property | Description |
|----------|-------------|
| `signal.aborted` | Boolean - is aborted? |
| `signal.reason` | Abort reason |
| `signal.throwIfAborted()` | Throw if aborted |
| `'abort'` event | Fired on abort |

### Static Methods

| Method | Description |
|--------|-------------|
| `AbortSignal.timeout(ms)` | Auto-abort after timeout |
| `AbortSignal.any(signals)` | Abort when any signal aborts |
| `AbortSignal.abort(reason)` | Create pre-aborted signal |

### Best Practices

1. **Create new controller** for each request
2. **Handle AbortError** separately from other errors
3. **Clean up listeners** to prevent memory leaks
4. **Abort on unmount** in component-based frameworks
5. **Use timeout** for long-running requests
6. **Cancel previous** when starting new related request

---

**End of Chapter 6.4: Request Cancellation**

Next chapter: **6.5 CORS** — covers Cross-Origin Resource Sharing and how to handle cross-origin requests.
# 6.5 CORS

Cross-Origin Resource Sharing (CORS) is a security mechanism that allows controlled access to resources from different origins. This chapter covers how CORS works, common scenarios, troubleshooting, and best practices for handling cross-origin requests.

---

## 6.5.1 Understanding CORS

### Same-Origin Policy

```javascript
// Same-origin policy: browser restricts scripts from making
// requests to different origins

// Origin = protocol + host + port
// https://example.com:443

// Same origin:
// https://example.com/page1 → https://example.com/page2  ✅

// Different origins:
// https://example.com → https://api.example.com  ❌ (different host)
// https://example.com → http://example.com       ❌ (different protocol)
// https://example.com → https://example.com:8080 ❌ (different port)
```

### What Is CORS?

```javascript
// CORS allows servers to specify who can access their resources
// Via HTTP headers:
// - Access-Control-Allow-Origin
// - Access-Control-Allow-Methods
// - Access-Control-Allow-Headers
// - Access-Control-Allow-Credentials
// - Access-Control-Max-Age
// - Access-Control-Expose-Headers
```

---

## 6.5.2 Simple vs Preflight Requests

### Simple Requests

```javascript
// Simple requests don't trigger preflight
// Requirements:
// - Method: GET, HEAD, or POST
// - Headers: Only simple headers (Accept, Accept-Language,
//   Content-Language, Content-Type with limited values)
// - Content-Type: application/x-www-form-urlencoded,
//   multipart/form-data, or text/plain

// This is a simple request
fetch('https://api.example.com/data', {
  method: 'GET',
  headers: {
    'Accept': 'application/json'
  }
});

// This is also simple
fetch('https://api.example.com/data', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/x-www-form-urlencoded'
  },
  body: 'name=John&email=john@example.com'
});
```

### Preflight Requests

```javascript
// Non-simple requests trigger preflight OPTIONS request
// Browser automatically sends OPTIONS before actual request

// This triggers preflight (custom header)
fetch('https://api.example.com/data', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',  // Not simple!
    'Authorization': 'Bearer token'       // Custom header
  },
  body: JSON.stringify({ name: 'John' })
});

// This triggers preflight (non-simple method)
fetch('https://api.example.com/data', {
  method: 'PUT'  // Not GET, HEAD, or POST
});

// Preflight flow:
// 1. Browser sends OPTIONS with:
//    - Origin: https://your-site.com
//    - Access-Control-Request-Method: POST
//    - Access-Control-Request-Headers: content-type, authorization
//
// 2. Server responds with:
//    - Access-Control-Allow-Origin: https://your-site.com
//    - Access-Control-Allow-Methods: POST, PUT, DELETE
//    - Access-Control-Allow-Headers: content-type, authorization
//    - Access-Control-Max-Age: 86400
//
// 3. If preflight succeeds, browser sends actual request
```

---

## 6.5.3 CORS Headers

### Server Response Headers

```javascript
// Access-Control-Allow-Origin
// Specifies allowed origin(s)
// Access-Control-Allow-Origin: https://example.com
// Access-Control-Allow-Origin: *  (any origin, no credentials)

// Access-Control-Allow-Methods
// Allowed HTTP methods for preflight
// Access-Control-Allow-Methods: GET, POST, PUT, DELETE

// Access-Control-Allow-Headers
// Allowed request headers
// Access-Control-Allow-Headers: Content-Type, Authorization, X-Custom-Header

// Access-Control-Allow-Credentials
// Allow credentials (cookies, HTTP auth)
// Access-Control-Allow-Credentials: true

// Access-Control-Max-Age
// Cache preflight response (seconds)
// Access-Control-Max-Age: 86400  (24 hours)

// Access-Control-Expose-Headers
// Headers readable by JavaScript
// Access-Control-Expose-Headers: X-Request-Id, X-RateLimit-Remaining
```

### Reading Exposed Headers

```javascript
const response = await fetch('https://api.example.com/data');

// These headers are always readable:
// - Cache-Control
// - Content-Language
// - Content-Type
// - Expires
// - Last-Modified
// - Pragma

// Custom headers need to be exposed:
const requestId = response.headers.get('X-Request-Id');
// Only works if server sends:
// Access-Control-Expose-Headers: X-Request-Id
```

---

## 6.5.4 Credentials and CORS

### Sending Credentials Cross-Origin

```javascript
// Include cookies/auth in cross-origin request
const response = await fetch('https://api.example.com/data', {
  credentials: 'include'
});

// Server MUST respond with:
// Access-Control-Allow-Credentials: true
// Access-Control-Allow-Origin: https://your-site.com (NOT *)

// ❌ Cannot use * with credentials
// Access-Control-Allow-Origin: *
// Access-Control-Allow-Credentials: true
// This combination is NOT allowed!
```

### Credential Modes

```javascript
// omit - never send credentials
fetch(url, { credentials: 'omit' });

// same-origin - send only to same origin (default)
fetch(url, { credentials: 'same-origin' });

// include - always send, even cross-origin
fetch(url, { credentials: 'include' });
```

---

## 6.5.5 Common CORS Errors

### No Access-Control-Allow-Origin

```javascript
// Error: "No 'Access-Control-Allow-Origin' header is present"

// Cause: Server doesn't include CORS headers

// Solution: Configure server to send:
// Access-Control-Allow-Origin: https://your-site.com
// Or for development:
// Access-Control-Allow-Origin: *
```

### Origin Not Allowed

```javascript
// Error: "Origin 'https://your-site.com' is not allowed"

// Cause: Server explicitly rejects your origin

// Solution: Add your origin to server's allowed list
```

### Preflight Failed

```javascript
// Error: "Response to preflight request doesn't pass"

// Cause: OPTIONS request failed or returned wrong headers

// Check:
// 1. Server handles OPTIONS method
// 2. Returns correct Access-Control-* headers
// 3. Returns 2xx status code
```

### Credentials with Wildcard

```javascript
// Error: "Cannot use wildcard with credentials"

// Cause: Using credentials: 'include' with
// Access-Control-Allow-Origin: *

// Solution: Server must specify exact origin:
// Access-Control-Allow-Origin: https://your-site.com
```

---

## 6.5.6 CORS Workarounds

### Proxy Server

```javascript
// Instead of direct cross-origin request:
// fetch('https://api.external.com/data')

// Use your own proxy:
fetch('/api/proxy?url=https://api.external.com/data');

// Your server makes the request (no CORS!)
// Express example:
app.get('/api/proxy', async (req, res) => {
  const response = await fetch(req.query.url);
  const data = await response.json();
  res.json(data);
});
```

### JSONP (Legacy)

```javascript
// Only for GET requests
// Server wraps response in callback

function jsonp(url, callbackName) {
  return new Promise((resolve, reject) => {
    const script = document.createElement('script');
    
    window[callbackName] = (data) => {
      delete window[callbackName];
      document.body.removeChild(script);
      resolve(data);
    };
    
    script.src = `${url}?callback=${callbackName}`;
    script.onerror = reject;
    document.body.appendChild(script);
  });
}

// Server returns: callback123({data: 'value'})
const data = await jsonp('https://api.example.com/data', 'callback123');
```

### no-cors Mode

```javascript
// For requests where you don't need to read response
fetch('https://api.example.com/track', {
  method: 'POST',
  mode: 'no-cors',  // Won't fail, but response is opaque
  body: JSON.stringify({ event: 'pageview' })
});

// Response is opaque:
// - status is 0
// - Can't read headers or body
// - Can cache in Service Worker
```

---

## 6.5.7 Server-Side CORS Configuration

### Node.js / Express

```javascript
const cors = require('cors');

// Allow all origins
app.use(cors());

// Or configure:
app.use(cors({
  origin: 'https://your-site.com',
  methods: ['GET', 'POST', 'PUT', 'DELETE'],
  allowedHeaders: ['Content-Type', 'Authorization'],
  credentials: true,
  maxAge: 86400
}));

// Or dynamically:
app.use(cors({
  origin: (origin, callback) => {
    const allowedOrigins = [
      'https://your-site.com',
      'https://app.your-site.com'
    ];
    
    if (!origin || allowedOrigins.includes(origin)) {
      callback(null, true);
    } else {
      callback(new Error('Not allowed by CORS'));
    }
  }
}));
```

### Manual Headers

```javascript
// Without cors package
app.use((req, res, next) => {
  res.header('Access-Control-Allow-Origin', 'https://your-site.com');
  res.header('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE');
  res.header('Access-Control-Allow-Headers', 'Content-Type, Authorization');
  res.header('Access-Control-Allow-Credentials', 'true');
  res.header('Access-Control-Max-Age', '86400');
  
  // Handle preflight
  if (req.method === 'OPTIONS') {
    return res.sendStatus(204);
  }
  
  next();
});
```

---

## 6.5.8 Debugging CORS

### Browser DevTools

```javascript
// Check Network tab:
// 1. Look for OPTIONS request (preflight)
// 2. Check request headers (Origin, Access-Control-Request-*)
// 3. Check response headers (Access-Control-Allow-*)

// Console shows CORS errors with details
```

### Common Debugging Steps

```javascript
// 1. Is it actually a CORS error?
// - Check if request reaches server (server logs)
// - Check for other errors (network, DNS)

// 2. Is preflight needed?
// - Check method and headers
// - Simplify request to avoid preflight

// 3. Server returning correct headers?
// - Check OPTIONS response
// - Verify headers are present

// 4. Using credentials?
// - Wildcard origin not allowed
// - Check cookie SameSite attribute
```

### Testing Tool

```javascript
// Quick test from console
async function testCORS(url) {
  try {
    const response = await fetch(url);
    console.log('Status:', response.status);
    console.log('CORS headers:');
    for (const [name, value] of response.headers) {
      if (name.startsWith('access-control')) {
        console.log(`  ${name}: ${value}`);
      }
    }
  } catch (error) {
    console.error('CORS error:', error);
  }
}

testCORS('https://api.example.com/test');
```

---

## 6.5.9 Security Considerations

### Don't Use Wildcard in Production

```javascript
// ❌ Avoid in production
Access-Control-Allow-Origin: *

// ✅ Specify allowed origins
Access-Control-Allow-Origin: https://trusted-site.com

// Or dynamically validate origin
function validateOrigin(origin) {
  const allowed = ['https://app.example.com', 'https://admin.example.com'];
  return allowed.includes(origin);
}
```

### Validate Origin Server-Side

```javascript
// ❌ Don't blindly reflect origin
res.header('Access-Control-Allow-Origin', req.headers.origin);

// ✅ Validate against whitelist
const allowedOrigins = ['https://trusted-site.com'];
const origin = req.headers.origin;

if (allowedOrigins.includes(origin)) {
  res.header('Access-Control-Allow-Origin', origin);
}
```

### Be Careful with Credentials

```javascript
// Credentials expose user sessions cross-origin
// Only enable for trusted origins

// ❌ Too permissive
Access-Control-Allow-Origin: *
Access-Control-Allow-Credentials: true  // Invalid anyway

// ✅ Strict
Access-Control-Allow-Origin: https://trusted-app.com
Access-Control-Allow-Credentials: true
```

---

## 6.5.10 Summary

### Request Types

| Type | When Triggered |
|------|---------------|
| Simple | GET/HEAD/POST with simple headers |
| Preflight | Custom headers, methods like PUT/DELETE |

### Key Headers

| Header | Description |
|--------|-------------|
| `Access-Control-Allow-Origin` | Allowed origin(s) |
| `Access-Control-Allow-Methods` | Allowed methods |
| `Access-Control-Allow-Headers` | Allowed headers |
| `Access-Control-Allow-Credentials` | Allow cookies |
| `Access-Control-Max-Age` | Preflight cache time |
| `Access-Control-Expose-Headers` | Readable headers |

### Credentials Mode

| Mode | Behavior |
|------|----------|
| `omit` | Never send credentials |
| `same-origin` | Same-origin only (default) |
| `include` | Always send |

### Best Practices

1. **Don't use wildcard** in production
2. **Validate origins** server-side
3. **Limit exposed headers** to what's needed
4. **Cache preflight** with Max-Age
5. **Use proxy** for third-party APIs without CORS
6. **Enable credentials** only for trusted origins

---

**End of Chapter 6.5: CORS**

This completes the Fetch and AJAX group. Next section: **Group 07 — Timers and Scheduling** — covers setTimeout, setInterval, requestAnimationFrame, and scheduling APIs.
# 7.1 Canvas API

The Canvas API provides a powerful way to draw graphics via JavaScript and HTML. This chapter covers 2D rendering, shapes, paths, images, transformations, and common patterns for canvas-based applications.

---

## 7.1.1 Canvas Basics

### Creating a Canvas

```html
<canvas id="myCanvas" width="800" height="600">
  Your browser does not support canvas.
</canvas>
```

```javascript
// Get canvas element
const canvas = document.getElementById('myCanvas');

// Get 2D rendering context
const ctx = canvas.getContext('2d');

// Check if canvas is supported
if (!ctx) {
  console.error('Canvas not supported');
}
```

### Canvas Size vs CSS Size

```javascript
// Canvas has two sizes:
// 1. Actual pixel size (width/height attributes)
// 2. Display size (CSS width/height)

const canvas = document.getElementById('myCanvas');

// Pixel size (drawing resolution)
canvas.width = 1600;   // Actual pixels
canvas.height = 1200;

// CSS size (display size)
canvas.style.width = '800px';
canvas.style.height = '600px';

// This creates a 2x resolution (HiDPI/Retina support)
```

### High DPI Support

```javascript
function setupCanvas(canvas) {
  const dpr = window.devicePixelRatio || 1;
  const rect = canvas.getBoundingClientRect();
  
  // Set actual pixel dimensions
  canvas.width = rect.width * dpr;
  canvas.height = rect.height * dpr;
  
  // Set CSS dimensions
  canvas.style.width = rect.width + 'px';
  canvas.style.height = rect.height + 'px';
  
  // Scale context
  const ctx = canvas.getContext('2d');
  ctx.scale(dpr, dpr);
  
  return ctx;
}
```

---

## 7.1.2 Drawing Shapes

### Rectangles

```javascript
// Fill rectangle
ctx.fillStyle = 'blue';
ctx.fillRect(10, 10, 100, 50);  // x, y, width, height

// Stroke rectangle (outline)
ctx.strokeStyle = 'red';
ctx.lineWidth = 2;
ctx.strokeRect(10, 70, 100, 50);

// Clear rectangle (transparent)
ctx.clearRect(30, 30, 50, 30);
```

### Paths

```javascript
// Drawing with paths
ctx.beginPath();          // Start new path
ctx.moveTo(50, 50);       // Move to start
ctx.lineTo(150, 50);      // Line to point
ctx.lineTo(100, 100);     // Another line
ctx.closePath();          // Close path (connect to start)

ctx.fillStyle = 'green';
ctx.fill();               // Fill the shape

ctx.strokeStyle = 'black';
ctx.stroke();             // Draw outline
```

### Arcs and Circles

```javascript
// Arc: x, y, radius, startAngle, endAngle, counterclockwise
ctx.beginPath();
ctx.arc(100, 100, 50, 0, Math.PI * 2);  // Full circle
ctx.fill();

// Half circle
ctx.beginPath();
ctx.arc(200, 100, 50, 0, Math.PI);
ctx.stroke();

// Arc segment
ctx.beginPath();
ctx.arc(300, 100, 50, Math.PI / 4, Math.PI * 3 / 4);
ctx.lineTo(300, 100);  // Connect to center
ctx.closePath();
ctx.fill();
```

### Curves

```javascript
// Quadratic curve: control point, end point
ctx.beginPath();
ctx.moveTo(50, 200);
ctx.quadraticCurveTo(100, 100, 150, 200);  // cpx, cpy, x, y
ctx.stroke();

// Bezier curve: two control points, end point
ctx.beginPath();
ctx.moveTo(200, 200);
ctx.bezierCurveTo(220, 100, 280, 100, 300, 200);  // cp1x, cp1y, cp2x, cp2y, x, y
ctx.stroke();
```

---

## 7.1.3 Styles and Colors

### Fill and Stroke

```javascript
// Colors
ctx.fillStyle = 'red';
ctx.fillStyle = '#ff0000';
ctx.fillStyle = 'rgb(255, 0, 0)';
ctx.fillStyle = 'rgba(255, 0, 0, 0.5)';
ctx.fillStyle = 'hsl(0, 100%, 50%)';

ctx.strokeStyle = 'blue';
```

### Line Styles

```javascript
ctx.lineWidth = 5;            // Line width
ctx.lineCap = 'round';        // butt, round, square
ctx.lineJoin = 'round';       // miter, round, bevel
ctx.miterLimit = 10;          // Miter limit

// Dashed lines
ctx.setLineDash([5, 15]);     // dash pattern [dash, gap]
ctx.lineDashOffset = 0;       // Offset for animation
```

### Gradients

```javascript
// Linear gradient
const linearGrad = ctx.createLinearGradient(0, 0, 200, 0);
linearGrad.addColorStop(0, 'red');
linearGrad.addColorStop(0.5, 'yellow');
linearGrad.addColorStop(1, 'blue');
ctx.fillStyle = linearGrad;
ctx.fillRect(0, 0, 200, 100);

// Radial gradient
const radialGrad = ctx.createRadialGradient(100, 100, 20, 100, 100, 80);
radialGrad.addColorStop(0, 'white');
radialGrad.addColorStop(1, 'blue');
ctx.fillStyle = radialGrad;
ctx.beginPath();
ctx.arc(100, 100, 80, 0, Math.PI * 2);
ctx.fill();
```

### Patterns

```javascript
const img = new Image();
img.onload = function() {
  const pattern = ctx.createPattern(img, 'repeat');  // repeat, repeat-x, repeat-y, no-repeat
  ctx.fillStyle = pattern;
  ctx.fillRect(0, 0, 400, 400);
};
img.src = 'texture.png';
```

---

## 7.1.4 Text

### Drawing Text

```javascript
// Font settings
ctx.font = '24px Arial';
ctx.textAlign = 'center';     // left, right, center, start, end
ctx.textBaseline = 'middle';  // top, hanging, middle, alphabetic, ideographic, bottom

// Fill text
ctx.fillStyle = 'black';
ctx.fillText('Hello Canvas', 200, 50);

// Stroke text
ctx.strokeStyle = 'red';
ctx.lineWidth = 2;
ctx.strokeText('Hello Canvas', 200, 100);

// Max width (text will be compressed)
ctx.fillText('This is a long text', 200, 150, 100);
```

### Measuring Text

```javascript
ctx.font = '20px Arial';
const text = 'Hello Canvas';
const metrics = ctx.measureText(text);

console.log('Width:', metrics.width);
console.log('Actual bounding box:', metrics.actualBoundingBoxAscent);
```

---

## 7.1.5 Images

### Drawing Images

```javascript
// Basic image drawing
const img = new Image();
img.onload = function() {
  ctx.drawImage(img, 10, 10);  // x, y
};
img.src = 'image.png';

// With size
ctx.drawImage(img, 10, 10, 100, 100);  // x, y, width, height

// Clipping (source rectangle)
ctx.drawImage(
  img,
  sx, sy, sWidth, sHeight,  // Source rectangle
  dx, dy, dWidth, dHeight   // Destination rectangle
);
```

### Pixel Manipulation

```javascript
// Get image data
const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
const data = imageData.data;  // Uint8ClampedArray [r,g,b,a, r,g,b,a, ...]

// Modify pixels (invert colors)
for (let i = 0; i < data.length; i += 4) {
  data[i] = 255 - data[i];       // Red
  data[i + 1] = 255 - data[i + 1]; // Green
  data[i + 2] = 255 - data[i + 2]; // Blue
  // data[i + 3] is alpha
}

// Put modified data back
ctx.putImageData(imageData, 0, 0);

// Create empty image data
const newImageData = ctx.createImageData(200, 200);
```

---

## 7.1.6 Transformations

### Basic Transforms

```javascript
// Save current state
ctx.save();

// Translate (move origin)
ctx.translate(100, 100);

// Rotate (in radians)
ctx.rotate(Math.PI / 4);  // 45 degrees

// Scale
ctx.scale(2, 2);  // Double size

// Draw at transformed position
ctx.fillRect(-25, -25, 50, 50);

// Restore previous state
ctx.restore();
```

### Transform Matrix

```javascript
// Set transform matrix
ctx.setTransform(a, b, c, d, e, f);
// a: scale x
// b: skew y
// c: skew x
// d: scale y
// e: translate x
// f: translate y

// Multiply current matrix
ctx.transform(a, b, c, d, e, f);

// Reset to identity matrix
ctx.resetTransform();

// Get current transform
const matrix = ctx.getTransform();
```

---

## 7.1.7 Compositing

### Global Alpha

```javascript
// Semi-transparent drawing
ctx.globalAlpha = 0.5;
ctx.fillRect(0, 0, 100, 100);
ctx.globalAlpha = 1;  // Reset
```

### Composite Operations

```javascript
// Default: new shapes drawn over existing
ctx.globalCompositeOperation = 'source-over';

// Common operations:
ctx.globalCompositeOperation = 'destination-over';  // Draw behind
ctx.globalCompositeOperation = 'destination-out';   // Erase (like cookie cutter)
ctx.globalCompositeOperation = 'lighter';           // Additive blending
ctx.globalCompositeOperation = 'multiply';          // Multiply blend
ctx.globalCompositeOperation = 'screen';            // Screen blend
ctx.globalCompositeOperation = 'overlay';           // Overlay blend
```

### Clipping

```javascript
// Create clipping path
ctx.beginPath();
ctx.arc(100, 100, 50, 0, Math.PI * 2);
ctx.clip();

// All subsequent drawing is clipped
ctx.drawImage(img, 0, 0);

// Use save/restore to limit clipping scope
ctx.save();
ctx.beginPath();
ctx.arc(100, 100, 50, 0, Math.PI * 2);
ctx.clip();
ctx.drawImage(img, 0, 0);
ctx.restore();
```

---

## 7.1.8 Exporting Canvas

### To Data URL

```javascript
// Get as base64 PNG
const pngDataUrl = canvas.toDataURL();  // default: image/png

// Get as JPEG with quality
const jpgDataUrl = canvas.toDataURL('image/jpeg', 0.8);

// Get as WebP
const webpDataUrl = canvas.toDataURL('image/webp', 0.9);

// Use in image
img.src = pngDataUrl;

// Download
const link = document.createElement('a');
link.download = 'canvas.png';
link.href = pngDataUrl;
link.click();
```

### To Blob

```javascript
canvas.toBlob((blob) => {
  // Use blob
  const url = URL.createObjectURL(blob);
  
  // Download
  const link = document.createElement('a');
  link.download = 'canvas.png';
  link.href = url;
  link.click();
  
  URL.revokeObjectURL(url);
}, 'image/png');

// With quality (JPEG/WebP)
canvas.toBlob(callback, 'image/jpeg', 0.8);

// Promise version
const blob = await new Promise(resolve => canvas.toBlob(resolve));
```

---

## 7.1.9 OffscreenCanvas

### Background Rendering

```javascript
// Create offscreen canvas
const offscreen = new OffscreenCanvas(800, 600);
const offCtx = offscreen.getContext('2d');

// Draw on offscreen canvas
offCtx.fillStyle = 'red';
offCtx.fillRect(0, 0, 400, 300);

// Transfer to visible canvas
const bitmap = offscreen.transferToImageBitmap();
ctx.drawImage(bitmap, 0, 0);
```

### Worker Usage

```javascript
// main.js
const canvas = document.getElementById('myCanvas');
const offscreen = canvas.transferControlToOffscreen();

const worker = new Worker('canvas-worker.js');
worker.postMessage({ canvas: offscreen }, [offscreen]);

// canvas-worker.js
self.onmessage = function(e) {
  const canvas = e.data.canvas;
  const ctx = canvas.getContext('2d');
  
  // Render in worker thread
  function draw() {
    ctx.fillRect(0, 0, 100, 100);
    requestAnimationFrame(draw);
  }
  draw();
};
```

---

## 7.1.10 Animation Loop

### requestAnimationFrame

```javascript
function draw() {
  // Clear canvas
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  
  // Draw frame
  update();
  render();
  
  // Request next frame
  requestAnimationFrame(draw);
}

// Start animation
requestAnimationFrame(draw);

// Stop animation
let animationId;
function start() {
  animationId = requestAnimationFrame(draw);
}
function stop() {
  cancelAnimationFrame(animationId);
}
```

### Delta Time

```javascript
let lastTime = 0;

function draw(currentTime) {
  const deltaTime = currentTime - lastTime;
  lastTime = currentTime;
  
  // Update with delta time for consistent speed
  position += velocity * deltaTime;
  
  // Draw
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.fillRect(position, 100, 50, 50);
  
  requestAnimationFrame(draw);
}

requestAnimationFrame(draw);
```

---

## 7.1.11 Summary

### Context Methods

| Method | Description |
|--------|-------------|
| `fillRect(x, y, w, h)` | Fill rectangle |
| `strokeRect(x, y, w, h)` | Stroke rectangle |
| `clearRect(x, y, w, h)` | Clear rectangle |
| `beginPath()` | Start new path |
| `moveTo(x, y)` | Move to point |
| `lineTo(x, y)` | Line to point |
| `arc(x, y, r, start, end)` | Draw arc |
| `closePath()` | Close path |
| `fill()` | Fill path |
| `stroke()` | Stroke path |

### Style Properties

| Property | Description |
|----------|-------------|
| `fillStyle` | Fill color/gradient/pattern |
| `strokeStyle` | Stroke color |
| `lineWidth` | Line width |
| `lineCap` | Line end style |
| `lineJoin` | Line join style |
| `font` | Text font |
| `textAlign` | Text alignment |
| `globalAlpha` | Global opacity |

### Best Practices

1. **Use requestAnimationFrame** for animation
2. **Clear canvas** before redrawing
3. **Save/restore state** for complex transforms
4. **Use OffscreenCanvas** for heavy rendering
5. **Handle HiDPI displays** properly
6. **Batch drawing operations** when possible

---

**End of Chapter 7.1: Canvas API**

Next chapter: **7.2 WebGL** — covers 3D graphics with WebGL.
# 7.2 WebGL

WebGL enables hardware-accelerated 3D and 2D graphics in the browser. This chapter covers the basics of WebGL, shaders, buffers, textures, and common patterns for 3D rendering.

---

## 7.2.1 WebGL Basics

### Getting WebGL Context

```javascript
const canvas = document.getElementById('canvas');

// Try WebGL 2 first, fall back to WebGL 1
const gl = canvas.getContext('webgl2') || canvas.getContext('webgl');

if (!gl) {
  console.error('WebGL not supported');
}

// Context options
const gl = canvas.getContext('webgl', {
  alpha: true,                // Transparent background
  antialias: true,           // Smooth edges
  depth: true,               // Depth buffer
  preserveDrawingBuffer: false,  // Don't preserve buffer
  powerPreference: 'high-performance'  // GPU preference
});
```

### WebGL Pipeline Overview

```javascript
// 1. Create shaders (vertex + fragment)
// 2. Create program (link shaders)
// 3. Create buffers (vertices, indices)
// 4. Bind attributes and uniforms
// 5. Draw

// Clear screen
gl.clearColor(0.0, 0.0, 0.0, 1.0);  // Black
gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
```

---

## 7.2.2 Shaders

### Vertex Shader

```javascript
const vertexShaderSource = `
  attribute vec4 a_position;
  attribute vec4 a_color;
  
  uniform mat4 u_modelViewProjection;
  
  varying vec4 v_color;
  
  void main() {
    gl_Position = u_modelViewProjection * a_position;
    v_color = a_color;
  }
`;
```

### Fragment Shader

```javascript
const fragmentShaderSource = `
  precision mediump float;
  
  varying vec4 v_color;
  
  void main() {
    gl_FragColor = v_color;
  }
`;
```

### Compiling Shaders

```javascript
function createShader(gl, type, source) {
  const shader = gl.createShader(type);
  gl.shaderSource(shader, source);
  gl.compileShader(shader);
  
  // Check for errors
  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
    console.error('Shader error:', gl.getShaderInfoLog(shader));
    gl.deleteShader(shader);
    return null;
  }
  
  return shader;
}

const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
```

### Creating Program

```javascript
function createProgram(gl, vertexShader, fragmentShader) {
  const program = gl.createProgram();
  gl.attachShader(program, vertexShader);
  gl.attachShader(program, fragmentShader);
  gl.linkProgram(program);
  
  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
    console.error('Program error:', gl.getProgramInfoLog(program));
    gl.deleteProgram(program);
    return null;
  }
  
  return program;
}

const program = createProgram(gl, vertexShader, fragmentShader);
gl.useProgram(program);
```

---

## 7.2.3 Buffers

### Creating Vertex Buffer

```javascript
// Triangle vertices (x, y, z)
const vertices = new Float32Array([
  0.0,  0.5, 0.0,   // Top
 -0.5, -0.5, 0.0,   // Bottom left
  0.5, -0.5, 0.0    // Bottom right
]);

// Create buffer
const vertexBuffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
```

### Index Buffer

```javascript
// For indexed drawing (reuse vertices)
const indices = new Uint16Array([0, 1, 2]);

const indexBuffer = gl.createBuffer();
gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);
```

### Binding Attributes

```javascript
// Get attribute location
const positionLocation = gl.getAttribLocation(program, 'a_position');

// Bind buffer
gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);

// Configure attribute
gl.vertexAttribPointer(
  positionLocation,  // Attribute location
  3,                 // Components per vertex (x, y, z)
  gl.FLOAT,          // Data type
  false,             // Normalize
  0,                 // Stride (0 = auto)
  0                  // Offset
);

// Enable attribute
gl.enableVertexAttribArray(positionLocation);
```

---

## 7.2.4 Uniforms

### Setting Uniforms

```javascript
const colorLocation = gl.getUniformLocation(program, 'u_color');
const matrixLocation = gl.getUniformLocation(program, 'u_matrix');

// Single float
gl.uniform1f(location, value);

// Float vector
gl.uniform2f(location, x, y);
gl.uniform3f(location, x, y, z);
gl.uniform4f(location, x, y, z, w);

// Float array
gl.uniform3fv(location, [r, g, b]);

// Matrix
gl.uniformMatrix4fv(matrixLocation, false, matrix);
```

---

## 7.2.5 Drawing

### Basic Drawing

```javascript
// Clear canvas
gl.clearColor(0.0, 0.0, 0.0, 1.0);
gl.clear(gl.COLOR_BUFFER_BIT);

// Draw triangles
gl.drawArrays(gl.TRIANGLES, 0, 3);  // mode, first, count

// Draw modes:
// gl.POINTS
// gl.LINES
// gl.LINE_STRIP
// gl.LINE_LOOP
// gl.TRIANGLES
// gl.TRIANGLE_STRIP
// gl.TRIANGLE_FAN
```

### Indexed Drawing

```javascript
// Bind index buffer
gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);

// Draw with indices
gl.drawElements(
  gl.TRIANGLES,      // Mode
  indices.length,    // Count
  gl.UNSIGNED_SHORT, // Type
  0                  // Offset
);
```

---

## 7.2.6 Textures

### Loading Texture

```javascript
function loadTexture(gl, url) {
  const texture = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, texture);
  
  // Placeholder until image loads
  gl.texImage2D(
    gl.TEXTURE_2D, 0, gl.RGBA,
    1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE,
    new Uint8Array([0, 0, 255, 255])  // Blue pixel
  );
  
  const image = new Image();
  image.onload = function() {
    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.texImage2D(
      gl.TEXTURE_2D, 0, gl.RGBA,
      gl.RGBA, gl.UNSIGNED_BYTE, image
    );
    
    // Set texture parameters
    if (isPowerOf2(image.width) && isPowerOf2(image.height)) {
      gl.generateMipmap(gl.TEXTURE_2D);
    } else {
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    }
  };
  image.src = url;
  
  return texture;
}

function isPowerOf2(value) {
  return (value & (value - 1)) === 0;
}
```

### Using Textures

```javascript
// In fragment shader
const fragmentShader = `
  precision mediump float;
  varying vec2 v_texCoord;
  uniform sampler2D u_texture;
  
  void main() {
    gl_FragColor = texture2D(u_texture, v_texCoord);
  }
`;

// Bind texture
gl.activeTexture(gl.TEXTURE0);
gl.bindTexture(gl.TEXTURE_2D, texture);
gl.uniform1i(textureLocation, 0);  // Texture unit 0
```

---

## 7.2.7 3D Transformations

### Matrix Operations

```javascript
// Using a matrix library (glMatrix)
const modelMatrix = mat4.create();
const viewMatrix = mat4.create();
const projectionMatrix = mat4.create();

// Model transform
mat4.translate(modelMatrix, modelMatrix, [0, 0, -5]);
mat4.rotateY(modelMatrix, modelMatrix, rotation);
mat4.scale(modelMatrix, modelMatrix, [1, 1, 1]);

// View transform (camera)
mat4.lookAt(viewMatrix, 
  [0, 0, 5],   // Camera position
  [0, 0, 0],   // Look at
  [0, 1, 0]    // Up vector
);

// Projection
mat4.perspective(projectionMatrix,
  Math.PI / 4,              // Field of view (radians)
  canvas.width / canvas.height,  // Aspect ratio
  0.1,                      // Near plane
  100.0                     // Far plane
);

// Combined matrix
const mvpMatrix = mat4.create();
mat4.multiply(mvpMatrix, projectionMatrix, viewMatrix);
mat4.multiply(mvpMatrix, mvpMatrix, modelMatrix);

// Send to shader
gl.uniformMatrix4fv(matrixLocation, false, mvpMatrix);
```

---

## 7.2.8 Depth and Culling

### Depth Testing

```javascript
// Enable depth testing
gl.enable(gl.DEPTH_TEST);
gl.depthFunc(gl.LEQUAL);

// Clear depth buffer
gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
```

### Face Culling

```javascript
// Enable culling (don't render back faces)
gl.enable(gl.CULL_FACE);
gl.cullFace(gl.BACK);    // Cull back faces
gl.frontFace(gl.CCW);    // Counter-clockwise = front
```

### Blending

```javascript
// Enable blending for transparency
gl.enable(gl.BLEND);
gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
```

---

## 7.2.9 WebGL 2 Features

### Vertex Array Objects (VAO)

```javascript
// Create VAO
const vao = gl.createVertexArray();
gl.bindVertexArray(vao);

// Set up attributes once
gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
gl.vertexAttribPointer(positionLoc, 3, gl.FLOAT, false, 0, 0);
gl.enableVertexAttribArray(positionLoc);

// Unbind
gl.bindVertexArray(null);

// Later, just bind VAO to use all attributes
gl.bindVertexArray(vao);
gl.drawArrays(gl.TRIANGLES, 0, 36);
```

### Instanced Rendering

```javascript
// Draw multiple instances efficiently
gl.vertexAttribDivisor(instanceMatrixLoc, 1);  // Once per instance
gl.drawArraysInstanced(gl.TRIANGLES, 0, 36, instanceCount);
```

### Transform Feedback

```javascript
// Capture vertex shader output
const tf = gl.createTransformFeedback();
gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, tf);
gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, 0, outputBuffer);

gl.beginTransformFeedback(gl.POINTS);
gl.drawArrays(gl.POINTS, 0, count);
gl.endTransformFeedback();
```

---

## 7.2.10 Summary

### WebGL Pipeline

| Step | Description |
|------|-------------|
| Create shaders | Vertex + Fragment |
| Create program | Link shaders |
| Create buffers | Vertices, indices |
| Set attributes | Vertex layout |
| Set uniforms | Matrices, colors |
| Draw | Render |

### Common Functions

| Function | Description |
|----------|-------------|
| `createShader()` | Create shader |
| `createProgram()` | Link program |
| `createBuffer()` | Create buffer |
| `bindBuffer()` | Bind buffer |
| `bufferData()` | Upload data |
| `drawArrays()` | Draw vertices |
| `drawElements()` | Draw indexed |

### Best Practices

1. **Use VAOs** in WebGL 2
2. **Batch draw calls** when possible
3. **Minimize state changes**
4. **Use appropriate buffer usage hints**
5. **Reuse buffers** instead of creating new ones
6. **Consider using a library** (Three.js, Babylon.js)

---

**End of Chapter 7.2: WebGL**

Next chapter: **7.3 Web Audio API** — covers audio processing and synthesis.
# 7.3 Web Audio API

The Web Audio API provides a powerful system for controlling audio in web applications. This chapter covers audio contexts, nodes, oscillators, effects, and common patterns for audio processing.

---

## 7.3.1 Audio Context

### Creating Audio Context

```javascript
// Create audio context
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

// Context states: suspended, running, closed
console.log(audioCtx.state);  // 'suspended' initially

// Resume on user interaction (required by browsers)
button.addEventListener('click', () => {
  if (audioCtx.state === 'suspended') {
    audioCtx.resume();
  }
});

// Close context when done
audioCtx.close();
```

### Context Properties

```javascript
// Current time in seconds
console.log(audioCtx.currentTime);

// Sample rate (usually 44100 or 48000)
console.log(audioCtx.sampleRate);

// Destination (speakers)
const destination = audioCtx.destination;
console.log(destination.maxChannelCount);  // e.g., 2 for stereo
```

---

## 7.3.2 Audio Sources

### Playing Audio Files

```javascript
// Load and play audio buffer
async function playAudio(url) {
  const response = await fetch(url);
  const arrayBuffer = await response.arrayBuffer();
  const audioBuffer = await audioCtx.decodeAudioData(arrayBuffer);
  
  // Create source node
  const source = audioCtx.createBufferSource();
  source.buffer = audioBuffer;
  
  // Connect to output
  source.connect(audioCtx.destination);
  
  // Play
  source.start(0);  // Start immediately
  
  // Stop after 5 seconds
  source.stop(audioCtx.currentTime + 5);
  
  return source;
}
```

### Audio Element Source

```javascript
// Use HTML audio element
const audio = document.querySelector('audio');
const source = audioCtx.createMediaElementSource(audio);

// Connect through processing chain
source.connect(audioCtx.destination);

// Audio element controls playback
audio.play();
```

### Microphone Input

```javascript
async function getMicrophoneInput() {
  const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
  const source = audioCtx.createMediaStreamSource(stream);
  
  // Connect to analyzer or effects
  const analyser = audioCtx.createAnalyser();
  source.connect(analyser);
  
  return { source, analyser, stream };
}
```

---

## 7.3.3 Oscillators

### Basic Oscillator

```javascript
// Create oscillator
const oscillator = audioCtx.createOscillator();

// Set waveform type
oscillator.type = 'sine';     // sine, square, sawtooth, triangle

// Set frequency (Hz)
oscillator.frequency.value = 440;  // A4 note

// Connect and play
oscillator.connect(audioCtx.destination);
oscillator.start();
oscillator.stop(audioCtx.currentTime + 1);  // Stop after 1 second

// Oscillators can only be started once - create new for each use
```

### Frequency and Detune

```javascript
const oscillator = audioCtx.createOscillator();

// Set frequency
oscillator.frequency.value = 440;

// Detune in cents (100 cents = 1 semitone)
oscillator.detune.value = 100;  // One semitone up

// Schedule frequency changes
oscillator.frequency.setValueAtTime(440, audioCtx.currentTime);
oscillator.frequency.linearRampToValueAtTime(880, audioCtx.currentTime + 1);
```

### Custom Waveforms

```javascript
// Create custom periodic wave
const real = new Float32Array([0, 1, 0.5, 0.25]);  // Cosine terms
const imag = new Float32Array([0, 0, 0, 0]);       // Sine terms

const wave = audioCtx.createPeriodicWave(real, imag);
oscillator.setPeriodicWave(wave);
```

---

## 7.3.4 Gain Node

### Volume Control

```javascript
// Create gain node
const gainNode = audioCtx.createGain();

// Set volume (0 = silent, 1 = full)
gainNode.gain.value = 0.5;

// Connect: source → gain → destination
source.connect(gainNode);
gainNode.connect(audioCtx.destination);
```

### Fade In/Out

```javascript
const gainNode = audioCtx.createGain();

// Fade in
gainNode.gain.setValueAtTime(0, audioCtx.currentTime);
gainNode.gain.linearRampToValueAtTime(1, audioCtx.currentTime + 0.5);

// Fade out
gainNode.gain.setValueAtTime(1, audioCtx.currentTime);
gainNode.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.5);

// Exponential fade (more natural for audio)
gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.5);
```

---

## 7.3.5 Filters

### Biquad Filter

```javascript
// Create filter
const filter = audioCtx.createBiquadFilter();

// Filter types
filter.type = 'lowpass';    // Low frequencies pass
filter.type = 'highpass';   // High frequencies pass
filter.type = 'bandpass';   // Band of frequencies pass
filter.type = 'notch';      // Band of frequencies blocked
filter.type = 'peaking';    // Boost/cut at frequency
filter.type = 'lowshelf';   // Boost/cut below frequency
filter.type = 'highshelf';  // Boost/cut above frequency

// Set parameters
filter.frequency.value = 1000;  // Cutoff frequency (Hz)
filter.Q.value = 1;             // Quality factor (resonance)
filter.gain.value = 0;          // Gain for peaking/shelf filters

// Connect
source.connect(filter);
filter.connect(audioCtx.destination);
```

### Multiple Filters

```javascript
// Chain filters for complex EQ
const lowFilter = audioCtx.createBiquadFilter();
lowFilter.type = 'lowshelf';
lowFilter.frequency.value = 320;
lowFilter.gain.value = 3;

const highFilter = audioCtx.createBiquadFilter();
highFilter.type = 'highshelf';
highFilter.frequency.value = 3200;
highFilter.gain.value = -2;

source.connect(lowFilter);
lowFilter.connect(highFilter);
highFilter.connect(audioCtx.destination);
```

---

## 7.3.6 Analyser Node

### Visualizing Audio

```javascript
const analyser = audioCtx.createAnalyser();
analyser.fftSize = 2048;  // Must be power of 2

// Connect
source.connect(analyser);
analyser.connect(audioCtx.destination);

// Get frequency data
const frequencyData = new Uint8Array(analyser.frequencyBinCount);
analyser.getByteFrequencyData(frequencyData);

// Get waveform data
const timeData = new Uint8Array(analyser.fftSize);
analyser.getByteTimeDomainData(timeData);
```

### Frequency Visualizer

```javascript
function drawFrequency() {
  requestAnimationFrame(drawFrequency);
  
  analyser.getByteFrequencyData(frequencyData);
  
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  
  const barWidth = canvas.width / frequencyData.length;
  
  frequencyData.forEach((value, i) => {
    const height = (value / 255) * canvas.height;
    ctx.fillStyle = `hsl(${i}, 100%, 50%)`;
    ctx.fillRect(i * barWidth, canvas.height - height, barWidth, height);
  });
}

drawFrequency();
```

### Waveform Visualizer

```javascript
function drawWaveform() {
  requestAnimationFrame(drawWaveform);
  
  analyser.getByteTimeDomainData(timeData);
  
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.beginPath();
  
  const sliceWidth = canvas.width / timeData.length;
  let x = 0;
  
  timeData.forEach((value, i) => {
    const y = (value / 255) * canvas.height;
    
    if (i === 0) {
      ctx.moveTo(x, y);
    } else {
      ctx.lineTo(x, y);
    }
    
    x += sliceWidth;
  });
  
  ctx.stroke();
}
```

---

## 7.3.7 Effects

### Delay Effect

```javascript
// Create delay
const delay = audioCtx.createDelay(5);  // Max 5 seconds
delay.delayTime.value = 0.5;  // 500ms delay

// Create feedback loop
const feedback = audioCtx.createGain();
feedback.gain.value = 0.5;

// Connect
source.connect(delay);
delay.connect(feedback);
feedback.connect(delay);  // Feedback loop
delay.connect(audioCtx.destination);
```

### Reverb (Convolution)

```javascript
// Load impulse response
async function createReverb(url) {
  const response = await fetch(url);
  const arrayBuffer = await response.arrayBuffer();
  const impulseBuffer = await audioCtx.decodeAudioData(arrayBuffer);
  
  const convolver = audioCtx.createConvolver();
  convolver.buffer = impulseBuffer;
  
  return convolver;
}

const reverb = await createReverb('impulse-response.wav');
source.connect(reverb);
reverb.connect(audioCtx.destination);
```

### Compressor

```javascript
const compressor = audioCtx.createDynamicsCompressor();

compressor.threshold.value = -24;  // dB
compressor.knee.value = 30;        // dB
compressor.ratio.value = 12;       // Compression ratio
compressor.attack.value = 0.003;   // Seconds
compressor.release.value = 0.25;   // Seconds

source.connect(compressor);
compressor.connect(audioCtx.destination);
```

---

## 7.3.8 Spatial Audio

### Panner Node

```javascript
// Create panner
const panner = audioCtx.createPanner();

// Positioning model
panner.panningModel = 'HRTF';  // Head-related transfer function
panner.distanceModel = 'inverse';  // inverse, linear, exponential

// Set position
panner.positionX.value = 0;
panner.positionY.value = 0;
panner.positionZ.value = 0;

// Set orientation (direction sound is facing)
panner.orientationX.value = 0;
panner.orientationY.value = 0;
panner.orientationZ.value = -1;

// Distance parameters
panner.refDistance = 1;
panner.maxDistance = 10000;
panner.rolloffFactor = 1;

// Connect
source.connect(panner);
panner.connect(audioCtx.destination);
```

### Stereo Panning

```javascript
// Simple left-right panning
const panner = audioCtx.createStereoPanner();

// Range: -1 (left) to 1 (right)
panner.pan.value = -1;  // Full left
panner.pan.value = 0;   // Center
panner.pan.value = 1;   // Full right

source.connect(panner);
panner.connect(audioCtx.destination);
```

### Listener Position

```javascript
// Set listener (camera) position
const listener = audioCtx.listener;

listener.positionX.value = 0;
listener.positionY.value = 0;
listener.positionZ.value = 0;

// Listener orientation
listener.forwardX.value = 0;
listener.forwardY.value = 0;
listener.forwardZ.value = -1;

listener.upX.value = 0;
listener.upY.value = 1;
listener.upZ.value = 0;
```

---

## 7.3.9 Worklets

### Audio Worklet

```javascript
// Register processor
await audioCtx.audioWorklet.addModule('my-processor.js');

// Create node
const workletNode = new AudioWorkletNode(audioCtx, 'my-processor');

source.connect(workletNode);
workletNode.connect(audioCtx.destination);

// my-processor.js
class MyProcessor extends AudioWorkletProcessor {
  process(inputs, outputs, parameters) {
    const input = inputs[0];
    const output = outputs[0];
    
    for (let channel = 0; channel < output.length; channel++) {
      for (let i = 0; i < output[channel].length; i++) {
        output[channel][i] = input[channel][i] * 0.5;  // Half volume
      }
    }
    
    return true;  // Keep processor alive
  }
}

registerProcessor('my-processor', MyProcessor);
```

---

## 7.3.10 Summary

### Common Nodes

| Node | Description |
|------|-------------|
| `BufferSource` | Play audio buffer |
| `MediaElementSource` | Audio/video element |
| `Oscillator` | Generate tones |
| `GainNode` | Volume control |
| `BiquadFilter` | Frequency filter |
| `AnalyserNode` | Audio analysis |
| `DelayNode` | Echo effect |
| `ConvolverNode` | Reverb |
| `DynamicsCompressor` | Dynamic range compression |
| `PannerNode` | 3D spatial audio |
| `StereoPanner` | Left-right panning |

### Audio Graph Pattern

```javascript
// Typical audio processing chain
source.connect(filter);
filter.connect(effects);
effects.connect(gain);
gain.connect(analyser);
analyser.connect(destination);
```

### Best Practices

1. **Resume context on user interaction**
2. **Create new oscillators** for each use
3. **Use gain ramps** to avoid clicks
4. **Disconnect unused nodes**
5. **Use AudioWorklet** for custom DSP
6. **Handle context state changes**

---

**End of Chapter 7.3: Web Audio API**

Next chapter: **7.4 WebRTC** — covers real-time communication.
# 7.4 WebRTC

WebRTC (Web Real-Time Communication) enables peer-to-peer audio, video, and data sharing directly between browsers. This chapter covers peer connections, media streams, signaling, and data channels.

---

## 7.4.1 WebRTC Overview

### What Is WebRTC?

```javascript
// WebRTC enables:
// - Peer-to-peer video/audio calls
// - Screen sharing
// - File transfer
// - Real-time data channels

// Key components:
// 1. RTCPeerConnection - manages P2P connection
// 2. MediaStream - audio/video tracks
// 3. RTCDataChannel - arbitrary data
// 4. Signaling - exchange connection info (not part of WebRTC)
```

### Connection Flow

```javascript
// 1. Create peer connections on both sides
// 2. Get local media (camera/mic)
// 3. Exchange ICE candidates (network info)
// 4. Create and exchange offer/answer (SDP)
// 5. Connection established!
```

---

## 7.4.2 Getting User Media

### Camera and Microphone

```javascript
async function getMediaStream() {
  try {
    const stream = await navigator.mediaDevices.getUserMedia({
      video: true,
      audio: true
    });
    
    // Display in video element
    const videoElement = document.getElementById('localVideo');
    videoElement.srcObject = stream;
    
    return stream;
  } catch (error) {
    console.error('Error accessing media:', error);
  }
}
```

### Constraints

```javascript
const constraints = {
  video: {
    width: { ideal: 1280 },
    height: { ideal: 720 },
    facingMode: 'user',  // 'environment' for back camera
    frameRate: { max: 30 }
  },
  audio: {
    echoCancellation: true,
    noiseSuppression: true,
    autoGainControl: true
  }
};

const stream = await navigator.mediaDevices.getUserMedia(constraints);
```

### Screen Sharing

```javascript
async function shareScreen() {
  const stream = await navigator.mediaDevices.getDisplayMedia({
    video: {
      cursor: 'always'  // Show cursor
    },
    audio: true  // Include system audio if supported
  });
  
  return stream;
}
```

---

## 7.4.3 Peer Connection

### Creating Peer Connection

```javascript
// Configuration with STUN/TURN servers
const configuration = {
  iceServers: [
    { urls: 'stun:stun.l.google.com:19302' },
    {
      urls: 'turn:turn.example.com:3478',
      username: 'user',
      credential: 'password'
    }
  ]
};

const peerConnection = new RTCPeerConnection(configuration);

// Monitor connection state
peerConnection.onconnectionstatechange = () => {
  console.log('Connection state:', peerConnection.connectionState);
  // 'new', 'connecting', 'connected', 'disconnected', 'failed', 'closed'
};

peerConnection.oniceconnectionstatechange = () => {
  console.log('ICE state:', peerConnection.iceConnectionState);
};
```

### Adding Tracks

```javascript
// Add local stream tracks to connection
const stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });

stream.getTracks().forEach(track => {
  peerConnection.addTrack(track, stream);
});

// Receive remote tracks
peerConnection.ontrack = (event) => {
  const remoteVideo = document.getElementById('remoteVideo');
  remoteVideo.srcObject = event.streams[0];
};
```

---

## 7.4.4 Signaling

### Creating Offer (Caller)

```javascript
// Create offer
const offer = await peerConnection.createOffer();
await peerConnection.setLocalDescription(offer);

// Send offer to remote peer via signaling server
signalingChannel.send({
  type: 'offer',
  sdp: peerConnection.localDescription
});
```

### Creating Answer (Callee)

```javascript
// Receive offer from signaling server
signalingChannel.onmessage = async (event) => {
  const message = JSON.parse(event.data);
  
  if (message.type === 'offer') {
    await peerConnection.setRemoteDescription(message.sdp);
    
    // Create answer
    const answer = await peerConnection.createAnswer();
    await peerConnection.setLocalDescription(answer);
    
    // Send answer back
    signalingChannel.send({
      type: 'answer',
      sdp: peerConnection.localDescription
    });
  }
  
  if (message.type === 'answer') {
    await peerConnection.setRemoteDescription(message.sdp);
  }
  
  if (message.type === 'candidate') {
    await peerConnection.addIceCandidate(message.candidate);
  }
};
```

### ICE Candidates

```javascript
// Gather and send ICE candidates
peerConnection.onicecandidate = (event) => {
  if (event.candidate) {
    signalingChannel.send({
      type: 'candidate',
      candidate: event.candidate
    });
  }
};

// Receive and add ICE candidates
async function handleCandidate(candidate) {
  await peerConnection.addIceCandidate(candidate);
}
```

---

## 7.4.5 Data Channels

### Creating Data Channel

```javascript
// Creator side
const dataChannel = peerConnection.createDataChannel('chat', {
  ordered: true,       // Guarantee order
  maxRetransmits: 3    // Max retransmit attempts
});

dataChannel.onopen = () => {
  console.log('Data channel open');
  dataChannel.send('Hello!');
};

dataChannel.onmessage = (event) => {
  console.log('Received:', event.data);
};

dataChannel.onclose = () => {
  console.log('Data channel closed');
};
```

### Receiving Data Channel

```javascript
// Receiver side
peerConnection.ondatachannel = (event) => {
  const dataChannel = event.channel;
  
  dataChannel.onopen = () => {
    console.log('Data channel open');
  };
  
  dataChannel.onmessage = (event) => {
    console.log('Received:', event.data);
  };
};
```

### Sending Data

```javascript
// Send text
dataChannel.send('Hello, World!');

// Send binary data
const buffer = new ArrayBuffer(1024);
dataChannel.send(buffer);

// Send Blob
const blob = new Blob(['Hello'], { type: 'text/plain' });
dataChannel.send(blob);

// Check if ready to send
if (dataChannel.readyState === 'open') {
  dataChannel.send(data);
}
```

---

## 7.4.6 Managing Media

### Mute/Unmute

```javascript
function toggleAudio(stream) {
  stream.getAudioTracks().forEach(track => {
    track.enabled = !track.enabled;
  });
}

function toggleVideo(stream) {
  stream.getVideoTracks().forEach(track => {
    track.enabled = !track.enabled;
  });
}
```

### Replace Track

```javascript
// Switch camera or share screen
async function replaceVideoTrack(newStream) {
  const [videoTrack] = newStream.getVideoTracks();
  const sender = peerConnection.getSenders().find(s => 
    s.track?.kind === 'video'
  );
  
  if (sender) {
    await sender.replaceTrack(videoTrack);
  }
}
```

### Stop Tracks

```javascript
function stopAllTracks(stream) {
  stream.getTracks().forEach(track => track.stop());
}
```

---

## 7.4.7 Statistics

### Getting Stats

```javascript
async function getConnectionStats() {
  const stats = await peerConnection.getStats();
  
  stats.forEach(report => {
    if (report.type === 'inbound-rtp' && report.kind === 'video') {
      console.log('Bytes received:', report.bytesReceived);
      console.log('Packets lost:', report.packetsLost);
      console.log('Frames decoded:', report.framesDecoded);
    }
    
    if (report.type === 'candidate-pair' && report.state === 'succeeded') {
      console.log('RTT:', report.currentRoundTripTime);
      console.log('Available bandwidth:', report.availableOutgoingBitrate);
    }
  });
}
```

---

## 7.4.8 Complete Example

### Simple Peer-to-Peer Call

```javascript
class WebRTCCall {
  constructor(signalingChannel) {
    this.signaling = signalingChannel;
    this.pc = null;
    this.localStream = null;
  }
  
  async initialize() {
    // Get user media
    this.localStream = await navigator.mediaDevices.getUserMedia({
      video: true,
      audio: true
    });
    
    // Display local video
    document.getElementById('localVideo').srcObject = this.localStream;
    
    // Create peer connection
    this.pc = new RTCPeerConnection({
      iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
    });
    
    // Add tracks
    this.localStream.getTracks().forEach(track => {
      this.pc.addTrack(track, this.localStream);
    });
    
    // Handle remote stream
    this.pc.ontrack = (event) => {
      document.getElementById('remoteVideo').srcObject = event.streams[0];
    };
    
    // Handle ICE candidates
    this.pc.onicecandidate = (event) => {
      if (event.candidate) {
        this.signaling.send({ type: 'candidate', candidate: event.candidate });
      }
    };
    
    // Listen for signaling messages
    this.signaling.onmessage = async (message) => {
      await this.handleSignalingMessage(message);
    };
  }
  
  async call() {
    const offer = await this.pc.createOffer();
    await this.pc.setLocalDescription(offer);
    this.signaling.send({ type: 'offer', sdp: this.pc.localDescription });
  }
  
  async handleSignalingMessage(message) {
    if (message.type === 'offer') {
      await this.pc.setRemoteDescription(message.sdp);
      const answer = await this.pc.createAnswer();
      await this.pc.setLocalDescription(answer);
      this.signaling.send({ type: 'answer', sdp: this.pc.localDescription });
    }
    
    if (message.type === 'answer') {
      await this.pc.setRemoteDescription(message.sdp);
    }
    
    if (message.type === 'candidate') {
      await this.pc.addIceCandidate(message.candidate);
    }
  }
  
  hangup() {
    this.localStream?.getTracks().forEach(track => track.stop());
    this.pc?.close();
  }
}
```

---

## 7.4.9 Summary

### Key Objects

| Object | Purpose |
|--------|---------|
| `RTCPeerConnection` | Manages P2P connection |
| `MediaStream` | Audio/video tracks |
| `RTCDataChannel` | Arbitrary data transfer |
| `RTCSessionDescription` | SDP offer/answer |
| `RTCIceCandidate` | Network candidate |

### Connection States

| State | Meaning |
|-------|---------|
| `new` | Initial state |
| `connecting` | Establishing connection |
| `connected` | Connection active |
| `disconnected` | Temporarily disconnected |
| `failed` | Connection failed |
| `closed` | Connection closed |

### Best Practices

1. **Use TURN servers** for NAT traversal
2. **Handle all connection states**
3. **Implement reconnection logic**
4. **Monitor stats** for quality
5. **Clean up resources** on disconnect
6. **Use adapter.js** for cross-browser support

---

**End of Chapter 7.4: WebRTC**

Next chapter: **7.5 Media Capture and Streams** — covers getUserMedia and MediaStream APIs.
# 7.5 Media Capture and Streams

The Media Capture and Streams API provides access to media input devices like cameras and microphones. This chapter covers getUserMedia, MediaStream, constraints, and device enumeration.

---

## 7.5.1 getUserMedia

### Basic Usage

```javascript
// Request camera and microphone access
async function getMedia() {
  try {
    const stream = await navigator.mediaDevices.getUserMedia({
      video: true,
      audio: true
    });
    
    // Use the stream
    const video = document.querySelector('video');
    video.srcObject = stream;
    
    return stream;
  } catch (error) {
    handleError(error);
  }
}

function handleError(error) {
  switch (error.name) {
    case 'NotAllowedError':
      console.error('Permission denied');
      break;
    case 'NotFoundError':
      console.error('No media devices found');
      break;
    case 'NotReadableError':
      console.error('Device is in use');
      break;
    case 'OverconstrainedError':
      console.error('Constraints cannot be satisfied');
      break;
    default:
      console.error('Error:', error);
  }
}
```

### Video Only

```javascript
const stream = await navigator.mediaDevices.getUserMedia({
  video: true,
  audio: false
});
```

### Audio Only

```javascript
const stream = await navigator.mediaDevices.getUserMedia({
  video: false,
  audio: true
});
```

---

## 7.5.2 Video Constraints

### Resolution

```javascript
const constraints = {
  video: {
    width: 1280,
    height: 720
  }
};

// With ideal/min/max
const constraints = {
  video: {
    width: { min: 640, ideal: 1280, max: 1920 },
    height: { min: 480, ideal: 720, max: 1080 }
  }
};

// Exact value (will fail if not available)
const constraints = {
  video: {
    width: { exact: 1920 },
    height: { exact: 1080 }
  }
};
```

### Frame Rate

```javascript
const constraints = {
  video: {
    frameRate: { ideal: 30, max: 60 }
  }
};
```

### Facing Mode

```javascript
// Front camera
const constraints = {
  video: {
    facingMode: 'user'
  }
};

// Back camera
const constraints = {
  video: {
    facingMode: 'environment'
  }
};

// Exact facing mode (fail if not available)
const constraints = {
  video: {
    facingMode: { exact: 'environment' }
  }
};
```

### Aspect Ratio

```javascript
const constraints = {
  video: {
    aspectRatio: 16 / 9
  }
};
```

### Specific Device

```javascript
const constraints = {
  video: {
    deviceId: { exact: 'specific-device-id' }
  }
};
```

---

## 7.5.3 Audio Constraints

### Basic Audio Settings

```javascript
const constraints = {
  audio: {
    echoCancellation: true,
    noiseSuppression: true,
    autoGainControl: true
  }
};
```

### Sample Rate and Channels

```javascript
const constraints = {
  audio: {
    sampleRate: 48000,
    channelCount: 2  // Stereo
  }
};
```

### Specific Microphone

```javascript
const constraints = {
  audio: {
    deviceId: { exact: 'microphone-device-id' }
  }
};
```

---

## 7.5.4 MediaStream

### Stream Properties

```javascript
const stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });

// Stream ID
console.log(stream.id);

// Check if active
console.log(stream.active);  // true

// Get all tracks
const tracks = stream.getTracks();

// Get video tracks
const videoTracks = stream.getVideoTracks();

// Get audio tracks
const audioTracks = stream.getAudioTracks();
```

### Stream Events

```javascript
stream.addEventListener('addtrack', (event) => {
  console.log('Track added:', event.track);
});

stream.addEventListener('removetrack', (event) => {
  console.log('Track removed:', event.track);
});
```

### Adding and Removing Tracks

```javascript
// Add track
stream.addTrack(newTrack);

// Remove track
stream.removeTrack(track);
```

### Cloning Stream

```javascript
// Clone entire stream
const clonedStream = stream.clone();

// Cloned tracks are independent
```

---

## 7.5.5 MediaStreamTrack

### Track Properties

```javascript
const track = stream.getVideoTracks()[0];

console.log(track.id);          // Unique ID
console.log(track.kind);        // 'video' or 'audio'
console.log(track.label);       // Device name
console.log(track.enabled);     // true/false
console.log(track.muted);       // true/false
console.log(track.readyState);  // 'live' or 'ended'
```

### Enable/Disable Track

```javascript
// Disable (mute) track
track.enabled = false;

// Enable track
track.enabled = true;

// Note: enabled only affects output, track still captures
```

### Stop Track

```javascript
// Stop track permanently
track.stop();

// Track becomes 'ended' and cannot be restarted
```

### Track Events

```javascript
track.addEventListener('ended', () => {
  console.log('Track ended');
});

track.addEventListener('mute', () => {
  console.log('Track muted');
});

track.addEventListener('unmute', () => {
  console.log('Track unmuted');
});
```

### Get Track Constraints

```javascript
// Get current constraints
const constraints = track.getConstraints();

// Get actual settings
const settings = track.getSettings();
console.log(settings.width);
console.log(settings.height);
console.log(settings.frameRate);

// Get supported capabilities
const capabilities = track.getCapabilities();
console.log(capabilities.width);  // { min: 1, max: 1920 }
```

### Apply Constraints

```javascript
await track.applyConstraints({
  width: 1920,
  height: 1080
});
```

---

## 7.5.6 Device Enumeration

### List Devices

```javascript
async function listDevices() {
  const devices = await navigator.mediaDevices.enumerateDevices();
  
  const videoInputs = devices.filter(d => d.kind === 'videoinput');
  const audioInputs = devices.filter(d => d.kind === 'audioinput');
  const audioOutputs = devices.filter(d => d.kind === 'audiooutput');
  
  console.log('Cameras:', videoInputs);
  console.log('Microphones:', audioInputs);
  console.log('Speakers:', audioOutputs);
  
  return { videoInputs, audioInputs, audioOutputs };
}
```

### Device Properties

```javascript
devices.forEach(device => {
  console.log('Device ID:', device.deviceId);
  console.log('Kind:', device.kind);      // videoinput, audioinput, audiooutput
  console.log('Label:', device.label);    // Human-readable name
  console.log('Group ID:', device.groupId);  // Same hardware device
});

// Note: labels may be empty until permission granted
```

### Device Change Event

```javascript
navigator.mediaDevices.addEventListener('devicechange', async () => {
  console.log('Devices changed');
  const devices = await navigator.mediaDevices.enumerateDevices();
  updateDeviceList(devices);
});
```

### Select Specific Device

```javascript
// Create device selector
async function createDeviceSelector() {
  const devices = await navigator.mediaDevices.enumerateDevices();
  const cameras = devices.filter(d => d.kind === 'videoinput');
  
  const select = document.getElementById('cameraSelect');
  
  cameras.forEach(camera => {
    const option = document.createElement('option');
    option.value = camera.deviceId;
    option.text = camera.label || `Camera ${select.length + 1}`;
    select.appendChild(option);
  });
}

// Use selected device
async function useSelectedCamera() {
  const deviceId = document.getElementById('cameraSelect').value;
  
  const stream = await navigator.mediaDevices.getUserMedia({
    video: { deviceId: { exact: deviceId } }
  });
  
  return stream;
}
```

---

## 7.5.7 getDisplayMedia

### Screen Capture

```javascript
async function captureScreen() {
  const stream = await navigator.mediaDevices.getDisplayMedia({
    video: {
      cursor: 'always'  // 'always', 'motion', 'never'
    },
    audio: true  // Capture system audio (if supported)
  });
  
  return stream;
}
```

### Screen Sharing Constraints

```javascript
const stream = await navigator.mediaDevices.getDisplayMedia({
  video: {
    displaySurface: 'monitor',  // 'monitor', 'window', 'application', 'browser'
    logicalSurface: true,
    cursor: 'always',
    width: { max: 1920 },
    height: { max: 1080 },
    frameRate: { max: 30 }
  }
});
```

### Handle Screen Share Stop

```javascript
const stream = await navigator.mediaDevices.getDisplayMedia({ video: true });
const track = stream.getVideoTracks()[0];

track.addEventListener('ended', () => {
  console.log('User stopped screen sharing');
  // Clean up or switch back to camera
});
```

---

## 7.5.8 Common Patterns

### Camera Switcher

```javascript
class CameraManager {
  constructor(videoElement) {
    this.video = videoElement;
    this.stream = null;
  }
  
  async start(deviceId = null) {
    // Stop existing stream
    this.stop();
    
    const constraints = {
      video: deviceId ? { deviceId: { exact: deviceId } } : true
    };
    
    this.stream = await navigator.mediaDevices.getUserMedia(constraints);
    this.video.srcObject = this.stream;
  }
  
  async switchCamera() {
    const devices = await navigator.mediaDevices.enumerateDevices();
    const cameras = devices.filter(d => d.kind === 'videoinput');
    
    const currentTrack = this.stream?.getVideoTracks()[0];
    const currentId = currentTrack?.getSettings().deviceId;
    
    const currentIndex = cameras.findIndex(c => c.deviceId === currentId);
    const nextIndex = (currentIndex + 1) % cameras.length;
    
    await this.start(cameras[nextIndex].deviceId);
  }
  
  stop() {
    this.stream?.getTracks().forEach(track => track.stop());
    this.stream = null;
    this.video.srcObject = null;
  }
}
```

### Picture from Video

```javascript
function captureFrame(video) {
  const canvas = document.createElement('canvas');
  canvas.width = video.videoWidth;
  canvas.height = video.videoHeight;
  
  const ctx = canvas.getContext('2d');
  ctx.drawImage(video, 0, 0);
  
  return canvas.toDataURL('image/jpeg');
}
```

---

## 7.5.9 Summary

### getUserMedia Constraints

| Video | Audio |
|-------|-------|
| `width/height` | `echoCancellation` |
| `frameRate` | `noiseSuppression` |
| `facingMode` | `autoGainControl` |
| `aspectRatio` | `sampleRate` |
| `deviceId` | `channelCount` |

### MediaStreamTrack States

| State | Meaning |
|-------|---------|
| `live` | Track is active |
| `ended` | Track has stopped |

### Error Types

| Error | Cause |
|-------|-------|
| `NotAllowedError` | Permission denied |
| `NotFoundError` | No matching device |
| `NotReadableError` | Device in use |
| `OverconstrainedError` | Constraints impossible |

### Best Practices

1. **Handle permission errors** gracefully
2. **Stop tracks when done** to release devices
3. **Use constraints** to get desired quality
4. **Monitor device changes** for hot-plugging
5. **Check capabilities** before applying constraints
6. **Provide fallbacks** for unsupported features

---

**End of Chapter 7.5: Media Capture and Streams**

Next chapter: **7.6 MediaRecorder API** — covers recording media streams.
# 7.6 MediaRecorder API

The MediaRecorder API captures audio and video from a MediaStream for recording. This chapter covers recording streams, handling data, and exporting recordings.

---

## 7.6.1 Basic Recording

### Creating MediaRecorder

```javascript
// Get a stream first
const stream = await navigator.mediaDevices.getUserMedia({
  video: true,
  audio: true
});

// Create recorder
const mediaRecorder = new MediaRecorder(stream);

// Check if format is supported
if (!MediaRecorder.isTypeSupported('video/webm')) {
  console.error('WebM not supported');
}
```

### Recording Options

```javascript
const options = {
  mimeType: 'video/webm;codecs=vp9',
  videoBitsPerSecond: 2500000,  // 2.5 Mbps
  audioBitsPerSecond: 128000    // 128 kbps
};

const mediaRecorder = new MediaRecorder(stream, options);
```

### Supported Formats

```javascript
// Check format support
MediaRecorder.isTypeSupported('video/webm');
MediaRecorder.isTypeSupported('video/webm;codecs=vp8');
MediaRecorder.isTypeSupported('video/webm;codecs=vp9');
MediaRecorder.isTypeSupported('video/webm;codecs=h264');
MediaRecorder.isTypeSupported('audio/webm');
MediaRecorder.isTypeSupported('audio/webm;codecs=opus');

// Common formats:
// video/webm (Chrome, Firefox)
// video/mp4 (Safari, some browsers)
// audio/webm
// audio/ogg
```

---

## 7.6.2 Recording Controls

### Start, Stop, Pause, Resume

```javascript
// Start recording
mediaRecorder.start();

// Start with timeslice (data every N milliseconds)
mediaRecorder.start(1000);  // Fire ondataavailable every second

// Pause recording
mediaRecorder.pause();

// Resume recording
mediaRecorder.resume();

// Stop recording
mediaRecorder.stop();
```

### Recording State

```javascript
console.log(mediaRecorder.state);
// 'inactive' - not recording
// 'recording' - currently recording
// 'paused' - recording paused
```

---

## 7.6.3 Handling Data

### ondataavailable Event

```javascript
const chunks = [];

mediaRecorder.ondataavailable = (event) => {
  if (event.data.size > 0) {
    chunks.push(event.data);
  }
};

// Request data manually (if not using timeslice)
mediaRecorder.requestData();
```

### Creating Final Recording

```javascript
mediaRecorder.onstop = () => {
  // Create blob from chunks
  const blob = new Blob(chunks, { type: 'video/webm' });
  
  // Create URL for playback
  const url = URL.createObjectURL(blob);
  
  // Play recording
  const video = document.getElementById('playback');
  video.src = url;
  
  // Download recording
  const a = document.createElement('a');
  a.href = url;
  a.download = 'recording.webm';
  a.click();
};
```

---

## 7.6.4 Events

### All Events

```javascript
mediaRecorder.onstart = () => {
  console.log('Recording started');
};

mediaRecorder.onstop = () => {
  console.log('Recording stopped');
};

mediaRecorder.onpause = () => {
  console.log('Recording paused');
};

mediaRecorder.onresume = () => {
  console.log('Recording resumed');
};

mediaRecorder.ondataavailable = (event) => {
  console.log('Data available:', event.data.size, 'bytes');
};

mediaRecorder.onerror = (event) => {
  console.error('Recording error:', event.error);
};
```

---

## 7.6.5 Complete Example

### Video Recorder

```javascript
class VideoRecorder {
  constructor(videoElement) {
    this.videoElement = videoElement;
    this.stream = null;
    this.mediaRecorder = null;
    this.chunks = [];
  }
  
  async start() {
    // Get camera stream
    this.stream = await navigator.mediaDevices.getUserMedia({
      video: true,
      audio: true
    });
    
    // Display preview
    this.videoElement.srcObject = this.stream;
    this.videoElement.muted = true;
    
    // Create recorder
    this.mediaRecorder = new MediaRecorder(this.stream, {
      mimeType: 'video/webm;codecs=vp9'
    });
    
    this.chunks = [];
    
    this.mediaRecorder.ondataavailable = (event) => {
      if (event.data.size > 0) {
        this.chunks.push(event.data);
      }
    };
    
    // Start recording
    this.mediaRecorder.start(1000);  // Chunk every second
  }
  
  pause() {
    if (this.mediaRecorder?.state === 'recording') {
      this.mediaRecorder.pause();
    }
  }
  
  resume() {
    if (this.mediaRecorder?.state === 'paused') {
      this.mediaRecorder.resume();
    }
  }
  
  async stop() {
    return new Promise((resolve) => {
      this.mediaRecorder.onstop = () => {
        // Stop camera
        this.stream.getTracks().forEach(track => track.stop());
        
        // Create blob
        const blob = new Blob(this.chunks, { type: 'video/webm' });
        resolve(blob);
      };
      
      this.mediaRecorder.stop();
    });
  }
  
  getState() {
    return this.mediaRecorder?.state || 'inactive';
  }
}

// Usage
const recorder = new VideoRecorder(document.querySelector('video'));

document.getElementById('start').onclick = () => recorder.start();
document.getElementById('pause').onclick = () => recorder.pause();
document.getElementById('resume').onclick = () => recorder.resume();
document.getElementById('stop').onclick = async () => {
  const blob = await recorder.stop();
  
  // Download
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `recording-${Date.now()}.webm`;
  a.click();
  
  URL.revokeObjectURL(url);
};
```

---

## 7.6.6 Audio Recording

### Audio Only Recorder

```javascript
async function recordAudio() {
  const stream = await navigator.mediaDevices.getUserMedia({
    audio: true
  });
  
  const mediaRecorder = new MediaRecorder(stream, {
    mimeType: 'audio/webm;codecs=opus'
  });
  
  const chunks = [];
  
  mediaRecorder.ondataavailable = (e) => {
    chunks.push(e.data);
  };
  
  mediaRecorder.onstop = () => {
    const blob = new Blob(chunks, { type: 'audio/webm' });
    const url = URL.createObjectURL(blob);
    
    const audio = new Audio(url);
    audio.controls = true;
    document.body.appendChild(audio);
  };
  
  return mediaRecorder;
}
```

---

## 7.6.7 Screen Recording

### Record Screen with Audio

```javascript
async function recordScreen() {
  // Get screen
  const screenStream = await navigator.mediaDevices.getDisplayMedia({
    video: { cursor: 'always' },
    audio: true
  });
  
  // Optionally add microphone
  const micStream = await navigator.mediaDevices.getUserMedia({
    audio: true
  });
  
  // Combine streams
  const combinedStream = new MediaStream([
    ...screenStream.getVideoTracks(),
    ...micStream.getAudioTracks()
  ]);
  
  const mediaRecorder = new MediaRecorder(combinedStream, {
    mimeType: 'video/webm;codecs=vp9,opus'
  });
  
  const chunks = [];
  mediaRecorder.ondataavailable = e => chunks.push(e.data);
  
  mediaRecorder.onstop = () => {
    // Stop all tracks
    screenStream.getTracks().forEach(t => t.stop());
    micStream.getTracks().forEach(t => t.stop());
    
    const blob = new Blob(chunks, { type: 'video/webm' });
    // Handle recording...
  };
  
  // Handle user stopping screen share
  screenStream.getVideoTracks()[0].onended = () => {
    mediaRecorder.stop();
  };
  
  return mediaRecorder;
}
```

---

## 7.6.8 Converting Formats

### WebM to MP4 (Using FFmpeg.wasm)

```javascript
// Note: Requires ffmpeg.wasm library
import { createFFmpeg, fetchFile } from '@ffmpeg/ffmpeg';

async function convertToMP4(webmBlob) {
  const ffmpeg = createFFmpeg({ log: true });
  await ffmpeg.load();
  
  // Write input file
  ffmpeg.FS('writeFile', 'input.webm', await fetchFile(webmBlob));
  
  // Convert
  await ffmpeg.run('-i', 'input.webm', 'output.mp4');
  
  // Read output
  const data = ffmpeg.FS('readFile', 'output.mp4');
  const mp4Blob = new Blob([data.buffer], { type: 'video/mp4' });
  
  return mp4Blob;
}
```

---

## 7.6.9 Summary

### MediaRecorder States

| State | Description |
|-------|-------------|
| `inactive` | Not recording |
| `recording` | Currently recording |
| `paused` | Recording paused |

### MediaRecorder Methods

| Method | Description |
|--------|-------------|
| `start(timeslice)` | Start recording |
| `stop()` | Stop recording |
| `pause()` | Pause recording |
| `resume()` | Resume recording |
| `requestData()` | Request data chunk |

### Common MIME Types

| Type | Codec |
|------|-------|
| `video/webm` | VP8, VP9 |
| `video/webm;codecs=vp9` | VP9 |
| `video/webm;codecs=h264` | H.264 |
| `audio/webm` | Opus, Vorbis |
| `audio/webm;codecs=opus` | Opus |

### Best Practices

1. **Check format support** before recording
2. **Use timeslice** for long recordings
3. **Handle errors** gracefully
4. **Stop tracks** when done
5. **Monitor state** for UI updates
6. **Test across browsers** for compatibility

---

**End of Chapter 7.6: MediaRecorder API**

Next chapter: **7.7 HTMLMediaElement** — covers audio and video element APIs.
# 7.7 HTMLMediaElement

The HTMLMediaElement interface provides common functionality for `<audio>` and `<video>` elements. This chapter covers playback control, events, time manipulation, and common media patterns.

---

## 7.7.1 Media Elements

### Creating Media Elements

```html
<!-- Video element -->
<video id="video" src="video.mp4" controls>
  <source src="video.webm" type="video/webm">
  <source src="video.mp4" type="video/mp4">
  Your browser doesn't support video.
</video>

<!-- Audio element -->
<audio id="audio" src="audio.mp3" controls>
  <source src="audio.ogg" type="audio/ogg">
  <source src="audio.mp3" type="audio/mpeg">
</audio>
```

```javascript
// Create via JavaScript
const video = document.createElement('video');
video.src = 'video.mp4';

const audio = new Audio('audio.mp3');
```

---

## 7.7.2 Playback Control

### Play and Pause

```javascript
const video = document.getElementById('video');

// Play (returns promise)
video.play()
  .then(() => console.log('Playing'))
  .catch(err => console.error('Playback failed:', err));

// Pause
video.pause();

// Toggle play/pause
function togglePlay() {
  if (video.paused) {
    video.play();
  } else {
    video.pause();
  }
}
```

### Load and Source

```javascript
// Change source
video.src = 'newvideo.mp4';

// Or use source elements
video.innerHTML = `
  <source src="video.webm" type="video/webm">
  <source src="video.mp4" type="video/mp4">
`;

// Reload media
video.load();
```

---

## 7.7.3 Time Properties

### Current Time and Duration

```javascript
// Current playback position (seconds)
console.log(video.currentTime);  // e.g., 45.5

// Set current time (seek)
video.currentTime = 60;  // Jump to 1 minute

// Total duration
console.log(video.duration);  // e.g., 180

// Remaining time
const remaining = video.duration - video.currentTime;
```

### Progress and Buffered

```javascript
// Buffered time ranges
const buffered = video.buffered;
for (let i = 0; i < buffered.length; i++) {
  console.log(`Range ${i}: ${buffered.start(i)} - ${buffered.end(i)}`);
}

// Amount buffered
const bufferedEnd = buffered.length ? buffered.end(buffered.length - 1) : 0;
const bufferedPercent = (bufferedEnd / video.duration) * 100;

// Played time ranges
const played = video.played;

// Seekable time ranges
const seekable = video.seekable;
```

---

## 7.7.4 Playback State

### Properties

```javascript
// Paused state
console.log(video.paused);  // true/false

// Ended state
console.log(video.ended);   // true/false

// Seeking state
console.log(video.seeking); // true/false

// Ready state
console.log(video.readyState);
// 0 = HAVE_NOTHING
// 1 = HAVE_METADATA
// 2 = HAVE_CURRENT_DATA
// 3 = HAVE_FUTURE_DATA
// 4 = HAVE_ENOUGH_DATA

// Network state
console.log(video.networkState);
// 0 = NETWORK_EMPTY
// 1 = NETWORK_IDLE
// 2 = NETWORK_LOADING
// 3 = NETWORK_NO_SOURCE
```

---

## 7.7.5 Volume and Mute

### Volume Control

```javascript
// Volume (0.0 to 1.0)
video.volume = 0.5;  // 50%

// Mute/unmute
video.muted = true;
video.muted = false;

// Toggle mute
video.muted = !video.muted;
```

---

## 7.7.6 Playback Rate

### Speed Control

```javascript
// Normal speed
video.playbackRate = 1.0;

// Slow motion
video.playbackRate = 0.5;

// Fast forward
video.playbackRate = 2.0;

// Reverse (some browsers)
video.playbackRate = -1.0;

// Default playback rate
video.defaultPlaybackRate = 1.0;
```

---

## 7.7.7 Events

### Playback Events

```javascript
// Can play
video.addEventListener('canplay', () => {
  console.log('Can start playing');
});

// Can play through
video.addEventListener('canplaythrough', () => {
  console.log('Can play without buffering');
});

// Playing
video.addEventListener('playing', () => {
  console.log('Playback started');
});

// Pause
video.addEventListener('pause', () => {
  console.log('Playback paused');
});

// Ended
video.addEventListener('ended', () => {
  console.log('Playback ended');
});

// Time update (fires during playback)
video.addEventListener('timeupdate', () => {
  console.log('Current time:', video.currentTime);
});
```

### Loading Events

```javascript
// Metadata loaded
video.addEventListener('loadedmetadata', () => {
  console.log('Duration:', video.duration);
  console.log('Dimensions:', video.videoWidth, video.videoHeight);
});

// Data loaded
video.addEventListener('loadeddata', () => {
  console.log('First frame available');
});

// Progress (buffering)
video.addEventListener('progress', () => {
  console.log('Buffering...');
});

// Stalled
video.addEventListener('stalled', () => {
  console.log('Download stalled');
});

// Waiting
video.addEventListener('waiting', () => {
  console.log('Waiting for data');
});
```

### Seek Events

```javascript
video.addEventListener('seeking', () => {
  console.log('Seeking to:', video.currentTime);
});

video.addEventListener('seeked', () => {
  console.log('Seek complete');
});
```

### Error Events

```javascript
video.addEventListener('error', () => {
  const error = video.error;
  switch (error.code) {
    case MediaError.MEDIA_ERR_ABORTED:
      console.error('Playback aborted');
      break;
    case MediaError.MEDIA_ERR_NETWORK:
      console.error('Network error');
      break;
    case MediaError.MEDIA_ERR_DECODE:
      console.error('Decode error');
      break;
    case MediaError.MEDIA_ERR_SRC_NOT_SUPPORTED:
      console.error('Format not supported');
      break;
  }
});
```

---

## 7.7.8 Video-Specific Properties

### Dimensions

```javascript
// Native video dimensions
console.log(video.videoWidth);   // e.g., 1920
console.log(video.videoHeight);  // e.g., 1080

// Element dimensions (CSS)
console.log(video.clientWidth);
console.log(video.clientHeight);
```

### Poster

```javascript
// Set poster image
video.poster = 'thumbnail.jpg';
```

---

## 7.7.9 Text Tracks (Subtitles)

### Adding Subtitles

```html
<video src="video.mp4">
  <track kind="subtitles" src="en.vtt" srclang="en" label="English" default>
  <track kind="subtitles" src="es.vtt" srclang="es" label="Spanish">
</video>
```

### Controlling Text Tracks

```javascript
// Get text tracks
const tracks = video.textTracks;

// Enable/disable track
tracks[0].mode = 'showing';  // showing, hidden, disabled

// Listen for cue changes
tracks[0].oncuechange = function() {
  const cue = this.activeCues[0];
  if (cue) {
    console.log('Subtitle:', cue.text);
  }
};
```

---

## 7.7.10 Common Patterns

### Custom Video Player

```javascript
class VideoPlayer {
  constructor(container) {
    this.container = container;
    this.video = container.querySelector('video');
    this.setupControls();
    this.bindEvents();
  }
  
  setupControls() {
    this.playBtn = this.container.querySelector('.play-btn');
    this.progress = this.container.querySelector('.progress');
    this.progressBar = this.container.querySelector('.progress-bar');
    this.timeDisplay = this.container.querySelector('.time');
    this.volumeSlider = this.container.querySelector('.volume');
  }
  
  bindEvents() {
    this.playBtn.onclick = () => this.togglePlay();
    this.progress.onclick = (e) => this.seek(e);
    this.volumeSlider.oninput = (e) => this.setVolume(e.target.value);
    
    this.video.ontimeupdate = () => this.updateProgress();
    this.video.onloadedmetadata = () => this.updateTime();
  }
  
  togglePlay() {
    if (this.video.paused) {
      this.video.play();
      this.playBtn.textContent = '⏸';
    } else {
      this.video.pause();
      this.playBtn.textContent = '▶';
    }
  }
  
  seek(event) {
    const rect = this.progress.getBoundingClientRect();
    const percent = (event.clientX - rect.left) / rect.width;
    this.video.currentTime = percent * this.video.duration;
  }
  
  setVolume(value) {
    this.video.volume = value;
  }
  
  updateProgress() {
    const percent = (this.video.currentTime / this.video.duration) * 100;
    this.progressBar.style.width = `${percent}%`;
    this.updateTime();
  }
  
  updateTime() {
    const current = this.formatTime(this.video.currentTime);
    const duration = this.formatTime(this.video.duration);
    this.timeDisplay.textContent = `${current} / ${duration}`;
  }
  
  formatTime(seconds) {
    const mins = Math.floor(seconds / 60);
    const secs = Math.floor(seconds % 60);
    return `${mins}:${secs.toString().padStart(2, '0')}`;
  }
}
```

### Lazy Loading Videos

```javascript
const videos = document.querySelectorAll('video[data-src]');

const observer = new IntersectionObserver((entries) => {
  entries.forEach(entry => {
    if (entry.isIntersecting) {
      const video = entry.target;
      video.src = video.dataset.src;
      video.load();
      observer.unobserve(video);
    }
  });
});

videos.forEach(video => observer.observe(video));
```

---

## 7.7.11 Summary

### Key Properties

| Property | Description |
|----------|-------------|
| `currentTime` | Current position (seconds) |
| `duration` | Total duration |
| `paused` | Is paused |
| `ended` | Has ended |
| `volume` | Volume level (0-1) |
| `muted` | Is muted |
| `playbackRate` | Playback speed |
| `readyState` | Data availability |

### Key Methods

| Method | Description |
|--------|-------------|
| `play()` | Start playback |
| `pause()` | Pause playback |
| `load()` | Reload media |

### Key Events

| Event | When |
|-------|------|
| `play` | Playback starts |
| `pause` | Playback pauses |
| `ended` | Playback ends |
| `timeupdate` | Time changes |
| `loadedmetadata` | Metadata loaded |
| `error` | Error occurs |

### Best Practices

1. **Always handle play() promise** for autoplay
2. **Check readyState** before operations
3. **Handle errors** gracefully
4. **Provide fallback formats**
5. **Use lazy loading** for performance
6. **Respect user preferences** (prefers-reduced-motion)

---

**End of Chapter 7.7: HTMLMediaElement**

Next chapter: **7.8 Picture-in-Picture API** — covers floating video windows.
# 7.8 Picture-in-Picture API

The Picture-in-Picture (PiP) API allows videos to float in a small window above other windows. This chapter covers entering and exiting PiP mode, handling events, and styling the PiP window.

---

## 7.8.1 Picture-in-Picture Basics

### What Is Picture-in-Picture?

```javascript
// Picture-in-Picture (PiP):
// - Video floats above other windows
// - Stays visible while using other apps
// - User can resize and position
// - Works across browser tabs and applications
```

### Checking Support

```javascript
// Check if PiP is supported
if ('pictureInPictureEnabled' in document) {
  console.log('PiP supported');
}

// Check if currently disabled
if (document.pictureInPictureEnabled) {
  console.log('PiP is available');
} else {
  console.log('PiP is disabled');
}

// Check if video can enter PiP
if (video.disablePictureInPicture) {
  console.log('PiP disabled for this video');
}
```

---

## 7.8.2 Entering and Exiting PiP

### Request Picture-in-Picture

```javascript
const video = document.getElementById('video');

async function enterPiP() {
  try {
    await video.requestPictureInPicture();
    console.log('Entered PiP');
  } catch (error) {
    console.error('Failed to enter PiP:', error);
  }
}

// Must be called from user gesture
button.addEventListener('click', enterPiP);
```

### Exit Picture-in-Picture

```javascript
async function exitPiP() {
  if (document.pictureInPictureElement) {
    await document.exitPictureInPicture();
    console.log('Exited PiP');
  }
}

// Or just close the PiP window
```

### Toggle PiP

```javascript
async function togglePiP() {
  if (document.pictureInPictureElement) {
    await document.exitPictureInPicture();
  } else {
    await video.requestPictureInPicture();
  }
}
```

---

## 7.8.3 PiP Events

### Video Events

```javascript
const video = document.getElementById('video');

video.addEventListener('enterpictureinpicture', (event) => {
  console.log('Entered PiP');
  
  // PictureInPictureWindow object
  const pipWindow = event.pictureInPictureWindow;
  console.log('PiP window size:', pipWindow.width, pipWindow.height);
});

video.addEventListener('leavepictureinpicture', () => {
  console.log('Left PiP');
});
```

### PiP Window Events

```javascript
video.addEventListener('enterpictureinpicture', (event) => {
  const pipWindow = event.pictureInPictureWindow;
  
  // Window resize
  pipWindow.addEventListener('resize', () => {
    console.log('PiP resized:', pipWindow.width, pipWindow.height);
  });
});
```

---

## 7.8.4 PictureInPictureWindow

### Window Properties

```javascript
video.addEventListener('enterpictureinpicture', (event) => {
  const pipWindow = event.pictureInPictureWindow;
  
  // Window dimensions
  console.log('Width:', pipWindow.width);
  console.log('Height:', pipWindow.height);
});
```

### Current PiP Element

```javascript
// Get current PiP element
const currentPiP = document.pictureInPictureElement;

if (currentPiP) {
  console.log('Video in PiP:', currentPiP);
}
```

---

## 7.8.5 Disabling PiP

### Per Video

```html
<!-- Disable PiP for specific video -->
<video src="video.mp4" disablepictureinpicture></video>
```

```javascript
// Or via JavaScript
video.disablePictureInPicture = true;
```

---

## 7.8.6 Media Session Integration

### Controlling PiP Playback

```javascript
// Add media session actions for PiP controls
if ('mediaSession' in navigator) {
  navigator.mediaSession.setActionHandler('play', () => {
    video.play();
  });
  
  navigator.mediaSession.setActionHandler('pause', () => {
    video.pause();
  });
  
  navigator.mediaSession.setActionHandler('seekbackward', () => {
    video.currentTime -= 10;
  });
  
  navigator.mediaSession.setActionHandler('seekforward', () => {
    video.currentTime += 10;
  });
  
  navigator.mediaSession.setActionHandler('previoustrack', () => {
    playPreviousVideo();
  });
  
  navigator.mediaSession.setActionHandler('nexttrack', () => {
    playNextVideo();
  });
}
```

### Media Metadata

```javascript
navigator.mediaSession.metadata = new MediaMetadata({
  title: 'Video Title',
  artist: 'Creator Name',
  album: 'Series Name',
  artwork: [
    { src: 'thumbnail-96.png', sizes: '96x96', type: 'image/png' },
    { src: 'thumbnail-512.png', sizes: '512x512', type: 'image/png' }
  ]
});
```

---

## 7.8.7 Complete Example

### PiP Video Player

```javascript
class PiPPlayer {
  constructor(videoElement, pipButton) {
    this.video = videoElement;
    this.button = pipButton;
    this.pipWindow = null;
    
    this.setupEventListeners();
    this.updateButton();
  }
  
  setupEventListeners() {
    // Button click
    this.button.addEventListener('click', () => this.togglePiP());
    
    // PiP events
    this.video.addEventListener('enterpictureinpicture', (e) => {
      this.pipWindow = e.pictureInPictureWindow;
      this.updateButton();
      
      this.pipWindow.addEventListener('resize', () => {
        this.onPiPResize();
      });
    });
    
    this.video.addEventListener('leavepictureinpicture', () => {
      this.pipWindow = null;
      this.updateButton();
    });
  }
  
  async togglePiP() {
    try {
      if (document.pictureInPictureElement) {
        await document.exitPictureInPicture();
      } else if (document.pictureInPictureEnabled) {
        await this.video.requestPictureInPicture();
      }
    } catch (error) {
      console.error('PiP error:', error);
    }
  }
  
  updateButton() {
    if (document.pictureInPictureElement) {
      this.button.textContent = 'Exit PiP';
      this.button.classList.add('active');
    } else {
      this.button.textContent = 'Enter PiP';
      this.button.classList.remove('active');
    }
    
    // Disable if PiP not available
    this.button.disabled = !document.pictureInPictureEnabled;
  }
  
  onPiPResize() {
    console.log(`PiP resized: ${this.pipWindow.width}x${this.pipWindow.height}`);
  }
  
  get isInPiP() {
    return document.pictureInPictureElement === this.video;
  }
}

// Usage
const player = new PiPPlayer(
  document.getElementById('video'),
  document.getElementById('pip-button')
);
```

---

## 7.8.8 Auto-PiP on Scroll

```javascript
function setupAutoPiP(video) {
  const observer = new IntersectionObserver(
    async (entries) => {
      const [entry] = entries;
      
      if (!entry.isIntersecting && !video.paused) {
        // Video scrolled out of view while playing
        try {
          if (document.pictureInPictureEnabled && !document.pictureInPictureElement) {
            await video.requestPictureInPicture();
          }
        } catch (e) {
          // User gesture required or other error
        }
      } else if (entry.isIntersecting && document.pictureInPictureElement === video) {
        // Video scrolled back into view
        await document.exitPictureInPicture();
      }
    },
    { threshold: 0.5 }
  );
  
  observer.observe(video);
  
  return observer;
}
```

---

## 7.8.9 Document Picture-in-Picture (Emerging)

### Full Document PiP

```javascript
// Document PiP API (Chrome 116+)
// Allows any HTML content in PiP, not just video

async function openDocumentPiP() {
  // Check support
  if (!('documentPictureInPicture' in window)) {
    console.log('Document PiP not supported');
    return;
  }
  
  // Open PiP window
  const pipWindow = await documentPictureInPicture.requestWindow({
    width: 400,
    height: 300
  });
  
  // Add content to PiP window
  const container = document.createElement('div');
  container.innerHTML = `
    <video src="video.mp4" autoplay></video>
    <button id="next">Next</button>
  `;
  
  // Copy styles
  [...document.styleSheets].forEach(sheet => {
    try {
      const css = [...sheet.cssRules].map(rule => rule.cssText).join('');
      const style = pipWindow.document.createElement('style');
      style.textContent = css;
      pipWindow.document.head.appendChild(style);
    } catch (e) {
      // Cross-origin stylesheets
    }
  });
  
  pipWindow.document.body.appendChild(container);
}
```

---

## 7.8.10 Summary

### Key Methods

| Method | Description |
|--------|-------------|
| `video.requestPictureInPicture()` | Enter PiP |
| `document.exitPictureInPicture()` | Exit PiP |

### Key Properties

| Property | Description |
|----------|-------------|
| `document.pictureInPictureEnabled` | PiP available |
| `document.pictureInPictureElement` | Current PiP element |
| `video.disablePictureInPicture` | Disable PiP |

### Key Events

| Event | When |
|-------|------|
| `enterpictureinpicture` | Entered PiP |
| `leavepictureinpicture` | Left PiP |

### PiP Window Properties

| Property | Description |
|----------|-------------|
| `width` | Window width |
| `height` | Window height |

### Best Practices

1. **Check support** before using
2. **Handle errors** from requestPictureInPicture
3. **Integrate with Media Session** for controls
4. **Update UI** on PiP state changes
5. **Consider auto-PiP** on scroll for video sites
6. **Respect user preference** - don't force PiP

---

**End of Chapter 7.8: Picture-in-Picture API**

This completes the Multimedia APIs group. Next section: **Group 08 — Graphics and Visualization** — covers SVG and Web Animations API.
# 8.1 SVG

Scalable Vector Graphics (SVG) provides XML-based vector graphics in the browser. This chapter covers inline SVG, DOM manipulation, paths, animations, and filters.

---

## 8.1.1 SVG Fundamentals

### What Is SVG?

```xml
<!-- SVG is XML-based vector graphics -->
<svg width="200" height="200" xmlns="http://www.w3.org/2000/svg">
  <circle cx="100" cy="100" r="50" fill="blue" />
</svg>
```

```javascript
// SVG advantages:
// - Resolution independent (scales without pixelation)
// - DOM accessible (can manipulate with JavaScript)
// - Styleable with CSS
// - Animatable
// - Smaller file sizes for simple graphics
// - Accessible (can add titles, descriptions)
```

### Inline SVG

```html
<!-- Inline SVG in HTML -->
<svg width="300" height="200" viewBox="0 0 300 200">
  <rect x="10" y="10" width="280" height="180" fill="#f0f0f0" stroke="#333" />
  <circle cx="150" cy="100" r="50" fill="blue" />
  <text x="150" y="105" text-anchor="middle" fill="white">SVG</text>
</svg>
```

### SVG as Image

```html
<!-- External SVG file -->
<img src="graphic.svg" alt="SVG graphic">

<!-- Background image -->
<style>
  .icon {
    background-image: url('icon.svg');
  }
</style>
```

---

## 8.1.2 Basic Shapes

### Rectangle

```xml
<!-- Rectangle -->
<rect x="10" y="10" width="100" height="50" 
      fill="blue" stroke="black" stroke-width="2" />

<!-- Rounded rectangle -->
<rect x="10" y="80" width="100" height="50" rx="10" ry="10" fill="green" />
```

### Circle and Ellipse

```xml
<!-- Circle -->
<circle cx="100" cy="100" r="50" fill="red" />

<!-- Ellipse -->
<ellipse cx="200" cy="100" rx="80" ry="50" fill="purple" />
```

### Line and Polyline

```xml
<!-- Line -->
<line x1="10" y1="10" x2="200" y2="100" stroke="black" stroke-width="2" />

<!-- Polyline (connected lines, not closed) -->
<polyline points="10,10 50,50 90,30 130,70" 
          fill="none" stroke="blue" stroke-width="2" />
```

### Polygon

```xml
<!-- Polygon (closed shape) -->
<polygon points="100,10 150,100 50,100" fill="orange" />

<!-- Star -->
<polygon points="100,10 120,80 190,80 130,120 150,190 100,150 50,190 70,120 10,80 80,80"
         fill="gold" stroke="orange" stroke-width="2" />
```

---

## 8.1.3 Paths

### Path Basics

```xml
<!-- Path element uses d attribute for commands -->
<path d="M 10 10 L 100 10 L 100 100 Z" fill="blue" />

<!-- Commands:
     M = Move to (start point)
     L = Line to
     H = Horizontal line
     V = Vertical line
     Z = Close path
     Lowercase = relative coordinates
-->
```

### Path Commands

```xml
<!-- Line commands -->
<path d="M 10 10 L 90 90" stroke="black" />          <!-- Line to -->
<path d="M 10 10 H 90" stroke="black" />              <!-- Horizontal -->
<path d="M 10 10 V 90" stroke="black" />              <!-- Vertical -->

<!-- Relative (lowercase) -->
<path d="M 10 10 l 80 80" stroke="black" />           <!-- Line relative -->
<path d="M 10 10 h 80" stroke="black" />              <!-- H relative -->
<path d="M 10 10 v 80" stroke="black" />              <!-- V relative -->
```

### Curves

```xml
<!-- Quadratic Bezier (Q) -->
<path d="M 10 80 Q 95 10 180 80" fill="none" stroke="black" />

<!-- Cubic Bezier (C) -->
<path d="M 10 80 C 40 10, 65 10, 95 80 S 150 150, 180 80" 
      fill="none" stroke="blue" />

<!-- Arc (A) -->
<path d="M 10 80 A 45 45, 0, 0, 0, 125 125" fill="none" stroke="red" />

<!-- Arc parameters: rx ry x-axis-rotation large-arc-flag sweep-flag x y -->
```

### Complex Path Example

```xml
<!-- Heart shape -->
<path d="M 100 50 
         C 100 30, 130 10, 150 30
         C 170 50, 170 80, 100 140
         C 30 80, 30 50, 50 30
         C 70 10, 100 30, 100 50 Z" 
      fill="red" />
```

---

## 8.1.4 Text

### Basic Text

```xml
<text x="50" y="50" font-size="24" fill="black">Hello SVG</text>

<!-- Text attributes -->
<text x="50" y="80"
      font-family="Arial"
      font-size="20"
      font-weight="bold"
      fill="blue"
      text-anchor="middle">  <!-- start | middle | end -->
  Centered Text
</text>
```

### Text on Path

```xml
<defs>
  <path id="textPath" d="M 10 100 Q 100 20 190 100" />
</defs>

<text>
  <textPath href="#textPath">Text along a curved path</textPath>
</text>
```

### Multiline Text

```xml
<text x="50" y="50">
  <tspan x="50" dy="0">Line 1</tspan>
  <tspan x="50" dy="1.2em">Line 2</tspan>
  <tspan x="50" dy="1.2em">Line 3</tspan>
</text>
```

---

## 8.1.5 Gradients and Patterns

### Linear Gradient

```xml
<defs>
  <linearGradient id="gradient1" x1="0%" y1="0%" x2="100%" y2="0%">
    <stop offset="0%" style="stop-color:blue" />
    <stop offset="100%" style="stop-color:red" />
  </linearGradient>
</defs>

<rect x="10" y="10" width="200" height="100" fill="url(#gradient1)" />
```

### Radial Gradient

```xml
<defs>
  <radialGradient id="gradient2" cx="50%" cy="50%" r="50%">
    <stop offset="0%" style="stop-color:white" />
    <stop offset="100%" style="stop-color:blue" />
  </radialGradient>
</defs>

<circle cx="100" cy="100" r="80" fill="url(#gradient2)" />
```

### Patterns

```xml
<defs>
  <pattern id="pattern1" x="0" y="0" width="20" height="20" 
           patternUnits="userSpaceOnUse">
    <circle cx="10" cy="10" r="5" fill="blue" />
  </pattern>
</defs>

<rect x="10" y="10" width="200" height="100" fill="url(#pattern1)" />
```

---

## 8.1.6 SVG DOM Manipulation

### Creating SVG Elements

```javascript
const svgNS = 'http://www.w3.org/2000/svg';

// Create SVG element
const svg = document.createElementNS(svgNS, 'svg');
svg.setAttribute('width', '300');
svg.setAttribute('height', '200');
svg.setAttribute('viewBox', '0 0 300 200');

// Create circle
const circle = document.createElementNS(svgNS, 'circle');
circle.setAttribute('cx', '100');
circle.setAttribute('cy', '100');
circle.setAttribute('r', '50');
circle.setAttribute('fill', 'blue');

svg.appendChild(circle);
document.body.appendChild(svg);
```

### Modifying SVG Elements

```javascript
// Get existing element
const circle = document.querySelector('circle');

// Modify attributes
circle.setAttribute('fill', 'red');
circle.setAttribute('r', '75');

// Get attributes
const radius = circle.getAttribute('r');
console.log(radius);  // "75"

// Remove attribute
circle.removeAttribute('stroke');
```

### SVG Element Properties

```javascript
// Some SVG elements have direct properties
const rect = document.querySelector('rect');

// Access via baseVal for animated properties
rect.x.baseVal.value = 50;
rect.width.baseVal.value = 100;

// For circles
const circle = document.querySelector('circle');
circle.cx.baseVal.value = 150;
circle.cy.baseVal.value = 100;
circle.r.baseVal.value = 40;
```

### Dynamic SVG Creation

```javascript
function createChart(data) {
  const svgNS = 'http://www.w3.org/2000/svg';
  const svg = document.createElementNS(svgNS, 'svg');
  svg.setAttribute('viewBox', '0 0 400 200');
  
  const barWidth = 400 / data.length - 10;
  const maxValue = Math.max(...data);
  
  data.forEach((value, index) => {
    const barHeight = (value / maxValue) * 180;
    
    const rect = document.createElementNS(svgNS, 'rect');
    rect.setAttribute('x', index * (barWidth + 10) + 5);
    rect.setAttribute('y', 200 - barHeight - 10);
    rect.setAttribute('width', barWidth);
    rect.setAttribute('height', barHeight);
    rect.setAttribute('fill', `hsl(${index * 60}, 70%, 50%)`);
    
    svg.appendChild(rect);
  });
  
  return svg;
}

document.body.appendChild(createChart([40, 80, 60, 100, 45, 90]));
```

---

## 8.1.7 SVG Filters

### Basic Filter

```xml
<defs>
  <filter id="blur">
    <feGaussianBlur in="SourceGraphic" stdDeviation="5" />
  </filter>
</defs>

<circle cx="100" cy="100" r="50" fill="blue" filter="url(#blur)" />
```

### Drop Shadow

```xml
<defs>
  <filter id="shadow" x="-20%" y="-20%" width="140%" height="140%">
    <feDropShadow dx="5" dy="5" stdDeviation="3" flood-color="black" 
                  flood-opacity="0.5" />
  </filter>
</defs>

<rect x="50" y="50" width="100" height="100" fill="blue" filter="url(#shadow)" />
```

### Complex Filter

```xml
<defs>
  <filter id="glow">
    <!-- Blur the source -->
    <feGaussianBlur in="SourceGraphic" stdDeviation="4" result="blur" />
    <!-- Merge original on top of blur -->
    <feMerge>
      <feMergeNode in="blur" />
      <feMergeNode in="SourceGraphic" />
    </feMerge>
  </filter>
</defs>

<text x="100" y="50" font-size="24" fill="yellow" filter="url(#glow)">
  Glowing Text
</text>
```

### Color Matrix

```xml
<defs>
  <filter id="grayscale">
    <feColorMatrix type="saturate" values="0" />
  </filter>
</defs>

<image href="photo.jpg" width="200" height="150" filter="url(#grayscale)" />
```

---

## 8.1.8 SVG Animation

### CSS Animation

```xml
<style>
  .pulse {
    animation: pulse 1s ease-in-out infinite;
    transform-origin: center;
  }
  
  @keyframes pulse {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.2); }
  }
</style>

<circle class="pulse" cx="100" cy="100" r="50" fill="red" />
```

### SMIL Animation (Native SVG)

```xml
<!-- Animate attribute -->
<circle cx="100" cy="100" r="50" fill="blue">
  <animate attributeName="r" from="50" to="80" dur="1s" 
           repeatCount="indefinite" />
</circle>

<!-- Animate along path -->
<circle r="10" fill="red">
  <animateMotion dur="3s" repeatCount="indefinite"
                 path="M 50 100 Q 150 50 250 100 T 450 100" />
</circle>

<!-- Transform animation -->
<rect x="-25" y="-25" width="50" height="50" fill="green">
  <animateTransform attributeName="transform" type="rotate"
                    from="0" to="360" dur="2s" repeatCount="indefinite" />
</rect>
```

### JavaScript Animation

```javascript
function animateCircle(circle) {
  let radius = 50;
  let growing = true;
  
  function animate() {
    if (growing) {
      radius += 0.5;
      if (radius >= 80) growing = false;
    } else {
      radius -= 0.5;
      if (radius <= 50) growing = true;
    }
    
    circle.setAttribute('r', radius);
    requestAnimationFrame(animate);
  }
  
  animate();
}
```

---

## 8.1.9 Transforms

### Transform Attribute

```xml
<!-- Translate -->
<rect transform="translate(50, 30)" ... />

<!-- Rotate -->
<rect transform="rotate(45)" ... />
<rect transform="rotate(45, 100, 100)" ... />  <!-- Around point -->

<!-- Scale -->
<rect transform="scale(2)" ... />
<rect transform="scale(2, 0.5)" ... />  <!-- Different x/y -->

<!-- Skew -->
<rect transform="skewX(30)" ... />
<rect transform="skewY(30)" ... />

<!-- Multiple transforms -->
<rect transform="translate(50, 50) rotate(45) scale(1.5)" ... />
```

### Transform via JavaScript

```javascript
// Apply transform
element.setAttribute('transform', 'translate(100, 50) rotate(45)');

// Using SVGTransform API
const svg = document.querySelector('svg');
const rect = document.querySelector('rect');

const transform = svg.createSVGTransform();
transform.setRotate(45, 100, 100);

rect.transform.baseVal.appendItem(transform);
```

---

## 8.1.10 viewBox and Coordinate System

### viewBox

```xml
<!-- viewBox: min-x, min-y, width, height -->
<svg width="200" height="200" viewBox="0 0 100 100">
  <!-- Coordinates 0-100 map to 0-200px -->
  <circle cx="50" cy="50" r="40" />
</svg>

<!-- Zoom in (smaller viewBox = zoomed) -->
<svg width="200" height="200" viewBox="25 25 50 50">
  <!-- Only see center portion, zoomed 2x -->
</svg>

<!-- Pan (offset viewBox) -->
<svg width="200" height="200" viewBox="50 0 100 100">
  <!-- Shifted right by 50 units -->
</svg>
```

### preserveAspectRatio

```xml
<!-- How to fit content when aspect ratios differ -->
<svg viewBox="0 0 100 50" preserveAspectRatio="xMidYMid meet">
  <!-- Default: center and fit inside -->
</svg>

<svg viewBox="0 0 100 50" preserveAspectRatio="xMidYMid slice">
  <!-- Fill container, crop excess -->
</svg>

<svg viewBox="0 0 100 50" preserveAspectRatio="none">
  <!-- Stretch to fill (distorts) -->
</svg>
```

---

## 8.1.11 Summary

### Basic Shapes

| Shape | Key Attributes |
|-------|----------------|
| `<rect>` | x, y, width, height, rx, ry |
| `<circle>` | cx, cy, r |
| `<ellipse>` | cx, cy, rx, ry |
| `<line>` | x1, y1, x2, y2 |
| `<polygon>` | points |
| `<path>` | d (path commands) |

### Path Commands

| Command | Meaning |
|---------|---------|
| M/m | Move to |
| L/l | Line to |
| H/h | Horizontal line |
| V/v | Vertical line |
| C/c | Cubic Bezier |
| Q/q | Quadratic Bezier |
| A/a | Arc |
| Z | Close path |

### Filter Primitives

| Filter | Effect |
|--------|--------|
| `feGaussianBlur` | Blur |
| `feDropShadow` | Shadow |
| `feColorMatrix` | Color transform |
| `feMerge` | Combine results |

### Best Practices

1. **Use viewBox** for responsive SVGs
2. **Define reusable elements** in `<defs>`
3. **Optimize paths** with tools like SVGO
4. **Use CSS for styling** when possible
5. **Add accessibility** with title and desc
6. **Use symbols** for icon systems

---

**End of Chapter 8.1: SVG**

Next chapter: **8.2 Web Animations API** — covers JavaScript-based animations.
# 8.2 Web Animations API

The Web Animations API provides programmatic control over animations, unifying CSS Animations, CSS Transitions, and JavaScript-based animations under a single API.

---

## 8.2.1 Basic Animation

### element.animate()

```javascript
const element = document.getElementById('box');

// Simple animation
const animation = element.animate([
  { transform: 'translateX(0px)' },
  { transform: 'translateX(300px)' }
], {
  duration: 1000,
  iterations: 1
});
```

### Multiple Properties

```javascript
element.animate([
  { 
    transform: 'scale(1)',
    opacity: 1,
    backgroundColor: 'blue'
  },
  { 
    transform: 'scale(1.5)',
    opacity: 0.5,
    backgroundColor: 'red'
  }
], {
  duration: 500,
  fill: 'forwards'
});
```

---

## 8.2.2 Keyframes

### Array Format

```javascript
// Array of keyframes (auto-distributed)
const keyframes = [
  { transform: 'rotate(0deg)', opacity: 1 },
  { transform: 'rotate(180deg)', opacity: 0.5 },
  { transform: 'rotate(360deg)', opacity: 1 }
];

element.animate(keyframes, 2000);
```

### With Offsets

```javascript
// Control timing with offset (0-1)
const keyframes = [
  { transform: 'translateX(0)', offset: 0 },
  { transform: 'translateX(100px)', offset: 0.3 },
  { transform: 'translateX(200px)', offset: 0.8 },
  { transform: 'translateX(300px)', offset: 1 }
];

element.animate(keyframes, 2000);
```

### Object Format

```javascript
// Object format with arrays per property
const keyframes = {
  transform: ['translateX(0)', 'translateX(100px)', 'translateX(0)'],
  opacity: [1, 0.5, 1],
  offset: [0, 0.7, 1]  // Optional timing
};

element.animate(keyframes, 1000);
```

### Computed Keyframes

```javascript
// Use null to compute from current style
element.style.transform = 'translateX(50px)';

element.animate([
  { transform: null },  // Computed: translateX(50px)
  { transform: 'translateX(200px)' }
], 1000);
```

---

## 8.2.3 Animation Options

### All Options

```javascript
element.animate(keyframes, {
  // Timing
  duration: 1000,              // milliseconds
  delay: 200,                  // start delay
  endDelay: 100,               // delay after animation
  
  // Iteration
  iterations: 3,               // number or Infinity
  iterationStart: 0.5,         // start midway through
  
  // Direction
  direction: 'normal',         // normal | reverse | alternate | alternate-reverse
  
  // Easing
  easing: 'ease-in-out',       // CSS easing or cubic-bezier
  
  // Fill mode
  fill: 'forwards',            // none | forwards | backwards | both
  
  // Composite
  composite: 'replace',        // replace | add | accumulate
  
  // ID for debugging
  id: 'my-animation'
});
```

### Easing Functions

```javascript
// Built-in
element.animate(keyframes, { easing: 'linear' });
element.animate(keyframes, { easing: 'ease' });
element.animate(keyframes, { easing: 'ease-in' });
element.animate(keyframes, { easing: 'ease-out' });
element.animate(keyframes, { easing: 'ease-in-out' });

// Cubic bezier
element.animate(keyframes, { easing: 'cubic-bezier(0.42, 0, 0.58, 1)' });

// Steps
element.animate(keyframes, { easing: 'steps(5, end)' });

// Per-keyframe easing
const keyframes = [
  { transform: 'translateX(0)', easing: 'ease-in' },
  { transform: 'translateX(100px)', easing: 'ease-out' },
  { transform: 'translateX(200px)' }
];
```

---

## 8.2.4 Animation Object

### Properties

```javascript
const animation = element.animate(keyframes, options);

// Read-only properties
console.log(animation.id);              // Animation ID
console.log(animation.playState);       // 'idle' | 'running' | 'paused' | 'finished'
console.log(animation.pending);         // true if pending play/pause
console.log(animation.ready);           // Promise resolved when ready
console.log(animation.finished);        // Promise resolved when finished

// Writable properties
animation.currentTime = 500;            // Current position (ms)
animation.playbackRate = 2;             // Speed multiplier
animation.startTime = 1000;             // Sync with timeline
```

### Methods

```javascript
const animation = element.animate(keyframes, options);

// Playback control
animation.play();       // Start/resume
animation.pause();      // Pause
animation.finish();     // Jump to end
animation.cancel();     // Stop and reset
animation.reverse();    // Reverse direction

// Update timing
animation.updatePlaybackRate(0.5);  // Smooth rate change

// Persist
animation.persist();    // Keep finished animation (replaces fill: forwards)

// Commit
animation.commitStyles();  // Apply current styles to element
```

---

## 8.2.5 Playback Control

### Play, Pause, Resume

```javascript
const animation = element.animate(keyframes, { duration: 2000 });

// Pause
pauseButton.onclick = () => animation.pause();

// Resume
playButton.onclick = () => animation.play();

// Check state
console.log(animation.playState);  // 'running', 'paused', etc.
```

### Speed Control

```javascript
// Slow motion
animation.playbackRate = 0.5;

// Fast forward
animation.playbackRate = 2;

// Reverse
animation.playbackRate = -1;

// Smooth rate change
animation.updatePlaybackRate(2);
```

### Seeking

```javascript
// Jump to specific time
animation.currentTime = 1000;  // Jump to 1 second

// Jump to percentage
animation.currentTime = animation.effect.getTiming().duration * 0.5;

// Scrubbing (paused seeking)
animation.pause();
slider.oninput = (e) => {
  animation.currentTime = e.target.value;
};
```

---

## 8.2.6 Animation Events

### Promise-Based Events

```javascript
const animation = element.animate(keyframes, options);

// When animation is ready to play
animation.ready.then(() => {
  console.log('Animation ready');
});

// When animation finishes
animation.finished.then(() => {
  console.log('Animation finished');
}).catch(() => {
  console.log('Animation cancelled');
});
```

### Event Listeners

```javascript
animation.addEventListener('finish', () => {
  console.log('Animation finished');
});

animation.addEventListener('cancel', () => {
  console.log('Animation cancelled');
});

animation.addEventListener('remove', () => {
  console.log('Animation removed');
});

// Using onfinish
animation.onfinish = () => {
  console.log('Finished');
};

animation.oncancel = () => {
  console.log('Cancelled');
};
```

---

## 8.2.7 KeyframeEffect

### Creating KeyframeEffect

```javascript
// Create effect separately from animation
const effect = new KeyframeEffect(
  element,
  keyframes,
  options
);

// Create animation from effect
const animation = new Animation(effect, document.timeline);
animation.play();
```

### Modifying Effect

```javascript
const animation = element.animate(keyframes, options);

// Access the effect
const effect = animation.effect;

// Get timing
const timing = effect.getTiming();
console.log(timing.duration);
console.log(timing.iterations);

// Update timing
effect.updateTiming({ duration: 2000 });

// Get computed timing
const computed = effect.getComputedTiming();
console.log(computed.progress);       // 0-1 progress
console.log(computed.currentIteration);

// Get keyframes
const frames = effect.getKeyframes();

// Set new keyframes
effect.setKeyframes([
  { opacity: 1 },
  { opacity: 0 }
]);
```

### Retargeting Animation

```javascript
// Change target element
const newElement = document.getElementById('other');
const effect = animation.effect;

const newEffect = new KeyframeEffect(
  newElement,
  effect.getKeyframes(),
  effect.getTiming()
);

animation.effect = newEffect;
```

---

## 8.2.8 Document.getAnimations()

### Get All Animations

```javascript
// All animations on document
const allAnimations = document.getAnimations();

// Animations on specific element
const elementAnimations = element.getAnimations();

// Include CSS animations
const animations = element.getAnimations({ subtree: true });
```

### Controlling Multiple Animations

```javascript
// Pause all
document.getAnimations().forEach(animation => {
  animation.pause();
});

// Resume all
document.getAnimations().forEach(animation => {
  animation.play();
});

// Speed up all
document.getAnimations().forEach(animation => {
  animation.playbackRate = 2;
});
```

---

## 8.2.9 Composite Modes

### Replace (Default)

```javascript
// Each animation replaces previous values
element.animate([{ transform: 'translateX(100px)' }], {
  duration: 1000,
  composite: 'replace'  // Default
});
```

### Add

```javascript
// Animations combine
element.animate([{ transform: 'translateX(100px)' }], {
  duration: 1000,
  composite: 'add'
});

// Second animation adds to first
element.animate([{ transform: 'translateY(50px)' }], {
  duration: 1000,
  composite: 'add'
});

// Result: translateX(100px) + translateY(50px)
```

### Accumulate

```javascript
// Values accumulate across iterations
element.animate([
  { transform: 'translateX(0)' },
  { transform: 'translateX(100px)' }
], {
  duration: 500,
  iterations: 3,
  iterationComposite: 'accumulate'
});

// Each iteration adds 100px more
```

---

## 8.2.10 Common Patterns

### Fade In/Out

```javascript
function fadeIn(element, duration = 300) {
  return element.animate([
    { opacity: 0 },
    { opacity: 1 }
  ], {
    duration,
    fill: 'forwards'
  }).finished;
}

function fadeOut(element, duration = 300) {
  return element.animate([
    { opacity: 1 },
    { opacity: 0 }
  ], {
    duration,
    fill: 'forwards'
  }).finished;
}

// Usage with await
await fadeOut(element);
element.remove();
```

### Slide Animation

```javascript
function slideIn(element, direction = 'left') {
  const from = {
    left: 'translateX(-100%)',
    right: 'translateX(100%)',
    up: 'translateY(-100%)',
    down: 'translateY(100%)'
  }[direction];
  
  return element.animate([
    { transform: from, opacity: 0 },
    { transform: 'translate(0)', opacity: 1 }
  ], {
    duration: 300,
    easing: 'ease-out',
    fill: 'forwards'
  });
}
```

### Bounce Effect

```javascript
function bounce(element) {
  return element.animate([
    { transform: 'scale(1)' },
    { transform: 'scale(1.2)', offset: 0.3 },
    { transform: 'scale(0.9)', offset: 0.5 },
    { transform: 'scale(1.05)', offset: 0.7 },
    { transform: 'scale(1)' }
  ], {
    duration: 500,
    easing: 'ease-out'
  });
}
```

### Shake Effect

```javascript
function shake(element) {
  return element.animate([
    { transform: 'translateX(0)' },
    { transform: 'translateX(-10px)' },
    { transform: 'translateX(10px)' },
    { transform: 'translateX(-10px)' },
    { transform: 'translateX(10px)' },
    { transform: 'translateX(0)' }
  ], {
    duration: 500,
    easing: 'ease-in-out'
  });
}
```

### Staggered Animation

```javascript
function staggeredFadeIn(elements, stagger = 100) {
  return elements.map((element, index) => {
    return element.animate([
      { opacity: 0, transform: 'translateY(20px)' },
      { opacity: 1, transform: 'translateY(0)' }
    ], {
      duration: 300,
      delay: index * stagger,
      fill: 'forwards',
      easing: 'ease-out'
    });
  });
}

// Usage
const items = document.querySelectorAll('.item');
staggeredFadeIn([...items], 50);
```

---

## 8.2.11 Summary

### Animation Methods

| Method | Description |
|--------|-------------|
| `element.animate()` | Create animation |
| `animation.play()` | Start/resume |
| `animation.pause()` | Pause |
| `animation.cancel()` | Stop and reset |
| `animation.finish()` | Jump to end |
| `animation.reverse()` | Reverse direction |

### Animation Properties

| Property | Description |
|----------|-------------|
| `playState` | Current state |
| `currentTime` | Position in ms |
| `playbackRate` | Speed multiplier |
| `ready` | Ready promise |
| `finished` | Finished promise |

### Animation Options

| Option | Description |
|--------|-------------|
| `duration` | Length in ms |
| `delay` | Start delay |
| `iterations` | Repeat count |
| `direction` | Play direction |
| `easing` | Timing function |
| `fill` | Before/after behavior |

### Best Practices

1. **Use promises** for sequencing
2. **Clean up animations** to prevent memory leaks
3. **Use `will-change`** for performance hints
4. **Prefer transform/opacity** for smooth animations
5. **Consider reduced motion** preferences
6. **Use composite modes** for layered effects

---

**End of Chapter 8.2: Web Animations API**

This completes the Graphics and Visualization group. Next section: **Group 09 — Web Workers** — covers background thread APIs.
# 9.1 Dedicated Workers

Dedicated Workers run scripts in background threads, enabling parallel computation without blocking the main thread. This chapter covers worker creation, communication, and best practices.

---

## 9.1.1 Web Workers Overview

### What Are Web Workers?

```javascript
// Web Workers run JavaScript in background threads
// - Don't block the UI
// - No access to DOM
// - Communicate via messages
// - Separate global scope (WorkerGlobalScope)

// Use cases:
// - Heavy computation
// - Data processing
// - Image manipulation
// - Parsing large files
// - Cryptographic operations
```

### Browser Support

```javascript
if (typeof Worker !== 'undefined') {
  console.log('Web Workers supported');
} else {
  console.log('Web Workers not supported');
}
```

---

## 9.1.2 Creating Workers

### From Separate File

```javascript
// main.js
const worker = new Worker('worker.js');
```

```javascript
// worker.js
console.log('Worker started');
```

### Inline Worker (Blob URL)

```javascript
// Create worker from inline code
const workerCode = `
  self.onmessage = (e) => {
    const result = e.data * 2;
    self.postMessage(result);
  };
`;

const blob = new Blob([workerCode], { type: 'application/javascript' });
const worker = new Worker(URL.createObjectURL(blob));
```

### Module Workers

```javascript
// ES modules in workers (modern browsers)
const worker = new Worker('worker.js', { type: 'module' });
```

```javascript
// worker.js (module)
import { processData } from './utils.js';

self.onmessage = (e) => {
  const result = processData(e.data);
  self.postMessage(result);
};
```

---

## 9.1.3 Communication

### postMessage and onmessage

```javascript
// main.js
const worker = new Worker('worker.js');

// Send data to worker
worker.postMessage({ task: 'process', data: [1, 2, 3, 4, 5] });

// Receive messages from worker
worker.onmessage = (event) => {
  console.log('Result:', event.data);
};

// Handle errors
worker.onerror = (error) => {
  console.error('Worker error:', error.message);
};
```

```javascript
// worker.js
self.onmessage = (event) => {
  const { task, data } = event.data;
  
  if (task === 'process') {
    const result = data.map(x => x * 2);
    self.postMessage(result);
  }
};
```

### Message Events

```javascript
// Using addEventListener
worker.addEventListener('message', (event) => {
  console.log('Received:', event.data);
});

worker.addEventListener('error', (event) => {
  console.error('Error:', event.message);
  console.error('File:', event.filename);
  console.error('Line:', event.lineno);
});

worker.addEventListener('messageerror', (event) => {
  console.error('Message deserialization failed');
});
```

### Structured Clone

```javascript
// Data is copied via structured clone algorithm
// Supported types:
// - Primitives (strings, numbers, booleans)
// - Arrays and objects
// - ArrayBuffer, TypedArrays
// - Map, Set
// - Date, RegExp
// - Blob, File, FileList
// - ImageData

// NOT supported:
// - Functions
// - DOM elements
// - Error objects (in some browsers)
// - Symbols

// Example
worker.postMessage({
  name: 'Task 1',
  data: new Float32Array([1.0, 2.0, 3.0]),
  timestamp: new Date(),
  metadata: new Map([['key', 'value']])
});
```

---

## 9.1.4 Transferable Objects

### Transfer vs Copy

```javascript
// Create large buffer
const buffer = new ArrayBuffer(1024 * 1024 * 100);  // 100MB

// COPY (slow, doubles memory)
worker.postMessage({ buffer });

// TRANSFER (instant, moves ownership)
worker.postMessage({ buffer }, [buffer]);
// buffer.byteLength is now 0 in main thread
```

### Transferable Types

```javascript
// ArrayBuffer
const arrayBuffer = new ArrayBuffer(1024);
worker.postMessage(arrayBuffer, [arrayBuffer]);

// MessagePort
const channel = new MessageChannel();
worker.postMessage({ port: channel.port2 }, [channel.port2]);

// ImageBitmap
const imageBitmap = await createImageBitmap(imageElement);
worker.postMessage(imageBitmap, [imageBitmap]);

// OffscreenCanvas
const offscreen = canvas.transferControlToOffscreen();
worker.postMessage({ canvas: offscreen }, [offscreen]);

// ReadableStream / WritableStream (some browsers)
const stream = new ReadableStream({ /* ... */ });
worker.postMessage(stream, [stream]);
```

### Transfer Example

```javascript
// main.js
const buffer = new ArrayBuffer(1024 * 1024);
const view = new Uint8Array(buffer);

// Fill with data
for (let i = 0; i < view.length; i++) {
  view[i] = i % 256;
}

console.log('Before transfer:', buffer.byteLength);  // 1048576

worker.postMessage(buffer, [buffer]);

console.log('After transfer:', buffer.byteLength);   // 0 (neutered)
```

```javascript
// worker.js
self.onmessage = (event) => {
  const buffer = event.data;
  console.log('Received:', buffer.byteLength);  // 1048576
  
  // Process and transfer back
  const result = processBuffer(buffer);
  self.postMessage(result, [result]);
};
```

---

## 9.1.5 Worker Scope

### Available APIs in Workers

```javascript
// Available in workers
self                    // Worker global scope
postMessage()           // Send to main thread
close()                 // Terminate worker
importScripts()         // Load external scripts
fetch()                 // Network requests
setTimeout/setInterval  // Timers
IndexedDB              // Database
WebSockets             // Real-time communication
XMLHttpRequest         // HTTP requests
console                // Debugging
navigator              // Browser info (partial)
location               // URL info

// NOT available
document               // No DOM access
window                 // No window object
localStorage           // Use IndexedDB instead
alert/confirm/prompt   // No UI dialogs
```

### importScripts

```javascript
// worker.js
// Synchronous script loading
importScripts('helper.js');
importScripts('lib1.js', 'lib2.js');

// All scripts loaded before continuing
console.log('Scripts loaded');
```

### Worker Self Reference

```javascript
// worker.js
// 'self' is the global scope
self.onmessage = (e) => { /* ... */ };

// Or use global directly
onmessage = (e) => { /* ... */ };

// They're the same
console.log(self === this);  // true (at top level)
```

---

## 9.1.6 Terminating Workers

### From Main Thread

```javascript
const worker = new Worker('worker.js');

// Terminate immediately
worker.terminate();

// Worker is stopped, cannot be restarted
```

### From Worker

```javascript
// worker.js
self.onmessage = (event) => {
  if (event.data === 'shutdown') {
    // Clean up
    cleanup();
    
    // Terminate self
    self.close();
  }
};
```

### Cleanup Pattern

```javascript
// main.js
class WorkerManager {
  constructor(scriptUrl) {
    this.worker = new Worker(scriptUrl);
    this.pending = new Map();
    this.nextId = 0;
    
    this.worker.onmessage = (e) => {
      const { id, result, error } = e.data;
      const { resolve, reject } = this.pending.get(id);
      this.pending.delete(id);
      
      if (error) reject(new Error(error));
      else resolve(result);
    };
  }
  
  execute(task, data) {
    return new Promise((resolve, reject) => {
      const id = this.nextId++;
      this.pending.set(id, { resolve, reject });
      this.worker.postMessage({ id, task, data });
    });
  }
  
  terminate() {
    this.worker.terminate();
    // Reject pending promises
    for (const [id, { reject }] of this.pending) {
      reject(new Error('Worker terminated'));
    }
    this.pending.clear();
  }
}
```

---

## 9.1.7 Error Handling

### Worker Errors

```javascript
// main.js
worker.onerror = (event) => {
  console.error('Error in worker:');
  console.error('Message:', event.message);
  console.error('Filename:', event.filename);
  console.error('Line:', event.lineno);
  console.error('Column:', event.colno);
  
  // Prevent default error handling
  event.preventDefault();
};
```

### Error from Worker

```javascript
// worker.js
self.onmessage = (event) => {
  try {
    const result = riskyOperation(event.data);
    self.postMessage({ success: true, result });
  } catch (error) {
    self.postMessage({ 
      success: false, 
      error: error.message 
    });
  }
};
```

### Unhandled Rejection

```javascript
// worker.js
self.addEventListener('unhandledrejection', (event) => {
  console.error('Unhandled rejection:', event.reason);
  self.postMessage({ 
    type: 'error', 
    error: event.reason.message 
  });
});
```

---

## 9.1.8 Practical Example

### CPU-Intensive Task

```javascript
// main.js
const worker = new Worker('fibonacci-worker.js');

document.getElementById('calculate').onclick = () => {
  const n = parseInt(document.getElementById('input').value);
  
  // Won't block UI
  worker.postMessage(n);
  document.getElementById('status').textContent = 'Calculating...';
};

worker.onmessage = (event) => {
  document.getElementById('result').textContent = event.data;
  document.getElementById('status').textContent = 'Done!';
};
```

```javascript
// fibonacci-worker.js
function fibonacci(n) {
  if (n <= 1) return n;
  return fibonacci(n - 1) + fibonacci(n - 2);
}

self.onmessage = (event) => {
  const n = event.data;
  const result = fibonacci(n);
  self.postMessage(result);
};
```

### Image Processing

```javascript
// main.js
const worker = new Worker('image-worker.js');

async function processImage(canvas) {
  const ctx = canvas.getContext('2d');
  const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
  
  worker.postMessage({
    imageData: imageData.data.buffer,
    width: canvas.width,
    height: canvas.height
  }, [imageData.data.buffer]);
}

worker.onmessage = (event) => {
  const { processedData, width, height } = event.data;
  const imageData = new ImageData(
    new Uint8ClampedArray(processedData),
    width,
    height
  );
  ctx.putImageData(imageData, 0, 0);
};
```

```javascript
// image-worker.js
self.onmessage = (event) => {
  const { imageData, width, height } = event.data;
  const data = new Uint8ClampedArray(imageData);
  
  // Apply grayscale filter
  for (let i = 0; i < data.length; i += 4) {
    const avg = (data[i] + data[i + 1] + data[i + 2]) / 3;
    data[i] = avg;     // Red
    data[i + 1] = avg; // Green
    data[i + 2] = avg; // Blue
    // Alpha unchanged
  }
  
  self.postMessage({
    processedData: data.buffer,
    width,
    height
  }, [data.buffer]);
};
```

---

## 9.1.9 Summary

### Worker Creation

| Method | Use Case |
|--------|----------|
| `new Worker('file.js')` | Separate file |
| `new Worker(blobUrl)` | Inline code |
| `{ type: 'module' }` | ES modules |

### Communication

| Method | Direction |
|--------|-----------|
| `worker.postMessage()` | Main → Worker |
| `self.postMessage()` | Worker → Main |
| `worker.onmessage` | Receive in main |
| `self.onmessage` | Receive in worker |

### Transferable Objects

| Type | Purpose |
|------|---------|
| `ArrayBuffer` | Binary data |
| `MessagePort` | Communication channels |
| `ImageBitmap` | Processed images |
| `OffscreenCanvas` | Graphics rendering |

### Best Practices

1. **Transfer large data** instead of copying
2. **Use message pooling** for frequent communication
3. **Handle errors** in both threads
4. **Terminate unused workers** to free resources
5. **Use worker pools** for multiple tasks
6. **Keep messages small** and serializable

---

**End of Chapter 9.1: Dedicated Workers**

Next chapter: **9.2 Shared Workers** — covers workers shared between multiple windows.
# 9.2 Shared Workers

Shared Workers are background threads shared across multiple browsing contexts (tabs, windows, iframes). This chapter covers creating shared workers, port-based communication, and connection management.

---

## 9.2.1 Shared Workers Overview

### What Are Shared Workers?

```javascript
// Shared Workers:
// - Single worker shared by multiple pages
// - Same-origin tabs/windows can connect
// - Communication via MessagePorts
// - Persist until all connections close
// - Useful for shared state and coordination

// Use cases:
// - Shared WebSocket connection
// - Coordinated data caching
// - Cross-tab communication
// - Shared authentication state
```

### Browser Support

```javascript
if (typeof SharedWorker !== 'undefined') {
  console.log('Shared Workers supported');
} else {
  console.log('Shared Workers not supported');
}
```

---

## 9.2.2 Creating Shared Workers

### Basic Creation

```javascript
// main.js (multiple pages can use this)
const worker = new SharedWorker('shared-worker.js');

// Access the port for communication
const port = worker.port;

// Start the port
port.start();
```

```javascript
// shared-worker.js
self.onconnect = (event) => {
  const port = event.ports[0];
  
  port.onmessage = (e) => {
    port.postMessage('Received: ' + e.data);
  };
  
  port.start();
};
```

### Named Shared Workers

```javascript
// Different names = different workers
const worker1 = new SharedWorker('worker.js', 'worker-a');
const worker2 = new SharedWorker('worker.js', 'worker-b');

// Same name and URL = same worker
const worker3 = new SharedWorker('worker.js', 'worker-a');
// worker1 and worker3 share the same worker
```

---

## 9.2.3 Port Communication

### Basic Port Usage

```javascript
// main.js
const worker = new SharedWorker('shared-worker.js');
const port = worker.port;

// Send message
port.postMessage({ type: 'greeting', text: 'Hello' });

// Receive messages
port.onmessage = (event) => {
  console.log('Received:', event.data);
};

// Or with addEventListener
port.addEventListener('message', (event) => {
  console.log('Received:', event.data);
});

// Must call start() when using addEventListener
port.start();
```

### Worker Side

```javascript
// shared-worker.js
const connections = [];

self.onconnect = (event) => {
  const port = event.ports[0];
  connections.push(port);
  
  port.onmessage = (e) => {
    handleMessage(port, e.data);
  };
  
  port.start();
  
  // Send welcome message
  port.postMessage({ type: 'connected', count: connections.length });
};

function handleMessage(senderPort, message) {
  switch (message.type) {
    case 'broadcast':
      // Send to all connected ports
      connections.forEach(port => {
        port.postMessage(message.data);
      });
      break;
      
    case 'request':
      // Reply to sender only
      senderPort.postMessage({ type: 'response', data: 'result' });
      break;
  }
}
```

---

## 9.2.4 Managing Connections

### Track Connected Ports

```javascript
// shared-worker.js
const ports = new Set();

self.onconnect = (event) => {
  const port = event.ports[0];
  ports.add(port);
  
  console.log(`New connection. Total: ${ports.size}`);
  
  port.onmessage = (e) => {
    handleMessage(port, e.data);
  };
  
  // Handle disconnection (close detection is tricky)
  port.onmessageerror = () => {
    ports.delete(port);
  };
  
  port.start();
};

// Broadcast to all
function broadcast(message) {
  ports.forEach(port => {
    try {
      port.postMessage(message);
    } catch (e) {
      // Port might be closed
      ports.delete(port);
    }
  });
}
```

### Connection ID Pattern

```javascript
// shared-worker.js
let nextId = 1;
const connections = new Map();

self.onconnect = (event) => {
  const port = event.ports[0];
  const id = nextId++;
  
  connections.set(id, { port, data: {} });
  
  port.onmessage = (e) => {
    handleMessage(id, e.data);
  };
  
  port.postMessage({ type: 'welcome', id });
  port.start();
};

function handleMessage(id, message) {
  const connection = connections.get(id);
  
  if (message.type === 'setName') {
    connection.data.name = message.name;
  }
  
  if (message.type === 'getUsers') {
    const users = Array.from(connections.values())
      .map(c => c.data.name)
      .filter(Boolean);
    connection.port.postMessage({ type: 'users', users });
  }
}
```

---

## 9.2.5 Cross-Tab Communication

### Broadcasting Messages

```javascript
// main.js
const worker = new SharedWorker('broadcast-worker.js');
const port = worker.port;

// Send message to all tabs
function broadcastMessage(message) {
  port.postMessage({ type: 'broadcast', message });
}

// Receive broadcasts
port.onmessage = (event) => {
  if (event.data.type === 'broadcast') {
    displayMessage(event.data.message);
  }
};

port.start();
```

```javascript
// broadcast-worker.js
const ports = [];

self.onconnect = (event) => {
  const port = event.ports[0];
  ports.push(port);
  
  port.onmessage = (e) => {
    if (e.data.type === 'broadcast') {
      // Send to all ports including sender
      ports.forEach(p => {
        p.postMessage({ type: 'broadcast', message: e.data.message });
      });
    }
  };
  
  port.start();
};
```

### Tab Synchronization

```javascript
// shared-worker.js
let sharedState = {
  user: null,
  theme: 'light',
  notifications: []
};

self.onconnect = (event) => {
  const port = event.ports[0];
  
  // Send current state to new connection
  port.postMessage({ type: 'sync', state: sharedState });
  
  port.onmessage = (e) => {
    if (e.data.type === 'update') {
      // Update shared state
      sharedState = { ...sharedState, ...e.data.changes };
      
      // Notify all connections
      broadcast({ type: 'sync', state: sharedState });
    }
  };
  
  port.start();
};
```

---

## 9.2.6 Shared WebSocket

### Single WebSocket Connection

```javascript
// shared-worker.js
let socket = null;
const ports = [];

function initWebSocket() {
  socket = new WebSocket('wss://example.com/ws');
  
  socket.onmessage = (event) => {
    // Broadcast to all connected pages
    const data = JSON.parse(event.data);
    ports.forEach(port => {
      port.postMessage({ type: 'ws-message', data });
    });
  };
  
  socket.onclose = () => {
    socket = null;
    // Attempt reconnect
    setTimeout(initWebSocket, 5000);
  };
}

self.onconnect = (event) => {
  const port = event.ports[0];
  ports.push(port);
  
  // Initialize WebSocket on first connection
  if (!socket) {
    initWebSocket();
  }
  
  port.onmessage = (e) => {
    if (e.data.type === 'ws-send' && socket?.readyState === WebSocket.OPEN) {
      socket.send(JSON.stringify(e.data.data));
    }
  };
  
  port.start();
};
```

```javascript
// main.js
const worker = new SharedWorker('ws-worker.js');
const port = worker.port;

// Send via shared WebSocket
function send(data) {
  port.postMessage({ type: 'ws-send', data });
}

// Receive WebSocket messages
port.onmessage = (event) => {
  if (event.data.type === 'ws-message') {
    handleWebSocketMessage(event.data.data);
  }
};

port.start();
```

---

## 9.2.7 Debugging Shared Workers

### Chrome DevTools

```javascript
// Navigate to: chrome://inspect/#workers
// Click "inspect" on your shared worker

// In worker, add debugging
console.log('Shared worker started');
console.log('Connections:', ports.length);
```

### Logging Pattern

```javascript
// shared-worker.js
const DEBUG = true;

function log(...args) {
  if (DEBUG) {
    console.log('[SharedWorker]', ...args);
  }
}

self.onconnect = (event) => {
  log('New connection');
  const port = event.ports[0];
  
  port.onmessage = (e) => {
    log('Received:', e.data);
    // ...
  };
  
  port.start();
};
```

---

## 9.2.8 Error Handling

### Worker Errors

```javascript
// main.js
const worker = new SharedWorker('shared-worker.js');

worker.onerror = (error) => {
  console.error('Shared worker error:', error);
};

worker.port.onmessageerror = (error) => {
  console.error('Message error:', error);
};
```

### Error Broadcasting

```javascript
// shared-worker.js
self.onerror = (message, filename, lineno) => {
  // Notify all connections
  ports.forEach(port => {
    port.postMessage({
      type: 'error',
      message,
      filename,
      lineno
    });
  });
};
```

---

## 9.2.9 Summary

### Creating Shared Workers

| Syntax | Description |
|--------|-------------|
| `new SharedWorker(url)` | Create/connect to worker |
| `new SharedWorker(url, name)` | Named worker |
| `worker.port` | Communication port |

### Port Methods

| Method | Description |
|--------|-------------|
| `port.postMessage()` | Send message |
| `port.start()` | Start receiving |
| `port.close()` | Close port |

### Worker Events

| Event | Handler |
|-------|---------|
| `connect` | New connection |
| `message` | Message received |
| `error` | Error occurred |

### Best Practices

1. **Always call port.start()** when using addEventListener
2. **Track connections** for broadcasting
3. **Handle disconnections** gracefully
4. **Use named workers** to avoid conflicts
5. **Debug via chrome://inspect** for shared workers
6. **Consider fallback** for browsers without support

---

**End of Chapter 9.2: Shared Workers**

Next chapter: **9.3 Service Workers** — covers offline capability and caching.
# 9.3 Service Workers

Service Workers act as proxy servers between the browser and network, enabling offline functionality, background sync, and push notifications. This chapter covers registration, lifecycle, caching strategies, and advanced features.

---

## 9.3.1 Service Worker Overview

### What Are Service Workers?

```javascript
// Service Workers:
// - Run in background, separate from pages
// - Act as network proxy
// - Enable offline functionality
// - Support push notifications
// - Enable background sync
// - Cannot access DOM directly
// - Require HTTPS (except localhost)

// Use cases:
// - Offline-first applications
// - Caching and performance
// - Push notifications
// - Background data sync
// - Periodic background sync
```

### Check Support

```javascript
if ('serviceWorker' in navigator) {
  console.log('Service Workers supported');
}
```

---

## 9.3.2 Registration

### Basic Registration

```javascript
// main.js
if ('serviceWorker' in navigator) {
  window.addEventListener('load', async () => {
    try {
      const registration = await navigator.serviceWorker.register('/sw.js');
      console.log('SW registered:', registration.scope);
    } catch (error) {
      console.error('SW registration failed:', error);
    }
  });
}
```

### Registration Options

```javascript
navigator.serviceWorker.register('/sw.js', {
  scope: '/app/',           // Limit to /app/ path
  updateViaCache: 'none'    // Always fetch fresh SW
});
```

### Registration Object

```javascript
const registration = await navigator.serviceWorker.register('/sw.js');

// Properties
console.log(registration.scope);
console.log(registration.active);     // Active SW
console.log(registration.waiting);    // Waiting SW
console.log(registration.installing); // Installing SW

// Update manually
await registration.update();

// Unregister
await registration.unregister();
```

---

## 9.3.3 Lifecycle

### Lifecycle Events

```javascript
// sw.js
// 1. Install - first time or new version
self.addEventListener('install', (event) => {
  console.log('Installing...');
  
  event.waitUntil(
    caches.open('v1').then(cache => {
      return cache.addAll([
        '/',
        '/styles.css',
        '/app.js'
      ]);
    })
  );
});

// 2. Activate - when taking control
self.addEventListener('activate', (event) => {
  console.log('Activating...');
  
  event.waitUntil(
    // Clean old caches
    caches.keys().then(keys => {
      return Promise.all(
        keys.filter(key => key !== 'v1')
            .map(key => caches.delete(key))
      );
    })
  );
});

// 3. Fetch - intercept requests
self.addEventListener('fetch', (event) => {
  event.respondWith(
    caches.match(event.request)
      .then(response => response || fetch(event.request))
  );
});
```

### Skip Waiting

```javascript
// sw.js
self.addEventListener('install', (event) => {
  // Activate immediately
  self.skipWaiting();
});

self.addEventListener('activate', (event) => {
  // Take control of all pages immediately
  event.waitUntil(clients.claim());
});
```

### Update Flow

```javascript
// main.js
navigator.serviceWorker.register('/sw.js').then(registration => {
  // Check for updates
  registration.addEventListener('updatefound', () => {
    const newWorker = registration.installing;
    
    newWorker.addEventListener('statechange', () => {
      if (newWorker.state === 'installed') {
        if (navigator.serviceWorker.controller) {
          // New version available
          showUpdateNotification();
        }
      }
    });
  });
});

// Listen for controller change
navigator.serviceWorker.addEventListener('controllerchange', () => {
  // Page now controlled by new SW
  window.location.reload();
});
```

---

## 9.3.4 Fetch Interception

### Basic Fetch Handler

```javascript
// sw.js
self.addEventListener('fetch', (event) => {
  event.respondWith(
    handleFetch(event.request)
  );
});

async function handleFetch(request) {
  // Try cache first
  const cached = await caches.match(request);
  if (cached) return cached;
  
  // Then network
  return fetch(request);
}
```

### Request Information

```javascript
self.addEventListener('fetch', (event) => {
  const request = event.request;
  
  console.log('URL:', request.url);
  console.log('Method:', request.method);
  console.log('Mode:', request.mode);        // navigate, cors, no-cors
  console.log('Destination:', request.destination);  // document, image, script
  
  // Handle based on request type
  if (request.destination === 'image') {
    event.respondWith(handleImage(request));
  }
});
```

---

## 9.3.5 Caching Strategies

### Cache First (Cache Falling Back to Network)

```javascript
// Best for: static assets
self.addEventListener('fetch', (event) => {
  event.respondWith(
    caches.match(event.request)
      .then(cached => cached || fetch(event.request))
  );
});
```

### Network First (Network Falling Back to Cache)

```javascript
// Best for: frequently updated content
self.addEventListener('fetch', (event) => {
  event.respondWith(
    fetch(event.request)
      .catch(() => caches.match(event.request))
  );
});
```

### Stale While Revalidate

```javascript
// Best for: balance of freshness and speed
self.addEventListener('fetch', (event) => {
  event.respondWith(
    caches.open('dynamic').then(cache => {
      return cache.match(event.request).then(cached => {
        const fetchPromise = fetch(event.request).then(response => {
          cache.put(event.request, response.clone());
          return response;
        });
        
        return cached || fetchPromise;
      });
    })
  );
});
```

### Cache Only

```javascript
// Best for: offline-only resources
self.addEventListener('fetch', (event) => {
  event.respondWith(
    caches.match(event.request)
  );
});
```

### Network Only

```javascript
// Best for: non-cacheable requests
self.addEventListener('fetch', (event) => {
  event.respondWith(fetch(event.request));
});
```

---

## 9.3.6 Cache API

### Opening and Adding

```javascript
// Open cache
const cache = await caches.open('my-cache-v1');

// Add single item
await cache.add('/styles.css');

// Add multiple items
await cache.addAll([
  '/',
  '/app.js',
  '/styles.css',
  '/offline.html'
]);

// Put custom response
await cache.put('/api/data', new Response(JSON.stringify(data)));
```

### Matching and Retrieving

```javascript
// Match from specific cache
const cache = await caches.open('my-cache');
const response = await cache.match(request);

// Match from any cache
const response = await caches.match(request);

// Match options
const response = await cache.match(request, {
  ignoreSearch: true,    // Ignore query string
  ignoreMethod: true,    // Match any method
  ignoreVary: true       // Ignore Vary header
});
```

### Deleting

```javascript
// Delete item from cache
await cache.delete('/old-resource');

// Delete entire cache
await caches.delete('old-cache-v1');

// Delete old caches
const keys = await caches.keys();
await Promise.all(
  keys.filter(key => key !== 'current-cache')
      .map(key => caches.delete(key))
);
```

---

## 9.3.7 Clients API

### Get Connected Clients

```javascript
// sw.js
self.addEventListener('fetch', async (event) => {
  // Get all clients
  const clients = await self.clients.matchAll({
    type: 'window',
    includeUncontrolled: false
  });
  
  clients.forEach(client => {
    client.postMessage('Hello from SW!');
  });
});
```

### Open Window

```javascript
// sw.js (e.g., in notification click)
self.addEventListener('notificationclick', (event) => {
  event.waitUntil(
    clients.openWindow('/notifications')
  );
});
```

### Focus Window

```javascript
self.addEventListener('notificationclick', (event) => {
  event.waitUntil(
    clients.matchAll({ type: 'window' }).then(windowClients => {
      // Focus existing window or open new
      for (const client of windowClients) {
        if (client.url === '/' && 'focus' in client) {
          return client.focus();
        }
      }
      return clients.openWindow('/');
    })
  );
});
```

---

## 9.3.8 Push Notifications

### Subscribe to Push

```javascript
// main.js
async function subscribeToPush() {
  const registration = await navigator.serviceWorker.ready;
  
  const subscription = await registration.pushManager.subscribe({
    userVisibleOnly: true,
    applicationServerKey: urlBase64ToUint8Array(VAPID_PUBLIC_KEY)
  });
  
  // Send subscription to server
  await fetch('/api/push-subscribe', {
    method: 'POST',
    body: JSON.stringify(subscription)
  });
}
```

### Handle Push Event

```javascript
// sw.js
self.addEventListener('push', (event) => {
  const data = event.data?.json() ?? { title: 'Notification' };
  
  event.waitUntil(
    self.registration.showNotification(data.title, {
      body: data.body,
      icon: '/icon.png',
      badge: '/badge.png',
      data: data.url
    })
  );
});

self.addEventListener('notificationclick', (event) => {
  event.notification.close();
  
  event.waitUntil(
    clients.openWindow(event.notification.data)
  );
});
```

---

## 9.3.9 Background Sync

### Register Sync

```javascript
// main.js
async function syncData() {
  const registration = await navigator.serviceWorker.ready;
  
  try {
    await registration.sync.register('sync-data');
    console.log('Sync registered');
  } catch (error) {
    console.error('Sync registration failed');
  }
}
```

### Handle Sync Event

```javascript
// sw.js
self.addEventListener('sync', (event) => {
  if (event.tag === 'sync-data') {
    event.waitUntil(doBackgroundSync());
  }
});

async function doBackgroundSync() {
  // Get queued data from IndexedDB
  const pendingRequests = await getPendingRequests();
  
  for (const request of pendingRequests) {
    await fetch(request.url, request.options);
    await removePendingRequest(request.id);
  }
}
```

### Periodic Background Sync

```javascript
// main.js
const registration = await navigator.serviceWorker.ready;
await registration.periodicSync.register('update-content', {
  minInterval: 24 * 60 * 60 * 1000  // Once per day
});
```

```javascript
// sw.js
self.addEventListener('periodicsync', (event) => {
  if (event.tag === 'update-content') {
    event.waitUntil(updateContent());
  }
});
```

---

## 9.3.10 Complete Example

### Offline-First App

```javascript
// sw.js
const CACHE_NAME = 'app-v1';
const STATIC_ASSETS = [
  '/',
  '/index.html',
  '/styles.css',
  '/app.js',
  '/offline.html'
];

// Install: cache static assets
self.addEventListener('install', (event) => {
  event.waitUntil(
    caches.open(CACHE_NAME)
      .then(cache => cache.addAll(STATIC_ASSETS))
      .then(() => self.skipWaiting())
  );
});

// Activate: clean old caches
self.addEventListener('activate', (event) => {
  event.waitUntil(
    caches.keys().then(keys => {
      return Promise.all(
        keys.filter(key => key !== CACHE_NAME)
            .map(key => caches.delete(key))
      );
    }).then(() => self.clients.claim())
  );
});

// Fetch: serve from cache, fallback to network
self.addEventListener('fetch', (event) => {
  // Skip non-GET requests
  if (event.request.method !== 'GET') return;
  
  event.respondWith(
    caches.match(event.request)
      .then(cached => {
        if (cached) return cached;
        
        return fetch(event.request)
          .then(response => {
            // Cache successful responses
            if (response.ok) {
              const clone = response.clone();
              caches.open(CACHE_NAME)
                .then(cache => cache.put(event.request, clone));
            }
            return response;
          })
          .catch(() => {
            // Return offline page for navigation
            if (event.request.destination === 'document') {
              return caches.match('/offline.html');
            }
          });
      })
  );
});
```

---

## 9.3.11 Summary

### Lifecycle Events

| Event | When |
|-------|------|
| `install` | First install or update |
| `activate` | Taking control |
| `fetch` | Network request |

### Caching Strategies

| Strategy | Best For |
|----------|----------|
| Cache First | Static assets |
| Network First | Dynamic content |
| Stale While Revalidate | Balanced freshness |
| Cache Only | Offline resources |
| Network Only | Real-time data |

### Key Methods

| Method | Purpose |
|--------|---------|
| `skipWaiting()` | Activate immediately |
| `clients.claim()` | Control all pages |
| `event.waitUntil()` | Extend event lifetime |
| `event.respondWith()` | Provide response |

### Best Practices

1. **Version your caches** for clean updates
2. **Use skipWaiting carefully** — may break pages
3. **Handle offline gracefully** with fallback pages
4. **Clean old caches** on activate
5. **Test offline thoroughly**
6. **Use Workbox** for complex caching

---

**End of Chapter 9.3: Service Workers**

Next chapter: **9.4 Worklets** — covers specialized worker types.
# 9.4 Worklets

Worklets are lightweight, specialized workers for specific rendering and audio tasks. This chapter covers Audio Worklets, Paint Worklets, Animation Worklets, and Layout Worklets.

---

## 9.4.1 Worklets Overview

### What Are Worklets?

```javascript
// Worklets are specialized workers for:
// - Audio processing (Audio Worklet)
// - Custom CSS painting (Paint Worklet)
// - Custom animations (Animation Worklet)
// - Custom layout algorithms (Layout Worklet)

// Differences from Web Workers:
// - Render-thread access (most)
// - Specialized APIs
// - Lifecycle tied to rendering
// - Cannot use postMessage
// - Use class-based registration
```

### Worklet Types

| Worklet | Purpose | Thread |
|---------|---------|--------|
| AudioWorklet | Audio processing | Audio thread |
| PaintWorklet | Custom CSS painting | Main thread |
| AnimationWorklet | Scroll-linked animations | Compositor thread |
| LayoutWorklet | Custom layouts | Main thread |

---

## 9.4.2 Audio Worklet

### Overview

```javascript
// Audio Worklet replaces deprecated ScriptProcessorNode
// - Runs on dedicated audio thread
// - Low-latency audio processing
// - 128-sample block processing
```

### Registering Audio Worklet

```javascript
// main.js
const audioContext = new AudioContext();

// Load worklet module
await audioContext.audioWorklet.addModule('audio-processor.js');

// Create node
const processorNode = new AudioWorkletNode(audioContext, 'my-processor');

// Connect to audio graph
source.connect(processorNode);
processorNode.connect(audioContext.destination);
```

### Audio Processor

```javascript
// audio-processor.js
class MyProcessor extends AudioWorkletProcessor {
  constructor() {
    super();
    this.phase = 0;
  }
  
  process(inputs, outputs, parameters) {
    const output = outputs[0];
    const frequency = 440;
    const sampleRate = globalThis.sampleRate;
    
    for (let channel = 0; channel < output.length; channel++) {
      const outputChannel = output[channel];
      
      for (let i = 0; i < outputChannel.length; i++) {
        // Generate sine wave
        outputChannel[i] = Math.sin(this.phase);
        this.phase += (2 * Math.PI * frequency) / sampleRate;
      }
    }
    
    // Return true to keep processor alive
    return true;
  }
}

registerProcessor('my-processor', MyProcessor);
```

### Parameters

```javascript
// audio-processor.js
class GainProcessor extends AudioWorkletProcessor {
  static get parameterDescriptors() {
    return [{
      name: 'gain',
      defaultValue: 1,
      minValue: 0,
      maxValue: 1,
      automationRate: 'a-rate'  // or 'k-rate'
    }];
  }
  
  process(inputs, outputs, parameters) {
    const input = inputs[0];
    const output = outputs[0];
    const gain = parameters.gain;
    
    for (let channel = 0; channel < input.length; channel++) {
      for (let i = 0; i < input[channel].length; i++) {
        // Use per-sample gain if available
        const g = gain.length > 1 ? gain[i] : gain[0];
        output[channel][i] = input[channel][i] * g;
      }
    }
    
    return true;
  }
}

registerProcessor('gain-processor', GainProcessor);
```

### Communication

```javascript
// main.js
const node = new AudioWorkletNode(audioContext, 'my-processor');

// Send message to worklet
node.port.postMessage({ type: 'config', value: 42 });

// Receive from worklet
node.port.onmessage = (event) => {
  console.log('From worklet:', event.data);
};
```

```javascript
// audio-processor.js
class MyProcessor extends AudioWorkletProcessor {
  constructor() {
    super();
    
    this.port.onmessage = (event) => {
      console.log('From main:', event.data);
      // Handle configuration
    };
  }
  
  process(inputs, outputs, parameters) {
    // Send data back
    this.port.postMessage({ level: this.calculateLevel(inputs) });
    return true;
  }
}
```

---

## 9.4.3 Paint Worklet

### Overview

```javascript
// Paint Worklet enables custom CSS painting
// - Used with CSS paint() function
// - Runs on main thread
// - Access to canvas-like API
// - Triggered on paint
```

### Registering Paint Worklet

```javascript
// main.js
CSS.paintWorklet.addModule('paint-worklet.js');
```

### Paint Worklet Definition

```javascript
// paint-worklet.js
class CheckerboardPainter {
  static get inputProperties() {
    return ['--checker-size', '--checker-color'];
  }
  
  paint(ctx, size, properties) {
    const checkerSize = parseInt(properties.get('--checker-size')) || 16;
    const color = properties.get('--checker-color').toString() || 'black';
    
    ctx.fillStyle = color;
    
    for (let y = 0; y < size.height; y += checkerSize * 2) {
      for (let x = 0; x < size.width; x += checkerSize * 2) {
        ctx.fillRect(x, y, checkerSize, checkerSize);
        ctx.fillRect(x + checkerSize, y + checkerSize, checkerSize, checkerSize);
      }
    }
  }
}

registerPaint('checkerboard', CheckerboardPainter);
```

### Using in CSS

```css
.element {
  --checker-size: 20;
  --checker-color: blue;
  background-image: paint(checkerboard);
}
```

### Paint Context

```javascript
class MyPainter {
  paint(ctx, size, properties) {
    // ctx is similar to CanvasRenderingContext2D
    ctx.fillStyle = 'red';
    ctx.fillRect(0, 0, size.width, size.height);
    
    ctx.beginPath();
    ctx.arc(size.width / 2, size.height / 2, 50, 0, Math.PI * 2);
    ctx.fill();
    
    // size.width and size.height are element dimensions
  }
}
```

### Complex Example

```javascript
// ripple-worklet.js
class RipplePainter {
  static get inputProperties() {
    return ['--ripple-x', '--ripple-y', '--ripple-progress'];
  }
  
  paint(ctx, size, properties) {
    const x = parseFloat(properties.get('--ripple-x')) || 0;
    const y = parseFloat(properties.get('--ripple-y')) || 0;
    const progress = parseFloat(properties.get('--ripple-progress')) || 0;
    
    const maxRadius = Math.hypot(
      Math.max(x, size.width - x),
      Math.max(y, size.height - y)
    );
    
    const radius = maxRadius * progress;
    const alpha = 1 - progress;
    
    ctx.fillStyle = `rgba(255, 255, 255, ${alpha * 0.3})`;
    ctx.beginPath();
    ctx.arc(x, y, radius, 0, Math.PI * 2);
    ctx.fill();
  }
}

registerPaint('ripple', RipplePainter);
```

---

## 9.4.4 Animation Worklet

### Overview

```javascript
// Animation Worklet enables scroll-linked and
// high-performance animations
// - Runs on compositor thread
// - Avoids main thread jank
// - Scroll-driven animations
```

### Registering Animation Worklet

```javascript
// main.js
await CSS.animationWorklet.addModule('animation-worklet.js');
```

### Animation Definition

```javascript
// animation-worklet.js
class ScrollProgressAnimator {
  constructor(options) {
    this.rate = options.rate || 1;
  }
  
  animate(currentTime, effect) {
    // currentTime is scroll position (0-100%)
    effect.localTime = currentTime * this.rate;
  }
}

registerAnimator('scroll-progress', ScrollProgressAnimator);
```

### Using Animation Worklet

```javascript
// main.js
const element = document.querySelector('.animated');

// Create scroll timeline
const scrollTimeline = new ScrollTimeline({
  source: document.documentElement,
  orientation: 'vertical'
});

// Create animation
const animation = new WorkletAnimation(
  'scroll-progress',
  new KeyframeEffect(
    element,
    [
      { transform: 'translateX(0)' },
      { transform: 'translateX(500px)' }
    ],
    { duration: 1, fill: 'both' }
  ),
  scrollTimeline,
  { rate: 1 }
);

animation.play();
```

---

## 9.4.5 Layout Worklet

### Overview

```javascript
// Layout Worklet enables custom CSS layouts
// - Define your own display algorithms
// - Like creating a new display type
// - Experimental feature
```

### Registering Layout Worklet

```javascript
// main.js
CSS.layoutWorklet.addModule('layout-worklet.js');
```

### Layout Definition

```javascript
// layout-worklet.js
class MasonryLayout {
  static get inputProperties() {
    return ['--columns', '--gap'];
  }
  
  static get childInputProperties() {
    return [];
  }
  
  async intrinsicSizes(children, edges, styleMap) {
    // Return min/max content sizes
  }
  
  async layout(children, edges, constraints, styleMap) {
    const columns = parseInt(styleMap.get('--columns')) || 3;
    const gap = parseInt(styleMap.get('--gap')) || 10;
    
    const columnWidth = (constraints.fixedInlineSize - gap * (columns - 1)) / columns;
    const columnHeights = new Array(columns).fill(0);
    
    const childFragments = await Promise.all(children.map(async (child) => {
      const fragment = await child.layoutNextFragment({
        fixedInlineSize: columnWidth
      });
      
      // Find shortest column
      const column = columnHeights.indexOf(Math.min(...columnHeights));
      
      fragment.inlineOffset = column * (columnWidth + gap);
      fragment.blockOffset = columnHeights[column];
      
      columnHeights[column] += fragment.blockSize + gap;
      
      return fragment;
    }));
    
    return {
      childFragments,
      autoBlockSize: Math.max(...columnHeights)
    };
  }
}

registerLayout('masonry', MasonryLayout);
```

### Using in CSS

```css
.container {
  display: layout(masonry);
  --columns: 3;
  --gap: 16;
}
```

---

## 9.4.6 Comparison

### Feature Matrix

| Feature | Audio | Paint | Animation | Layout |
|---------|-------|-------|-----------|--------|
| Thread | Audio | Main | Compositor | Main |
| Canvas API | No | Yes | No | No |
| CSS Properties | No | Yes | No | Yes |
| Streaming | Yes | No | No | No |
| Browser Support | Good | Good | Limited | Limited |

### When to Use

```javascript
// Audio Worklet
// - Real-time audio effects
// - Audio synthesis
// - Audio analysis

// Paint Worklet
// - Custom backgrounds
// - Dynamic patterns
// - Animated backgrounds via CSS vars

// Animation Worklet
// - Scroll-linked animations
// - Parallax effects
// - Frame-perfect animations

// Layout Worklet
// - Custom layout algorithms
// - Masonry layouts
// - Complex grid systems
```

---

## 9.4.7 Summary

### Worklet Registration

| Type | Registration |
|------|--------------|
| Audio | `audioContext.audioWorklet.addModule()` |
| Paint | `CSS.paintWorklet.addModule()` |
| Animation | `CSS.animationWorklet.addModule()` |
| Layout | `CSS.layoutWorklet.addModule()` |

### Class Registration

| Type | Function |
|------|----------|
| Audio | `registerProcessor()` |
| Paint | `registerPaint()` |
| Animation | `registerAnimator()` |
| Layout | `registerLayout()` |

### Best Practices

1. **Check browser support** before using
2. **Keep worklet code lightweight**
3. **Use for performance-critical tasks**
4. **Provide fallbacks** for unsupported browsers
5. **Test across browsers**
6. **Consider polyfills** for Paint Worklet

---

**End of Chapter 9.4: Worklets**

This completes the Web Workers group. Next section: **Group 10 — Progressive Web Apps** — covers PWA features.
# 10.1 Web App Manifest

The Web App Manifest is a JSON file that defines how a Progressive Web App (PWA) appears when installed on a user's device. This chapter covers manifest structure, icons, display modes, and installation configuration.

---

## 10.1.1 Manifest Overview

### What Is a Web App Manifest?

```javascript
// The manifest.json file:
// - Defines app name, icons, colors
// - Controls how app appears when installed
// - Enables "Add to Home Screen"
// - Makes app installable
// - Provides native-like experience
```

### Basic Manifest

```json
{
  "name": "My Progressive Web App",
  "short_name": "MyPWA",
  "start_url": "/",
  "display": "standalone",
  "background_color": "#ffffff",
  "theme_color": "#3f51b5",
  "icons": [
    {
      "src": "/icons/icon-192.png",
      "sizes": "192x192",
      "type": "image/png"
    },
    {
      "src": "/icons/icon-512.png",
      "sizes": "512x512",
      "type": "image/png"
    }
  ]
}
```

### Linking Manifest

```html
<!DOCTYPE html>
<html>
<head>
  <!-- Link manifest in HTML head -->
  <link rel="manifest" href="/manifest.json">
  
  <!-- Also set theme color for browsers -->
  <meta name="theme-color" content="#3f51b5">
</head>
</html>
```

---

## 10.1.2 Core Properties

### Name Properties

```json
{
  "name": "My Progressive Web Application",
  "short_name": "MyPWA"
}
```

```javascript
// name: Full application name
// - Used on install prompts
// - Used on splash screens
// - Maximum ~45 characters recommended

// short_name: Abbreviated name
// - Used on home screen
// - Used where space is limited
// - Maximum ~12 characters recommended
```

### Start URL

```json
{
  "start_url": "/",
  "scope": "/"
}
```

```javascript
// start_url: URL opened when app launches
// - Can include query parameters for analytics
// - Example: "/?utm_source=homescreen"

// scope: Defines navigation scope
// - URLs outside scope open in browser
// - Defaults to start_url directory
```

### Description

```json
{
  "description": "A progressive web app for managing tasks efficiently.",
  "categories": ["productivity", "utilities"]
}
```

---

## 10.1.3 Icons

### Required Icons

```json
{
  "icons": [
    {
      "src": "/icons/icon-72.png",
      "sizes": "72x72",
      "type": "image/png"
    },
    {
      "src": "/icons/icon-96.png",
      "sizes": "96x96",
      "type": "image/png"
    },
    {
      "src": "/icons/icon-128.png",
      "sizes": "128x128",
      "type": "image/png"
    },
    {
      "src": "/icons/icon-144.png",
      "sizes": "144x144",
      "type": "image/png"
    },
    {
      "src": "/icons/icon-152.png",
      "sizes": "152x152",
      "type": "image/png"
    },
    {
      "src": "/icons/icon-192.png",
      "sizes": "192x192",
      "type": "image/png"
    },
    {
      "src": "/icons/icon-384.png",
      "sizes": "384x384",
      "type": "image/png"
    },
    {
      "src": "/icons/icon-512.png",
      "sizes": "512x512",
      "type": "image/png"
    }
  ]
}
```

### Maskable Icons

```json
{
  "icons": [
    {
      "src": "/icons/icon-maskable.png",
      "sizes": "512x512",
      "type": "image/png",
      "purpose": "maskable"
    },
    {
      "src": "/icons/icon-any.png",
      "sizes": "512x512",
      "type": "image/png",
      "purpose": "any"
    },
    {
      "src": "/icons/icon-both.png",
      "sizes": "512x512",
      "type": "image/png",
      "purpose": "any maskable"
    }
  ]
}
```

```javascript
// purpose values:
// - "any": Default, used anywhere
// - "maskable": Safe zone icon for adaptive icons
// - "monochrome": Single-color icon

// Maskable icons should have important content
// within the center 80% (safe zone)
```

### SVG Icons

```json
{
  "icons": [
    {
      "src": "/icons/icon.svg",
      "sizes": "any",
      "type": "image/svg+xml"
    }
  ]
}
```

---

## 10.1.4 Display Modes

### Available Modes

```json
{
  "display": "standalone"
}
```

| Mode | Description |
|------|-------------|
| `fullscreen` | No browser UI, fills entire screen |
| `standalone` | App-like window, no browser chrome |
| `minimal-ui` | Minimal navigation controls |
| `browser` | Standard browser tab |

### Display Mode Detection

```css
/* CSS media queries for display mode */
@media (display-mode: standalone) {
  /* Styles for installed PWA */
  .browser-only {
    display: none;
  }
}

@media (display-mode: browser) {
  /* Styles for browser tab */
  .install-prompt {
    display: block;
  }
}
```

```javascript
// JavaScript detection
function isInstalled() {
  return window.matchMedia('(display-mode: standalone)').matches ||
         window.navigator.standalone === true;  // iOS Safari
}
```

### Display Override

```json
{
  "display": "standalone",
  "display_override": ["window-controls-overlay", "standalone"]
}
```

---

## 10.1.5 Colors

### Theme and Background

```json
{
  "theme_color": "#3f51b5",
  "background_color": "#ffffff"
}
```

```javascript
// theme_color:
// - Browser toolbar color
// - Task switcher color
// - Status bar color

// background_color:
// - Splash screen background
// - Loading screen before CSS loads
// - Should match app background
```

### Dynamic Theme Color

```html
<!-- Can be changed per page -->
<meta name="theme-color" content="#3f51b5">

<!-- With media queries -->
<meta name="theme-color" media="(prefers-color-scheme: light)" content="#ffffff">
<meta name="theme-color" media="(prefers-color-scheme: dark)" content="#000000">
```

---

## 10.1.6 Orientation

### Screen Orientation

```json
{
  "orientation": "portrait"
}
```

| Value | Description |
|-------|-------------|
| `any` | Any orientation |
| `natural` | Natural for device |
| `portrait` | Portrait only |
| `portrait-primary` | Primary portrait |
| `portrait-secondary` | Upside-down portrait |
| `landscape` | Landscape only |
| `landscape-primary` | Primary landscape |
| `landscape-secondary` | Secondary landscape |

---

## 10.1.7 Shortcuts

### App Shortcuts

```json
{
  "shortcuts": [
    {
      "name": "New Task",
      "short_name": "New",
      "description": "Create a new task",
      "url": "/tasks/new",
      "icons": [
        {
          "src": "/icons/new-task.png",
          "sizes": "192x192"
        }
      ]
    },
    {
      "name": "Today's Tasks",
      "short_name": "Today",
      "description": "View today's tasks",
      "url": "/tasks/today",
      "icons": [
        {
          "src": "/icons/today.png",
          "sizes": "192x192"
        }
      ]
    }
  ]
}
```

```javascript
// Shortcuts appear on:
// - Long press on Android
// - Right-click on desktop
// - Jump lists on Windows
```

---

## 10.1.8 Screenshots

### App Screenshots

```json
{
  "screenshots": [
    {
      "src": "/screenshots/home.png",
      "sizes": "1280x720",
      "type": "image/png",
      "form_factor": "wide",
      "label": "Home screen showing task list"
    },
    {
      "src": "/screenshots/mobile.png",
      "sizes": "750x1334",
      "type": "image/png",
      "form_factor": "narrow",
      "label": "Mobile view of tasks"
    }
  ]
}
```

---

## 10.1.9 Related Applications

### Native App Links

```json
{
  "prefer_related_applications": false,
  "related_applications": [
    {
      "platform": "play",
      "url": "https://play.google.com/store/apps/details?id=com.example.app",
      "id": "com.example.app"
    },
    {
      "platform": "itunes",
      "url": "https://apps.apple.com/app/example-app/id123456789"
    }
  ]
}
```

---

## 10.1.10 Advanced Features

### Share Target

```json
{
  "share_target": {
    "action": "/share",
    "method": "POST",
    "enctype": "multipart/form-data",
    "params": {
      "title": "title",
      "text": "text",
      "url": "url",
      "files": [
        {
          "name": "media",
          "accept": ["image/*", "video/*"]
        }
      ]
    }
  }
}
```

### Protocol Handlers

```json
{
  "protocol_handlers": [
    {
      "protocol": "web+myapp",
      "url": "/open?url=%s"
    }
  ]
}
```

### File Handlers

```json
{
  "file_handlers": [
    {
      "action": "/open-file",
      "accept": {
        "text/plain": [".txt"],
        "application/json": [".json"]
      }
    }
  ]
}
```

---

## 10.1.11 Complete Example

### Full Manifest

```json
{
  "name": "Task Manager PWA",
  "short_name": "Tasks",
  "description": "A progressive web app for managing tasks",
  "start_url": "/?source=pwa",
  "scope": "/",
  "display": "standalone",
  "orientation": "any",
  "theme_color": "#6200ee",
  "background_color": "#ffffff",
  "lang": "en",
  "dir": "ltr",
  "icons": [
    {
      "src": "/icons/icon-192.png",
      "sizes": "192x192",
      "type": "image/png",
      "purpose": "any"
    },
    {
      "src": "/icons/icon-512.png",
      "sizes": "512x512",
      "type": "image/png",
      "purpose": "any"
    },
    {
      "src": "/icons/icon-maskable.png",
      "sizes": "512x512",
      "type": "image/png",
      "purpose": "maskable"
    }
  ],
  "shortcuts": [
    {
      "name": "New Task",
      "url": "/new",
      "icons": [{ "src": "/icons/new.png", "sizes": "192x192" }]
    }
  ],
  "screenshots": [
    {
      "src": "/screenshots/wide.png",
      "sizes": "1280x720",
      "form_factor": "wide"
    }
  ],
  "categories": ["productivity"]
}
```

---

## 10.1.12 Summary

### Required Fields

| Field | Purpose |
|-------|---------|
| `name` | App name |
| `icons` | App icons (192x192, 512x512 minimum) |
| `start_url` | Launch URL |
| `display` | Display mode |

### Recommended Fields

| Field | Purpose |
|-------|---------|
| `short_name` | Abbreviated name |
| `theme_color` | Browser chrome color |
| `background_color` | Splash screen background |
| `description` | App description |

### Best Practices

1. **Provide multiple icon sizes** for all devices
2. **Include maskable icons** for adaptive icon shapes
3. **Set theme_color** matching your app's brand
4. **Test on multiple devices** and browsers
5. **Validate manifest** using Chrome DevTools
6. **Use absolute URLs** when possible

---

**End of Chapter 10.1: Web App Manifest**

Next chapter: **10.2 Service Worker Strategies** — covers caching strategies for PWAs.
# 10.2 Service Worker Strategies

Service Worker caching strategies determine how your PWA handles network requests. This chapter covers various caching strategies, their implementation, and when to use each.

---

## 10.2.1 Caching Strategies Overview

### Available Strategies

```javascript
// Primary caching strategies:
// 1. Cache First (Cache Falling Back to Network)
// 2. Network First (Network Falling Back to Cache)
// 3. Stale While Revalidate
// 4. Cache Only
// 5. Network Only

// Strategy selection depends on:
// - Content type (static vs dynamic)
// - Freshness requirements
// - Offline support needs
// - Performance priorities
```

---

## 10.2.2 Cache First

### Implementation

```javascript
// sw.js
// Best for: static assets (CSS, JS, images, fonts)
self.addEventListener('fetch', (event) => {
  event.respondWith(
    caches.match(event.request).then((cached) => {
      // Return cached response if available
      if (cached) {
        return cached;
      }
      
      // Otherwise fetch from network
      return fetch(event.request).then((response) => {
        // Clone and cache new response
        if (response.ok) {
          const clone = response.clone();
          caches.open('cache-v1').then((cache) => {
            cache.put(event.request, clone);
          });
        }
        return response;
      });
    })
  );
});
```

### When to Use

```javascript
// ✅ Good for:
// - Versioned static assets
// - Fonts
// - Images that don't change
// - Third-party libraries

// ❌ Avoid for:
// - API responses
// - User-specific content
// - Time-sensitive data
```

---

## 10.2.3 Network First

### Implementation

```javascript
// sw.js
// Best for: frequently updated content
self.addEventListener('fetch', (event) => {
  event.respondWith(
    fetch(event.request)
      .then((response) => {
        // Cache successful response
        if (response.ok) {
          const clone = response.clone();
          caches.open('dynamic-cache').then((cache) => {
            cache.put(event.request, clone);
          });
        }
        return response;
      })
      .catch(() => {
        // Fallback to cache on network failure
        return caches.match(event.request);
      })
  );
});
```

### With Timeout

```javascript
// Network first with timeout
async function networkFirstWithTimeout(request, timeout = 3000) {
  const cache = await caches.open('dynamic-cache');
  
  try {
    // Race between network and timeout
    const response = await Promise.race([
      fetch(request),
      new Promise((_, reject) => 
        setTimeout(() => reject(new Error('timeout')), timeout)
      )
    ]);
    
    // Cache successful response
    if (response.ok) {
      cache.put(request, response.clone());
    }
    
    return response;
  } catch (error) {
    // Fallback to cache
    const cached = await cache.match(request);
    return cached || new Response('Offline', { status: 503 });
  }
}
```

### When to Use

```javascript
// ✅ Good for:
// - Articles and blog posts
// - Social media feeds
// - News content
// - Non-critical API data

// ❌ Avoid for:
// - Large static assets
// - Rarely changing content
```

---

## 10.2.4 Stale While Revalidate

### Implementation

```javascript
// sw.js
// Best for: balance of speed and freshness
self.addEventListener('fetch', (event) => {
  event.respondWith(
    caches.open('swr-cache').then((cache) => {
      return cache.match(event.request).then((cached) => {
        // Fetch from network (in background)
        const fetchPromise = fetch(event.request).then((response) => {
          if (response.ok) {
            cache.put(event.request, response.clone());
          }
          return response;
        });
        
        // Return cached immediately, or wait for network
        return cached || fetchPromise;
      });
    })
  );
});
```

### With Notification

```javascript
// SWR with update notification
async function staleWhileRevalidate(request) {
  const cache = await caches.open('swr-cache');
  const cached = await cache.match(request);
  
  const fetchPromise = fetch(request).then(async (response) => {
    if (response.ok) {
      const oldResponse = await cache.match(request);
      await cache.put(request, response.clone());
      
      // Check if content changed
      if (oldResponse) {
        const oldData = await oldResponse.text();
        const newData = await response.clone().text();
        
        if (oldData !== newData) {
          // Notify clients of update
          const clients = await self.clients.matchAll();
          clients.forEach(client => {
            client.postMessage({
              type: 'content-updated',
              url: request.url
            });
          });
        }
      }
    }
    return response;
  });
  
  return cached || fetchPromise;
}
```

### When to Use

```javascript
// ✅ Good for:
// - User profiles
// - Settings
// - Frequently accessed data
// - Avatar images

// ❌ Avoid for:
// - Real-time data
// - Transaction data
```

---

## 10.2.5 Cache Only

### Implementation

```javascript
// sw.js
// Best for: offline-only resources
self.addEventListener('fetch', (event) => {
  event.respondWith(
    caches.match(event.request)
  );
});
```

### Precached Resources

```javascript
// Cache during install
self.addEventListener('install', (event) => {
  event.waitUntil(
    caches.open('static-v1').then((cache) => {
      return cache.addAll([
        '/offline.html',
        '/app-shell.html',
        '/styles/main.css',
        '/scripts/app.js'
      ]);
    })
  );
});

// Serve only from cache
self.addEventListener('fetch', (event) => {
  if (event.request.mode === 'navigate') {
    event.respondWith(
      caches.match('/app-shell.html')
    );
  }
});
```

---

## 10.2.6 Network Only

### Implementation

```javascript
// sw.js
// Best for: non-cacheable requests
self.addEventListener('fetch', (event) => {
  event.respondWith(fetch(event.request));
});
```

### Use Cases

```javascript
// Network only for specific requests
self.addEventListener('fetch', (event) => {
  const url = new URL(event.request.url);
  
  // Always fetch from network
  if (
    url.pathname.startsWith('/api/transactions') ||
    url.pathname.startsWith('/api/auth') ||
    event.request.method !== 'GET'
  ) {
    event.respondWith(fetch(event.request));
    return;
  }
  
  // Other strategies for other requests...
});
```

---

## 10.2.7 Combined Strategies

### Strategy Router

```javascript
// sw.js
const CACHE_NAME = 'app-v1';

// Route requests to different strategies
self.addEventListener('fetch', (event) => {
  const url = new URL(event.request.url);
  
  // Static assets - Cache First
  if (url.pathname.match(/\.(css|js|png|jpg|svg|woff2)$/)) {
    event.respondWith(cacheFirst(event.request));
    return;
  }
  
  // API calls - Network First
  if (url.pathname.startsWith('/api/')) {
    event.respondWith(networkFirst(event.request));
    return;
  }
  
  // HTML pages - Stale While Revalidate
  if (event.request.destination === 'document') {
    event.respondWith(staleWhileRevalidate(event.request));
    return;
  }
  
  // Default - Network with cache fallback
  event.respondWith(networkFirst(event.request));
});

// Strategy implementations
async function cacheFirst(request) {
  const cached = await caches.match(request);
  return cached || fetch(request).then(response => {
    caches.open(CACHE_NAME).then(cache => cache.put(request, response.clone()));
    return response;
  });
}

async function networkFirst(request) {
  try {
    const response = await fetch(request);
    if (response.ok) {
      const cache = await caches.open(CACHE_NAME);
      cache.put(request, response.clone());
    }
    return response;
  } catch {
    return caches.match(request);
  }
}

async function staleWhileRevalidate(request) {
  const cache = await caches.open(CACHE_NAME);
  const cached = await cache.match(request);
  
  const fetchPromise = fetch(request).then(response => {
    if (response.ok) {
      cache.put(request, response.clone());
    }
    return response;
  }).catch(() => cached);
  
  return cached || fetchPromise;
}
```

---

## 10.2.8 Offline Fallbacks

### Offline Page

```javascript
// Install offline fallback
self.addEventListener('install', (event) => {
  event.waitUntil(
    caches.open('offline-v1').then((cache) => {
      return cache.addAll([
        '/offline.html',
        '/offline.css',
        '/offline.js'
      ]);
    })
  );
});

// Serve offline page for navigation failures
self.addEventListener('fetch', (event) => {
  if (event.request.mode === 'navigate') {
    event.respondWith(
      fetch(event.request).catch(() => {
        return caches.match('/offline.html');
      })
    );
  }
});
```

### Fallback Images

```javascript
const FALLBACK_IMAGE = '/images/offline-placeholder.png';

self.addEventListener('fetch', (event) => {
  if (event.request.destination === 'image') {
    event.respondWith(
      caches.match(event.request).then((cached) => {
        return cached || fetch(event.request).catch(() => {
          return caches.match(FALLBACK_IMAGE);
        });
      })
    );
  }
});
```

---

## 10.2.9 Cache Management

### Cache Versioning

```javascript
const CACHE_VERSION = 'v2';
const CACHES = {
  static: `static-${CACHE_VERSION}`,
  dynamic: `dynamic-${CACHE_VERSION}`
};

// Clean old caches on activate
self.addEventListener('activate', (event) => {
  event.waitUntil(
    caches.keys().then((keys) => {
      return Promise.all(
        keys.filter((key) => !Object.values(CACHES).includes(key))
            .map((key) => caches.delete(key))
      );
    })
  );
});
```

### Cache Size Limits

```javascript
// Limit cache entries
async function limitCache(cacheName, maxEntries) {
  const cache = await caches.open(cacheName);
  const keys = await cache.keys();
  
  if (keys.length > maxEntries) {
    // Remove oldest entries (FIFO)
    await Promise.all(
      keys.slice(0, keys.length - maxEntries)
          .map(key => cache.delete(key))
    );
  }
}

// Limit cache age
async function expireOldEntries(cacheName, maxAgeSeconds) {
  const cache = await caches.open(cacheName);
  const keys = await cache.keys();
  const now = Date.now();
  
  for (const request of keys) {
    const response = await cache.match(request);
    const dateHeader = response.headers.get('date');
    
    if (dateHeader) {
      const responseDate = new Date(dateHeader).getTime();
      if (now - responseDate > maxAgeSeconds * 1000) {
        await cache.delete(request);
      }
    }
  }
}
```

---

## 10.2.10 Summary

### Strategy Comparison

| Strategy | Speed | Freshness | Offline |
|----------|-------|-----------|---------|
| Cache First | ⚡⚡⚡ | ⭐ | ✅ |
| Network First | ⚡ | ⭐⭐⭐ | ✅ |
| Stale While Revalidate | ⚡⚡⚡ | ⭐⭐ | ✅ |
| Cache Only | ⚡⚡⚡ | ⭐ | ✅ |
| Network Only | ⚡ | ⭐⭐⭐ | ❌ |

### Strategy Selection

| Content Type | Recommended Strategy |
|--------------|---------------------|
| Static assets | Cache First |
| API data | Network First |
| User content | Stale While Revalidate |
| Auth tokens | Network Only |
| App shell | Cache Only |

### Best Practices

1. **Match strategy to content** type and freshness needs
2. **Provide offline fallbacks** for critical pages
3. **Version your caches** for clean updates
4. **Limit cache size** to prevent storage issues
5. **Test offline thoroughly**
6. **Consider using Workbox** for complex strategies

---

**End of Chapter 10.2: Service Worker Strategies**

Next chapter: **10.3 App Installation** — covers PWA installation prompts and events.
# 10.3 App Installation

Progressive Web Apps can be installed on user devices for a native-like experience. This chapter covers the beforeinstallprompt event, custom install prompts, and installation detection.

---

## 10.3.1 Installation Overview

### PWA Installation Requirements

```javascript
// For a PWA to be installable, it needs:
// 1. Valid Web App Manifest with required fields
// 2. HTTPS (or localhost for development)
// 3. Registered Service Worker
// 4. (Chrome) User engagement heuristic met

// Required manifest fields:
// - name or short_name
// - icons (192px and 512px minimum)
// - start_url
// - display (standalone, fullscreen, or minimal-ui)
// - prefer_related_applications not true
```

### Check Installability

```javascript
// Check if app can be installed
window.addEventListener('beforeinstallprompt', (event) => {
  console.log('App is installable!');
});

// Check if already installed
function isInstalled() {
  // Check display mode
  if (window.matchMedia('(display-mode: standalone)').matches) {
    return true;
  }
  
  // iOS Safari
  if (window.navigator.standalone === true) {
    return true;
  }
  
  return false;
}
```

---

## 10.3.2 beforeinstallprompt Event

### Capturing the Event

```javascript
// Store the event for later use
let deferredPrompt;

window.addEventListener('beforeinstallprompt', (event) => {
  // Prevent automatic prompt
  event.preventDefault();
  
  // Store for later
  deferredPrompt = event;
  
  // Show your custom install button
  showInstallButton();
});

function showInstallButton() {
  const installButton = document.getElementById('install-btn');
  installButton.style.display = 'block';
}
```

### Using the Deferred Prompt

```javascript
const installButton = document.getElementById('install-btn');

installButton.addEventListener('click', async () => {
  if (!deferredPrompt) return;
  
  // Show the browser's install prompt
  deferredPrompt.prompt();
  
  // Wait for user response
  const { outcome } = await deferredPrompt.userChoice;
  
  console.log(`User choice: ${outcome}`);
  // 'accepted' or 'dismissed'
  
  // Clear the deferred prompt
  deferredPrompt = null;
  
  // Hide install button
  installButton.style.display = 'none';
});
```

### Event Properties

```javascript
window.addEventListener('beforeinstallprompt', (event) => {
  // Available platforms
  console.log('Platforms:', event.platforms);
  // e.g., ['web', 'play'] for Android
  
  // User choice promise
  event.userChoice.then((result) => {
    console.log('Outcome:', result.outcome);
    console.log('Platform:', result.platform);
  });
});
```

---

## 10.3.3 appinstalled Event

### Detecting Installation

```javascript
window.addEventListener('appinstalled', (event) => {
  console.log('App was installed!');
  
  // Track installation
  analytics.track('pwa_installed');
  
  // Hide install UI
  hideInstallPromotion();
  
  // Show welcome message
  showWelcomeMessage();
});
```

### Complete Installation Flow

```javascript
class InstallManager {
  constructor() {
    this.deferredPrompt = null;
    this.isInstalled = this.checkInstalled();
    
    this.setupEventListeners();
  }
  
  checkInstalled() {
    return window.matchMedia('(display-mode: standalone)').matches ||
           window.navigator.standalone === true;
  }
  
  setupEventListeners() {
    // Capture install prompt
    window.addEventListener('beforeinstallprompt', (e) => {
      e.preventDefault();
      this.deferredPrompt = e;
      this.showInstallUI();
    });
    
    // Handle installation
    window.addEventListener('appinstalled', () => {
      this.isInstalled = true;
      this.deferredPrompt = null;
      this.hideInstallUI();
      this.onInstalled();
    });
    
    // Handle display mode changes
    window.matchMedia('(display-mode: standalone)').addEventListener('change', (e) => {
      if (e.matches) {
        this.isInstalled = true;
        this.hideInstallUI();
      }
    });
  }
  
  showInstallUI() {
    const banner = document.getElementById('install-banner');
    if (banner && !this.isInstalled) {
      banner.classList.add('visible');
    }
  }
  
  hideInstallUI() {
    const banner = document.getElementById('install-banner');
    if (banner) {
      banner.classList.remove('visible');
    }
  }
  
  async promptInstall() {
    if (!this.deferredPrompt) {
      console.log('Install prompt not available');
      return false;
    }
    
    this.deferredPrompt.prompt();
    const { outcome } = await this.deferredPrompt.userChoice;
    
    this.deferredPrompt = null;
    
    return outcome === 'accepted';
  }
  
  onInstalled() {
    console.log('PWA installed successfully');
    // Analytics, welcome message, etc.
  }
}

const installManager = new InstallManager();
```

---

## 10.3.4 Custom Install UI

### Install Banner

```html
<div id="install-banner" class="install-banner">
  <div class="install-content">
    <img src="/icons/icon-48.png" alt="App icon">
    <div class="install-text">
      <h3>Install Our App</h3>
      <p>Get quick access from your home screen</p>
    </div>
  </div>
  <div class="install-actions">
    <button id="install-dismiss">Not now</button>
    <button id="install-accept">Install</button>
  </div>
</div>
```

```css
.install-banner {
  position: fixed;
  bottom: 0;
  left: 0;
  right: 0;
  background: white;
  box-shadow: 0 -2px 10px rgba(0, 0, 0, 0.1);
  padding: 16px;
  transform: translateY(100%);
  transition: transform 0.3s ease;
  z-index: 1000;
}

.install-banner.visible {
  transform: translateY(0);
}

.install-content {
  display: flex;
  align-items: center;
  gap: 12px;
}

.install-actions {
  display: flex;
  gap: 8px;
  margin-top: 12px;
}

#install-accept {
  background: #6200ee;
  color: white;
  border: none;
  padding: 8px 16px;
  border-radius: 4px;
  cursor: pointer;
}
```

```javascript
document.getElementById('install-accept').addEventListener('click', async () => {
  const installed = await installManager.promptInstall();
  if (installed) {
    installManager.hideInstallUI();
  }
});

document.getElementById('install-dismiss').addEventListener('click', () => {
  installManager.hideInstallUI();
  // Remember dismissal
  localStorage.setItem('install-dismissed', Date.now());
});
```

### Smart Timing

```javascript
class InstallPromotion {
  constructor(options = {}) {
    this.minPageViews = options.minPageViews || 3;
    this.minVisitDuration = options.minVisitDuration || 30000;
    this.dismissCooldown = options.dismissCooldown || 7 * 24 * 60 * 60 * 1000;
    
    this.startTime = Date.now();
    this.incrementPageViews();
  }
  
  incrementPageViews() {
    const views = parseInt(localStorage.getItem('page-views') || '0');
    localStorage.setItem('page-views', views + 1);
  }
  
  shouldShowPrompt() {
    // Check if already installed
    if (window.matchMedia('(display-mode: standalone)').matches) {
      return false;
    }
    
    // Check dismissal cooldown
    const dismissed = parseInt(localStorage.getItem('install-dismissed') || '0');
    if (Date.now() - dismissed < this.dismissCooldown) {
      return false;
    }
    
    // Check minimum page views
    const views = parseInt(localStorage.getItem('page-views') || '0');
    if (views < this.minPageViews) {
      return false;
    }
    
    // Check visit duration
    if (Date.now() - this.startTime < this.minVisitDuration) {
      return false;
    }
    
    return true;
  }
}
```

---

## 10.3.5 iOS Installation

### iOS Safari Limitations

```javascript
// iOS doesn't support beforeinstallprompt
// Must provide manual instructions

function isIOS() {
  return /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
}

function isInStandaloneMode() {
  return window.navigator.standalone === true;
}

function showIOSInstallPrompt() {
  if (isIOS() && !isInStandaloneMode()) {
    // Show custom iOS instructions
    const banner = document.getElementById('ios-install-banner');
    banner.style.display = 'block';
  }
}
```

### iOS Install Instructions

```html
<div id="ios-install-banner" class="ios-banner" style="display: none;">
  <button class="close-btn" onclick="this.parentElement.style.display='none'">&times;</button>
  <p>Install this app on your iPhone:</p>
  <ol>
    <li>Tap the Share button <span class="share-icon">⬆️</span></li>
    <li>Scroll down and tap "Add to Home Screen"</li>
    <li>Tap "Add" to confirm</li>
  </ol>
</div>
```

---

## 10.3.6 Installation Analytics

### Tracking Installation

```javascript
let deferredPrompt;
const installSource = new URLSearchParams(window.location.search).get('source');

window.addEventListener('beforeinstallprompt', (e) => {
  e.preventDefault();
  deferredPrompt = e;
  
  // Track that prompt was available
  analytics.track('pwa_install_available', {
    source: installSource || 'direct'
  });
});

async function triggerInstall(source) {
  if (!deferredPrompt) return;
  
  // Track prompt shown
  analytics.track('pwa_install_prompt_shown', { source });
  
  deferredPrompt.prompt();
  const { outcome } = await deferredPrompt.userChoice;
  
  // Track user choice
  analytics.track('pwa_install_choice', {
    outcome,
    source
  });
  
  deferredPrompt = null;
}

window.addEventListener('appinstalled', () => {
  analytics.track('pwa_installed', {
    source: installSource || 'unknown'
  });
});
```

### Launch Tracking

```javascript
// In manifest.json
// "start_url": "/?source=pwa"

// Track PWA launches
if (window.matchMedia('(display-mode: standalone)').matches) {
  analytics.track('pwa_launch');
}
```

---

## 10.3.7 Related Applications

### Prefer Native App

```json
{
  "prefer_related_applications": true,
  "related_applications": [
    {
      "platform": "play",
      "url": "https://play.google.com/store/apps/details?id=com.example.app",
      "id": "com.example.app"
    }
  ]
}
```

### Check Native App

```javascript
// Check if related native app is installed
if ('getInstalledRelatedApps' in navigator) {
  const relatedApps = await navigator.getInstalledRelatedApps();
  
  if (relatedApps.length > 0) {
    console.log('Native app installed:', relatedApps[0].platform);
    // Hide PWA install prompt
  }
}
```

---

## 10.3.8 Mini Info Bar

### Chrome Mini Info Bar

```javascript
// Chrome shows a mini info bar automatically
// To customize, intercept beforeinstallprompt

window.addEventListener('beforeinstallprompt', (e) => {
  // Prevent mini info bar on mobile
  e.preventDefault();
  
  // Show your own UI at the right time
  showInstallPromotionAtRightTime(e);
});
```

---

## 10.3.9 Summary

### Installation Events

| Event | When |
|-------|------|
| `beforeinstallprompt` | App is installable |
| `appinstalled` | App was installed |

### Event Methods

| Method | Description |
|--------|-------------|
| `event.preventDefault()` | Prevent automatic prompt |
| `event.prompt()` | Show install dialog |
| `event.userChoice` | Promise with user decision |

### Best Practices

1. **Don't prompt immediately** — wait for engagement
2. **Provide custom UI** for better conversion
3. **Track installation funnel** with analytics
4. **Handle iOS separately** with manual instructions
5. **Respect user dismissals** — use cooldown period
6. **Test on multiple devices** and browsers

---

**End of Chapter 10.3: App Installation**

This completes the Progressive Web Apps group. Next section: **Group 11 — Notifications and Messaging** — covers browser notifications and cross-context communication.
# 11.1 Notifications API

The Notifications API displays system-level notifications to users. This chapter covers requesting permission, creating notifications, and handling notification events.

---

## 11.1.1 Notifications Overview

### What Are Web Notifications?

```javascript
// Web Notifications:
// - System-level alerts outside the browser
// - Work even when browser is minimized
// - Require user permission
// - Support icons, badges, and actions
// - Can be triggered from Service Workers
```

### Check Support

```javascript
if ('Notification' in window) {
  console.log('Notifications supported');
}
```

---

## 11.1.2 Requesting Permission

### Permission States

```javascript
// Check current permission
console.log(Notification.permission);
// 'default' - not yet asked
// 'granted' - permission given
// 'denied'  - permission refused
```

### Request Permission

```javascript
async function requestNotificationPermission() {
  // Check if already granted
  if (Notification.permission === 'granted') {
    return true;
  }
  
  // Check if already denied
  if (Notification.permission === 'denied') {
    console.log('Notifications blocked by user');
    return false;
  }
  
  // Request permission
  const permission = await Notification.requestPermission();
  return permission === 'granted';
}

// Best practice: request on user action
document.getElementById('enable-notifications').addEventListener('click', async () => {
  const granted = await requestNotificationPermission();
  if (granted) {
    showNotification('Notifications enabled!');
  }
});
```

---

## 11.1.3 Creating Notifications

### Basic Notification

```javascript
// Simple notification
new Notification('Hello World!');

// With options
new Notification('New Message', {
  body: 'You have a new message from John',
  icon: '/icons/notification.png'
});
```

### Notification Options

```javascript
const notification = new Notification('Notification Title', {
  // Text content
  body: 'This is the notification body text',
  
  // Visual
  icon: '/icons/icon-192.png',      // Main icon
  badge: '/icons/badge-72.png',      // Small icon (Android)
  image: '/images/large-image.jpg',  // Large image
  
  // Behavior
  tag: 'message-group-1',            // Replace same-tag notifications
  renotify: true,                    // Notify even if replacing
  requireInteraction: false,         // Stay until dismissed
  silent: false,                     // Play sound
  
  // Data
  data: { messageId: 123 },          // Custom data
  timestamp: Date.now(),             // When event occurred
  
  // Direction
  dir: 'auto',                       // 'ltr', 'rtl', or 'auto'
  lang: 'en-US'                      // Language
});
```

### Actions (Service Worker only)

```javascript
// In Service Worker
self.registration.showNotification('New Message', {
  body: 'John: Hey, are you free tonight?',
  icon: '/icons/icon.png',
  actions: [
    {
      action: 'reply',
      title: 'Reply',
      icon: '/icons/reply.png'
    },
    {
      action: 'dismiss',
      title: 'Dismiss',
      icon: '/icons/dismiss.png'
    }
  ],
  data: { messageId: 123 }
});
```

---

## 11.1.4 Notification Events

### Event Handlers

```javascript
const notification = new Notification('Click me', {
  body: 'Click to open the app'
});

// Notification clicked
notification.onclick = (event) => {
  event.preventDefault();
  window.focus();
  window.location.href = '/messages';
  notification.close();
};

// Notification closed
notification.onclose = () => {
  console.log('Notification closed');
};

// Notification shown
notification.onshow = () => {
  console.log('Notification displayed');
};

// Error occurred
notification.onerror = (error) => {
  console.error('Notification error:', error);
};
```

### Auto-Close

```javascript
const notification = new Notification('Temporary', {
  body: 'This will close in 5 seconds'
});

// Auto-close after 5 seconds
setTimeout(() => {
  notification.close();
}, 5000);
```

---

## 11.1.5 Service Worker Notifications

### Show from Service Worker

```javascript
// sw.js
self.registration.showNotification('Background Notification', {
  body: 'Sent from Service Worker',
  icon: '/icons/icon.png',
  badge: '/icons/badge.png',
  tag: 'sw-notification',
  data: { url: '/notifications' }
});
```

### Handle Notification Click

```javascript
// sw.js
self.addEventListener('notificationclick', (event) => {
  event.notification.close();
  
  // Handle action clicks
  if (event.action === 'reply') {
    // Open reply page
    event.waitUntil(
      clients.openWindow('/reply')
    );
    return;
  }
  
  // Default click - focus or open window
  event.waitUntil(
    clients.matchAll({ type: 'window' }).then((windowClients) => {
      // Focus existing window
      for (const client of windowClients) {
        if (client.url === '/' && 'focus' in client) {
          return client.focus();
        }
      }
      // Open new window
      return clients.openWindow(event.notification.data?.url || '/');
    })
  );
});
```

### Handle Notification Close

```javascript
// sw.js
self.addEventListener('notificationclose', (event) => {
  // Track dismissal
  const data = event.notification.data;
  console.log('Notification dismissed:', data);
  
  // Analytics
  event.waitUntil(
    fetch('/api/analytics/notification-dismissed', {
      method: 'POST',
      body: JSON.stringify(data)
    })
  );
});
```

---

## 11.1.6 Notification Tags

### Replacing Notifications

```javascript
// First notification
new Notification('1 new message', {
  tag: 'messages',
  body: 'John: Hello!'
});

// Later, replace with updated notification
new Notification('2 new messages', {
  tag: 'messages',
  body: 'John: Hello!\nJane: Hi there!',
  renotify: true  // Alert user again
});
```

### Grouping Notifications

```javascript
// Group notifications by tag
function notifyNewMessage(message) {
  const tag = `chat-${message.roomId}`;
  
  new Notification(`New in ${message.roomName}`, {
    tag,
    body: `${message.sender}: ${message.text}`,
    data: { roomId: message.roomId },
    renotify: true
  });
}
```

---

## 11.1.7 Patterns

### Notification Manager

```javascript
class NotificationManager {
  constructor() {
    this.permission = Notification.permission;
  }
  
  async requestPermission() {
    if (this.permission === 'granted') return true;
    if (this.permission === 'denied') return false;
    
    this.permission = await Notification.requestPermission();
    return this.permission === 'granted';
  }
  
  canNotify() {
    return 'Notification' in window && this.permission === 'granted';
  }
  
  show(title, options = {}) {
    if (!this.canNotify()) {
      console.warn('Cannot show notification');
      return null;
    }
    
    const notification = new Notification(title, {
      icon: '/icons/default.png',
      ...options
    });
    
    // Auto-close after timeout
    if (options.timeout) {
      setTimeout(() => notification.close(), options.timeout);
    }
    
    return notification;
  }
  
  async showFromServiceWorker(title, options = {}) {
    if (!('serviceWorker' in navigator)) {
      return this.show(title, options);
    }
    
    const registration = await navigator.serviceWorker.ready;
    return registration.showNotification(title, options);
  }
}

const notifier = new NotificationManager();
```

### Notification Queue

```javascript
class NotificationQueue {
  constructor(maxVisible = 3, delay = 500) {
    this.queue = [];
    this.visible = 0;
    this.maxVisible = maxVisible;
    this.delay = delay;
  }
  
  add(title, options) {
    this.queue.push({ title, options });
    this.process();
  }
  
  process() {
    if (this.visible >= this.maxVisible || this.queue.length === 0) {
      return;
    }
    
    const { title, options } = this.queue.shift();
    this.visible++;
    
    const notification = new Notification(title, options);
    
    notification.onclose = () => {
      this.visible--;
      setTimeout(() => this.process(), this.delay);
    };
    
    // Auto-close after 5 seconds
    setTimeout(() => notification.close(), 5000);
  }
}
```

---

## 11.1.8 Best Practices

### Permission UX

```javascript
// ❌ Bad: Request immediately on page load
Notification.requestPermission();

// ✅ Good: Request after user action with context
const enableBtn = document.getElementById('enable-notifications');
const explainer = document.getElementById('notification-explainer');

enableBtn.addEventListener('click', async () => {
  // Show explainer first
  explainer.textContent = 'We\'ll notify you when you receive new messages';
  
  const permission = await Notification.requestPermission();
  
  if (permission === 'granted') {
    enableBtn.textContent = 'Notifications enabled ✓';
    enableBtn.disabled = true;
  } else if (permission === 'denied') {
    explainer.textContent = 'Notifications blocked. Enable in browser settings.';
  }
});
```

---

## 11.1.9 Summary

### Permission States

| State | Meaning |
|-------|---------|
| `default` | Not yet requested |
| `granted` | Permission given |
| `denied` | Permission refused |

### Notification Options

| Option | Description |
|--------|-------------|
| `body` | Message text |
| `icon` | Main icon |
| `badge` | Small badge icon |
| `image` | Large image |
| `tag` | Grouping/replacement |
| `actions` | Action buttons (SW only) |
| `data` | Custom data |

### Events

| Event | When |
|-------|------|
| `click` | Notification clicked |
| `close` | Notification closed |
| `show` | Notification displayed |
| `error` | Error occurred |

### Best Practices

1. **Request permission contextually** after user action
2. **Explain value** before requesting
3. **Use tags** to prevent notification spam
4. **Handle denied** state gracefully
5. **Keep notifications brief** and actionable
6. **Use Service Worker** for background notifications

---

**End of Chapter 11.1: Notifications API**

Next chapter: **11.2 Push API** — covers server-to-browser push messages.
# 11.2 Push API

The Push API enables servers to send messages to web applications, even when the app isn't open. This chapter covers push subscriptions, server integration, and handling push events.

---

## 11.2.1 Push API Overview

### How Push Works

```javascript
// Push API flow:
// 1. User grants notification permission
// 2. Browser subscribes to push service
// 3. Server stores subscription endpoint
// 4. Server sends push to browser's push service
// 5. Browser wakes Service Worker
// 6. Service Worker shows notification

// Components:
// - Push Service (browser vendor)
// - Application Server (your backend)
// - Service Worker (client-side)
// - VAPID keys (authentication)
```

### Requirements

```javascript
// Push API requires:
// - HTTPS (except localhost)
// - Service Worker
// - Notification permission
// - VAPID keys for authentication
```

---

## 11.2.2 VAPID Keys

### Generate Keys

```bash
# Using web-push library (Node.js)
npx web-push generate-vapid-keys
```

```javascript
// Output:
// Public Key: BEl62iUYgUivxIkv69yViEuiBIa-Ib9-SkvMeAtA3LFgDzkrxZJjSgSnfckjBJuBkr3qBUYIHBQFLXYp5Nksh8U
// Private Key: UUxI4O8-FbRouADVXc-hK3ltRAc8yWn4qQb5H5K1C8I
```

### Key Conversion

```javascript
// Convert base64 to Uint8Array for subscribe()
function urlBase64ToUint8Array(base64String) {
  const padding = '='.repeat((4 - base64String.length % 4) % 4);
  const base64 = (base64String + padding)
    .replace(/-/g, '+')
    .replace(/_/g, '/');
  
  const rawData = window.atob(base64);
  const outputArray = new Uint8Array(rawData.length);
  
  for (let i = 0; i < rawData.length; ++i) {
    outputArray[i] = rawData.charCodeAt(i);
  }
  
  return outputArray;
}
```

---

## 11.2.3 Subscribing to Push

### Subscribe User

```javascript
const VAPID_PUBLIC_KEY = 'BEl62iUYgUivxIkv69yViEuiBIa-...';

async function subscribeToPush() {
  // Check for Service Worker and Push support
  if (!('serviceWorker' in navigator) || !('PushManager' in window)) {
    throw new Error('Push not supported');
  }
  
  // Get service worker registration
  const registration = await navigator.serviceWorker.ready;
  
  // Check existing subscription
  let subscription = await registration.pushManager.getSubscription();
  
  if (subscription) {
    return subscription;
  }
  
  // Subscribe to push
  subscription = await registration.pushManager.subscribe({
    userVisibleOnly: true,  // Must show notification
    applicationServerKey: urlBase64ToUint8Array(VAPID_PUBLIC_KEY)
  });
  
  // Send subscription to server
  await sendSubscriptionToServer(subscription);
  
  return subscription;
}

async function sendSubscriptionToServer(subscription) {
  await fetch('/api/push/subscribe', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(subscription)
  });
}
```

### Subscription Object

```javascript
// PushSubscription object
{
  endpoint: 'https://fcm.googleapis.com/fcm/send/...',
  expirationTime: null,
  keys: {
    p256dh: 'BNcRdreALRFX...',  // Encryption key
    auth: 'tBHItJI5svbpez...'   // Auth secret
  }
}

// Get subscription details
console.log(subscription.endpoint);
console.log(subscription.toJSON());
```

---

## 11.2.4 Server-Side Push

### Node.js with web-push

```javascript
// server.js
const webpush = require('web-push');

// Configure VAPID
webpush.setVapidDetails(
  'mailto:your@email.com',
  VAPID_PUBLIC_KEY,
  VAPID_PRIVATE_KEY
);

// Store subscriptions (use database in production)
const subscriptions = [];

// Save subscription endpoint
app.post('/api/push/subscribe', (req, res) => {
  const subscription = req.body;
  subscriptions.push(subscription);
  res.status(201).json({ message: 'Subscribed' });
});

// Send push notification
async function sendPushNotification(subscription, payload) {
  try {
    await webpush.sendNotification(
      subscription,
      JSON.stringify(payload)
    );
  } catch (error) {
    if (error.statusCode === 410 || error.statusCode === 404) {
      // Subscription expired or invalid - remove it
      removeSubscription(subscription);
    }
    throw error;
  }
}

// Send to all subscribers
async function broadcast(payload) {
  const results = await Promise.allSettled(
    subscriptions.map(sub => sendPushNotification(sub, payload))
  );
  
  return results;
}
```

### Push Payload

```javascript
// Server sends JSON payload
const payload = {
  title: 'New Message',
  body: 'You have a new message from John',
  icon: '/icons/icon-192.png',
  badge: '/icons/badge-72.png',
  url: '/messages/123',
  tag: 'message',
  data: {
    messageId: 123,
    senderId: 'john'
  }
};

await webpush.sendNotification(subscription, JSON.stringify(payload));
```

---

## 11.2.5 Handling Push Events

### Push Event in Service Worker

```javascript
// sw.js
self.addEventListener('push', (event) => {
  console.log('Push received');
  
  // Get payload
  let data = { title: 'Notification' };
  
  if (event.data) {
    data = event.data.json();
  }
  
  // Show notification
  const options = {
    body: data.body,
    icon: data.icon || '/icons/icon-192.png',
    badge: data.badge || '/icons/badge-72.png',
    tag: data.tag,
    data: data.data || {},
    actions: data.actions || [],
    requireInteraction: data.requireInteraction || false
  };
  
  event.waitUntil(
    self.registration.showNotification(data.title, options)
  );
});
```

### Handle Notification Click

```javascript
// sw.js
self.addEventListener('notificationclick', (event) => {
  const notification = event.notification;
  const data = notification.data;
  const action = event.action;
  
  notification.close();
  
  // Handle action buttons
  if (action === 'view') {
    event.waitUntil(clients.openWindow(data.url));
    return;
  }
  
  if (action === 'dismiss') {
    return;
  }
  
  // Default click - open URL
  event.waitUntil(
    clients.matchAll({ type: 'window', includeUncontrolled: true })
      .then((clientList) => {
        // Try to focus existing window
        for (const client of clientList) {
          if (client.url.includes(data.url) && 'focus' in client) {
            return client.focus();
          }
        }
        // Open new window
        return clients.openWindow(data.url || '/');
      })
  );
});
```

---

## 11.2.6 Subscription Management

### Unsubscribe

```javascript
async function unsubscribeFromPush() {
  const registration = await navigator.serviceWorker.ready;
  const subscription = await registration.pushManager.getSubscription();
  
  if (subscription) {
    // Unsubscribe from browser
    await subscription.unsubscribe();
    
    // Remove from server
    await fetch('/api/push/unsubscribe', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ endpoint: subscription.endpoint })
    });
  }
}
```

### Check Subscription Status

```javascript
async function getPushSubscription() {
  const registration = await navigator.serviceWorker.ready;
  return registration.pushManager.getSubscription();
}

async function isPushEnabled() {
  const subscription = await getPushSubscription();
  return subscription !== null;
}
```

### Subscription Refresh

```javascript
// Subscriptions can expire - handle refreshing
async function refreshSubscription() {
  const registration = await navigator.serviceWorker.ready;
  let subscription = await registration.pushManager.getSubscription();
  
  if (subscription) {
    // Check if expired or about to expire
    if (subscription.expirationTime && 
        subscription.expirationTime < Date.now() + 86400000) {
      await subscription.unsubscribe();
      subscription = null;
    }
  }
  
  if (!subscription) {
    subscription = await registration.pushManager.subscribe({
      userVisibleOnly: true,
      applicationServerKey: urlBase64ToUint8Array(VAPID_PUBLIC_KEY)
    });
    
    await sendSubscriptionToServer(subscription);
  }
  
  return subscription;
}
```

---

## 11.2.7 Permission State

### Check Permission

```javascript
async function checkPushPermission() {
  const registration = await navigator.serviceWorker.ready;
  const permissionState = await registration.pushManager.permissionState({
    userVisibleOnly: true,
    applicationServerKey: urlBase64ToUint8Array(VAPID_PUBLIC_KEY)
  });
  
  return permissionState;  // 'granted', 'denied', or 'prompt'
}
```

---

## 11.2.8 Complete Example

### Full Push Implementation

```javascript
// push-manager.js
class PushManager {
  constructor(vapidPublicKey) {
    this.vapidKey = vapidPublicKey;
  }
  
  async isSupported() {
    return 'serviceWorker' in navigator && 'PushManager' in window;
  }
  
  async getSubscription() {
    const registration = await navigator.serviceWorker.ready;
    return registration.pushManager.getSubscription();
  }
  
  async subscribe() {
    if (!(await this.isSupported())) {
      throw new Error('Push not supported');
    }
    
    // Request notification permission
    const permission = await Notification.requestPermission();
    if (permission !== 'granted') {
      throw new Error('Notification permission denied');
    }
    
    const registration = await navigator.serviceWorker.ready;
    
    // Subscribe
    const subscription = await registration.pushManager.subscribe({
      userVisibleOnly: true,
      applicationServerKey: this.urlBase64ToUint8Array(this.vapidKey)
    });
    
    // Send to server
    await this.saveSubscription(subscription);
    
    return subscription;
  }
  
  async unsubscribe() {
    const subscription = await this.getSubscription();
    
    if (subscription) {
      await subscription.unsubscribe();
      await this.removeSubscription(subscription);
    }
  }
  
  async saveSubscription(subscription) {
    await fetch('/api/push/subscribe', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(subscription.toJSON())
    });
  }
  
  async removeSubscription(subscription) {
    await fetch('/api/push/unsubscribe', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ endpoint: subscription.endpoint })
    });
  }
  
  urlBase64ToUint8Array(base64String) {
    const padding = '='.repeat((4 - base64String.length % 4) % 4);
    const base64 = (base64String + padding)
      .replace(/-/g, '+')
      .replace(/_/g, '/');
    
    const rawData = atob(base64);
    return Uint8Array.from([...rawData].map(char => char.charCodeAt(0)));
  }
}

// Usage
const pushManager = new PushManager(VAPID_PUBLIC_KEY);

document.getElementById('enable-push').addEventListener('click', async () => {
  try {
    await pushManager.subscribe();
    console.log('Push enabled');
  } catch (error) {
    console.error('Failed to enable push:', error);
  }
});
```

---

## 11.2.9 Summary

### Push Flow

| Step | Component | Action |
|------|-----------|--------|
| 1 | Client | Request permission |
| 2 | Client | Subscribe to push |
| 3 | Server | Store subscription |
| 4 | Server | Send push message |
| 5 | SW | Handle push event |
| 6 | SW | Show notification |

### Key Methods

| Method | Description |
|--------|-------------|
| `pushManager.subscribe()` | Subscribe to push |
| `pushManager.getSubscription()` | Get current subscription |
| `subscription.unsubscribe()` | Unsubscribe |

### Server Libraries

| Language | Library |
|----------|---------|
| Node.js | web-push |
| Python | pywebpush |
| PHP | web-push-php |
| Ruby | webpush |

### Best Practices

1. **Use VAPID keys** for authentication
2. **Handle subscription expiration** and refresh
3. **Remove invalid subscriptions** (410/404 errors)
4. **Keep payloads small** (< 4KB)
5. **Always show notification** (userVisibleOnly)
6. **Handle offline** — queue and retry

---

**End of Chapter 11.2: Push API**

Next chapter: **11.3 Broadcast Channel API** — covers cross-tab communication.
# 11.3 Broadcast Channel API

The Broadcast Channel API enables simple communication between browsing contexts (tabs, windows, iframes) of the same origin. This chapter covers channel creation, messaging, and common patterns.

---

## 11.3.1 Broadcast Channel Overview

### What Is Broadcast Channel?

```javascript
// Broadcast Channel:
// - Simple cross-tab communication
// - Same-origin only
// - Broadcast to all listeners (no targeting)
// - Works with tabs, windows, iframes, workers
// - Messages are cloned (structured clone)
```

### Check Support

```javascript
if ('BroadcastChannel' in window) {
  console.log('Broadcast Channel supported');
}
```

---

## 11.3.2 Creating Channels

### Basic Channel

```javascript
// Create channel (same name = same channel)
const channel = new BroadcastChannel('my-channel');

// Channel name identifies the channel
// All contexts with same name are connected
```

### Multiple Channels

```javascript
// Different channels for different purposes
const authChannel = new BroadcastChannel('auth');
const syncChannel = new BroadcastChannel('data-sync');
const uiChannel = new BroadcastChannel('ui-updates');
```

---

## 11.3.3 Sending Messages

### Basic Message

```javascript
const channel = new BroadcastChannel('updates');

// Send string
channel.postMessage('Hello, other tabs!');

// Send object
channel.postMessage({
  type: 'notification',
  text: 'New data available'
});

// Send array
channel.postMessage([1, 2, 3, 4, 5]);
```

### Message Types

```javascript
// Any structured-cloneable data
channel.postMessage('string');
channel.postMessage(123);
channel.postMessage({ key: 'value' });
channel.postMessage([1, 2, 3]);
channel.postMessage(new Date());
channel.postMessage(new Map([['a', 1]]));
channel.postMessage(new Set([1, 2, 3]));
channel.postMessage(new ArrayBuffer(8));

// NOT supported
// channel.postMessage(function() {});  // Functions
// channel.postMessage(document.body);   // DOM nodes
// channel.postMessage(Symbol('x'));     // Symbols
```

---

## 11.3.4 Receiving Messages

### Message Handler

```javascript
const channel = new BroadcastChannel('updates');

// Using onmessage
channel.onmessage = (event) => {
  console.log('Received:', event.data);
  console.log('Origin:', event.origin);
};

// Using addEventListener
channel.addEventListener('message', (event) => {
  console.log('Received:', event.data);
});

// Note: Sender does NOT receive their own message
```

### Message Event Properties

```javascript
channel.onmessage = (event) => {
  event.data;         // The message data
  event.origin;       // Origin of sender
  event.lastEventId;  // Always empty string
  event.source;       // Always null
  event.ports;        // Always empty array
};
```

---

## 11.3.5 Closing Channels

### Close Channel

```javascript
const channel = new BroadcastChannel('updates');

// Close when done
channel.close();

// After closing:
// - Cannot send messages
// - Will not receive messages
// - Channel object is unusable
```

### Cleanup Pattern

```javascript
class TabSync {
  constructor() {
    this.channel = new BroadcastChannel('tab-sync');
    this.setupListeners();
  }
  
  setupListeners() {
    this.channel.onmessage = (e) => this.handleMessage(e);
    
    // Cleanup on page unload
    window.addEventListener('beforeunload', () => {
      this.channel.close();
    });
  }
  
  handleMessage(event) {
    // Handle message
  }
  
  send(message) {
    this.channel.postMessage(message);
  }
  
  destroy() {
    this.channel.close();
  }
}
```

---

## 11.3.6 Common Patterns

### User Authentication Sync

```javascript
// Sync login/logout across tabs
const authChannel = new BroadcastChannel('auth');

// On login
function onLogin(user) {
  authChannel.postMessage({
    type: 'LOGIN',
    user
  });
}

// On logout
function onLogout() {
  authChannel.postMessage({
    type: 'LOGOUT'
  });
}

// Listen for auth changes
authChannel.onmessage = (event) => {
  if (event.data.type === 'LOGIN') {
    // Update UI with logged-in user
    updateUserUI(event.data.user);
  }
  
  if (event.data.type === 'LOGOUT') {
    // Redirect to login
    window.location.href = '/login';
  }
};
```

### Theme Sync

```javascript
// Sync theme preference across tabs
const themeChannel = new BroadcastChannel('theme');

function setTheme(theme) {
  document.documentElement.setAttribute('data-theme', theme);
  localStorage.setItem('theme', theme);
  
  // Notify other tabs
  themeChannel.postMessage({ theme });
}

themeChannel.onmessage = (event) => {
  const { theme } = event.data;
  document.documentElement.setAttribute('data-theme', theme);
};
```

### Cart Sync

```javascript
// Sync shopping cart across tabs
class CartSync {
  constructor() {
    this.channel = new BroadcastChannel('cart');
    this.cart = this.loadCart();
    
    this.channel.onmessage = (e) => {
      this.cart = e.data.cart;
      this.updateUI();
    };
  }
  
  loadCart() {
    return JSON.parse(localStorage.getItem('cart') || '[]');
  }
  
  addItem(item) {
    this.cart.push(item);
    this.save();
    this.broadcast();
  }
  
  removeItem(id) {
    this.cart = this.cart.filter(item => item.id !== id);
    this.save();
    this.broadcast();
  }
  
  save() {
    localStorage.setItem('cart', JSON.stringify(this.cart));
  }
  
  broadcast() {
    this.channel.postMessage({ cart: this.cart });
  }
  
  updateUI() {
    // Update cart UI
  }
}
```

### Tab Activity Tracking

```javascript
// Track which tab is active
const activityChannel = new BroadcastChannel('activity');
let tabId = Date.now().toString();

// Announce when becoming active
document.addEventListener('visibilitychange', () => {
  if (!document.hidden) {
    activityChannel.postMessage({
      type: 'TAB_ACTIVE',
      tabId
    });
  }
});

// Listen for other tabs
activityChannel.onmessage = (event) => {
  if (event.data.type === 'TAB_ACTIVE' && event.data.tabId !== tabId) {
    // Another tab became active
    pauseExpensiveOperations();
  }
};
```

---

## 11.3.7 Leader Election

### Simple Leader Election

```javascript
class TabLeader {
  constructor() {
    this.channel = new BroadcastChannel('leader-election');
    this.isLeader = false;
    this.tabId = Math.random().toString(36).substring(2);
    this.leaderId = null;
    
    this.channel.onmessage = (e) => this.handleMessage(e);
    
    // Attempt to become leader
    this.requestLeadership();
    
    // Heartbeat
    setInterval(() => this.heartbeat(), 5000);
  }
  
  requestLeadership() {
    this.channel.postMessage({
      type: 'LEADER_REQUEST',
      tabId: this.tabId
    });
    
    // If no response, become leader
    setTimeout(() => {
      if (!this.leaderId) {
        this.becomeLeader();
      }
    }, 100);
  }
  
  becomeLeader() {
    this.isLeader = true;
    this.leaderId = this.tabId;
    
    this.channel.postMessage({
      type: 'LEADER_ANNOUNCE',
      tabId: this.tabId
    });
    
    console.log('This tab is now the leader');
  }
  
  handleMessage(event) {
    const { type, tabId } = event.data;
    
    if (type === 'LEADER_REQUEST' && this.isLeader) {
      // Already have a leader
      this.channel.postMessage({
        type: 'LEADER_ANNOUNCE',
        tabId: this.tabId
      });
    }
    
    if (type === 'LEADER_ANNOUNCE') {
      this.leaderId = tabId;
      if (tabId !== this.tabId) {
        this.isLeader = false;
      }
    }
    
    if (type === 'LEADER_RESIGN' && tabId === this.leaderId) {
      this.leaderId = null;
      this.requestLeadership();
    }
  }
  
  heartbeat() {
    if (this.isLeader) {
      this.channel.postMessage({
        type: 'LEADER_HEARTBEAT',
        tabId: this.tabId
      });
    }
  }
  
  resign() {
    if (this.isLeader) {
      this.channel.postMessage({
        type: 'LEADER_RESIGN',
        tabId: this.tabId
      });
      this.isLeader = false;
    }
  }
}
```

---

## 11.3.8 Summary

### Key Methods

| Method | Description |
|--------|-------------|
| `new BroadcastChannel(name)` | Create/join channel |
| `channel.postMessage(data)` | Send message |
| `channel.close()` | Close channel |

### Event Properties

| Property | Description |
|----------|-------------|
| `event.data` | Message payload |
| `event.origin` | Sender origin |

### Use Cases

| Use Case | Description |
|----------|-------------|
| Auth sync | Login/logout across tabs |
| Settings sync | Theme, preferences |
| Data sync | Cart, notifications |
| Coordination | Leader election |

### Limitations

- Same origin only
- No targeting (broadcast only)
- No message acknowledgment
- Sender doesn't receive own message

### Best Practices

1. **Use descriptive channel names**
2. **Structure messages** with type field
3. **Close channels** on unload
4. **Handle missing support** gracefully
5. **Don't rely on message order**
6. **Use for sync, not primary storage**

---

**End of Chapter 11.3: Broadcast Channel API**

Next chapter: **11.4 Channel Messaging API** — covers targeted messaging with MessageChannel.
# 11.4 Channel Messaging API

The Channel Messaging API provides a way to create direct communication channels between browsing contexts. Unlike Broadcast Channel, it enables targeted one-to-one messaging via MessageChannel and MessagePort.

---

## 11.4.1 Channel Messaging Overview

### What Is Channel Messaging?

```javascript
// Channel Messaging provides:
// - Direct communication between two contexts
// - Two linked MessagePorts
// - One-to-one messaging (not broadcast)
// - Can be transferred to workers, iframes
// - Bidirectional communication
```

### Components

```javascript
// MessageChannel - creates port pair
const channel = new MessageChannel();

// MessagePort - communication endpoint
channel.port1  // One end
channel.port2  // Other end

// Messages sent on port1 arrive at port2 and vice versa
```

---

## 11.4.2 MessageChannel

### Creating a Channel

```javascript
// Create channel
const channel = new MessageChannel();

// Send port2 somewhere else (iframe, worker)
iframe.contentWindow.postMessage('init', '*', [channel.port2]);

// Use port1 locally
channel.port1.onmessage = (event) => {
  console.log('Received:', event.data);
};

channel.port1.start();
channel.port1.postMessage('Hello from main!');
```

### Port Properties

```javascript
const channel = new MessageChannel();

// port1 and port2 are MessagePort objects
// Messages sent on one arrive at the other
channel.port1.postMessage('Hello');  // Arrives at port2
channel.port2.postMessage('Hi');     // Arrives at port1
```

---

## 11.4.3 MessagePort

### Basic Usage

```javascript
const channel = new MessageChannel();
const port = channel.port1;

// Send message
port.postMessage('Hello');
port.postMessage({ type: 'data', value: 42 });
port.postMessage([1, 2, 3]);

// Receive messages
port.onmessage = (event) => {
  console.log('Received:', event.data);
};

// Or with addEventListener (requires start())
port.addEventListener('message', (event) => {
  console.log('Received:', event.data);
});
port.start();  // Required when using addEventListener
```

### Port Methods

```javascript
// postMessage - send data
port.postMessage(data);
port.postMessage(data, [transferable]);

// start - begin receiving (only needed with addEventListener)
port.start();

// close - close the port
port.close();
```

### Message Error

```javascript
port.onmessageerror = (event) => {
  console.error('Failed to deserialize message');
};
```

---

## 11.4.4 Transferring Ports

### To Iframe

```javascript
// Parent page
const iframe = document.querySelector('iframe');
const channel = new MessageChannel();

// Send port2 to iframe
iframe.contentWindow.postMessage('port', '*', [channel.port2]);

// Use port1 locally
channel.port1.onmessage = (e) => console.log('From iframe:', e.data);
channel.port1.start();
```

```javascript
// Iframe
window.onmessage = (event) => {
  if (event.data === 'port') {
    const port = event.ports[0];
    
    port.onmessage = (e) => console.log('From parent:', e.data);
    port.start();
    
    port.postMessage('Hello from iframe!');
  }
};
```

### To Worker

```javascript
// Main thread
const worker = new Worker('worker.js');
const channel = new MessageChannel();

// Send port2 to worker
worker.postMessage({ type: 'port' }, [channel.port2]);

// Use port1
channel.port1.onmessage = (e) => console.log('From worker:', e.data);
channel.port1.start();
```

```javascript
// worker.js
self.onmessage = (event) => {
  if (event.data.type === 'port') {
    const port = event.ports[0];
    
    port.onmessage = (e) => {
      console.log('From main:', e.data);
      port.postMessage('Response from worker');
    };
    port.start();
  }
};
```

---

## 11.4.5 Transferable Objects

### Transferring Data

```javascript
const channel = new MessageChannel();

// Transfer ArrayBuffer (moves, not copies)
const buffer = new ArrayBuffer(1024 * 1024);
channel.port1.postMessage(buffer, [buffer]);
// buffer.byteLength is now 0

// Transfer multiple objects
const buffer1 = new ArrayBuffer(1024);
const buffer2 = new ArrayBuffer(1024);
channel.port1.postMessage(
  { a: buffer1, b: buffer2 },
  [buffer1, buffer2]
);
```

### Transferable Types

```javascript
// Types that can be transferred:
// - ArrayBuffer
// - MessagePort
// - ImageBitmap
// - OffscreenCanvas
// - ReadableStream
// - WritableStream
// - TransformStream

// Transfer port to another context
const newChannel = new MessageChannel();
someOtherPort.postMessage({ port: newChannel.port2 }, [newChannel.port2]);
```

---

## 11.4.6 Common Patterns

### Request-Response

```javascript
// Request-response pattern
class PortRPC {
  constructor(port) {
    this.port = port;
    this.pending = new Map();
    this.nextId = 0;
    
    this.port.onmessage = (e) => this.handleMessage(e);
    this.port.start();
  }
  
  handleMessage(event) {
    const { id, type, result, error } = event.data;
    
    if (type === 'response') {
      const { resolve, reject } = this.pending.get(id);
      this.pending.delete(id);
      
      if (error) reject(new Error(error));
      else resolve(result);
    }
  }
  
  call(method, args) {
    return new Promise((resolve, reject) => {
      const id = this.nextId++;
      this.pending.set(id, { resolve, reject });
      
      this.port.postMessage({
        id,
        type: 'request',
        method,
        args
      });
    });
  }
}

// Server side (worker or iframe)
class PortRPCServer {
  constructor(port, handlers) {
    this.port = port;
    this.handlers = handlers;
    
    this.port.onmessage = (e) => this.handleMessage(e);
    this.port.start();
  }
  
  async handleMessage(event) {
    const { id, type, method, args } = event.data;
    
    if (type === 'request') {
      try {
        const handler = this.handlers[method];
        if (!handler) throw new Error(`Unknown method: ${method}`);
        
        const result = await handler(...args);
        this.port.postMessage({ id, type: 'response', result });
      } catch (error) {
        this.port.postMessage({ id, type: 'response', error: error.message });
      }
    }
  }
}
```

### Iframe Communication

```javascript
// Parent page - iframe manager
class IframeBridge {
  constructor(iframe) {
    this.iframe = iframe;
    this.ready = this.init();
  }
  
  async init() {
    return new Promise((resolve) => {
      const channel = new MessageChannel();
      this.port = channel.port1;
      
      this.port.onmessage = (e) => this.handleMessage(e);
      this.port.start();
      
      // Wait for iframe to load
      this.iframe.onload = () => {
        this.iframe.contentWindow.postMessage(
          { type: 'connect' },
          '*',
          [channel.port2]
        );
      };
      
      // Wait for ready message
      const originalHandler = this.handleMessage.bind(this);
      this.handleMessage = (e) => {
        if (e.data.type === 'ready') {
          this.handleMessage = originalHandler;
          resolve();
        }
      };
    });
  }
  
  handleMessage(event) {
    console.log('From iframe:', event.data);
  }
  
  send(message) {
    this.port.postMessage(message);
  }
}

// Iframe side
window.addEventListener('message', (event) => {
  if (event.data.type === 'connect' && event.ports[0]) {
    const port = event.ports[0];
    
    port.onmessage = (e) => {
      console.log('From parent:', e.data);
    };
    port.start();
    
    // Signal ready
    port.postMessage({ type: 'ready' });
    
    // Store for later use
    window.parentPort = port;
  }
});
```

### Worker Pool

```javascript
// Worker pool using MessageChannels
class WorkerPool {
  constructor(workerScript, size = 4) {
    this.workers = [];
    this.available = [];
    this.queue = [];
    
    for (let i = 0; i < size; i++) {
      const worker = new Worker(workerScript);
      this.workers.push(worker);
      this.available.push(worker);
    }
  }
  
  execute(task) {
    return new Promise((resolve, reject) => {
      this.queue.push({ task, resolve, reject });
      this.processQueue();
    });
  }
  
  processQueue() {
    if (this.queue.length === 0 || this.available.length === 0) {
      return;
    }
    
    const worker = this.available.pop();
    const { task, resolve, reject } = this.queue.shift();
    
    const channel = new MessageChannel();
    
    channel.port1.onmessage = (e) => {
      this.available.push(worker);
      
      if (e.data.error) {
        reject(new Error(e.data.error));
      } else {
        resolve(e.data.result);
      }
      
      this.processQueue();
    };
    
    channel.port1.start();
    worker.postMessage({ task }, [channel.port2]);
  }
  
  terminate() {
    this.workers.forEach(w => w.terminate());
  }
}
```

---

## 11.4.7 Summary

### Key Classes

| Class | Description |
|-------|-------------|
| `MessageChannel` | Creates linked port pair |
| `MessagePort` | Communication endpoint |

### MessagePort Methods

| Method | Description |
|--------|-------------|
| `postMessage(data, [transfers])` | Send message |
| `start()` | Begin receiving |
| `close()` | Close port |

### Events

| Event | When |
|-------|------|
| `message` | Message received |
| `messageerror` | Deserialization failed |

### Use Cases

| Scenario | Description |
|----------|-------------|
| Iframe communication | Direct parent-child messaging |
| Worker communication | Dedicated channel to worker |
| RPC patterns | Request-response messaging |
| Port transfer | Moving channels between contexts |

### Best Practices

1. **Use start()** when using addEventListener
2. **Close ports** when done
3. **Transfer large data** instead of copying
4. **Handle messageerror** for robustness
5. **Use RPC patterns** for request-response
6. **Consider Broadcast Channel** for one-to-many

---

**End of Chapter 11.4: Channel Messaging API**

This completes the Notifications and Messaging group. Next section: **Group 12 — Device APIs** — covers device hardware access.
# 12.1 Geolocation API

The Geolocation API provides access to the user's geographical location. This chapter covers getting position, watching location, handling errors, and privacy considerations.

---

## 12.1.1 Geolocation Overview

### What Is the Geolocation API?

```javascript
// Geolocation API provides:
// - User's current position
// - Continuous position tracking
// - Works on mobile and desktop
// - Requires user permission
// - Can use GPS, WiFi, IP address
```

### Check Support

```javascript
if ('geolocation' in navigator) {
  console.log('Geolocation supported');
}
```

---

## 12.1.2 Getting Current Position

### Basic Usage

```javascript
navigator.geolocation.getCurrentPosition(
  // Success callback
  (position) => {
    console.log('Latitude:', position.coords.latitude);
    console.log('Longitude:', position.coords.longitude);
  },
  // Error callback
  (error) => {
    console.error('Error:', error.message);
  }
);
```

### With Options

```javascript
const options = {
  enableHighAccuracy: true,  // Use GPS if available
  timeout: 10000,            // Timeout in milliseconds
  maximumAge: 0              // Don't use cached position
};

navigator.geolocation.getCurrentPosition(
  successCallback,
  errorCallback,
  options
);
```

### Promise Wrapper

```javascript
function getCurrentPosition(options = {}) {
  return new Promise((resolve, reject) => {
    navigator.geolocation.getCurrentPosition(resolve, reject, options);
  });
}

// Usage
async function getLocation() {
  try {
    const position = await getCurrentPosition({
      enableHighAccuracy: true,
      timeout: 5000
    });
    
    return {
      lat: position.coords.latitude,
      lng: position.coords.longitude
    };
  } catch (error) {
    throw new Error(`Geolocation failed: ${error.message}`);
  }
}
```

---

## 12.1.3 Position Object

### Coordinates

```javascript
navigator.geolocation.getCurrentPosition((position) => {
  const coords = position.coords;
  
  // Always available
  console.log('Latitude:', coords.latitude);      // degrees
  console.log('Longitude:', coords.longitude);    // degrees
  console.log('Accuracy:', coords.accuracy);      // meters
  
  // May be null
  console.log('Altitude:', coords.altitude);              // meters
  console.log('Altitude Accuracy:', coords.altitudeAccuracy);  // meters
  console.log('Heading:', coords.heading);                // degrees (0-360)
  console.log('Speed:', coords.speed);                    // meters/second
  
  // Timestamp
  console.log('Timestamp:', position.timestamp);
});
```

### Using Position Data

```javascript
async function displayLocation() {
  const position = await getCurrentPosition();
  const { latitude, longitude, accuracy } = position.coords;
  
  // Display on map
  map.setCenter({ lat: latitude, lng: longitude });
  
  // Show accuracy circle
  const accuracyCircle = new google.maps.Circle({
    center: { lat: latitude, lng: longitude },
    radius: accuracy,
    map: map
  });
}
```

---

## 12.1.4 Watching Position

### watchPosition

```javascript
// Start watching
const watchId = navigator.geolocation.watchPosition(
  (position) => {
    console.log('Position updated:', position.coords);
    updateLocationOnMap(position);
  },
  (error) => {
    console.error('Watch error:', error);
  },
  {
    enableHighAccuracy: true,
    timeout: 5000,
    maximumAge: 0
  }
);

// Stop watching
function stopWatching() {
  navigator.geolocation.clearWatch(watchId);
}
```

### Location Tracker

```javascript
class LocationTracker {
  constructor(onUpdate, onError) {
    this.onUpdate = onUpdate;
    this.onError = onError;
    this.watchId = null;
    this.history = [];
  }
  
  start(options = {}) {
    if (this.watchId !== null) return;
    
    this.watchId = navigator.geolocation.watchPosition(
      (position) => {
        this.history.push({
          lat: position.coords.latitude,
          lng: position.coords.longitude,
          accuracy: position.coords.accuracy,
          timestamp: position.timestamp
        });
        
        this.onUpdate(position);
      },
      this.onError,
      {
        enableHighAccuracy: true,
        timeout: 10000,
        maximumAge: 0,
        ...options
      }
    );
  }
  
  stop() {
    if (this.watchId !== null) {
      navigator.geolocation.clearWatch(this.watchId);
      this.watchId = null;
    }
  }
  
  getDistance() {
    if (this.history.length < 2) return 0;
    
    let total = 0;
    for (let i = 1; i < this.history.length; i++) {
      total += this.calculateDistance(
        this.history[i - 1],
        this.history[i]
      );
    }
    return total;
  }
  
  calculateDistance(point1, point2) {
    // Haversine formula
    const R = 6371e3; // Earth radius in meters
    const φ1 = point1.lat * Math.PI / 180;
    const φ2 = point2.lat * Math.PI / 180;
    const Δφ = (point2.lat - point1.lat) * Math.PI / 180;
    const Δλ = (point2.lng - point1.lng) * Math.PI / 180;
    
    const a = Math.sin(Δφ/2) * Math.sin(Δφ/2) +
              Math.cos(φ1) * Math.cos(φ2) *
              Math.sin(Δλ/2) * Math.sin(Δλ/2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
    
    return R * c;
  }
}
```

---

## 12.1.5 Error Handling

### Error Codes

```javascript
navigator.geolocation.getCurrentPosition(
  (position) => { /* success */ },
  (error) => {
    switch (error.code) {
      case error.PERMISSION_DENIED:
        console.error('User denied geolocation permission');
        showPermissionInstructions();
        break;
        
      case error.POSITION_UNAVAILABLE:
        console.error('Position unavailable');
        showOfflineMessage();
        break;
        
      case error.TIMEOUT:
        console.error('Request timed out');
        retryWithLowerAccuracy();
        break;
        
      default:
        console.error('Unknown error:', error.message);
    }
  }
);
```

### Retry Logic

```javascript
async function getLocationWithRetry(maxRetries = 3) {
  const options = {
    enableHighAccuracy: true,
    timeout: 5000,
    maximumAge: 0
  };
  
  for (let i = 0; i < maxRetries; i++) {
    try {
      return await getCurrentPosition(options);
    } catch (error) {
      if (error.code === error.TIMEOUT && i < maxRetries - 1) {
        // Increase timeout and try again
        options.timeout *= 2;
        console.log(`Retrying with timeout: ${options.timeout}ms`);
        continue;
      }
      throw error;
    }
  }
}
```

---

## 12.1.6 Options

### enableHighAccuracy

```javascript
// High accuracy (GPS, slower, more battery)
{
  enableHighAccuracy: true
}

// Low accuracy (WiFi/Cell, faster, less battery)
{
  enableHighAccuracy: false
}
```

### timeout

```javascript
// Maximum time to wait for position
{
  timeout: 5000  // 5 seconds
}

// No timeout (wait indefinitely)
{
  timeout: Infinity
}
```

### maximumAge

```javascript
// Don't use cached position
{
  maximumAge: 0
}

// Accept position cached up to 5 minutes ago
{
  maximumAge: 300000
}

// Accept any cached position
{
  maximumAge: Infinity
}
```

---

## 12.1.7 Common Patterns

### Geofencing

```javascript
class Geofence {
  constructor(center, radius, onEnter, onExit) {
    this.center = center;
    this.radius = radius;
    this.onEnter = onEnter;
    this.onExit = onExit;
    this.isInside = false;
    this.watchId = null;
  }
  
  start() {
    this.watchId = navigator.geolocation.watchPosition(
      (position) => this.checkPosition(position),
      (error) => console.error('Geofence error:', error),
      { enableHighAccuracy: true }
    );
  }
  
  stop() {
    if (this.watchId !== null) {
      navigator.geolocation.clearWatch(this.watchId);
      this.watchId = null;
    }
  }
  
  checkPosition(position) {
    const distance = this.calculateDistance(
      { lat: position.coords.latitude, lng: position.coords.longitude },
      this.center
    );
    
    const nowInside = distance <= this.radius;
    
    if (nowInside && !this.isInside) {
      this.isInside = true;
      this.onEnter();
    } else if (!nowInside && this.isInside) {
      this.isInside = false;
      this.onExit();
    }
  }
  
  calculateDistance(point1, point2) {
    // Haversine formula (see above)
  }
}

// Usage
const fence = new Geofence(
  { lat: 37.7749, lng: -122.4194 },
  100, // 100 meters
  () => console.log('Entered geofence'),
  () => console.log('Exited geofence')
);

fence.start();
```

---

## 12.1.8 Summary

### Methods

| Method | Description |
|--------|-------------|
| `getCurrentPosition()` | Get current location once |
| `watchPosition()` | Track location changes |
| `clearWatch()` | Stop watching |

### Position Coordinates

| Property | Description | Always Available |
|----------|-------------|------------------|
| `latitude` | Degrees | ✅ |
| `longitude` | Degrees | ✅ |
| `accuracy` | Meters | ✅ |
| `altitude` | Meters | ❌ |
| `altitudeAccuracy` | Meters | ❌ |
| `heading` | Degrees | ❌ |
| `speed` | m/s | ❌ |

### Error Codes

| Code | Constant | Meaning |
|------|----------|---------|
| 1 | `PERMISSION_DENIED` | User denied |
| 2 | `POSITION_UNAVAILABLE` | No position |
| 3 | `TIMEOUT` | Timed out |

### Best Practices

1. **Handle permission denial** gracefully
2. **Use appropriate accuracy** for battery life
3. **Set reasonable timeouts**
4. **Clear watch** when not needed
5. **Provide fallbacks** when unavailable
6. **Respect user privacy**

---

**End of Chapter 12.1: Geolocation API**

Next chapter: **12.2 Device Orientation and Motion** — covers accelerometer and gyroscope.
# 12.2 Device Orientation and Motion

The Device Orientation and Motion events provide access to device sensors like accelerometers and gyroscopes. This chapter covers orientation events, motion events, and practical applications.

---

## 12.2.1 Overview

### What Are Device Orientation Events?

```javascript
// Device events provide:
// - Device orientation (alpha, beta, gamma)
// - Device motion (acceleration, rotation rate)
// - Works on mobile devices and laptops with sensors
// - May require permission on iOS 13+
```

### Check Support

```javascript
if ('DeviceOrientationEvent' in window) {
  console.log('Device orientation supported');
}

if ('DeviceMotionEvent' in window) {
  console.log('Device motion supported');
}
```

---

## 12.2.2 Permission (iOS 13+)

### Request Permission

```javascript
// iOS 13+ requires permission
async function requestOrientationPermission() {
  if (typeof DeviceOrientationEvent.requestPermission === 'function') {
    try {
      const permission = await DeviceOrientationEvent.requestPermission();
      return permission === 'granted';
    } catch (error) {
      console.error('Permission error:', error);
      return false;
    }
  }
  // Permission not required on this device
  return true;
}

// Must be triggered by user gesture
button.addEventListener('click', async () => {
  const granted = await requestOrientationPermission();
  if (granted) {
    startOrientationTracking();
  }
});
```

---

## 12.2.3 Device Orientation Event

### Basic Usage

```javascript
window.addEventListener('deviceorientation', (event) => {
  // Alpha: rotation around z-axis (0-360)
  // Compass direction when device is flat
  console.log('Alpha (compass):', event.alpha);
  
  // Beta: rotation around x-axis (-180 to 180)
  // Front-to-back tilt
  console.log('Beta (front/back):', event.beta);
  
  // Gamma: rotation around y-axis (-90 to 90)
  // Left-to-right tilt
  console.log('Gamma (left/right):', event.gamma);
  
  // Is calibrated compass?
  console.log('Absolute:', event.absolute);
});
```

### Understanding Axes

```javascript
// Device orientation axes:
//
//        ^ beta (x)
//        |
//        |
//    γ <---- α (z pointing up)
//   gamma
//
// alpha: Compass direction (0=North, 90=East, 180=South, 270=West)
// beta:  Front-to-back tilt (-180=face down, 0=vertical, 180=face up)
// gamma: Left-to-right tilt (-90=left, 0=flat, 90=right)
```

### Compass Example

```javascript
const compass = document.getElementById('compass');

window.addEventListener('deviceorientation', (event) => {
  if (event.alpha !== null) {
    // Rotate compass needle
    compass.style.transform = `rotate(${-event.alpha}deg)`;
  }
});
```

### Level/Bubble Example

```javascript
const bubble = document.getElementById('bubble');

window.addEventListener('deviceorientation', (event) => {
  const beta = event.beta || 0;
  const gamma = event.gamma || 0;
  
  // Map tilt to bubble position (-90 to 90 degrees to pixels)
  const x = gamma * 2;  // Adjust multiplier as needed
  const y = beta * 2;
  
  bubble.style.transform = `translate(${x}px, ${y}px)`;
});
```

---

## 12.2.4 Device Motion Event

### Basic Usage

```javascript
window.addEventListener('devicemotion', (event) => {
  // Acceleration including gravity
  const accWithGravity = event.accelerationIncludingGravity;
  console.log('Acc+G:', accWithGravity.x, accWithGravity.y, accWithGravity.z);
  
  // Acceleration without gravity (linear acceleration)
  const acc = event.acceleration;
  if (acc) {
    console.log('Linear:', acc.x, acc.y, acc.z);
  }
  
  // Rotation rate (degrees per second)
  const rotation = event.rotationRate;
  if (rotation) {
    console.log('Rotation:', rotation.alpha, rotation.beta, rotation.gamma);
  }
  
  // Interval between data collection (milliseconds)
  console.log('Interval:', event.interval);
});
```

### Understanding Acceleration

```javascript
// Acceleration axes (same as orientation):
// x: Left/right
// y: Forward/backward
// z: Up/down

// accelerationIncludingGravity:
// - Includes gravity (~9.8 m/s²)
// - When flat: x≈0, y≈0, z≈9.8

// acceleration (linear):
// - Gravity removed
// - When stationary: x≈0, y≈0, z≈0
```

---

## 12.2.5 Practical Examples

### Shake Detection

```javascript
class ShakeDetector {
  constructor(threshold = 15, callback) {
    this.threshold = threshold;
    this.callback = callback;
    this.lastX = null;
    this.lastY = null;
    this.lastZ = null;
    this.lastTime = Date.now();
  }
  
  start() {
    window.addEventListener('devicemotion', this.handleMotion);
  }
  
  stop() {
    window.removeEventListener('devicemotion', this.handleMotion);
  }
  
  handleMotion = (event) => {
    const acc = event.accelerationIncludingGravity;
    if (!acc) return;
    
    const now = Date.now();
    const timeDiff = now - this.lastTime;
    
    if (timeDiff > 100) {
      const deltaX = Math.abs(acc.x - (this.lastX || 0));
      const deltaY = Math.abs(acc.y - (this.lastY || 0));
      const deltaZ = Math.abs(acc.z - (this.lastZ || 0));
      
      const speed = (deltaX + deltaY + deltaZ) / timeDiff * 10000;
      
      if (speed > this.threshold) {
        this.callback();
      }
      
      this.lastX = acc.x;
      this.lastY = acc.y;
      this.lastZ = acc.z;
      this.lastTime = now;
    }
  };
}

// Usage
const detector = new ShakeDetector(15, () => {
  console.log('Shake detected!');
});
detector.start();
```

### Tilt Controls (Game)

```javascript
class TiltController {
  constructor(element, options = {}) {
    this.element = element;
    this.sensitivity = options.sensitivity || 3;
    this.maxTilt = options.maxTilt || 30;
  }
  
  start() {
    window.addEventListener('deviceorientation', this.handleOrientation);
  }
  
  stop() {
    window.removeEventListener('deviceorientation', this.handleOrientation);
  }
  
  handleOrientation = (event) => {
    let gamma = event.gamma || 0;  // Left/right
    let beta = event.beta || 0;    // Forward/back
    
    // Clamp values
    gamma = Math.max(-this.maxTilt, Math.min(this.maxTilt, gamma));
    beta = Math.max(-this.maxTilt, Math.min(this.maxTilt, beta));
    
    // Calculate position
    const x = gamma * this.sensitivity;
    const y = (beta - 45) * this.sensitivity;  // Offset for comfortable hold
    
    // Move element
    this.element.style.transform = `translate(${x}px, ${y}px)`;
  };
}
```

### Step Counter (Pedometer)

```javascript
class StepCounter {
  constructor(onStep) {
    this.onStep = onStep;
    this.steps = 0;
    this.threshold = 1.2;
    this.lastPeak = 0;
    this.lastValue = 0;
    this.rising = false;
  }
  
  start() {
    window.addEventListener('devicemotion', this.handleMotion);
  }
  
  stop() {
    window.removeEventListener('devicemotion', this.handleMotion);
  }
  
  handleMotion = (event) => {
    const acc = event.acceleration || event.accelerationIncludingGravity;
    if (!acc) return;
    
    // Calculate magnitude
    const magnitude = Math.sqrt(
      acc.x * acc.x + acc.y * acc.y + acc.z * acc.z
    );
    
    // Peak detection
    const now = Date.now();
    
    if (magnitude > this.lastValue && !this.rising) {
      this.rising = true;
    } else if (magnitude < this.lastValue && this.rising) {
      this.rising = false;
      
      // Check if peak is significant and not too close to last
      if (magnitude > this.threshold && now - this.lastPeak > 300) {
        this.steps++;
        this.lastPeak = now;
        this.onStep(this.steps);
      }
    }
    
    this.lastValue = magnitude;
  };
  
  reset() {
    this.steps = 0;
  }
}
```

---

## 12.2.6 Absolute Orientation

### deviceorientationabsolute Event

```javascript
// More reliable compass heading
window.addEventListener('deviceorientationabsolute', (event) => {
  // Always relative to Earth's coordinate frame
  console.log('Absolute alpha:', event.alpha);
  console.log('Absolute beta:', event.beta);
  console.log('Absolute gamma:', event.gamma);
  console.log('Is absolute:', event.absolute);  // Always true
});
```

---

## 12.2.7 Summary

### Device Orientation Properties

| Property | Range | Description |
|----------|-------|-------------|
| `alpha` | 0-360 | Compass direction (z-axis rotation) |
| `beta` | -180 to 180 | Front-back tilt (x-axis rotation) |
| `gamma` | -90 to 90 | Left-right tilt (y-axis rotation) |

### Device Motion Properties

| Property | Description |
|----------|-------------|
| `acceleration` | Linear acceleration (gravity removed) |
| `accelerationIncludingGravity` | Total acceleration |
| `rotationRate` | Angular velocity (α, β, γ) |
| `interval` | Time between samples |

### Best Practices

1. **Request permission on iOS** via user gesture
2. **Check for null values** — not all properties available
3. **Debounce/throttle** high-frequency events
4. **Use low-pass filter** for smooth readings
5. **Test on real devices** — simulators differ
6. **Provide fallbacks** for unsupported devices

---

**End of Chapter 12.2: Device Orientation and Motion**

Next chapter: **12.3 Battery Status API** — covers battery level and charging state.
# 12.3 Battery Status API

The Battery Status API provides information about the system's battery level and charging status. This chapter covers accessing battery information and responding to battery changes.

---

## 12.3.1 Battery API Overview

### What Is the Battery API?

```javascript
// Battery Status API provides:
// - Current battery level
// - Charging status
// - Time until charged/discharged
// - Events for battery changes

// Note: Limited browser support
// Chrome removed in 2016 for privacy
// Available in some contexts (Firefox, etc.)
```

### Check Support

```javascript
if ('getBattery' in navigator) {
  console.log('Battery API supported');
}
```

---

## 12.3.2 Getting Battery Status

### Basic Usage

```javascript
async function getBatteryStatus() {
  try {
    const battery = await navigator.getBattery();
    
    console.log('Level:', battery.level * 100 + '%');
    console.log('Charging:', battery.charging);
    console.log('Charging time:', battery.chargingTime);
    console.log('Discharging time:', battery.dischargingTime);
    
    return battery;
  } catch (error) {
    console.error('Battery API not available:', error);
    return null;
  }
}

getBatteryStatus();
```

### BatteryManager Properties

```javascript
const battery = await navigator.getBattery();

// Level (0.0 to 1.0)
const percentage = battery.level * 100;  // e.g., 75%

// Charging state
const isCharging = battery.charging;  // true or false

// Time until fully charged (seconds)
// Infinity if not charging or unknown
const chargingTime = battery.chargingTime;

// Time until empty (seconds)
// Infinity if charging or unknown
const dischargingTime = battery.dischargingTime;
```

---

## 12.3.3 Battery Events

### Event Listeners

```javascript
const battery = await navigator.getBattery();

// Charging state changed
battery.addEventListener('chargingchange', () => {
  console.log('Charging:', battery.charging);
});

// Battery level changed
battery.addEventListener('levelchange', () => {
  console.log('Level:', battery.level * 100 + '%');
});

// Charging time updated
battery.addEventListener('chargingtimechange', () => {
  console.log('Charging time:', battery.chargingTime);
});

// Discharging time updated
battery.addEventListener('dischargingtimechange', () => {
  console.log('Discharging time:', battery.dischargingTime);
});
```

### Using Event Properties

```javascript
battery.onchargingchange = function() {
  if (this.charging) {
    console.log('Device is now charging');
  } else {
    console.log('Device unplugged');
  }
};

battery.onlevelchange = function() {
  if (this.level < 0.2) {
    console.warn('Low battery: ' + (this.level * 100) + '%');
  }
};
```

---

## 12.3.4 Practical Examples

### Battery Monitor

```javascript
class BatteryMonitor {
  constructor() {
    this.battery = null;
    this.listeners = new Set();
  }
  
  async init() {
    if (!('getBattery' in navigator)) {
      throw new Error('Battery API not supported');
    }
    
    this.battery = await navigator.getBattery();
    this.setupListeners();
    
    return this.getStatus();
  }
  
  setupListeners() {
    this.battery.addEventListener('chargingchange', () => this.notify());
    this.battery.addEventListener('levelchange', () => this.notify());
  }
  
  getStatus() {
    return {
      level: Math.round(this.battery.level * 100),
      charging: this.battery.charging,
      chargingTime: this.formatTime(this.battery.chargingTime),
      dischargingTime: this.formatTime(this.battery.dischargingTime)
    };
  }
  
  formatTime(seconds) {
    if (seconds === Infinity) return 'Unknown';
    const hours = Math.floor(seconds / 3600);
    const minutes = Math.floor((seconds % 3600) / 60);
    return `${hours}h ${minutes}m`;
  }
  
  subscribe(callback) {
    this.listeners.add(callback);
    return () => this.listeners.delete(callback);
  }
  
  notify() {
    const status = this.getStatus();
    this.listeners.forEach(cb => cb(status));
  }
}

// Usage
const monitor = new BatteryMonitor();
monitor.init().then(status => {
  console.log('Initial status:', status);
  
  monitor.subscribe(status => {
    console.log('Battery changed:', status);
  });
});
```

### Power-Saving Mode

```javascript
async function enablePowerSaving() {
  const battery = await navigator.getBattery();
  
  function checkBattery() {
    if (!battery.charging && battery.level < 0.2) {
      activatePowerSaveMode();
    } else {
      deactivatePowerSaveMode();
    }
  }
  
  battery.addEventListener('levelchange', checkBattery);
  battery.addEventListener('chargingchange', checkBattery);
  
  checkBattery();
}

function activatePowerSaveMode() {
  // Reduce animations
  document.documentElement.classList.add('reduce-motion');
  
  // Reduce polling frequency
  pollingInterval = 60000;  // 1 minute instead of 10 seconds
  
  // Disable background sync
  pauseBackgroundSync();
  
  console.log('Power save mode activated');
}

function deactivatePowerSaveMode() {
  document.documentElement.classList.remove('reduce-motion');
  pollingInterval = 10000;
  resumeBackgroundSync();
  
  console.log('Power save mode deactivated');
}
```

### Battery-Aware Features

```javascript
async function configureFeaturesBasedOnBattery() {
  const battery = await navigator.getBattery();
  
  const config = {
    autoplay: true,
    highQuality: true,
    animations: true,
    backgroundSync: true
  };
  
  if (!battery.charging && battery.level < 0.5) {
    // Medium battery - reduce some features
    config.highQuality = false;
  }
  
  if (!battery.charging && battery.level < 0.2) {
    // Low battery - minimal features
    config.autoplay = false;
    config.highQuality = false;
    config.animations = false;
    config.backgroundSync = false;
  }
  
  return config;
}
```

---

## 12.3.5 Summary

### BatteryManager Properties

| Property | Type | Description |
|----------|------|-------------|
| `level` | Number | 0.0 to 1.0 |
| `charging` | Boolean | Is charging |
| `chargingTime` | Number | Seconds until full |
| `dischargingTime` | Number | Seconds until empty |

### BatteryManager Events

| Event | When |
|-------|------|
| `chargingchange` | Plugged/unplugged |
| `levelchange` | Level changes |
| `chargingtimechange` | Charging time updates |
| `dischargingtimechange` | Discharging time updates |

### Browser Support

| Browser | Support |
|---------|---------|
| Chrome | Removed (privacy) |
| Firefox | Available |
| Safari | Not supported |
| Edge | Removed |

### Best Practices

1. **Check support** before using
2. **Provide fallbacks** for unsupported browsers
3. **Use for enhancement** not core functionality
4. **Respect privacy** — don't fingerprint
5. **Implement power-saving** features thoughtfully

---

**End of Chapter 12.3: Battery Status API**

Next chapter: **12.4 Vibration API** — covers haptic feedback.
# 12.4 Vibration API

The Vibration API provides access to the device's vibration hardware. This chapter covers triggering vibrations and creating vibration patterns.

---

## 12.4.1 Vibration Overview

### What Is the Vibration API?

```javascript
// Vibration API provides:
// - Simple vibration feedback
// - Pattern-based vibrations
// - Works on mobile devices
// - Simple, single method API
```

### Check Support

```javascript
if ('vibrate' in navigator) {
  console.log('Vibration supported');
}
```

---

## 12.4.2 Basic Vibration

### Single Vibration

```javascript
// Vibrate for 200 milliseconds
navigator.vibrate(200);

// Vibrate for 1 second
navigator.vibrate(1000);
```

### Stop Vibration

```javascript
// Stop any ongoing vibration
navigator.vibrate(0);

// Or pass empty array
navigator.vibrate([]);
```

---

## 12.4.3 Vibration Patterns

### Pattern Array

```javascript
// Pattern: [vibrate, pause, vibrate, pause, ...]
// Vibrate 100ms, pause 50ms, vibrate 100ms
navigator.vibrate([100, 50, 100]);

// Longer pattern
navigator.vibrate([
  100,  // vibrate
  50,   // pause
  100,  // vibrate
  50,   // pause
  200   // vibrate
]);
```

### Common Patterns

```javascript
// Notification
navigator.vibrate([100, 50, 100]);

// Alert
navigator.vibrate([200, 100, 200, 100, 200]);

// Success
navigator.vibrate([50, 50, 100]);

// Error
navigator.vibrate([300, 100, 300, 100, 300]);

// Heartbeat
navigator.vibrate([100, 50, 100, 200, 100, 50, 100, 500]);
```

---

## 12.4.4 Pattern Library

### Reusable Patterns

```javascript
const VibrationPatterns = {
  // Feedback
  tap: [50],
  doubleTap: [50, 50, 50],
  
  // Notifications
  notification: [100, 50, 100],
  alert: [200, 100, 200, 100, 200],
  reminder: [300, 200, 300],
  
  // Results
  success: [50, 50, 100],
  warning: [200, 100, 200],
  error: [300, 100, 300, 100, 300],
  
  // Fun
  heartbeat: [100, 50, 100, 200, 100, 50, 100, 500],
  sos: [100, 30, 100, 30, 100, 200, 300, 30, 300, 30, 300, 200, 100, 30, 100, 30, 100],
  
  // Games
  explosion: [50, 25, 100, 25, 150, 25, 200],
  powerUp: [50, 50, 75, 50, 100, 50, 150]
};

function vibrate(pattern) {
  if ('vibrate' in navigator) {
    navigator.vibrate(VibrationPatterns[pattern] || pattern);
  }
}

// Usage
vibrate('success');
vibrate('error');
vibrate([100, 50, 100]);  // Custom
```

---

## 12.4.5 Practical Examples

### Form Validation

```javascript
function validateForm(form) {
  const errors = [];
  
  // Validate fields...
  if (!form.email.value) {
    errors.push('Email required');
  }
  
  if (errors.length > 0) {
    // Vibrate on error
    navigator.vibrate([100, 50, 100, 50, 100]);
    showErrors(errors);
    return false;
  }
  
  // Success vibration
  navigator.vibrate(50);
  return true;
}
```

### Button Feedback

```javascript
// Add haptic feedback to buttons
document.querySelectorAll('button').forEach(button => {
  button.addEventListener('click', () => {
    navigator.vibrate(50);
  });
});

// More sophisticated feedback
document.querySelectorAll('[data-haptic]').forEach(element => {
  element.addEventListener('click', (e) => {
    const pattern = e.target.dataset.haptic;
    
    switch (pattern) {
      case 'light':
        navigator.vibrate(30);
        break;
      case 'medium':
        navigator.vibrate(50);
        break;
      case 'heavy':
        navigator.vibrate(100);
        break;
      default:
        navigator.vibrate(50);
    }
  });
});
```

### Game Feedback

```javascript
class HapticFeedback {
  constructor() {
    this.enabled = true;
  }
  
  toggle() {
    this.enabled = !this.enabled;
  }
  
  vibrate(pattern) {
    if (this.enabled && 'vibrate' in navigator) {
      navigator.vibrate(pattern);
    }
  }
  
  // Game events
  hit() {
    this.vibrate([50, 25, 75]);
  }
  
  explosion() {
    this.vibrate([100, 50, 150, 50, 200]);
  }
  
  collectItem() {
    this.vibrate([30, 30, 50]);
  }
  
  levelUp() {
    this.vibrate([50, 50, 100, 50, 150, 50, 200]);
  }
  
  gameOver() {
    this.vibrate([500, 100, 500, 100, 500]);
  }
}

const haptic = new HapticFeedback();

// In game
function onCollision() {
  haptic.hit();
}

function onPowerUp() {
  haptic.collectItem();
}
```

### Accessibility Considerations

```javascript
// Respect user preferences
class AccessibleVibration {
  constructor() {
    // Check if user prefers reduced motion
    this.reducedMotion = window.matchMedia(
      '(prefers-reduced-motion: reduce)'
    ).matches;
    
    // Check saved preference
    this.userDisabled = localStorage.getItem('vibration-disabled') === 'true';
  }
  
  vibrate(pattern) {
    // Skip if reduced motion or user disabled
    if (this.reducedMotion || this.userDisabled) {
      return;
    }
    
    if ('vibrate' in navigator) {
      navigator.vibrate(pattern);
    }
  }
  
  disable() {
    this.userDisabled = true;
    localStorage.setItem('vibration-disabled', 'true');
    navigator.vibrate(0);  // Stop any current vibration
  }
  
  enable() {
    this.userDisabled = false;
    localStorage.setItem('vibration-disabled', 'false');
  }
}
```

---

## 12.4.6 Summary

### Methods

| Method | Description |
|--------|-------------|
| `navigator.vibrate(duration)` | Vibrate for duration (ms) |
| `navigator.vibrate(pattern)` | Vibrate with pattern |
| `navigator.vibrate(0)` | Stop vibration |

### Pattern Format

```javascript
[vibrate, pause, vibrate, pause, ...]
// Values in milliseconds
```

### Best Practices

1. **Check support** before using
2. **Keep vibrations short** — battery and UX
3. **Respect reduced motion** preferences
4. **Provide disable option** in settings
5. **Use sparingly** — don't annoy users
6. **Meaningful feedback** — not decoration

### Limitations

- Mobile only (generally)
- Requires user interaction (some browsers)
- Can be disabled by system settings
- Not all patterns feel distinct

---

**End of Chapter 12.4: Vibration API**

Next chapter: **12.5 Ambient Light API** — covers ambient light sensor.
# 12.5 Ambient Light API

The Ambient Light API provides information about the light intensity around the device. This chapter covers accessing light sensor data and practical applications.

---

## 12.5.1 Ambient Light Overview

### What Is the Ambient Light API?

```javascript
// Ambient Light API provides:
// - Current light level (lux)
// - Real-time updates
// - Useful for auto-adjusting UI

// Note: Very limited browser support
// Privacy concerns led to restrictions
```

### Check Support

```javascript
if ('AmbientLightSensor' in window) {
  console.log('Ambient Light Sensor supported');
}

// Legacy devicelight event
if ('ondevicelight' in window) {
  console.log('devicelight event supported');
}
```

---

## 12.5.2 AmbientLightSensor (Generic Sensor API)

### Basic Usage

```javascript
try {
  const sensor = new AmbientLightSensor();
  
  sensor.addEventListener('reading', () => {
    console.log('Light level:', sensor.illuminance, 'lux');
  });
  
  sensor.addEventListener('error', (event) => {
    console.error('Sensor error:', event.error.name);
  });
  
  sensor.start();
} catch (error) {
  console.error('Sensor not supported:', error);
}
```

### Request Permission

```javascript
async function requestLightSensorPermission() {
  try {
    const result = await navigator.permissions.query({
      name: 'ambient-light-sensor'
    });
    
    return result.state === 'granted';
  } catch (error) {
    console.error('Permission query failed:', error);
    return false;
  }
}
```

### Reading Values

```javascript
const sensor = new AmbientLightSensor();

sensor.addEventListener('reading', () => {
  const lux = sensor.illuminance;
  
  // Light level categories (approximate)
  if (lux < 10) {
    console.log('Dark');
  } else if (lux < 50) {
    console.log('Dim');
  } else if (lux < 1000) {
    console.log('Indoor lighting');
  } else if (lux < 10000) {
    console.log('Overcast');
  } else {
    console.log('Direct sunlight');
  }
});

sensor.start();
```

---

## 12.5.3 Legacy devicelight Event

### Usage (Deprecated)

```javascript
// Legacy API (Firefox only, now removed)
window.addEventListener('devicelight', (event) => {
  console.log('Light level:', event.value, 'lux');
});
```

---

## 12.5.4 Practical Applications

### Auto Dark Mode

```javascript
class AutoTheme {
  constructor(darkThreshold = 50, lightThreshold = 200) {
    this.darkThreshold = darkThreshold;
    this.lightThreshold = lightThreshold;
    this.currentTheme = 'auto';
    this.sensor = null;
  }
  
  async start() {
    if (!('AmbientLightSensor' in window)) {
      console.log('Ambient Light Sensor not supported');
      return;
    }
    
    try {
      this.sensor = new AmbientLightSensor();
      
      this.sensor.addEventListener('reading', () => {
        this.updateTheme(this.sensor.illuminance);
      });
      
      this.sensor.addEventListener('error', (e) => {
        console.error('Sensor error:', e.error.name);
      });
      
      this.sensor.start();
    } catch (error) {
      console.error('Failed to start sensor:', error);
    }
  }
  
  stop() {
    this.sensor?.stop();
  }
  
  updateTheme(lux) {
    let newTheme = this.currentTheme;
    
    if (lux < this.darkThreshold) {
      newTheme = 'dark';
    } else if (lux > this.lightThreshold) {
      newTheme = 'light';
    }
    
    if (newTheme !== this.currentTheme) {
      this.currentTheme = newTheme;
      this.applyTheme(newTheme);
    }
  }
  
  applyTheme(theme) {
    document.documentElement.setAttribute('data-theme', theme);
    console.log('Theme changed to:', theme);
  }
}

const autoTheme = new AutoTheme();
autoTheme.start();
```

### Brightness Adjustment

```javascript
class BrightnessController {
  constructor(minBrightness = 0.5, maxBrightness = 1.0) {
    this.min = minBrightness;
    this.max = maxBrightness;
    this.sensor = null;
  }
  
  async start() {
    if (!('AmbientLightSensor' in window)) return;
    
    this.sensor = new AmbientLightSensor();
    
    this.sensor.addEventListener('reading', () => {
      const brightness = this.calculateBrightness(this.sensor.illuminance);
      this.applyBrightness(brightness);
    });
    
    this.sensor.start();
  }
  
  calculateBrightness(lux) {
    // Map lux (0-10000) to brightness range
    const normalized = Math.min(lux / 10000, 1);
    return this.min + (this.max - this.min) * normalized;
  }
  
  applyBrightness(value) {
    // Apply via CSS filter
    document.body.style.filter = `brightness(${value})`;
    
    // Or adjust CSS variable
    document.documentElement.style.setProperty('--screen-brightness', value);
  }
  
  stop() {
    this.sensor?.stop();
    document.body.style.filter = '';
  }
}
```

---

## 12.5.5 Lux Reference Values

### Light Levels

| Environment | Lux |
|-------------|-----|
| Moonlight | 0.1 |
| Street lighting | 10-20 |
| Dark room | 10-50 |
| Home lighting | 150-300 |
| Office | 300-500 |
| Overcast day | 1,000 |
| Full daylight | 10,000-25,000 |
| Direct sunlight | 100,000+ |

---

## 12.5.6 Summary

### AmbientLightSensor Properties

| Property | Description |
|----------|-------------|
| `illuminance` | Light level in lux |

### Sensor Methods

| Method | Description |
|--------|-------------|
| `start()` | Begin readings |
| `stop()` | Stop readings |

### Events

| Event | When |
|-------|------|
| `reading` | New reading available |
| `error` | Error occurred |
| `activate` | Sensor activated |

### Browser Support

- Very limited support
- Requires HTTPS
- May need permissions
- Privacy restrictions apply

### Best Practices

1. **Feature detect** before using
2. **Provide fallbacks** (prefers-color-scheme)
3. **Use thresholds** to prevent flickering
4. **Respect privacy** concerns
5. **Combine with** user preference

---

**End of Chapter 12.5: Ambient Light API**

Next chapter: **12.6 Proximity API** — covers proximity sensor.
# 12.6 Proximity API

The Proximity API provides information about the distance between the device and nearby objects. This chapter covers the proximity sensor events and their applications.

---

## 12.6.1 Proximity Overview

### What Is the Proximity API?

```javascript
// Proximity API provides:
// - Detection of nearby objects
// - Used primarily for phone calls
// - Triggers screen dimming during calls

// Note: Extremely limited support
// Deprecated in most browsers
// Security/privacy concerns
```

### Check Support

```javascript
// Legacy event
if ('ondeviceproximity' in window) {
  console.log('deviceproximity supported');
}

if ('onuserproximity' in window) {
  console.log('userproximity supported');
}

// Generic Sensor API
if ('ProximitySensor' in window) {
  console.log('ProximitySensor supported');
}
```

---

## 12.6.2 ProximitySensor (Generic Sensor API)

### Basic Usage

```javascript
try {
  const sensor = new ProximitySensor();
  
  sensor.addEventListener('reading', () => {
    console.log('Distance:', sensor.distance);  // cm or null
    console.log('Near:', sensor.near);          // boolean
    console.log('Max:', sensor.max);            // maximum range
  });
  
  sensor.addEventListener('error', (event) => {
    console.error('Sensor error:', event.error.name);
  });
  
  sensor.start();
} catch (error) {
  console.error('Sensor not supported:', error);
}
```

### Sensor Properties

```javascript
const sensor = new ProximitySensor();

sensor.addEventListener('reading', () => {
  // Distance in centimeters (may be null)
  console.log('Distance:', sensor.distance);
  
  // Boolean - is object near?
  console.log('Near:', sensor.near);
  
  // Maximum detection distance
  console.log('Max range:', sensor.max);
});
```

---

## 12.6.3 Legacy Events (Deprecated)

### deviceproximity Event

```javascript
// Detailed proximity data (Firefox only, removed)
window.addEventListener('deviceproximity', (event) => {
  console.log('Value:', event.value);  // Distance in cm
  console.log('Min:', event.min);      // Minimum range
  console.log('Max:', event.max);      // Maximum range
});
```

### userproximity Event

```javascript
// Simple near/far boolean (Firefox only, removed)
window.addEventListener('userproximity', (event) => {
  if (event.near) {
    console.log('Object is near');
  } else {
    console.log('Object is far');
  }
});
```

---

## 12.6.4 Practical Applications

### Auto-Pause Video

```javascript
class ProximityPause {
  constructor(video) {
    this.video = video;
    this.wasPlaying = false;
    this.sensor = null;
  }
  
  async start() {
    if (!('ProximitySensor' in window)) {
      console.log('Proximity not supported');
      return;
    }
    
    try {
      this.sensor = new ProximitySensor();
      
      this.sensor.addEventListener('reading', () => {
        if (this.sensor.near) {
          // Object near - pause video
          if (!this.video.paused) {
            this.wasPlaying = true;
            this.video.pause();
          }
        } else {
          // Object far - resume if was playing
          if (this.wasPlaying) {
            this.wasPlaying = false;
            this.video.play();
          }
        }
      });
      
      this.sensor.start();
    } catch (error) {
      console.error('Failed to start sensor:', error);
    }
  }
  
  stop() {
    this.sensor?.stop();
  }
}
```

### Screen Dimming

```javascript
class ProximityDimmer {
  constructor() {
    this.sensor = null;
    this.originalOpacity = 1;
  }
  
  async start() {
    if (!('ProximitySensor' in window)) return;
    
    try {
      this.sensor = new ProximitySensor();
      
      this.sensor.addEventListener('reading', () => {
        if (this.sensor.near) {
          this.dimScreen();
        } else {
          this.restoreScreen();
        }
      });
      
      this.sensor.start();
    } catch (error) {
      console.error('Proximity sensor error:', error);
    }
  }
  
  dimScreen() {
    document.body.style.opacity = '0.3';
    document.body.style.pointerEvents = 'none';
  }
  
  restoreScreen() {
    document.body.style.opacity = '1';
    document.body.style.pointerEvents = 'auto';
  }
  
  stop() {
    this.sensor?.stop();
    this.restoreScreen();
  }
}
```

---

## 12.6.5 Summary

### ProximitySensor Properties

| Property | Type | Description |
|----------|------|-------------|
| `distance` | Number/null | Distance in cm |
| `near` | Boolean | Object is near |
| `max` | Number | Maximum range |

### Events

| Event | Description |
|-------|-------------|
| `reading` | New reading available |
| `error` | Sensor error |
| `activate` | Sensor started |

### Browser Support

| API | Support |
|-----|---------|
| ProximitySensor | Very limited |
| deviceproximity | Deprecated/Removed |
| userproximity | Deprecated/Removed |

### Use Cases

- Phone call screen dimming
- Auto-pause media
- Gesture detection (limited)
- Accessibility features

### Best Practices

1. **Always feature detect**
2. **Provide graceful fallback**
3. **Don't rely on proximity** for core features
4. **Consider privacy** implications
5. **Test on real devices**

---

**End of Chapter 12.6: Proximity API**

This completes the Device APIs group. Next section: **Group 13 — Sensor APIs** — covers the Generic Sensor API framework.
# 13.1 Generic Sensor API

The Generic Sensor API provides a consistent framework for accessing device sensors. This chapter covers the base Sensor interface, sensor lifecycle, and common patterns.

---

## 13.1.1 Overview

### What Is the Generic Sensor API?

```javascript
// Generic Sensor API provides:
// - Unified interface for all sensors
// - Consistent lifecycle management
// - Permission handling
// - Base class for specific sensors

// Available sensors:
// - Accelerometer
// - Gyroscope
// - Magnetometer
// - AbsoluteOrientationSensor
// - RelativeOrientationSensor
// - LinearAccelerationSensor
// - GravitySensor
// - AmbientLightSensor (limited support)
```

### Check Support

```javascript
// Check for specific sensor
if ('Accelerometer' in window) {
  console.log('Accelerometer supported');
}

if ('Gyroscope' in window) {
  console.log('Gyroscope supported');
}
```

---

## 13.1.2 Base Sensor Interface

### Common Properties

```javascript
const sensor = new Accelerometer();

// State
sensor.activated;     // boolean - is sensor active
sensor.hasReading;    // boolean - has reading available
sensor.timestamp;     // DOMHighResTimeStamp - time of reading
```

### Common Methods

```javascript
// Start sensor
sensor.start();

// Stop sensor
sensor.stop();
```

### Common Events

```javascript
// Reading available
sensor.addEventListener('reading', () => {
  console.log('New reading at:', sensor.timestamp);
});

// Sensor activated
sensor.addEventListener('activate', () => {
  console.log('Sensor activated');
});

// Error occurred
sensor.addEventListener('error', (event) => {
  console.error('Sensor error:', event.error.name);
});
```

---

## 13.1.3 Sensor Options

### Frequency

```javascript
// Set reading frequency (Hz)
const sensor = new Accelerometer({ frequency: 60 });

// Default is usually 60Hz, max depends on sensor
```

### Reference Frame

```javascript
// For orientation sensors
const sensor = new AbsoluteOrientationSensor({
  referenceFrame: 'device'  // 'device' or 'screen'
});
```

---

## 13.1.4 Permission Handling

### Check Permission

```javascript
async function checkSensorPermission(name) {
  try {
    const result = await navigator.permissions.query({ name });
    return result.state;  // 'granted', 'denied', 'prompt'
  } catch (error) {
    console.error('Permission check failed:', error);
    return 'unknown';
  }
}

// Check accelerometer
const state = await checkSensorPermission('accelerometer');
```

### Handle Permission Denied

```javascript
const sensor = new Accelerometer();

sensor.addEventListener('error', (event) => {
  if (event.error.name === 'NotAllowedError') {
    console.log('Permission to access sensor denied');
    showPermissionPrompt();
  } else if (event.error.name === 'NotReadableError') {
    console.log('Cannot read sensor data');
  }
});

sensor.start();
```

---

## 13.1.5 Sensor Lifecycle

### Start and Stop

```javascript
const sensor = new Accelerometer({ frequency: 30 });

function startTracking() {
  sensor.start();
}

function stopTracking() {
  sensor.stop();
}

// Cleanup on page unload
window.addEventListener('beforeunload', () => {
  sensor.stop();
});
```

### Check State

```javascript
sensor.addEventListener('activate', () => {
  console.log('Sensor is now active');
  console.log('Activated:', sensor.activated);
});

sensor.addEventListener('reading', () => {
  console.log('Has reading:', sensor.hasReading);
});
```

---

## 13.1.6 Error Handling

### Error Types

```javascript
sensor.addEventListener('error', (event) => {
  const error = event.error;
  
  switch (error.name) {
    case 'NotAllowedError':
      console.error('Permission denied');
      break;
      
    case 'NotReadableError':
      console.error('Sensor not available');
      break;
      
    case 'NotSupportedError':
      console.error('Sensor not supported');
      break;
      
    case 'SecurityError':
      console.error('Secure context required');
      break;
      
    default:
      console.error('Unknown error:', error);
  }
});
```

### Safe Sensor Creation

```javascript
function createSensor(SensorClass, options = {}) {
  return new Promise((resolve, reject) => {
    try {
      const sensor = new SensorClass(options);
      
      sensor.addEventListener('error', (event) => {
        reject(event.error);
      }, { once: true });
      
      sensor.addEventListener('reading', () => {
        resolve(sensor);
      }, { once: true });
      
      sensor.start();
    } catch (error) {
      reject(error);
    }
  });
}

// Usage
try {
  const accelerometer = await createSensor(Accelerometer, { frequency: 60 });
  console.log('Sensor ready:', accelerometer.x, accelerometer.y, accelerometer.z);
} catch (error) {
  console.error('Failed to create sensor:', error);
}
```

---

## 13.1.7 Sensor Manager Pattern

### Reusable Sensor Manager

```javascript
class SensorManager {
  constructor() {
    this.sensors = new Map();
  }
  
  async add(name, SensorClass, options = {}) {
    if (!SensorClass in window) {
      throw new Error(`${name} not supported`);
    }
    
    const sensor = new SensorClass(options);
    
    return new Promise((resolve, reject) => {
      const onError = (event) => {
        sensor.removeEventListener('reading', onReading);
        reject(event.error);
      };
      
      const onReading = () => {
        sensor.removeEventListener('error', onError);
        this.sensors.set(name, sensor);
        resolve(sensor);
      };
      
      sensor.addEventListener('error', onError, { once: true });
      sensor.addEventListener('reading', onReading, { once: true });
      
      sensor.start();
    });
  }
  
  get(name) {
    return this.sensors.get(name);
  }
  
  stop(name) {
    const sensor = this.sensors.get(name);
    if (sensor) {
      sensor.stop();
      this.sensors.delete(name);
    }
  }
  
  stopAll() {
    this.sensors.forEach(sensor => sensor.stop());
    this.sensors.clear();
  }
}

// Usage
const manager = new SensorManager();
await manager.add('accel', Accelerometer, { frequency: 30 });
await manager.add('gyro', Gyroscope, { frequency: 30 });

console.log(manager.get('accel').x);
manager.stopAll();
```

---

## 13.1.8 Summary

### Base Sensor Properties

| Property | Type | Description |
|----------|------|-------------|
| `activated` | Boolean | Sensor is active |
| `hasReading` | Boolean | Has valid reading |
| `timestamp` | Number | Time of reading |

### Base Sensor Methods

| Method | Description |
|--------|-------------|
| `start()` | Start sensor |
| `stop()` | Stop sensor |

### Events

| Event | When |
|-------|------|
| `reading` | New data available |
| `activate` | Sensor started |
| `error` | Error occurred |

### Error Types

| Error | Meaning |
|-------|---------|
| `NotAllowedError` | Permission denied |
| `NotReadableError` | Cannot read sensor |
| `NotSupportedError` | Not supported |
| `SecurityError` | Requires HTTPS |

### Best Practices

1. **Check support** before creating sensors
2. **Handle permissions** gracefully
3. **Stop sensors** when not needed
4. **Set appropriate frequency** for use case
5. **Use HTTPS** — required for sensors
6. **Clean up** on page unload

---

**End of Chapter 13.1: Generic Sensor API**

Next chapter: **13.2 Specific Sensors** — covers Accelerometer, Gyroscope, and more.
# 13.2 Specific Sensors

This chapter covers the specific sensor implementations built on the Generic Sensor API, including Accelerometer, Gyroscope, Magnetometer, and Orientation sensors.

---

## 13.2.1 Accelerometer

### Basic Usage

```javascript
const accelerometer = new Accelerometer({ frequency: 60 });

accelerometer.addEventListener('reading', () => {
  console.log('X:', accelerometer.x);  // m/s²
  console.log('Y:', accelerometer.y);
  console.log('Z:', accelerometer.z);
});

accelerometer.addEventListener('error', (e) => {
  console.error('Error:', e.error.name);
});

accelerometer.start();
```

### Understanding Values

```javascript
// Accelerometer measures acceleration including gravity
// When device is flat and stationary:
// x ≈ 0, y ≈ 0, z ≈ 9.8 (gravity)

// When device is tilted:
// Gravity component shifts between axes
```

### Example: Shake Detection

```javascript
class ShakeDetector {
  constructor(threshold = 15, onShake) {
    this.threshold = threshold;
    this.onShake = onShake;
    this.lastX = 0;
    this.lastY = 0;
    this.lastZ = 0;
    this.lastTime = Date.now();
    
    this.sensor = new Accelerometer({ frequency: 60 });
    this.sensor.addEventListener('reading', () => this.check());
  }
  
  check() {
    const now = Date.now();
    const delta = now - this.lastTime;
    
    if (delta > 100) {
      const { x, y, z } = this.sensor;
      const speed = Math.abs(x + y + z - this.lastX - this.lastY - this.lastZ) / delta * 10000;
      
      if (speed > this.threshold) {
        this.onShake();
      }
      
      this.lastX = x;
      this.lastY = y;
      this.lastZ = z;
      this.lastTime = now;
    }
  }
  
  start() { this.sensor.start(); }
  stop() { this.sensor.stop(); }
}
```

---

## 13.2.2 LinearAccelerationSensor

### Gravity-Free Acceleration

```javascript
// Measures acceleration without gravity
const sensor = new LinearAccelerationSensor({ frequency: 60 });

sensor.addEventListener('reading', () => {
  console.log('X:', sensor.x);  // Linear acceleration only
  console.log('Y:', sensor.y);
  console.log('Z:', sensor.z);
  
  // When stationary: all values ≈ 0
});

sensor.start();
```

### Use Case: Motion Detection

```javascript
const sensor = new LinearAccelerationSensor({ frequency: 30 });
const THRESHOLD = 1.0;

sensor.addEventListener('reading', () => {
  const magnitude = Math.sqrt(
    sensor.x ** 2 + sensor.y ** 2 + sensor.z ** 2
  );
  
  if (magnitude > THRESHOLD) {
    console.log('Device is moving');
  }
});
```

---

## 13.2.3 GravitySensor

### Gravity Vector

```javascript
// Measures gravity direction
const sensor = new GravitySensor({ frequency: 30 });

sensor.addEventListener('reading', () => {
  console.log('Gravity X:', sensor.x);
  console.log('Gravity Y:', sensor.y);
  console.log('Gravity Z:', sensor.z);
  
  // Magnitude ≈ 9.8 m/s²
});

sensor.start();
```

### Use Case: Tilt Detection

```javascript
const gravity = new GravitySensor({ frequency: 30 });

gravity.addEventListener('reading', () => {
  // Calculate tilt angles
  const roll = Math.atan2(gravity.y, gravity.z) * 180 / Math.PI;
  const pitch = Math.atan2(-gravity.x, Math.sqrt(gravity.y ** 2 + gravity.z ** 2)) * 180 / Math.PI;
  
  console.log('Roll:', roll.toFixed(1), '°');
  console.log('Pitch:', pitch.toFixed(1), '°');
});
```

---

## 13.2.4 Gyroscope

### Angular Velocity

```javascript
const gyroscope = new Gyroscope({ frequency: 60 });

gyroscope.addEventListener('reading', () => {
  console.log('X:', gyroscope.x);  // rad/s
  console.log('Y:', gyroscope.y);
  console.log('Z:', gyroscope.z);
});

gyroscope.start();
```

### Rotation Tracking

```javascript
class RotationTracker {
  constructor() {
    this.rotationX = 0;
    this.rotationY = 0;
    this.rotationZ = 0;
    this.lastTimestamp = null;
    
    this.gyro = new Gyroscope({ frequency: 60 });
    this.gyro.addEventListener('reading', () => this.update());
  }
  
  update() {
    if (this.lastTimestamp !== null) {
      const dt = (this.gyro.timestamp - this.lastTimestamp) / 1000;
      
      this.rotationX += this.gyro.x * dt * (180 / Math.PI);
      this.rotationY += this.gyro.y * dt * (180 / Math.PI);
      this.rotationZ += this.gyro.z * dt * (180 / Math.PI);
    }
    
    this.lastTimestamp = this.gyro.timestamp;
  }
  
  reset() {
    this.rotationX = 0;
    this.rotationY = 0;
    this.rotationZ = 0;
  }
  
  start() { this.gyro.start(); }
  stop() { this.gyro.stop(); }
}
```

---

## 13.2.5 Magnetometer

### Magnetic Field

```javascript
const magnetometer = new Magnetometer({ frequency: 30 });

magnetometer.addEventListener('reading', () => {
  console.log('X:', magnetometer.x);  // microTesla
  console.log('Y:', magnetometer.y);
  console.log('Z:', magnetometer.z);
});

magnetometer.start();
```

### Compass

```javascript
const magnetometer = new Magnetometer({ frequency: 30 });

magnetometer.addEventListener('reading', () => {
  // Calculate compass heading
  let heading = Math.atan2(magnetometer.y, magnetometer.x) * 180 / Math.PI;
  
  // Normalize to 0-360
  if (heading < 0) heading += 360;
  
  console.log('Heading:', heading.toFixed(1), '°');
  
  // Cardinal direction
  const directions = ['N', 'NE', 'E', 'SE', 'S', 'SW', 'W', 'NW'];
  const index = Math.round(heading / 45) % 8;
  console.log('Direction:', directions[index]);
});
```

---

## 13.2.6 AbsoluteOrientationSensor

### Device Orientation (Earth Frame)

```javascript
// Orientation relative to Earth's reference frame
const sensor = new AbsoluteOrientationSensor({ frequency: 60 });

sensor.addEventListener('reading', () => {
  // Quaternion representation
  console.log('Quaternion:', sensor.quaternion);
  // [x, y, z, w]
});

sensor.start();
```

### Convert to Euler Angles

```javascript
function quaternionToEuler(q) {
  const [x, y, z, w] = q;
  
  // Roll (x-axis rotation)
  const sinr_cosp = 2 * (w * x + y * z);
  const cosr_cosp = 1 - 2 * (x * x + y * y);
  const roll = Math.atan2(sinr_cosp, cosr_cosp);
  
  // Pitch (y-axis rotation)
  const sinp = 2 * (w * y - z * x);
  const pitch = Math.abs(sinp) >= 1 
    ? Math.sign(sinp) * Math.PI / 2 
    : Math.asin(sinp);
  
  // Yaw (z-axis rotation)
  const siny_cosp = 2 * (w * z + x * y);
  const cosy_cosp = 1 - 2 * (y * y + z * z);
  const yaw = Math.atan2(siny_cosp, cosy_cosp);
  
  return {
    roll: roll * 180 / Math.PI,
    pitch: pitch * 180 / Math.PI,
    yaw: yaw * 180 / Math.PI
  };
}

sensor.addEventListener('reading', () => {
  const euler = quaternionToEuler(sensor.quaternion);
  console.log('Roll:', euler.roll.toFixed(1));
  console.log('Pitch:', euler.pitch.toFixed(1));
  console.log('Yaw:', euler.yaw.toFixed(1));
});
```

### Apply to 3D Object

```javascript
// Using Three.js
const sensor = new AbsoluteOrientationSensor({ frequency: 60 });
const object3D = new THREE.Mesh(geometry, material);

sensor.addEventListener('reading', () => {
  object3D.quaternion.fromArray(sensor.quaternion);
});
```

---

## 13.2.7 RelativeOrientationSensor

### Device-Relative Orientation

```javascript
// Orientation relative to device's initial position
const sensor = new RelativeOrientationSensor({ frequency: 60 });

sensor.addEventListener('reading', () => {
  console.log('Quaternion:', sensor.quaternion);
});

sensor.start();
```

### Reference Frame Option

```javascript
// 'device' - x forward, y right, z up
// 'screen' - x right, y up, z out of screen
const sensor = new RelativeOrientationSensor({
  frequency: 60,
  referenceFrame: 'screen'
});
```

---

## 13.2.8 Sensor Fusion Example

### Combining Sensors

```javascript
class MotionSensors {
  constructor(frequency = 60) {
    this.frequency = frequency;
    this.sensors = {};
    this.data = {};
  }
  
  async init() {
    try {
      this.sensors.accel = new Accelerometer({ frequency: this.frequency });
      this.sensors.gyro = new Gyroscope({ frequency: this.frequency });
      
      // Set up listeners
      this.sensors.accel.addEventListener('reading', () => {
        this.data.acceleration = {
          x: this.sensors.accel.x,
          y: this.sensors.accel.y,
          z: this.sensors.accel.z
        };
      });
      
      this.sensors.gyro.addEventListener('reading', () => {
        this.data.rotation = {
          x: this.sensors.gyro.x,
          y: this.sensors.gyro.y,
          z: this.sensors.gyro.z
        };
      });
      
      // Start all
      Object.values(this.sensors).forEach(s => s.start());
      
    } catch (error) {
      console.error('Sensor init failed:', error);
      throw error;
    }
  }
  
  getData() {
    return { ...this.data };
  }
  
  stop() {
    Object.values(this.sensors).forEach(s => s.stop());
  }
}
```

---

## 13.2.9 Summary

### Available Sensors

| Sensor | Measures | Unit |
|--------|----------|------|
| Accelerometer | Acceleration + gravity | m/s² |
| LinearAccelerationSensor | Acceleration only | m/s² |
| GravitySensor | Gravity vector | m/s² |
| Gyroscope | Angular velocity | rad/s |
| Magnetometer | Magnetic field | µT |
| AbsoluteOrientationSensor | Earth-frame orientation | Quaternion |
| RelativeOrientationSensor | Device-frame orientation | Quaternion |

### Browser Support

| Sensor | Chrome | Firefox | Safari |
|--------|--------|---------|--------|
| Accelerometer | ✅ | ❌ | ❌ |
| Gyroscope | ✅ | ❌ | ❌ |
| Magnetometer | ✅ | ❌ | ❌ |
| Orientation | ✅ | ❌ | ❌ |

### Best Practices

1. **Use appropriate frequency** — higher = more battery
2. **Combine sensors** for better accuracy
3. **Apply filtering** for smooth data
4. **Handle errors** gracefully
5. **Stop when not needed**
6. **Test on real devices**

---

**End of Chapter 13.2: Specific Sensors**

This completes the Sensor APIs group. Next section: **Group 14 — Connectivity APIs** — covers WebSocket, SSE, and network info.
# 14.1 WebSocket API

The WebSocket API provides full-duplex communication channels over a single TCP connection. This chapter covers WebSocket creation, messaging, and connection management.

---

## 14.1.1 Creating a WebSocket

### Basic Connection

```javascript
const socket = new WebSocket('wss://example.com/socket');

socket.addEventListener('open', () => {
  console.log('Connected');
});

socket.addEventListener('message', (event) => {
  console.log('Received:', event.data);
});

socket.addEventListener('close', (event) => {
  console.log('Closed:', event.code, event.reason);
});

socket.addEventListener('error', (event) => {
  console.error('Error occurred');
});
```

### With Protocols

```javascript
// Specify sub-protocol(s)
const socket = new WebSocket('wss://example.com/socket', ['graphql-ws', 'json']);

socket.addEventListener('open', () => {
  console.log('Protocol:', socket.protocol);  // Server-selected protocol
});
```

---

## 14.1.2 Connection States

### ReadyState

```javascript
const socket = new WebSocket('wss://example.com/socket');

// Check state
console.log(socket.readyState);

// States:
// WebSocket.CONNECTING (0) - Connection not yet open
// WebSocket.OPEN (1) - Connection is open
// WebSocket.CLOSING (2) - Connection is closing
// WebSocket.CLOSED (3) - Connection is closed
```

### Check Before Sending

```javascript
function send(data) {
  if (socket.readyState === WebSocket.OPEN) {
    socket.send(data);
    return true;
  }
  return false;
}
```

---

## 14.1.3 Sending Data

### Send Text

```javascript
socket.send('Hello, server!');
```

### Send JSON

```javascript
const data = { type: 'message', content: 'Hello' };
socket.send(JSON.stringify(data));
```

### Send Binary

```javascript
// ArrayBuffer
const buffer = new ArrayBuffer(8);
socket.send(buffer);

// Blob
const blob = new Blob(['data'], { type: 'application/octet-stream' });
socket.send(blob);

// TypedArray
const array = new Uint8Array([1, 2, 3, 4]);
socket.send(array.buffer);
```

### Set Binary Type

```javascript
// For receiving binary data
socket.binaryType = 'arraybuffer';  // Default
// or
socket.binaryType = 'blob';
```

---

## 14.1.4 Receiving Messages

### Handle Messages

```javascript
socket.addEventListener('message', (event) => {
  if (typeof event.data === 'string') {
    // Text message
    try {
      const json = JSON.parse(event.data);
      handleJSON(json);
    } catch {
      handleText(event.data);
    }
  } else if (event.data instanceof ArrayBuffer) {
    // Binary data
    handleBinary(event.data);
  } else if (event.data instanceof Blob) {
    // Blob data
    handleBlob(event.data);
  }
});
```

### Read Blob Data

```javascript
socket.binaryType = 'blob';

socket.addEventListener('message', async (event) => {
  if (event.data instanceof Blob) {
    const text = await event.data.text();
    console.log('Blob as text:', text);
    
    // Or as ArrayBuffer
    const buffer = await event.data.arrayBuffer();
  }
});
```

---

## 14.1.5 Closing Connection

### Close Gracefully

```javascript
// Close with optional code and reason
socket.close(1000, 'Done');

// Codes:
// 1000 - Normal closure
// 1001 - Going away
// 1002 - Protocol error
// 1003 - Unsupported data
// 1008 - Policy violation
// 1011 - Server error
```

### Handle Close

```javascript
socket.addEventListener('close', (event) => {
  console.log('Code:', event.code);
  console.log('Reason:', event.reason);
  console.log('Clean:', event.wasClean);
  
  if (!event.wasClean) {
    console.log('Connection lost unexpectedly');
  }
});
```

---

## 14.1.6 Reconnection Logic

### Auto-Reconnect

```javascript
class ReconnectingWebSocket {
  constructor(url, options = {}) {
    this.url = url;
    this.maxRetries = options.maxRetries ?? 10;
    this.retryDelay = options.retryDelay ?? 1000;
    this.maxDelay = options.maxDelay ?? 30000;
    
    this.retries = 0;
    this.listeners = { open: [], message: [], close: [], error: [] };
    
    this.connect();
  }
  
  connect() {
    this.socket = new WebSocket(this.url);
    
    this.socket.addEventListener('open', (e) => {
      this.retries = 0;
      this.emit('open', e);
    });
    
    this.socket.addEventListener('message', (e) => {
      this.emit('message', e);
    });
    
    this.socket.addEventListener('close', (e) => {
      this.emit('close', e);
      this.reconnect();
    });
    
    this.socket.addEventListener('error', (e) => {
      this.emit('error', e);
    });
  }
  
  reconnect() {
    if (this.retries >= this.maxRetries) {
      console.log('Max retries reached');
      return;
    }
    
    const delay = Math.min(
      this.retryDelay * Math.pow(2, this.retries),
      this.maxDelay
    );
    
    this.retries++;
    console.log(`Reconnecting in ${delay}ms (attempt ${this.retries})`);
    
    setTimeout(() => this.connect(), delay);
  }
  
  send(data) {
    if (this.socket.readyState === WebSocket.OPEN) {
      this.socket.send(data);
    }
  }
  
  close() {
    this.maxRetries = 0;  // Prevent reconnection
    this.socket.close();
  }
  
  on(event, callback) {
    this.listeners[event].push(callback);
  }
  
  emit(event, data) {
    this.listeners[event].forEach(cb => cb(data));
  }
}
```

---

## 14.1.7 Message Queue

### Queue Messages When Disconnected

```javascript
class QueuedWebSocket {
  constructor(url) {
    this.url = url;
    this.queue = [];
    this.connect();
  }
  
  connect() {
    this.socket = new WebSocket(this.url);
    
    this.socket.addEventListener('open', () => {
      this.flushQueue();
    });
    
    this.socket.addEventListener('close', () => {
      setTimeout(() => this.connect(), 1000);
    });
  }
  
  send(data) {
    if (this.socket.readyState === WebSocket.OPEN) {
      this.socket.send(data);
    } else {
      this.queue.push(data);
    }
  }
  
  flushQueue() {
    while (this.queue.length > 0) {
      const data = this.queue.shift();
      this.socket.send(data);
    }
  }
}
```

---

## 14.1.8 Heartbeat / Ping-Pong

### Keep Connection Alive

```javascript
class HeartbeatWebSocket {
  constructor(url, interval = 30000) {
    this.interval = interval;
    this.socket = new WebSocket(url);
    
    this.socket.addEventListener('open', () => {
      this.startHeartbeat();
    });
    
    this.socket.addEventListener('message', (event) => {
      if (event.data === 'pong') {
        this.lastPong = Date.now();
      }
    });
    
    this.socket.addEventListener('close', () => {
      this.stopHeartbeat();
    });
  }
  
  startHeartbeat() {
    this.lastPong = Date.now();
    
    this.heartbeatTimer = setInterval(() => {
      if (Date.now() - this.lastPong > this.interval * 2) {
        console.log('No pong received, reconnecting...');
        this.socket.close();
        return;
      }
      
      this.socket.send('ping');
    }, this.interval);
  }
  
  stopHeartbeat() {
    clearInterval(this.heartbeatTimer);
  }
}
```

---

## 14.1.9 Summary

### Constructor

```javascript
new WebSocket(url)
new WebSocket(url, protocols)
```

### Properties

| Property | Description |
|----------|-------------|
| `readyState` | Connection state |
| `bufferedAmount` | Bytes queued |
| `protocol` | Selected protocol |
| `url` | WebSocket URL |
| `binaryType` | Binary data type |

### Methods

| Method | Description |
|--------|-------------|
| `send(data)` | Send data |
| `close(code, reason)` | Close connection |

### Events

| Event | When |
|-------|------|
| `open` | Connection opened |
| `message` | Message received |
| `close` | Connection closed |
| `error` | Error occurred |

### Best Practices

1. **Use WSS** (secure WebSocket) in production
2. **Implement reconnection** with exponential backoff
3. **Queue messages** when disconnected
4. **Add heartbeat** to detect dead connections
5. **Handle errors** gracefully
6. **Close properly** on page unload

---

**End of Chapter 14.1: WebSocket API**

Next chapter: **14.2 Server-Sent Events** — one-way server-to-client streaming.
# 14.2 Server-Sent Events

Server-Sent Events (SSE) enables servers to push updates to clients over HTTP. This chapter covers EventSource, handling events, and reconnection.

---

## 14.2.1 Basic Usage

### Create EventSource

```javascript
const source = new EventSource('/events');

source.addEventListener('open', () => {
  console.log('Connection opened');
});

source.addEventListener('message', (event) => {
  console.log('Data:', event.data);
});

source.addEventListener('error', (event) => {
  console.log('Error or closed');
});
```

### Close Connection

```javascript
source.close();
```

---

## 14.2.2 Named Events

### Custom Event Types

```javascript
// Server sends:
// event: notification
// data: {"message": "Hello"}

source.addEventListener('notification', (event) => {
  const data = JSON.parse(event.data);
  console.log('Notification:', data.message);
});

// Multiple event types
source.addEventListener('update', handleUpdate);
source.addEventListener('delete', handleDelete);
```

### Default Message Event

```javascript
// Server sends without event type:
// data: Hello

source.addEventListener('message', (event) => {
  console.log('Message:', event.data);
});
```

---

## 14.2.3 Event Properties

### Event Data

```javascript
source.addEventListener('message', (event) => {
  event.data;         // String data
  event.lastEventId;  // Event ID (for reconnection)
  event.origin;       // Server origin
  event.type;         // Event type ('message', 'notification', etc.)
});
```

---

## 14.2.4 Connection State

### ReadyState

```javascript
// States:
// EventSource.CONNECTING (0) - Connecting
// EventSource.OPEN (1) - Connected
// EventSource.CLOSED (2) - Closed

console.log(source.readyState);

// Check if open
if (source.readyState === EventSource.OPEN) {
  console.log('Connected');
}
```

---

## 14.2.5 Reconnection

### Auto-Reconnect

```javascript
// SSE automatically reconnects on disconnect
// Server can control retry interval:
// retry: 5000  (milliseconds)

source.addEventListener('error', (event) => {
  if (source.readyState === EventSource.CONNECTING) {
    console.log('Reconnecting...');
  } else if (source.readyState === EventSource.CLOSED) {
    console.log('Connection closed');
  }
});
```

### Last Event ID

```javascript
// Browser sends Last-Event-ID header on reconnect
// Server can resume from that point

source.addEventListener('message', (event) => {
  console.log('Last ID:', event.lastEventId);
});
```

---

## 14.2.6 With Credentials

### Send Cookies

```javascript
const source = new EventSource('/events', {
  withCredentials: true
});
```

---

## 14.2.7 Server Implementation

### Node.js Example

```javascript
// Express server
app.get('/events', (req, res) => {
  res.setHeader('Content-Type', 'text/event-stream');
  res.setHeader('Cache-Control', 'no-cache');
  res.setHeader('Connection', 'keep-alive');
  
  // Send event
  function send(data, event) {
    if (event) res.write(`event: ${event}\n`);
    res.write(`data: ${JSON.stringify(data)}\n\n`);
  }
  
  // Send initial data
  send({ connected: true });
  
  // Send updates
  const interval = setInterval(() => {
    send({ time: Date.now() }, 'tick');
  }, 1000);
  
  // Cleanup
  req.on('close', () => {
    clearInterval(interval);
  });
});
```

### Event Format

```
event: notification
id: 123
retry: 5000
data: {"message": "Hello"}
data: {"more": "data"}

```

---

## 14.2.8 SSE vs WebSocket

| Feature | SSE | WebSocket |
|---------|-----|-----------|
| Direction | Server → Client | Bidirectional |
| Protocol | HTTP | WS/WSS |
| Reconnection | Automatic | Manual |
| Binary data | No | Yes |
| Browser support | Wide | Wide |
| Simplicity | Simple | Complex |

### When to Use SSE

- Live feeds (news, stocks)
- Notifications
- Progress updates
- Any one-way streaming

---

## 14.2.9 Wrapper Class

### Enhanced EventSource

```javascript
class SSEClient {
  constructor(url, options = {}) {
    this.url = url;
    this.options = options;
    this.handlers = {};
    this.connect();
  }
  
  connect() {
    this.source = new EventSource(this.url, this.options);
    
    this.source.addEventListener('open', () => {
      console.log('SSE connected');
    });
    
    this.source.addEventListener('error', () => {
      if (this.source.readyState === EventSource.CLOSED) {
        console.log('SSE closed, not reconnecting');
      }
    });
    
    // Reattach handlers
    Object.keys(this.handlers).forEach(event => {
      this.source.addEventListener(event, this.handlers[event]);
    });
  }
  
  on(event, handler) {
    this.handlers[event] = handler;
    this.source.addEventListener(event, handler);
    return this;
  }
  
  close() {
    this.source.close();
  }
}

// Usage
const sse = new SSEClient('/events')
  .on('message', (e) => console.log(e.data))
  .on('update', (e) => handleUpdate(JSON.parse(e.data)));
```

---

## 14.2.10 Summary

### Constructor

```javascript
new EventSource(url)
new EventSource(url, { withCredentials: true })
```

### Properties

| Property | Description |
|----------|-------------|
| `readyState` | Connection state |
| `url` | Event source URL |
| `withCredentials` | Send cookies |

### Methods

| Method | Description |
|--------|-------------|
| `close()` | Close connection |

### Events

| Event | When |
|-------|------|
| `open` | Connection opened |
| `message` | Default message |
| `error` | Error/close |
| Custom | Named events |

### Best Practices

1. **Handle reconnection** states properly
2. **Use named events** for different data types
3. **Parse JSON** carefully
4. **Set proper headers** on server
5. **Clean up** on component unmount

---

**End of Chapter 14.2: Server-Sent Events**

Next chapter: **14.3 Beacon API** — send data on page unload.
# 14.3 Beacon API

The Beacon API provides an asynchronous way to send small amounts of data to a server, guaranteed to be sent even when the page is unloading.

---

## 14.3.1 Basic Usage

### sendBeacon

```javascript
// Send data when page unloads
window.addEventListener('beforeunload', () => {
  navigator.sendBeacon('/analytics', JSON.stringify({
    event: 'page_exit',
    timestamp: Date.now()
  }));
});
```

### Return Value

```javascript
const success = navigator.sendBeacon('/log', data);

if (success) {
  console.log('Beacon queued');
} else {
  console.log('Beacon failed to queue');
}
```

---

## 14.3.2 Data Types

### String Data

```javascript
navigator.sendBeacon('/log', 'user clicked button');
```

### JSON Data

```javascript
const data = { action: 'click', element: 'submit' };
navigator.sendBeacon('/log', JSON.stringify(data));
```

### FormData

```javascript
const formData = new FormData();
formData.append('event', 'pageview');
formData.append('url', location.href);

navigator.sendBeacon('/analytics', formData);
```

### Blob

```javascript
const blob = new Blob([JSON.stringify({ event: 'exit' })], {
  type: 'application/json'
});

navigator.sendBeacon('/log', blob);
```

### URLSearchParams

```javascript
const params = new URLSearchParams({
  event: 'click',
  target: 'button'
});

navigator.sendBeacon('/track', params);
```

---

## 14.3.3 Common Use Cases

### Analytics Tracking

```javascript
class Analytics {
  constructor(endpoint) {
    this.endpoint = endpoint;
    this.queue = [];
    
    window.addEventListener('beforeunload', () => this.flush());
  }
  
  track(event, data = {}) {
    this.queue.push({
      event,
      data,
      timestamp: Date.now()
    });
  }
  
  flush() {
    if (this.queue.length === 0) return;
    
    const blob = new Blob([JSON.stringify(this.queue)], {
      type: 'application/json'
    });
    
    navigator.sendBeacon(this.endpoint, blob);
    this.queue = [];
  }
}

const analytics = new Analytics('/analytics');
analytics.track('page_view', { path: location.pathname });
```

### Session Duration

```javascript
const sessionStart = Date.now();

window.addEventListener('beforeunload', () => {
  const duration = Date.now() - sessionStart;
  
  navigator.sendBeacon('/session', JSON.stringify({
    duration,
    pages: pageCount
  }));
});
```

### Error Reporting

```javascript
window.addEventListener('error', (event) => {
  const errorData = {
    message: event.message,
    filename: event.filename,
    lineno: event.lineno,
    colno: event.colno
  };
  
  // Queue error for reporting
  errorQueue.push(errorData);
});

window.addEventListener('beforeunload', () => {
  if (errorQueue.length > 0) {
    navigator.sendBeacon('/errors', JSON.stringify(errorQueue));
  }
});
```

---

## 14.3.4 Beacon vs Fetch

### Why Use Beacon?

```javascript
// ❌ Fetch might be cancelled on unload
window.addEventListener('beforeunload', () => {
  fetch('/log', {
    method: 'POST',
    body: JSON.stringify(data)
  });  // May not complete!
});

// ✅ Beacon is guaranteed to be sent
window.addEventListener('beforeunload', () => {
  navigator.sendBeacon('/log', JSON.stringify(data));
});
```

### Comparison

| Feature | Beacon | Fetch |
|---------|--------|-------|
| Unload safe | ✅ | ❌ |
| Response access | ❌ | ✅ |
| Custom headers | ❌ | ✅ |
| Max size | ~64KB | Unlimited |
| Method | POST only | Any |
| Async | Always | Configurable |

---

## 14.3.5 Limitations

### No Custom Headers

```javascript
// Cannot set Authorization or custom headers
// Use FormData or Blob with appropriate type
```

### POST Only

```javascript
// Always sends POST request
// Cannot use GET, PUT, DELETE, etc.
```

### No Response

```javascript
// Cannot read response
const result = navigator.sendBeacon('/log', data);
// result is just true/false for queue success
```

### Size Limit

```javascript
// Typically 64KB limit
// For larger data, use Fetch with keepalive
```

---

## 14.3.6 Fetch with keepalive

### Alternative for More Control

```javascript
// For larger payloads or custom headers
window.addEventListener('beforeunload', () => {
  fetch('/log', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(largeData),
    keepalive: true  // Survive page unload
  });
});
```

---

## 14.3.7 Summary

### Syntax

```javascript
navigator.sendBeacon(url)
navigator.sendBeacon(url, data)
```

### Data Types

| Type | Content-Type |
|------|--------------|
| String | text/plain |
| Blob | Blob's type |
| FormData | multipart/form-data |
| URLSearchParams | application/x-www-form-urlencoded |

### Best Practices

1. **Use for analytics** and logging
2. **Queue events** and flush on unload
3. **Keep payload small** (<64KB)
4. **Use Blob** for JSON with proper Content-Type
5. **Use keepalive fetch** for custom headers
6. **Don't rely on response**

---

**End of Chapter 14.3: Beacon API**

Next chapter: **14.4 Network Information API** — detect connection type and quality.
# 14.4 Network Information API

The Network Information API provides information about the system's connection type and quality. This enables adaptive content delivery based on network conditions.

---

## 14.4.1 Basic Usage

### Access Connection Info

```javascript
const connection = navigator.connection || 
                   navigator.mozConnection || 
                   navigator.webkitConnection;

if (connection) {
  console.log('Type:', connection.effectiveType);
  console.log('Downlink:', connection.downlink, 'Mbps');
  console.log('RTT:', connection.rtt, 'ms');
}
```

---

## 14.4.2 Connection Properties

### effectiveType

```javascript
// Effective connection type based on measured performance
// Values: 'slow-2g', '2g', '3g', '4g'

const connection = navigator.connection;

switch (connection.effectiveType) {
  case 'slow-2g':
  case '2g':
    loadLowQualityImages();
    break;
  case '3g':
    loadMediumQualityImages();
    break;
  case '4g':
    loadHighQualityImages();
    break;
}
```

### downlink

```javascript
// Estimated download speed in Mbps
const speed = connection.downlink;

if (speed < 1) {
  console.log('Slow connection');
} else if (speed < 5) {
  console.log('Moderate connection');
} else {
  console.log('Fast connection');
}
```

### rtt (Round-Trip Time)

```javascript
// Network round-trip time in milliseconds
const latency = connection.rtt;

if (latency > 500) {
  console.log('High latency connection');
}
```

### saveData

```javascript
// User has requested reduced data usage
if (connection.saveData) {
  disableAutoplay();
  loadCompressedAssets();
}
```

### type (Physical Connection)

```javascript
// Physical network type (limited support)
// Values: 'bluetooth', 'cellular', 'ethernet', 'wifi', 'wimax', 'none', 'other', 'unknown'

if (connection.type) {
  console.log('Connection type:', connection.type);
  
  if (connection.type === 'cellular') {
    warnAboutDataUsage();
  }
}
```

---

## 14.4.3 Change Events

### Monitor Connection Changes

```javascript
const connection = navigator.connection;

connection.addEventListener('change', () => {
  console.log('Connection changed');
  console.log('New type:', connection.effectiveType);
  console.log('New speed:', connection.downlink);
  
  updateContentQuality();
});
```

---

## 14.4.4 Adaptive Loading

### Image Quality

```javascript
function getImageQuality() {
  const connection = navigator.connection;
  
  if (!connection) return 'high';
  
  if (connection.saveData) return 'low';
  
  switch (connection.effectiveType) {
    case 'slow-2g':
    case '2g':
      return 'low';
    case '3g':
      return 'medium';
    default:
      return 'high';
  }
}

function loadImage(baseSrc) {
  const quality = getImageQuality();
  const img = new Image();
  
  img.src = `${baseSrc}?quality=${quality}`;
  return img;
}
```

### Video Quality

```javascript
function getVideoSource(sources) {
  const connection = navigator.connection;
  
  if (!connection) return sources.high;
  
  if (connection.effectiveType === '4g' && connection.downlink > 5) {
    return sources.high;
  } else if (connection.effectiveType === '3g') {
    return sources.medium;
  } else {
    return sources.low;
  }
}
```

### Prefetch Strategy

```javascript
function setupPrefetch() {
  const connection = navigator.connection;
  
  if (!connection) return;
  
  // Only prefetch on fast connections
  if (connection.effectiveType === '4g' && !connection.saveData) {
    prefetchNextPage();
    preloadImages();
  }
}
```

---

## 14.4.5 Complete Example

### Adaptive Media Loader

```javascript
class AdaptiveLoader {
  constructor() {
    this.connection = navigator.connection;
    this.quality = this.determineQuality();
    
    if (this.connection) {
      this.connection.addEventListener('change', () => {
        this.quality = this.determineQuality();
        this.onQualityChange?.(this.quality);
      });
    }
  }
  
  determineQuality() {
    if (!this.connection) return 'high';
    
    const { effectiveType, saveData, downlink } = this.connection;
    
    if (saveData) return 'low';
    
    if (effectiveType === '4g' && downlink > 5) return 'high';
    if (effectiveType === '3g' || downlink > 1) return 'medium';
    return 'low';
  }
  
  getImageSrc(baseSrc) {
    const sizes = { low: 480, medium: 720, high: 1080 };
    return `${baseSrc}?w=${sizes[this.quality]}`;
  }
  
  shouldAutoplay() {
    if (!this.connection) return true;
    return this.connection.effectiveType === '4g' && 
           !this.connection.saveData;
  }
  
  shouldPreload() {
    return this.quality === 'high';
  }
}

const loader = new AdaptiveLoader();
loader.onQualityChange = (quality) => {
  console.log('Quality changed to:', quality);
};
```

---

## 14.4.6 Browser Support

### Feature Detection

```javascript
function isNetworkInfoSupported() {
  return 'connection' in navigator || 
         'mozConnection' in navigator || 
         'webkitConnection' in navigator;
}

function getConnection() {
  return navigator.connection || 
         navigator.mozConnection || 
         navigator.webkitConnection;
}
```

### Polyfill Strategy

```javascript
function getNetworkInfo() {
  const connection = getConnection();
  
  if (connection) {
    return {
      effectiveType: connection.effectiveType || '4g',
      downlink: connection.downlink || 10,
      rtt: connection.rtt || 50,
      saveData: connection.saveData || false
    };
  }
  
  // Default fallback
  return {
    effectiveType: '4g',
    downlink: 10,
    rtt: 50,
    saveData: false
  };
}
```

---

## 14.4.7 Summary

### Properties

| Property | Type | Description |
|----------|------|-------------|
| `effectiveType` | String | '2g', '3g', '4g' |
| `downlink` | Number | Speed in Mbps |
| `rtt` | Number | Latency in ms |
| `saveData` | Boolean | Data saver enabled |
| `type` | String | Physical type |

### Events

| Event | When |
|-------|------|
| `change` | Connection changes |

### Best Practices

1. **Feature detect** before using
2. **Provide fallbacks** for unsupported browsers
3. **Respect saveData** preference
4. **Adapt content** based on connection
5. **Listen for changes** to update dynamically
6. **Don't block** on slow connections

---

**End of Chapter 14.4: Network Information API**

This completes Group 14 — Connectivity APIs. Next section: **Group 15 — Security and Authentication**.
# 15.1 File API

The File API provides access to file information and content selected by users through file inputs or drag-and-drop. This chapter covers File objects, FileList, and file metadata.

---

## 15.1.1 File Input

### Basic File Selection

```html
<input type="file" id="fileInput">
<input type="file" id="multiInput" multiple>
```

```javascript
const input = document.getElementById('fileInput');

input.addEventListener('change', (event) => {
  const file = event.target.files[0];
  
  if (file) {
    console.log('Name:', file.name);
    console.log('Size:', file.size, 'bytes');
    console.log('Type:', file.type);
    console.log('Last Modified:', new Date(file.lastModified));
  }
});
```

### Multiple Files

```javascript
const multiInput = document.getElementById('multiInput');

multiInput.addEventListener('change', (event) => {
  const files = event.target.files;  // FileList
  
  for (const file of files) {
    console.log(file.name);
  }
  
  // Or convert to array
  const fileArray = Array.from(files);
  fileArray.forEach(file => processFile(file));
});
```

---

## 15.1.2 File Object Properties

### Available Properties

```javascript
const file = input.files[0];

file.name;          // String - filename with extension
file.size;          // Number - size in bytes
file.type;          // String - MIME type (e.g., 'image/png')
file.lastModified;  // Number - timestamp
file.webkitRelativePath;  // String - path (for directories)
```

### Checking File Type

```javascript
function isImage(file) {
  return file.type.startsWith('image/');
}

function isPDF(file) {
  return file.type === 'application/pdf';
}

function isValidType(file, allowedTypes) {
  return allowedTypes.includes(file.type);
}

// Usage
if (isImage(file)) {
  displayImage(file);
}
```

### File Size Validation

```javascript
const MAX_SIZE = 5 * 1024 * 1024;  // 5MB

function validateFileSize(file, maxSize = MAX_SIZE) {
  if (file.size > maxSize) {
    throw new Error(`File too large. Max size: ${formatBytes(maxSize)}`);
  }
  return true;
}

function formatBytes(bytes) {
  if (bytes === 0) return '0 Bytes';
  const k = 1024;
  const sizes = ['Bytes', 'KB', 'MB', 'GB'];
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
}
```

---

## 15.1.3 FileList

### Working with FileList

```javascript
const files = input.files;  // FileList object

// Properties
files.length;  // Number of files

// Access by index
const firstFile = files[0];
const secondFile = files[1];

// Iterate
for (let i = 0; i < files.length; i++) {
  console.log(files[i].name);
}

// ❌ FileList is not an array
files.forEach(f => {});  // Error!

// ✅ Convert to array
Array.from(files).forEach(f => console.log(f.name));
[...files].forEach(f => console.log(f.name));
```

### Filter Files

```javascript
function filterImageFiles(fileList) {
  return Array.from(fileList).filter(file => 
    file.type.startsWith('image/')
  );
}

function filterByExtension(fileList, extensions) {
  return Array.from(fileList).filter(file => {
    const ext = '.' + file.name.split('.').pop().toLowerCase();
    return extensions.includes(ext);
  });
}

// Usage
const images = filterImageFiles(input.files);
const docs = filterByExtension(input.files, ['.pdf', '.doc', '.docx']);
```

---

## 15.1.4 Accept Attribute

### Restrict File Types

```html
<!-- Accept specific MIME types -->
<input type="file" accept="image/png, image/jpeg">

<!-- Accept by extension -->
<input type="file" accept=".pdf,.doc,.docx">

<!-- Accept categories -->
<input type="file" accept="image/*">
<input type="file" accept="audio/*">
<input type="file" accept="video/*">

<!-- Combine -->
<input type="file" accept="image/*,.pdf">
```

### Programmatic Accept

```javascript
const input = document.createElement('input');
input.type = 'file';
input.accept = 'image/*';
input.click();
```

---

## 15.1.5 Directory Selection

### webkitdirectory

```html
<input type="file" webkitdirectory>
```

```javascript
input.addEventListener('change', (event) => {
  const files = event.target.files;
  
  for (const file of files) {
    console.log('Path:', file.webkitRelativePath);
    console.log('Name:', file.name);
  }
});
```

---

## 15.1.6 Programmatic File Selection

### Create File Input

```javascript
function selectFile(accept = '*') {
  return new Promise((resolve, reject) => {
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = accept;
    
    input.addEventListener('change', () => {
      if (input.files.length > 0) {
        resolve(input.files[0]);
      } else {
        reject(new Error('No file selected'));
      }
    });
    
    input.addEventListener('cancel', () => {
      reject(new Error('Selection cancelled'));
    });
    
    input.click();
  });
}

// Usage
try {
  const file = await selectFile('image/*');
  console.log('Selected:', file.name);
} catch (error) {
  console.log('Cancelled');
}
```

### Select Multiple Files

```javascript
function selectFiles(accept = '*') {
  return new Promise((resolve) => {
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = accept;
    input.multiple = true;
    
    input.addEventListener('change', () => {
      resolve(Array.from(input.files));
    });
    
    input.click();
  });
}
```

---

## 15.1.7 File Validation

### Comprehensive Validator

```javascript
class FileValidator {
  constructor(options = {}) {
    this.maxSize = options.maxSize || 10 * 1024 * 1024;  // 10MB
    this.allowedTypes = options.allowedTypes || [];
    this.allowedExtensions = options.allowedExtensions || [];
  }
  
  validate(file) {
    const errors = [];
    
    // Size check
    if (file.size > this.maxSize) {
      errors.push(`File too large (${formatBytes(file.size)}). Max: ${formatBytes(this.maxSize)}`);
    }
    
    // Type check
    if (this.allowedTypes.length > 0 && !this.allowedTypes.includes(file.type)) {
      errors.push(`Invalid file type: ${file.type}`);
    }
    
    // Extension check
    if (this.allowedExtensions.length > 0) {
      const ext = '.' + file.name.split('.').pop().toLowerCase();
      if (!this.allowedExtensions.includes(ext)) {
        errors.push(`Invalid extension: ${ext}`);
      }
    }
    
    return {
      valid: errors.length === 0,
      errors
    };
  }
  
  validateAll(files) {
    return Array.from(files).map(file => ({
      file,
      ...this.validate(file)
    }));
  }
}

// Usage
const validator = new FileValidator({
  maxSize: 5 * 1024 * 1024,
  allowedTypes: ['image/jpeg', 'image/png'],
  allowedExtensions: ['.jpg', '.jpeg', '.png']
});

const result = validator.validate(file);
if (!result.valid) {
  console.log('Errors:', result.errors);
}
```

---

## 15.1.8 Summary

### File Properties

| Property | Type | Description |
|----------|------|-------------|
| `name` | String | Filename |
| `size` | Number | Size in bytes |
| `type` | String | MIME type |
| `lastModified` | Number | Timestamp |
| `webkitRelativePath` | String | Directory path |

### FileList Methods

| Method/Property | Description |
|----------------|-------------|
| `length` | Number of files |
| `[index]` | Access by index |
| `item(index)` | Access by index |

### Input Attributes

| Attribute | Purpose |
|-----------|---------|
| `accept` | Filter file types |
| `multiple` | Allow multiple files |
| `webkitdirectory` | Select directory |

### Best Practices

1. **Validate file type** on both client and server
2. **Check file size** before upload
3. **Convert FileList** to array for array methods
4. **Use accept** to guide users
5. **Provide feedback** on invalid files
6. **Handle cancel** gracefully

---

**End of Chapter 15.1: File API**

Next chapter: **15.2 FileReader** — reading file contents.
# 15.2 FileReader

FileReader provides asynchronous methods to read the contents of files or blobs. This chapter covers reading files as text, data URLs, and binary data.

---

## 15.2.1 Basic Usage

### Create FileReader

```javascript
const reader = new FileReader();

reader.addEventListener('load', (event) => {
  console.log('Result:', event.target.result);
});

reader.addEventListener('error', (event) => {
  console.error('Error:', event.target.error);
});

// Start reading
reader.readAsText(file);
```

---

## 15.2.2 Reading Methods

### readAsText

```javascript
const reader = new FileReader();

reader.onload = () => {
  const text = reader.result;
  console.log('Content:', text);
};

reader.readAsText(file);
reader.readAsText(file, 'UTF-8');  // With encoding
```

### readAsDataURL

```javascript
// For images, PDFs, etc.
const reader = new FileReader();

reader.onload = () => {
  const dataUrl = reader.result;
  // Example: "data:image/png;base64,iVBORw0KGgoAAAA..."
  
  const img = new Image();
  img.src = dataUrl;
  document.body.appendChild(img);
};

reader.readAsDataURL(imageFile);
```

### readAsArrayBuffer

```javascript
// For binary processing
const reader = new FileReader();

reader.onload = () => {
  const buffer = reader.result;  // ArrayBuffer
  const view = new Uint8Array(buffer);
  
  console.log('First byte:', view[0]);
  console.log('Size:', buffer.byteLength);
};

reader.readAsArrayBuffer(file);
```

### readAsBinaryString (Deprecated)

```javascript
// ❌ Deprecated - use readAsArrayBuffer instead
reader.readAsBinaryString(file);
```

---

## 15.2.3 Events

### All Events

```javascript
const reader = new FileReader();

// Reading started
reader.addEventListener('loadstart', () => {
  console.log('Started');
});

// Reading in progress
reader.addEventListener('progress', (event) => {
  if (event.lengthComputable) {
    const percent = (event.loaded / event.total) * 100;
    console.log(`Progress: ${percent.toFixed(2)}%`);
  }
});

// Reading complete
reader.addEventListener('load', () => {
  console.log('Complete');
});

// Reading aborted
reader.addEventListener('abort', () => {
  console.log('Aborted');
});

// Error occurred
reader.addEventListener('error', () => {
  console.error('Error:', reader.error);
});

// Reading finished (success, error, or abort)
reader.addEventListener('loadend', () => {
  console.log('Finished');
});
```

---

## 15.2.4 Properties

### State and Result

```javascript
const reader = new FileReader();

// State
reader.readyState;
// 0 = EMPTY (no data loaded)
// 1 = LOADING (reading in progress)
// 2 = DONE (reading complete)

// Result (after load)
reader.result;  // String, ArrayBuffer, or Data URL

// Error (if any)
reader.error;  // DOMException or null
```

---

## 15.2.5 Abort Reading

### Cancel In Progress

```javascript
const reader = new FileReader();

reader.addEventListener('abort', () => {
  console.log('Reading aborted');
});

reader.readAsText(largeFile);

// Cancel
document.getElementById('cancel').addEventListener('click', () => {
  reader.abort();
});
```

---

## 15.2.6 Progress Tracking

### Upload Progress UI

```javascript
function readWithProgress(file, onProgress) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    
    reader.addEventListener('progress', (event) => {
      if (event.lengthComputable && onProgress) {
        onProgress(event.loaded, event.total);
      }
    });
    
    reader.addEventListener('load', () => resolve(reader.result));
    reader.addEventListener('error', () => reject(reader.error));
    
    reader.readAsArrayBuffer(file);
  });
}

// Usage
const result = await readWithProgress(file, (loaded, total) => {
  const percent = ((loaded / total) * 100).toFixed(1);
  progressBar.style.width = percent + '%';
  progressText.textContent = `${percent}%`;
});
```

---

## 15.2.7 Promise Wrapper

### Promisified FileReader

```javascript
function readFile(file, method = 'readAsText') {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    
    reader.onload = () => resolve(reader.result);
    reader.onerror = () => reject(reader.error);
    
    reader[method](file);
  });
}

// Usage
const text = await readFile(file, 'readAsText');
const dataUrl = await readFile(file, 'readAsDataURL');
const buffer = await readFile(file, 'readAsArrayBuffer');
```

### Read as JSON

```javascript
async function readJSON(file) {
  const text = await readFile(file, 'readAsText');
  return JSON.parse(text);
}

try {
  const data = await readJSON(jsonFile);
  console.log(data);
} catch (error) {
  console.error('Invalid JSON:', error);
}
```

---

## 15.2.8 Image Preview

### Display Selected Image

```javascript
function previewImage(file, imgElement) {
  return new Promise((resolve, reject) => {
    if (!file.type.startsWith('image/')) {
      reject(new Error('Not an image'));
      return;
    }
    
    const reader = new FileReader();
    
    reader.onload = () => {
      imgElement.src = reader.result;
      resolve();
    };
    
    reader.onerror = () => reject(reader.error);
    
    reader.readAsDataURL(file);
  });
}

// Usage
const input = document.getElementById('imageInput');
const preview = document.getElementById('preview');

input.addEventListener('change', async (event) => {
  const file = event.target.files[0];
  if (file) {
    await previewImage(file, preview);
  }
});
```

### Multiple Image Preview

```javascript
async function previewImages(files, container) {
  container.innerHTML = '';
  
  for (const file of files) {
    if (!file.type.startsWith('image/')) continue;
    
    const img = document.createElement('img');
    img.style.maxWidth = '150px';
    
    await previewImage(file, img);
    container.appendChild(img);
  }
}
```

---

## 15.2.9 CSV Reader

### Parse CSV File

```javascript
async function readCSV(file) {
  const text = await readFile(file, 'readAsText');
  
  const lines = text.split('\n');
  const headers = lines[0].split(',').map(h => h.trim());
  
  const data = [];
  for (let i = 1; i < lines.length; i++) {
    if (lines[i].trim()) {
      const values = lines[i].split(',');
      const row = {};
      headers.forEach((header, index) => {
        row[header] = values[index]?.trim();
      });
      data.push(row);
    }
  }
  
  return { headers, data };
}
```

---

## 15.2.10 Summary

### Reading Methods

| Method | Returns | Use Case |
|--------|---------|----------|
| `readAsText(file, encoding?)` | String | Text files |
| `readAsDataURL(file)` | Data URL | Images, display |
| `readAsArrayBuffer(file)` | ArrayBuffer | Binary data |

### Events

| Event | When |
|-------|------|
| `loadstart` | Reading started |
| `progress` | Chunk read |
| `load` | Success |
| `error` | Error occurred |
| `abort` | Reading cancelled |
| `loadend` | Finished (any outcome) |

### Properties

| Property | Type | Description |
|----------|------|-------------|
| `result` | String/ArrayBuffer | Read data |
| `error` | DOMException | Error info |
| `readyState` | Number | 0, 1, or 2 |

### Best Practices

1. **Use promises** for cleaner code
2. **Track progress** for large files
3. **Handle errors** gracefully
4. **Abort** when component unmounts
5. **Validate** file type before reading
6. **Use ArrayBuffer** for binary processing

---

**End of Chapter 15.2: FileReader**

Next chapter: **15.3 Blob API** — creating and manipulating blobs.
# 15.3 Blob API

Blobs (Binary Large Objects) represent raw immutable data. This chapter covers creating blobs, manipulating them, and creating object URLs.

---

## 15.3.1 Creating Blobs

### From Arrays

```javascript
// From string
const textBlob = new Blob(['Hello, World!'], { type: 'text/plain' });

// From multiple parts
const multiBlob = new Blob(['Part 1', ' - ', 'Part 2'], { type: 'text/plain' });

// From JSON
const data = { name: 'John', age: 30 };
const jsonBlob = new Blob([JSON.stringify(data)], { type: 'application/json' });
```

### From TypedArrays

```javascript
// From Uint8Array
const bytes = new Uint8Array([72, 101, 108, 108, 111]);  // "Hello"
const byteBlob = new Blob([bytes], { type: 'application/octet-stream' });

// From ArrayBuffer
const buffer = new ArrayBuffer(8);
const bufferBlob = new Blob([buffer]);
```

### From Existing Blobs

```javascript
const blob1 = new Blob(['Part A']);
const blob2 = new Blob(['Part B']);

const combined = new Blob([blob1, blob2], { type: 'text/plain' });
```

---

## 15.3.2 Blob Properties

### Size and Type

```javascript
const blob = new Blob(['Hello'], { type: 'text/plain' });

blob.size;  // 5 (bytes)
blob.type;  // 'text/plain'
```

---

## 15.3.3 Blob Methods

### slice()

```javascript
const blob = new Blob(['Hello, World!'], { type: 'text/plain' });

// Extract portion
const hello = blob.slice(0, 5);
const world = blob.slice(7, 12);

// With content type
const slice = blob.slice(0, 5, 'text/plain');
```

### text()

```javascript
const blob = new Blob(['Hello, World!'], { type: 'text/plain' });

// Returns Promise<string>
const text = await blob.text();
console.log(text);  // 'Hello, World!'
```

### arrayBuffer()

```javascript
const blob = new Blob(['Hello'], { type: 'text/plain' });

// Returns Promise<ArrayBuffer>
const buffer = await blob.arrayBuffer();
const view = new Uint8Array(buffer);
console.log(view);  // Uint8Array([72, 101, 108, 108, 111])
```

### stream()

```javascript
const blob = new Blob(['Large content here...']);

// Returns ReadableStream
const stream = blob.stream();
const reader = stream.getReader();

while (true) {
  const { done, value } = await reader.read();
  if (done) break;
  console.log('Chunk:', value);
}
```

---

## 15.3.4 Object URLs

### Create Object URL

```javascript
const blob = new Blob(['Hello'], { type: 'text/plain' });

// Create URL
const url = URL.createObjectURL(blob);
console.log(url);  // 'blob:https://example.com/uuid'
```

### Display Image

```javascript
function displayImage(imageBlob) {
  const url = URL.createObjectURL(imageBlob);
  
  const img = document.createElement('img');
  img.src = url;
  
  // Revoke after load
  img.onload = () => URL.revokeObjectURL(url);
  
  document.body.appendChild(img);
}
```

### Revoke URL

```javascript
// ⚠️ Important: Always revoke to free memory
const url = URL.createObjectURL(blob);

// Use the URL...

// Then revoke
URL.revokeObjectURL(url);
```

---

## 15.3.5 Download Files

### Download Text File

```javascript
function downloadText(content, filename) {
  const blob = new Blob([content], { type: 'text/plain' });
  downloadBlob(blob, filename);
}

function downloadBlob(blob, filename) {
  const url = URL.createObjectURL(blob);
  
  const a = document.createElement('a');
  a.href = url;
  a.download = filename;
  
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  
  URL.revokeObjectURL(url);
}

// Usage
downloadText('Hello, World!', 'hello.txt');
```

### Download JSON

```javascript
function downloadJSON(data, filename) {
  const json = JSON.stringify(data, null, 2);
  const blob = new Blob([json], { type: 'application/json' });
  downloadBlob(blob, filename);
}
```

### Download Canvas

```javascript
async function downloadCanvas(canvas, filename) {
  const blob = await new Promise(resolve => 
    canvas.toBlob(resolve, 'image/png')
  );
  downloadBlob(blob, filename);
}
```

---

## 15.3.6 File from Blob

### Convert Blob to File

```javascript
const blob = new Blob(['File content'], { type: 'text/plain' });

// Create File from Blob
const file = new File([blob], 'document.txt', {
  type: 'text/plain',
  lastModified: Date.now()
});

console.log(file.name);  // 'document.txt'
console.log(file.size);  // 12
```

---

## 15.3.7 Fetch and Blobs

### Get Blob from URL

```javascript
async function fetchBlob(url) {
  const response = await fetch(url);
  return await response.blob();
}

const imageBlob = await fetchBlob('/image.png');
```

### Send Blob in Request

```javascript
const blob = new Blob(['data'], { type: 'application/octet-stream' });

fetch('/upload', {
  method: 'POST',
  body: blob
});

// Or with FormData
const formData = new FormData();
formData.append('file', blob, 'filename.txt');

fetch('/upload', {
  method: 'POST',
  body: formData
});
```

---

## 15.3.8 Blob Utilities

### Blob to Base64

```javascript
function blobToBase64(blob) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = () => resolve(reader.result);
    reader.onerror = reject;
    reader.readAsDataURL(blob);
  });
}

const base64 = await blobToBase64(blob);
```

### Base64 to Blob

```javascript
function base64ToBlob(base64, contentType = '') {
  const byteChars = atob(base64.split(',')[1]);
  const byteArrays = [];
  
  for (let i = 0; i < byteChars.length; i += 512) {
    const slice = byteChars.slice(i, i + 512);
    const byteNumbers = new Array(slice.length);
    
    for (let j = 0; j < slice.length; j++) {
      byteNumbers[j] = slice.charCodeAt(j);
    }
    
    byteArrays.push(new Uint8Array(byteNumbers));
  }
  
  return new Blob(byteArrays, { type: contentType });
}
```

### Resize Image Blob

```javascript
async function resizeImage(blob, maxWidth, maxHeight) {
  const img = await createImageBitmap(blob);
  
  let { width, height } = img;
  
  if (width > maxWidth) {
    height = (height / width) * maxWidth;
    width = maxWidth;
  }
  
  if (height > maxHeight) {
    width = (width / height) * maxHeight;
    height = maxHeight;
  }
  
  const canvas = new OffscreenCanvas(width, height);
  const ctx = canvas.getContext('2d');
  ctx.drawImage(img, 0, 0, width, height);
  
  return await canvas.convertToBlob({ type: 'image/jpeg', quality: 0.8 });
}
```

---

## 15.3.9 Summary

### Constructor

```javascript
new Blob(blobParts, options)
// blobParts: Array of strings, ArrayBuffers, other Blobs
// options: { type: MIME string, endings: 'native'|'transparent' }
```

### Properties

| Property | Type | Description |
|----------|------|-------------|
| `size` | Number | Size in bytes |
| `type` | String | MIME type |

### Methods

| Method | Returns | Description |
|--------|---------|-------------|
| `slice(start, end, type)` | Blob | Extract portion |
| `text()` | Promise<String> | Read as text |
| `arrayBuffer()` | Promise<ArrayBuffer> | Read as buffer |
| `stream()` | ReadableStream | Get stream |

### URL Methods

| Method | Description |
|--------|-------------|
| `URL.createObjectURL(blob)` | Create blob URL |
| `URL.revokeObjectURL(url)` | Free memory |

### Best Practices

1. **Revoke URLs** to prevent memory leaks
2. **Use slice** for large blob operations
3. **Set content type** for proper handling
4. **Use stream** for very large blobs
5. **Convert to File** when filename needed

---

**End of Chapter 15.3: Blob API**

Next chapter: **15.4 File System Access API** — read/write local files.
# 15.4 File System Access API

The File System Access API provides read and write access to the user's local file system. This chapter covers file pickers, handles, and file/directory operations.

---

## 15.4.1 File Picker

### Open File

```javascript
async function openFile() {
  try {
    const [fileHandle] = await window.showOpenFilePicker();
    const file = await fileHandle.getFile();
    const contents = await file.text();
    
    return { fileHandle, contents };
  } catch (error) {
    if (error.name === 'AbortError') {
      console.log('User cancelled');
    }
    throw error;
  }
}
```

### With Options

```javascript
const [fileHandle] = await window.showOpenFilePicker({
  types: [
    {
      description: 'Text Files',
      accept: {
        'text/plain': ['.txt'],
        'text/markdown': ['.md']
      }
    },
    {
      description: 'Images',
      accept: {
        'image/*': ['.png', '.jpg', '.jpeg', '.gif']
      }
    }
  ],
  excludeAcceptAllOption: false,  // Show "All files" option
  multiple: false  // Single file only
});
```

### Open Multiple Files

```javascript
const fileHandles = await window.showOpenFilePicker({
  multiple: true
});

for (const handle of fileHandles) {
  const file = await handle.getFile();
  console.log('File:', file.name);
}
```

---

## 15.4.2 Save File

### Save File Picker

```javascript
async function saveFile(contents) {
  const fileHandle = await window.showSaveFilePicker({
    suggestedName: 'untitled.txt',
    types: [
      {
        description: 'Text Files',
        accept: { 'text/plain': ['.txt'] }
      }
    ]
  });
  
  const writable = await fileHandle.createWritable();
  await writable.write(contents);
  await writable.close();
  
  return fileHandle;
}
```

### Write Options

```javascript
const writable = await fileHandle.createWritable({
  keepExistingData: false  // Truncate file
});

// Write string
await writable.write('Hello');

// Write at position
await writable.write({ type: 'write', position: 0, data: 'Hi' });

// Seek then write
await writable.seek(5);
await writable.write('World');

// Truncate
await writable.truncate(10);

await writable.close();
```

---

## 15.4.3 Directory Picker

### Select Directory

```javascript
async function openDirectory() {
  const dirHandle = await window.showDirectoryPicker({
    mode: 'read'  // 'read' or 'readwrite'
  });
  
  console.log('Directory:', dirHandle.name);
  return dirHandle;
}
```

### List Contents

```javascript
async function listDirectory(dirHandle) {
  const entries = [];
  
  for await (const entry of dirHandle.values()) {
    entries.push({
      name: entry.name,
      kind: entry.kind  // 'file' or 'directory'
    });
  }
  
  return entries;
}
```

### Recursive Listing

```javascript
async function listRecursive(dirHandle, path = '') {
  const entries = [];
  
  for await (const entry of dirHandle.values()) {
    const entryPath = path ? `${path}/${entry.name}` : entry.name;
    
    if (entry.kind === 'file') {
      entries.push({ path: entryPath, kind: 'file', handle: entry });
    } else {
      entries.push({ path: entryPath, kind: 'directory', handle: entry });
      const subEntries = await listRecursive(entry, entryPath);
      entries.push(...subEntries);
    }
  }
  
  return entries;
}
```

---

## 15.4.4 File Handles

### Get File from Handle

```javascript
const file = await fileHandle.getFile();

console.log('Name:', file.name);
console.log('Size:', file.size);
console.log('Type:', file.type);
console.log('Modified:', file.lastModified);

const text = await file.text();
```

### Create Writable Stream

```javascript
const writable = await fileHandle.createWritable();

// Write data
await writable.write('Content');

// Must close!
await writable.close();
```

### Query Permission

```javascript
// Check permission
const readPerm = await fileHandle.queryPermission({ mode: 'read' });
const writePerm = await fileHandle.queryPermission({ mode: 'readwrite' });

console.log('Read:', readPerm);    // 'granted', 'denied', or 'prompt'
console.log('Write:', writePerm);
```

### Request Permission

```javascript
async function requestWritePermission(fileHandle) {
  const options = { mode: 'readwrite' };
  
  // Check current permission
  if (await fileHandle.queryPermission(options) === 'granted') {
    return true;
  }
  
  // Request if needed
  if (await fileHandle.requestPermission(options) === 'granted') {
    return true;
  }
  
  return false;
}
```

---

## 15.4.5 Directory Operations

### Get File in Directory

```javascript
// Get existing file
const fileHandle = await dirHandle.getFileHandle('file.txt');

// Create if doesn't exist
const newFileHandle = await dirHandle.getFileHandle('new.txt', {
  create: true
});
```

### Get Subdirectory

```javascript
// Get existing directory
const subDir = await dirHandle.getDirectoryHandle('subdir');

// Create if doesn't exist
const newDir = await dirHandle.getDirectoryHandle('newdir', {
  create: true
});
```

### Remove Entry

```javascript
// Remove file
await dirHandle.removeEntry('file.txt');

// Remove directory (must be empty)
await dirHandle.removeEntry('subdir');

// Remove directory recursively
await dirHandle.removeEntry('subdir', { recursive: true });
```

### Resolve Path

```javascript
// Get path from directory to file
const path = await dirHandle.resolve(fileHandle);
// Returns ['subdir', 'file.txt'] or null if not descendant
```

---

## 15.4.6 Persisting Handles

### Store in IndexedDB

```javascript
// File handles can be stored in IndexedDB
async function saveHandle(name, handle) {
  const db = await openDatabase();
  const tx = db.transaction('handles', 'readwrite');
  await tx.store.put(handle, name);
}

async function getHandle(name) {
  const db = await openDatabase();
  return await db.get('handles', name);
}

// After page reload, re-request permission
const handle = await getHandle('myFile');
if (handle) {
  const permission = await handle.requestPermission({ mode: 'readwrite' });
  if (permission === 'granted') {
    // Use handle
  }
}
```

---

## 15.4.7 Complete Example

### Text Editor

```javascript
class FileEditor {
  constructor() {
    this.fileHandle = null;
    this.textarea = document.getElementById('editor');
  }
  
  async open() {
    const [handle] = await window.showOpenFilePicker({
      types: [{
        description: 'Text Files',
        accept: { 'text/plain': ['.txt'] }
      }]
    });
    
    this.fileHandle = handle;
    const file = await handle.getFile();
    this.textarea.value = await file.text();
  }
  
  async save() {
    if (!this.fileHandle) {
      return this.saveAs();
    }
    
    await this.writeFile(this.fileHandle);
  }
  
  async saveAs() {
    const handle = await window.showSaveFilePicker({
      suggestedName: 'document.txt',
      types: [{
        description: 'Text Files',
        accept: { 'text/plain': ['.txt'] }
      }]
    });
    
    this.fileHandle = handle;
    await this.writeFile(handle);
  }
  
  async writeFile(handle) {
    const writable = await handle.createWritable();
    await writable.write(this.textarea.value);
    await writable.close();
  }
}
```

---

## 15.4.8 Feature Detection

### Check Support

```javascript
function isFileSystemAccessSupported() {
  return 'showOpenFilePicker' in window;
}

if (!isFileSystemAccessSupported()) {
  // Fall back to <input type="file">
  showLegacyFilePicker();
}
```

---

## 15.4.9 Summary

### Picker Functions

| Function | Returns | Description |
|----------|---------|-------------|
| `showOpenFilePicker(options)` | FileSystemFileHandle[] | Open files |
| `showSaveFilePicker(options)` | FileSystemFileHandle | Save file |
| `showDirectoryPicker(options)` | FileSystemDirectoryHandle | Select directory |

### FileSystemFileHandle Methods

| Method | Returns | Description |
|--------|---------|-------------|
| `getFile()` | File | Get file object |
| `createWritable(options)` | WritableStream | Get write stream |
| `queryPermission(descriptor)` | String | Check permission |
| `requestPermission(descriptor)` | String | Request permission |

### FileSystemDirectoryHandle Methods

| Method | Returns | Description |
|--------|---------|-------------|
| `getFileHandle(name, options)` | FileHandle | Get/create file |
| `getDirectoryHandle(name, options)` | DirectoryHandle | Get/create directory |
| `removeEntry(name, options)` | void | Remove entry |
| `resolve(handle)` | String[] | Get path |
| `values()` | AsyncIterator | List entries |

### Best Practices

1. **Handle AbortError** when user cancels
2. **Request permission** after page reload
3. **Close writable streams** to save changes
4. **Use recursive option** carefully when deleting
5. **Fall back** to legacy file input when unsupported
6. **Persist handles** in IndexedDB for re-use

---

**End of Chapter 15.4: File System Access API**

Next chapter: **15.5 Drag and Drop Files** — handling file drops.
# 15.5 Drag and Drop Files

This chapter covers handling files dropped into a web page, including drag events, DataTransfer, and file extraction.

---

## 15.5.1 Basic Drop Zone

### HTML Setup

```html
<div id="dropzone">
  Drop files here
</div>

<style>
  #dropzone {
    border: 2px dashed #ccc;
    padding: 50px;
    text-align: center;
  }
  
  #dropzone.dragover {
    border-color: #2196F3;
    background: #e3f2fd;
  }
</style>
```

### Event Handling

```javascript
const dropzone = document.getElementById('dropzone');

// Prevent default to allow drop
dropzone.addEventListener('dragover', (e) => {
  e.preventDefault();
  dropzone.classList.add('dragover');
});

dropzone.addEventListener('dragleave', (e) => {
  dropzone.classList.remove('dragover');
});

dropzone.addEventListener('drop', (e) => {
  e.preventDefault();
  dropzone.classList.remove('dragover');
  
  const files = e.dataTransfer.files;
  handleFiles(files);
});

function handleFiles(files) {
  for (const file of files) {
    console.log('Dropped:', file.name);
  }
}
```

---

## 15.5.2 DataTransfer Object

### Access Files

```javascript
dropzone.addEventListener('drop', (e) => {
  e.preventDefault();
  
  // FileList
  const files = e.dataTransfer.files;
  console.log('File count:', files.length);
  
  // Items (for more control)
  const items = e.dataTransfer.items;
  for (const item of items) {
    if (item.kind === 'file') {
      const file = item.getAsFile();
      console.log('File:', file.name);
    }
  }
});
```

### DataTransfer Properties

```javascript
dropzone.addEventListener('drop', (e) => {
  const dt = e.dataTransfer;
  
  dt.files;       // FileList
  dt.items;       // DataTransferItemList
  dt.types;       // Array of types ('Files', 'text/plain', etc.)
  dt.dropEffect;  // 'copy', 'move', 'link', 'none'
});
```

---

## 15.5.3 Drag Feedback

### Visual Feedback

```javascript
dropzone.addEventListener('dragenter', (e) => {
  e.preventDefault();
  dropzone.classList.add('dragover');
});

dropzone.addEventListener('dragover', (e) => {
  e.preventDefault();
  e.dataTransfer.dropEffect = 'copy';  // Show copy cursor
});

dropzone.addEventListener('dragleave', (e) => {
  // Only remove if leaving the dropzone itself
  if (e.target === dropzone) {
    dropzone.classList.remove('dragover');
  }
});
```

### Better dragenter/dragleave

```javascript
// Counter to handle nested elements
let dragCounter = 0;

dropzone.addEventListener('dragenter', (e) => {
  e.preventDefault();
  dragCounter++;
  dropzone.classList.add('dragover');
});

dropzone.addEventListener('dragleave', (e) => {
  dragCounter--;
  if (dragCounter === 0) {
    dropzone.classList.remove('dragover');
  }
});

dropzone.addEventListener('drop', (e) => {
  e.preventDefault();
  dragCounter = 0;
  dropzone.classList.remove('dragover');
  // Handle files...
});
```

---

## 15.5.4 File Type Validation

### Check During Drag

```javascript
dropzone.addEventListener('dragover', (e) => {
  e.preventDefault();
  
  // Check if files are being dragged
  if (e.dataTransfer.types.includes('Files')) {
    e.dataTransfer.dropEffect = 'copy';
  } else {
    e.dataTransfer.dropEffect = 'none';
  }
});
```

### Validate on Drop

```javascript
const allowedTypes = ['image/jpeg', 'image/png', 'image/gif'];

dropzone.addEventListener('drop', (e) => {
  e.preventDefault();
  
  const validFiles = [];
  const invalidFiles = [];
  
  for (const file of e.dataTransfer.files) {
    if (allowedTypes.includes(file.type)) {
      validFiles.push(file);
    } else {
      invalidFiles.push(file);
    }
  }
  
  if (invalidFiles.length > 0) {
    alert(`Invalid files: ${invalidFiles.map(f => f.name).join(', ')}`);
  }
  
  handleFiles(validFiles);
});
```

---

## 15.5.5 Directory Drop

### Handle Dropped Directories

```javascript
dropzone.addEventListener('drop', async (e) => {
  e.preventDefault();
  
  const items = e.dataTransfer.items;
  
  for (const item of items) {
    // getAsFileSystemHandle() for File System Access API
    if (item.getAsFileSystemHandle) {
      const handle = await item.getAsFileSystemHandle();
      
      if (handle.kind === 'directory') {
        await processDirectory(handle);
      } else {
        await processFile(handle);
      }
    } else {
      // Fallback for older browsers
      const entry = item.webkitGetAsEntry();
      if (entry) {
        await readEntry(entry);
      }
    }
  }
});

async function processDirectory(dirHandle) {
  for await (const entry of dirHandle.values()) {
    if (entry.kind === 'file') {
      const file = await entry.getFile();
      console.log('File:', file.name);
    } else {
      await processDirectory(entry);
    }
  }
}
```

### Legacy webkitGetAsEntry

```javascript
function readEntry(entry) {
  if (entry.isFile) {
    entry.file(file => {
      console.log('File:', file.name);
    });
  } else if (entry.isDirectory) {
    const reader = entry.createReader();
    reader.readEntries(entries => {
      entries.forEach(readEntry);
    });
  }
}
```

---

## 15.5.6 Image Preview

### Preview Dropped Images

```javascript
const preview = document.getElementById('preview');

dropzone.addEventListener('drop', (e) => {
  e.preventDefault();
  preview.innerHTML = '';
  
  for (const file of e.dataTransfer.files) {
    if (file.type.startsWith('image/')) {
      const img = document.createElement('img');
      img.src = URL.createObjectURL(file);
      img.onload = () => URL.revokeObjectURL(img.src);
      img.style.maxWidth = '200px';
      preview.appendChild(img);
    }
  }
});
```

---

## 15.5.7 Complete Drop Zone Component

### Reusable Component

```javascript
class DropZone {
  constructor(element, options = {}) {
    this.element = element;
    this.options = {
      accept: options.accept || '*',
      multiple: options.multiple ?? true,
      onFiles: options.onFiles || (() => {}),
      onError: options.onError || console.error
    };
    
    this.dragCounter = 0;
    this.bindEvents();
  }
  
  bindEvents() {
    this.element.addEventListener('dragenter', this.onDragEnter.bind(this));
    this.element.addEventListener('dragover', this.onDragOver.bind(this));
    this.element.addEventListener('dragleave', this.onDragLeave.bind(this));
    this.element.addEventListener('drop', this.onDrop.bind(this));
  }
  
  onDragEnter(e) {
    e.preventDefault();
    this.dragCounter++;
    this.element.classList.add('dragover');
  }
  
  onDragOver(e) {
    e.preventDefault();
    e.dataTransfer.dropEffect = 'copy';
  }
  
  onDragLeave(e) {
    this.dragCounter--;
    if (this.dragCounter === 0) {
      this.element.classList.remove('dragover');
    }
  }
  
  onDrop(e) {
    e.preventDefault();
    this.dragCounter = 0;
    this.element.classList.remove('dragover');
    
    const files = this.filterFiles([...e.dataTransfer.files]);
    
    if (!this.options.multiple && files.length > 1) {
      files.length = 1;
    }
    
    if (files.length > 0) {
      this.options.onFiles(files);
    }
  }
  
  filterFiles(files) {
    if (this.options.accept === '*') return files;
    
    const types = this.options.accept.split(',').map(t => t.trim());
    
    return files.filter(file => {
      return types.some(type => {
        if (type.endsWith('/*')) {
          return file.type.startsWith(type.replace('/*', '/'));
        }
        if (type.startsWith('.')) {
          return file.name.toLowerCase().endsWith(type);
        }
        return file.type === type;
      });
    });
  }
}

// Usage
new DropZone(document.getElementById('dropzone'), {
  accept: 'image/*,.pdf',
  multiple: true,
  onFiles: (files) => {
    files.forEach(f => console.log('Received:', f.name));
  }
});
```

---

## 15.5.8 Summary

### Events

| Event | Description |
|-------|-------------|
| `dragenter` | File enters drop zone |
| `dragover` | File is over drop zone |
| `dragleave` | File leaves drop zone |
| `drop` | File is dropped |

### DataTransfer Properties

| Property | Type | Description |
|----------|------|-------------|
| `files` | FileList | Dropped files |
| `items` | DataTransferItemList | All items |
| `types` | Array | Data types |
| `dropEffect` | String | Drop effect |

### Best Practices

1. **Prevent default** on dragover and drop
2. **Use counter** for drag enter/leave
3. **Validate file types** on drop
4. **Provide visual feedback** during drag
5. **Handle directories** when needed
6. **Clean up object URLs** after use

---

**End of Chapter 15.5: Drag and Drop Files**

This completes Group 15 — File APIs. Next section: **Group 16 — Clipboard API**.
# 16.1 Clipboard Operations

The modern Clipboard API provides asynchronous read/write access to the system clipboard. This chapter covers text, images, and rich content operations.

---

## 16.1.1 Check Support

### Feature Detection

```javascript
function isClipboardSupported() {
  return navigator.clipboard !== undefined;
}

function canWriteText() {
  return navigator.clipboard?.writeText !== undefined;
}

function canReadText() {
  return navigator.clipboard?.readText !== undefined;
}

function canWrite() {
  return navigator.clipboard?.write !== undefined;
}
```

---

## 16.1.2 Write Text

### Copy Text to Clipboard

```javascript
async function copyText(text) {
  try {
    await navigator.clipboard.writeText(text);
    console.log('Copied!');
  } catch (error) {
    console.error('Copy failed:', error);
  }
}

// Usage
await copyText('Hello, World!');
```

### Copy Button Example

```javascript
const copyButton = document.getElementById('copy');
const textInput = document.getElementById('text');

copyButton.addEventListener('click', async () => {
  try {
    await navigator.clipboard.writeText(textInput.value);
    copyButton.textContent = 'Copied!';
    setTimeout(() => {
      copyButton.textContent = 'Copy';
    }, 2000);
  } catch (error) {
    copyButton.textContent = 'Failed';
  }
});
```

---

## 16.1.3 Read Text

### Paste Text from Clipboard

```javascript
async function pasteText() {
  try {
    const text = await navigator.clipboard.readText();
    console.log('Pasted:', text);
    return text;
  } catch (error) {
    console.error('Paste failed:', error);
  }
}
```

### Permission Required

```javascript
// Reading requires user permission
// Browser shows permission prompt automatically

async function readWithPermissionCheck() {
  try {
    const permission = await navigator.permissions.query({
      name: 'clipboard-read'
    });
    
    if (permission.state === 'denied') {
      console.log('Clipboard access denied');
      return null;
    }
    
    return await navigator.clipboard.readText();
  } catch (error) {
    console.error('Error:', error);
  }
}
```

---

## 16.1.4 Write Rich Content

### ClipboardItem

```javascript
// Write multiple formats
async function copyRichText(text, html) {
  const item = new ClipboardItem({
    'text/plain': new Blob([text], { type: 'text/plain' }),
    'text/html': new Blob([html], { type: 'text/html' })
  });
  
  await navigator.clipboard.write([item]);
}

// Usage
await copyRichText(
  'Hello World',
  '<b>Hello</b> <i>World</i>'
);
```

### Copy Image

```javascript
async function copyImage(imageUrl) {
  const response = await fetch(imageUrl);
  const blob = await response.blob();
  
  const item = new ClipboardItem({
    [blob.type]: blob
  });
  
  await navigator.clipboard.write([item]);
}

// From canvas
async function copyCanvas(canvas) {
  const blob = await new Promise(resolve => 
    canvas.toBlob(resolve, 'image/png')
  );
  
  const item = new ClipboardItem({
    'image/png': blob
  });
  
  await navigator.clipboard.write([item]);
}
```

---

## 16.1.5 Read Rich Content

### Read All Formats

```javascript
async function readClipboard() {
  const items = await navigator.clipboard.read();
  
  for (const item of items) {
    console.log('Types:', item.types);
    
    for (const type of item.types) {
      const blob = await item.getType(type);
      
      if (type === 'text/plain') {
        console.log('Text:', await blob.text());
      } else if (type === 'text/html') {
        console.log('HTML:', await blob.text());
      } else if (type.startsWith('image/')) {
        displayImage(blob);
      }
    }
  }
}
```

### Read Image

```javascript
async function pasteImage() {
  const items = await navigator.clipboard.read();
  
  for (const item of items) {
    for (const type of item.types) {
      if (type.startsWith('image/')) {
        const blob = await item.getType(type);
        return URL.createObjectURL(blob);
      }
    }
  }
  
  return null;
}
```

---

## 16.1.6 Clipboard Events

### Listen for Copy/Paste

```javascript
document.addEventListener('copy', (e) => {
  console.log('Copy event');
  
  // Modify copied content
  const selection = window.getSelection().toString();
  e.clipboardData.setData('text/plain', selection.toUpperCase());
  e.preventDefault();
});

document.addEventListener('paste', (e) => {
  console.log('Paste event');
  
  const text = e.clipboardData.getData('text/plain');
  console.log('Pasted:', text);
  
  // Prevent default paste
  e.preventDefault();
  // Insert modified content
  document.execCommand('insertText', false, text.trim());
});

document.addEventListener('cut', (e) => {
  console.log('Cut event');
});
```

### Clipboard Event Data

```javascript
document.addEventListener('paste', (e) => {
  const clipboardData = e.clipboardData;
  
  // Available types
  console.log('Types:', clipboardData.types);
  
  // Get specific type
  const text = clipboardData.getData('text/plain');
  const html = clipboardData.getData('text/html');
  
  // Files (for images)
  if (clipboardData.files.length > 0) {
    const file = clipboardData.files[0];
    handlePastedFile(file);
  }
});
```

---

## 16.1.7 Paste Image from Clipboard

### Handle Pasted Images

```javascript
document.addEventListener('paste', async (e) => {
  const items = e.clipboardData.items;
  
  for (const item of items) {
    if (item.type.startsWith('image/')) {
      const file = item.getAsFile();
      displayPastedImage(file);
      e.preventDefault();
      break;
    }
  }
});

function displayPastedImage(file) {
  const url = URL.createObjectURL(file);
  const img = document.createElement('img');
  img.src = url;
  img.onload = () => URL.revokeObjectURL(url);
  document.body.appendChild(img);
}
```

---

## 16.1.8 Security Considerations

### HTTPS Required

```javascript
// Clipboard API requires secure context (HTTPS)
if (!window.isSecureContext) {
  console.warn('Clipboard API requires HTTPS');
}
```

### User Gesture Required

```javascript
// Write operations need user gesture
// ❌ This won't work on page load
window.addEventListener('load', async () => {
  await navigator.clipboard.writeText('Hello');  // May fail
});

// ✅ This works - triggered by user action
button.addEventListener('click', async () => {
  await navigator.clipboard.writeText('Hello');  // Works
});
```

### Permission Best Practices

```javascript
async function safeCopy(text) {
  // Check if we have permission first
  try {
    const permission = await navigator.permissions.query({
      name: 'clipboard-write'
    });
    
    if (permission.state === 'denied') {
      showManualCopyDialog(text);
      return false;
    }
    
    await navigator.clipboard.writeText(text);
    return true;
  } catch (error) {
    // Fall back to legacy method
    return legacyCopy(text);
  }
}
```

---

## 16.1.9 Summary

### Write Methods

| Method | Description |
|--------|-------------|
| `writeText(text)` | Copy text |
| `write(items)` | Copy rich content |

### Read Methods

| Method | Description |
|--------|-------------|
| `readText()` | Paste text |
| `read()` | Paste rich content |

### ClipboardItem

```javascript
new ClipboardItem({
  'text/plain': blob,
  'text/html': blob,
  'image/png': blob
});
```

### Events

| Event | When |
|-------|------|
| `copy` | User copies |
| `cut` | User cuts |
| `paste` | User pastes |

### Best Practices

1. **Check support** before using
2. **Handle errors** gracefully
3. **Require user gesture** for writes
4. **Use HTTPS** in production
5. **Provide fallback** for unsupported browsers
6. **Request permission** when needed

---

**End of Chapter 16.1: Clipboard Operations**

Next chapter: **16.2 Legacy Clipboard** — execCommand and older approaches.
# 16.2 Legacy Clipboard

Before the modern Clipboard API, clipboard operations used `document.execCommand()`. This chapter covers legacy methods for broader compatibility.

---

## 16.2.1 execCommand Basics

### Copy with execCommand

```javascript
function legacyCopy(text) {
  // Create temporary element
  const textarea = document.createElement('textarea');
  textarea.value = text;
  textarea.style.position = 'fixed';
  textarea.style.left = '-9999px';
  
  document.body.appendChild(textarea);
  textarea.select();
  
  try {
    const success = document.execCommand('copy');
    console.log(success ? 'Copied!' : 'Copy failed');
    return success;
  } catch (error) {
    console.error('Copy error:', error);
    return false;
  } finally {
    document.body.removeChild(textarea);
  }
}
```

### Cut and Paste

```javascript
// Cut selected text
document.execCommand('cut');

// Paste (requires permission, rarely works)
document.execCommand('paste');
```

---

## 16.2.2 Copy Selected Text

### Copy Current Selection

```javascript
function copySelection() {
  const selection = window.getSelection().toString();
  
  if (selection) {
    return document.execCommand('copy');
  }
  
  return false;
}
```

### Copy from Input

```javascript
function copyFromInput(input) {
  input.select();
  input.setSelectionRange(0, input.value.length);
  
  const success = document.execCommand('copy');
  
  // Deselect
  input.setSelectionRange(0, 0);
  input.blur();
  
  return success;
}
```

---

## 16.2.3 Copy Specific Element

### Copy Element Content

```javascript
function copyElement(element) {
  const range = document.createRange();
  range.selectNodeContents(element);
  
  const selection = window.getSelection();
  selection.removeAllRanges();
  selection.addRange(range);
  
  const success = document.execCommand('copy');
  
  selection.removeAllRanges();
  
  return success;
}

// Usage
const codeBlock = document.querySelector('pre code');
copyElement(codeBlock);
```

---

## 16.2.4 Clipboard Events (Legacy)

### Intercept Copy

```javascript
document.addEventListener('copy', (e) => {
  const selection = window.getSelection().toString();
  
  // Modify copied text
  e.clipboardData.setData('text/plain', 
    selection + '\n\nCopied from MySite.com'
  );
  
  e.preventDefault();
});
```

### Intercept Paste

```javascript
document.addEventListener('paste', (e) => {
  // Get pasted text
  const text = e.clipboardData.getData('text/plain');
  const html = e.clipboardData.getData('text/html');
  
  // Prevent default and handle manually
  e.preventDefault();
  
  // Insert plain text
  document.execCommand('insertText', false, text);
});
```

### Intercept Cut

```javascript
document.addEventListener('cut', (e) => {
  const selection = window.getSelection().toString();
  
  e.clipboardData.setData('text/plain', selection);
  
  // Delete selection
  document.execCommand('delete');
  
  e.preventDefault();
});
```

---

## 16.2.5 contenteditable Integration

### Copy from Editable

```javascript
const editor = document.querySelector('[contenteditable]');

function copyEditorContent() {
  editor.focus();
  document.execCommand('selectAll');
  document.execCommand('copy');
  window.getSelection().removeAllRanges();
}
```

### Paste into Editable

```javascript
// Paste plain text only
editor.addEventListener('paste', (e) => {
  e.preventDefault();
  
  const text = e.clipboardData.getData('text/plain');
  document.execCommand('insertText', false, text);
});
```

---

## 16.2.6 Cross-Browser Fallback

### Modern + Legacy

```javascript
async function copy(text) {
  // Try modern API first
  if (navigator.clipboard?.writeText) {
    try {
      await navigator.clipboard.writeText(text);
      return true;
    } catch (error) {
      console.warn('Modern clipboard failed, trying fallback');
    }
  }
  
  // Fallback to execCommand
  return legacyCopy(text);
}

function legacyCopy(text) {
  const textarea = document.createElement('textarea');
  textarea.value = text;
  textarea.setAttribute('readonly', '');
  textarea.style.cssText = 'position:fixed;left:-9999px';
  
  document.body.appendChild(textarea);
  textarea.select();
  
  let success = false;
  try {
    success = document.execCommand('copy');
  } catch (e) {}
  
  document.body.removeChild(textarea);
  return success;
}
```

### Read with Fallback

```javascript
async function paste() {
  // Modern API (requires permission)
  if (navigator.clipboard?.readText) {
    try {
      return await navigator.clipboard.readText();
    } catch (error) {
      console.warn('Clipboard read failed');
    }
  }
  
  // No reliable legacy fallback for reading
  // Must handle via paste event
  return null;
}
```

---

## 16.2.7 Deprecation Status

### execCommand Status

```javascript
// execCommand is deprecated but still widely used
// Modern browsers still support it

// Check support
if (document.queryCommandSupported('copy')) {
  console.log('execCommand copy supported');
}

// Check if enabled
if (document.queryCommandEnabled('copy')) {
  console.log('execCommand copy enabled');
}
```

### Migration Path

```javascript
// Recommend modern API with fallback
const clipboard = {
  async write(text) {
    if (navigator.clipboard?.writeText) {
      return navigator.clipboard.writeText(text);
    }
    return legacyCopy(text);
  },
  
  async read() {
    if (navigator.clipboard?.readText) {
      return navigator.clipboard.readText();
    }
    throw new Error('Clipboard read not supported');
  }
};
```

---

## 16.2.8 Summary

### execCommand Methods

| Command | Description |
|---------|-------------|
| `copy` | Copy selection |
| `cut` | Cut selection |
| `paste` | Paste clipboard |
| `selectAll` | Select all content |
| `delete` | Delete selection |
| `insertText` | Insert text |

### Event Methods

| Method | Description |
|--------|-------------|
| `getData(type)` | Get clipboard data |
| `setData(type, data)` | Set clipboard data |
| `clearData(type)` | Clear clipboard |

### Best Practices

1. **Use modern API** when available
2. **Provide legacy fallback** for compatibility
3. **Use textarea** trick for copying text
4. **Handle paste events** for reading
5. **Prevent default** when modifying
6. **Clean up** temporary elements

---

**End of Chapter 16.2: Legacy Clipboard**

This completes Group 16 — Clipboard API. Next section: **Group 17 — Payment APIs**.
# 17.1 Payment Request API

The Payment Request API provides a standardized way to collect payment information, integrating with browsers' stored payment methods and digital wallets.

---

## 17.1.1 Basic Usage

### Create Payment Request

```javascript
// Check support
if (!window.PaymentRequest) {
  console.log('Payment Request API not supported');
  showFallbackCheckout();
}

// Define payment methods
const methods = [{
  supportedMethods: 'basic-card',
  data: {
    supportedNetworks: ['visa', 'mastercard', 'amex'],
    supportedTypes: ['credit', 'debit']
  }
}];

// Define payment details
const details = {
  total: {
    label: 'Total',
    amount: { currency: 'USD', value: '99.99' }
  }
};

// Create request
const request = new PaymentRequest(methods, details);
```

---

## 17.1.2 Show Payment UI

### Display and Process

```javascript
async function processPayment() {
  const methods = [{ supportedMethods: 'basic-card' }];
  
  const details = {
    total: {
      label: 'Total',
      amount: { currency: 'USD', value: '49.99' }
    }
  };
  
  try {
    const request = new PaymentRequest(methods, details);
    const response = await request.show();
    
    // Process payment
    const result = await submitToServer(response);
    
    if (result.success) {
      await response.complete('success');
    } else {
      await response.complete('fail');
    }
    
  } catch (error) {
    if (error.name === 'AbortError') {
      console.log('User cancelled payment');
    } else {
      console.error('Payment error:', error);
    }
  }
}
```

---

## 17.1.3 Payment Details

### Line Items

```javascript
const details = {
  displayItems: [
    {
      label: 'Product',
      amount: { currency: 'USD', value: '89.99' }
    },
    {
      label: 'Shipping',
      amount: { currency: 'USD', value: '10.00' }
    },
    {
      label: 'Discount',
      amount: { currency: 'USD', value: '-10.00' }
    }
  ],
  total: {
    label: 'Total',
    amount: { currency: 'USD', value: '89.99' }
  }
};
```

### Shipping Options

```javascript
const details = {
  total: {
    label: 'Total',
    amount: { currency: 'USD', value: '99.99' }
  },
  shippingOptions: [
    {
      id: 'standard',
      label: 'Standard Shipping (5-7 days)',
      amount: { currency: 'USD', value: '5.00' },
      selected: true
    },
    {
      id: 'express',
      label: 'Express Shipping (2-3 days)',
      amount: { currency: 'USD', value: '15.00' }
    }
  ]
};
```

---

## 17.1.4 Request Options

### Collect Additional Info

```javascript
const options = {
  requestPayerName: true,
  requestPayerEmail: true,
  requestPayerPhone: true,
  requestShipping: true,
  shippingType: 'shipping'  // 'shipping', 'delivery', or 'pickup'
};

const request = new PaymentRequest(methods, details, options);
```

---

## 17.1.5 Handle Events

### Shipping Address Change

```javascript
const request = new PaymentRequest(methods, details, {
  requestShipping: true
});

request.addEventListener('shippingaddresschange', async (event) => {
  const address = request.shippingAddress;
  
  // Calculate shipping based on address
  event.updateWith(
    calculateShipping(address).then(updatedDetails => updatedDetails)
  );
});

async function calculateShipping(address) {
  // API call to calculate shipping
  const shipping = await fetch('/api/shipping', {
    method: 'POST',
    body: JSON.stringify({ country: address.country })
  }).then(r => r.json());
  
  return {
    ...details,
    shippingOptions: shipping.options,
    total: {
      label: 'Total',
      amount: { currency: 'USD', value: shipping.total }
    }
  };
}
```

### Shipping Option Change

```javascript
request.addEventListener('shippingoptionchange', (event) => {
  const selectedId = request.shippingOption;
  
  event.updateWith(
    updateTotal(selectedId).then(updatedDetails => updatedDetails)
  );
});
```

---

## 17.1.6 Payment Response

### Access Response Data

```javascript
const response = await request.show();

// Card details
response.methodName;           // 'basic-card'
response.details.cardNumber;   // '4111111111111111'
response.details.expiryMonth;  // '12'
response.details.expiryYear;   // '2025'
response.details.cardSecurityCode;  // '123'
response.details.billingAddress;

// Payer info
response.payerName;
response.payerEmail;
response.payerPhone;

// Shipping
response.shippingAddress;
response.shippingOption;

// Complete the payment
await response.complete('success');
```

---

## 17.1.7 Can Make Payment

### Check Before Showing

```javascript
async function checkout() {
  const request = new PaymentRequest(methods, details);
  
  // Check if payment can be made
  const canPay = await request.canMakePayment();
  
  if (canPay) {
    const response = await request.show();
    // Process...
  } else {
    // Show fallback checkout
    showManualCheckout();
  }
}
```

---

## 17.1.8 Abort Payment

### Cancel Request

```javascript
const request = new PaymentRequest(methods, details);

// Store request for later cancellation
let paymentPromise;

function startPayment() {
  paymentPromise = request.show();
}

function cancelPayment() {
  request.abort();
}

// Handle abort
try {
  await paymentPromise;
} catch (error) {
  if (error.name === 'AbortError') {
    console.log('Payment was aborted');
  }
}
```

---

## 17.1.9 Complete Example

### E-Commerce Checkout

```javascript
class PaymentHandler {
  constructor() {
    this.request = null;
  }
  
  createRequest(cart) {
    const methods = [
      { supportedMethods: 'basic-card' }
    ];
    
    const details = {
      displayItems: cart.items.map(item => ({
        label: item.name,
        amount: { currency: 'USD', value: item.price.toFixed(2) }
      })),
      total: {
        label: 'Total',
        amount: { currency: 'USD', value: cart.total.toFixed(2) }
      }
    };
    
    const options = {
      requestPayerEmail: true,
      requestShipping: true
    };
    
    this.request = new PaymentRequest(methods, details, options);
    
    this.request.addEventListener('shippingaddresschange', 
      this.onAddressChange.bind(this));
    
    return this.request;
  }
  
  async onAddressChange(event) {
    const address = this.request.shippingAddress;
    
    event.updateWith(
      this.calculateUpdatedDetails(address)
    );
  }
  
  async checkout(cart) {
    if (!window.PaymentRequest) {
      return this.fallbackCheckout(cart);
    }
    
    try {
      this.createRequest(cart);
      
      if (!await this.request.canMakePayment()) {
        return this.fallbackCheckout(cart);
      }
      
      const response = await this.request.show();
      const result = await this.processPayment(response);
      
      await response.complete(result.success ? 'success' : 'fail');
      
      return result;
      
    } catch (error) {
      if (error.name !== 'AbortError') {
        console.error('Payment failed:', error);
      }
      return { success: false, error };
    }
  }
}
```

---

## 17.1.10 Summary

### Constructor

```javascript
new PaymentRequest(methodData, details, options)
```

### Methods

| Method | Returns | Description |
|--------|---------|-------------|
| `show()` | Promise<PaymentResponse> | Display UI |
| `abort()` | Promise | Cancel request |
| `canMakePayment()` | Promise<boolean> | Check availability |

### Events

| Event | When |
|-------|------|
| `shippingaddresschange` | Address changed |
| `shippingoptionchange` | Shipping option changed |

### Response Properties

| Property | Type | Description |
|----------|------|-------------|
| `methodName` | String | Payment method |
| `details` | Object | Payment details |
| `payerName` | String | Payer name |
| `payerEmail` | String | Payer email |
| `shippingAddress` | Object | Shipping address |

### Best Practices

1. **Check canMakePayment** before showing
2. **Provide fallback** checkout
3. **Handle abort** gracefully
4. **Complete response** with success/fail
5. **Validate on server** — never trust client data
6. **Update details** on shipping changes

---

**End of Chapter 17.1: Payment Request API**

Next chapter: **17.2 Payment Handler API** — implementing payment handlers.
# 17.2 Payment Handler API

The Payment Handler API allows web applications to handle payment requests, enabling PWAs to act as payment apps for Payment Request API.

---

## 17.2.1 Overview

### What is Payment Handler?

```javascript
// Payment Handler API enables:
// - PWAs to handle payments
// - Custom payment methods
// - Service Worker integration
// - Native app-like payment experiences

// Use cases:
// - Digital wallets
// - Cryptocurrency payments
// - Bank-specific payment apps
// - Store credit systems
```

---

## 17.2.2 Register Payment Handler

### Service Worker Registration

```javascript
// In main script
async function registerPaymentApp() {
  const registration = await navigator.serviceWorker.register('/sw.js');
  
  // Check for payment support
  if (!registration.paymentManager) {
    console.log('Payment Handler not supported');
    return;
  }
  
  // Set user hint
  registration.paymentManager.userHint = 'My Wallet App';
  
  // Register instruments
  await registration.paymentManager.instruments.set(
    'my-wallet-id',
    {
      name: 'My Digital Wallet',
      icons: [
        { src: '/icons/wallet-96.png', sizes: '96x96', type: 'image/png' }
      ],
      method: 'https://example.com/pay'
    }
  );
}
```

---

## 17.2.3 Web App Manifest

### Payment Handler Manifest

```json
{
  "name": "My Payment App",
  "short_name": "PayApp",
  "icons": [
    {
      "src": "/icons/icon-192.png",
      "sizes": "192x192",
      "type": "image/png"
    }
  ],
  "serviceworker": {
    "src": "/sw.js",
    "scope": "/",
    "use_cache": false
  },
  "payment": {
    "supported_origins": ["https://merchant.example"]
  }
}
```

---

## 17.2.4 Service Worker Events

### Handle Payment Request

```javascript
// In service worker (sw.js)
self.addEventListener('paymentrequest', (event) => {
  event.respondWith(handlePayment(event));
});

async function handlePayment(event) {
  // Open payment window
  const client = await event.openWindow('/pay');
  
  // Wait for payment completion
  return new Promise((resolve) => {
    self.addEventListener('message', (messageEvent) => {
      if (messageEvent.data.type === 'payment-complete') {
        resolve({
          methodName: 'https://example.com/pay',
          details: messageEvent.data.paymentDetails
        });
      }
    });
  });
}
```

### Payment Event Properties

```javascript
self.addEventListener('paymentrequest', (event) => {
  const { 
    topOrigin,           // Merchant origin
    paymentRequestOrigin, // Payment request origin
    paymentRequestId,     // Unique request ID
    methodData,           // Payment method data
    total,               // Total amount
    modifiers,           // Price modifiers
    instrumentKey        // Selected instrument
  } = event;
  
  console.log('Payment requested from:', topOrigin);
  console.log('Amount:', total.value, total.currency);
});
```

---

## 17.2.5 Payment Window

### Payment UI Page

```html
<!-- /pay.html -->
<!DOCTYPE html>
<html>
<head>
  <title>Complete Payment</title>
</head>
<body>
  <div id="payment-form">
    <h1>Complete Your Payment</h1>
    <p id="amount"></p>
    <button id="confirm">Confirm Payment</button>
    <button id="cancel">Cancel</button>
  </div>
  
  <script>
    // Get payment details from Service Worker
    navigator.serviceWorker.controller.postMessage({
      type: 'get-payment-details'
    });
    
    navigator.serviceWorker.addEventListener('message', (event) => {
      if (event.data.type === 'payment-details') {
        document.getElementById('amount').textContent = 
          `Amount: ${event.data.total.currency} ${event.data.total.value}`;
      }
    });
    
    document.getElementById('confirm').addEventListener('click', () => {
      navigator.serviceWorker.controller.postMessage({
        type: 'payment-complete',
        paymentDetails: {
          transactionId: generateTransactionId(),
          status: 'success'
        }
      });
      window.close();
    });
    
    document.getElementById('cancel').addEventListener('click', () => {
      navigator.serviceWorker.controller.postMessage({
        type: 'payment-cancelled'
      });
      window.close();
    });
  </script>
</body>
</html>
```

---

## 17.2.6 Instrument Management

### Add/Update Instruments

```javascript
const registration = await navigator.serviceWorker.ready;
const instruments = registration.paymentManager.instruments;

// Add instrument
await instruments.set('card-1234', {
  name: 'Visa ending in 1234',
  icons: [{ src: '/icons/visa.png', sizes: '32x32' }],
  method: 'basic-card'
});

// Get instrument
const instrument = await instruments.get('card-1234');

// List all instruments
const keys = await instruments.keys();
for (const key of keys) {
  console.log(await instruments.get(key));
}

// Delete instrument
await instruments.delete('card-1234');

// Clear all
await instruments.clear();
```

---

## 17.2.7 Just-in-Time Registration

### Register on First Use

```javascript
// Called when user selects your payment method
self.addEventListener('paymentrequest', async (event) => {
  // Check if instruments exist
  const instruments = await self.registration.paymentManager.instruments.keys();
  
  if (instruments.length === 0) {
    // Show enrollment flow
    event.respondWith(enrollUser(event));
  } else {
    event.respondWith(handlePayment(event));
  }
});

async function enrollUser(event) {
  const client = await event.openWindow('/enroll');
  
  return new Promise((resolve, reject) => {
    // Wait for enrollment completion
    self.addEventListener('message', async (e) => {
      if (e.data.type === 'enrollment-complete') {
        // Now handle the payment
        resolve(await handlePayment(event));
      }
    });
  });
}
```

---

## 17.2.8 Browser Support

### Feature Detection

```javascript
async function isPaymentHandlerSupported() {
  if (!('serviceWorker' in navigator)) return false;
  
  const registration = await navigator.serviceWorker.ready;
  return 'paymentManager' in registration;
}
```

---

## 17.2.9 Summary

### Service Worker Events

| Event | When |
|-------|------|
| `paymentrequest` | Payment requested |

### PaymentManager Methods

| Method | Description |
|--------|-------------|
| `instruments.set(key, details)` | Add/update instrument |
| `instruments.get(key)` | Get instrument |
| `instruments.delete(key)` | Remove instrument |
| `instruments.keys()` | List all keys |
| `instruments.clear()` | Remove all |

### Best Practices

1. **Register instruments** on app install
2. **Handle errors** gracefully
3. **Provide clear UI** in payment window
4. **Validate transactions** server-side
5. **Support JIT registration**
6. **Test thoroughly** with different merchants

---

**End of Chapter 17.2: Payment Handler API**

This completes Group 17 — Payment APIs. Next section: **Group 18 — Credential Management API**.
# 18.1 Credentials

The Credential Management API provides a programmatic interface for storing and retrieving user credentials. This chapter covers credential types and the CredentialsContainer interface.

---

## 18.1.1 Overview

### Credential Types

```javascript
// Available credential types:
// - PasswordCredential: username/password pairs
// - FederatedCredential: third-party identity providers
// - PublicKeyCredential: WebAuthn (biometrics, security keys)

// Check support
if ('credentials' in navigator) {
  console.log('Credentials API supported');
}
```

---

## 18.1.2 PasswordCredential

### Create Password Credential

```javascript
const credential = new PasswordCredential({
  id: 'user@example.com',
  password: 'secretPassword123',
  name: 'John Doe',
  iconURL: '/avatars/john.png'
});

console.log(credential.id);    // 'user@example.com'
console.log(credential.name);  // 'John Doe'
console.log(credential.type);  // 'password'
// password property not accessible for security
```

### From Form

```javascript
const form = document.getElementById('loginForm');

form.addEventListener('submit', async (e) => {
  e.preventDefault();
  
  // Create from form data
  const credential = new PasswordCredential(form);
  
  // Store for future use
  await navigator.credentials.store(credential);
  
  // Submit login
  await login(credential);
});
```

### Form Requirements

```html
<form id="loginForm">
  <input type="text" name="username" autocomplete="username">
  <input type="password" name="password" autocomplete="current-password">
  <input type="text" name="name" autocomplete="name">
  <button type="submit">Login</button>
</form>
```

---

## 18.1.3 FederatedCredential

### Create Federated Credential

```javascript
const credential = new FederatedCredential({
  id: 'user@example.com',
  provider: 'https://accounts.google.com',
  name: 'John Doe',
  iconURL: '/avatars/john.png'
});

console.log(credential.provider);  // 'https://accounts.google.com'
console.log(credential.type);      // 'federated'
```

### Common Providers

```javascript
// Google
const googleCredential = new FederatedCredential({
  id: 'user@gmail.com',
  provider: 'https://accounts.google.com'
});

// Facebook
const fbCredential = new FederatedCredential({
  id: '123456789',
  provider: 'https://www.facebook.com'
});
```

---

## 18.1.4 PublicKeyCredential (WebAuthn)

### Overview

```javascript
// PublicKeyCredential is used for:
// - Biometric authentication (fingerprint, face)
// - Hardware security keys (YubiKey)
// - Platform authenticators (Windows Hello, Touch ID)

// Check support
if (window.PublicKeyCredential) {
  console.log('WebAuthn supported');
}

// Check platform authenticator
const available = await PublicKeyCredential
  .isUserVerifyingPlatformAuthenticatorAvailable();
```

---

## 18.1.5 Credential Properties

### Common Properties

| Property | Type | Description |
|----------|------|-------------|
| `id` | String | User identifier |
| `type` | String | Credential type |
| `name` | String | Display name |
| `iconURL` | String | User avatar |

### PasswordCredential Specific

| Property | Type | Description |
|----------|------|-------------|
| `password` | String | Password (write-only) |

### FederatedCredential Specific

| Property | Type | Description |
|----------|------|-------------|
| `provider` | String | Identity provider URL |
| `protocol` | String | Federation protocol |

---

## 18.1.6 Summary

### Credential Types

| Type | Use Case |
|------|----------|
| `PasswordCredential` | Username/password login |
| `FederatedCredential` | Social login (Google, Facebook) |
| `PublicKeyCredential` | Biometrics, security keys |

### Constructor Signatures

```javascript
// PasswordCredential
new PasswordCredential({
  id: string,
  password: string,
  name?: string,
  iconURL?: string
})

// FederatedCredential
new FederatedCredential({
  id: string,
  provider: string,
  name?: string,
  iconURL?: string,
  protocol?: string
})
```

### Best Practices

1. **Use autocomplete** attributes on forms
2. **Store credentials** after successful login
3. **Support multiple types** for flexibility
4. **Handle missing support** gracefully
5. **Validate server-side** always

---

**End of Chapter 18.1: Credentials**

Next chapter: **18.2 Operations** — storing, retrieving, and managing credentials.
# 18.2 Operations

This chapter covers the credential operations: storing, retrieving, creating, and preventing silent access.

---

## 18.2.1 navigator.credentials.get()

### Retrieve Stored Credentials

```javascript
async function getCredentials() {
  try {
    const credential = await navigator.credentials.get({
      password: true,
      federated: {
        providers: ['https://accounts.google.com']
      },
      mediation: 'optional'
    });
    
    if (credential) {
      console.log('Got credential:', credential.id);
      return credential;
    }
    
    console.log('No credential selected');
    return null;
    
  } catch (error) {
    console.error('Get credential failed:', error);
  }
}
```

### Mediation Options

```javascript
// 'silent' - No UI, only if single saved credential
const silentCred = await navigator.credentials.get({
  password: true,
  mediation: 'silent'
});

// 'optional' - Show UI if needed (default)
const optionalCred = await navigator.credentials.get({
  password: true,
  mediation: 'optional'
});

// 'required' - Always show UI
const requiredCred = await navigator.credentials.get({
  password: true,
  mediation: 'required'
});
```

---

## 18.2.2 navigator.credentials.store()

### Save Credentials

```javascript
async function saveCredentials(username, password) {
  const credential = new PasswordCredential({
    id: username,
    password: password
  });
  
  try {
    await navigator.credentials.store(credential);
    console.log('Credentials saved');
  } catch (error) {
    console.error('Store failed:', error);
  }
}
```

### After Login

```javascript
async function login(form) {
  const formData = new FormData(form);
  
  // Send to server
  const response = await fetch('/api/login', {
    method: 'POST',
    body: formData
  });
  
  if (response.ok) {
    // Store credentials on successful login
    const credential = new PasswordCredential(form);
    await navigator.credentials.store(credential);
  }
  
  return response;
}
```

---

## 18.2.3 navigator.credentials.create()

### Create Credentials

```javascript
// For WebAuthn (PublicKeyCredential)
const credential = await navigator.credentials.create({
  publicKey: {
    challenge: new Uint8Array(32),
    rp: { name: 'Example Site' },
    user: {
      id: new Uint8Array(16),
      name: 'user@example.com',
      displayName: 'User'
    },
    pubKeyCredParams: [
      { type: 'public-key', alg: -7 }  // ES256
    ]
  }
});
```

---

## 18.2.4 navigator.credentials.preventSilentAccess()

### Prevent Auto-Login

```javascript
async function logout() {
  // Clear session
  await fetch('/api/logout', { method: 'POST' });
  
  // Prevent silent credential retrieval
  await navigator.credentials.preventSilentAccess();
  
  // Next get() with 'silent' will return null
  // User must interact to select credentials
}
```

### When to Use

```javascript
// Call after:
// - User logs out
// - User switches accounts
// - Session expires

async function handleLogout() {
  // Server logout
  await fetch('/api/logout');
  
  // Prevent auto-login
  if (navigator.credentials?.preventSilentAccess) {
    await navigator.credentials.preventSilentAccess();
  }
  
  // Redirect
  window.location.href = '/login';
}
```

---

## 18.2.5 Auto Sign-In Flow

### Automatic Login

```javascript
async function autoSignIn() {
  // Try silent sign-in first
  const credential = await navigator.credentials.get({
    password: true,
    federated: {
      providers: ['https://accounts.google.com']
    },
    mediation: 'silent'
  });
  
  if (credential) {
    // Auto sign-in
    return await signInWithCredential(credential);
  }
  
  return null;
}

// On page load
document.addEventListener('DOMContentLoaded', async () => {
  const user = await autoSignIn();
  
  if (user) {
    showWelcomeBack(user);
  } else {
    showLoginForm();
  }
});
```

---

## 18.2.6 Account Chooser

### Show Account Selection

```javascript
async function showAccountChooser() {
  const credential = await navigator.credentials.get({
    password: true,
    federated: {
      providers: [
        'https://accounts.google.com',
        'https://www.facebook.com'
      ]
    },
    mediation: 'required'  // Always show UI
  });
  
  if (credential) {
    if (credential.type === 'password') {
      return signInWithPassword(credential);
    } else if (credential.type === 'federated') {
      return signInWithProvider(credential.provider);
    }
  }
}
```

---

## 18.2.7 Handle Credential Type

### Type-Specific Handling

```javascript
async function handleCredential(credential) {
  switch (credential.type) {
    case 'password':
      return await fetch('/api/login', {
        method: 'POST',
        body: JSON.stringify({
          username: credential.id,
          password: credential.password
        }),
        headers: { 'Content-Type': 'application/json' }
      });
      
    case 'federated':
      // Redirect to provider
      return signInWithFederated(credential.provider, credential.id);
      
    case 'public-key':
      // WebAuthn assertion
      return verifyAssertion(credential);
      
    default:
      throw new Error('Unknown credential type');
  }
}
```

---

## 18.2.8 Complete Login Flow

### Full Implementation

```javascript
class CredentialManager {
  constructor(providers = []) {
    this.providers = providers;
    this.supported = 'credentials' in navigator;
  }
  
  async autoSignIn() {
    if (!this.supported) return null;
    
    try {
      const credential = await navigator.credentials.get({
        password: true,
        federated: { providers: this.providers },
        mediation: 'silent'
      });
      
      if (credential) {
        return await this.signIn(credential);
      }
    } catch (error) {
      console.error('Auto sign-in failed:', error);
    }
    
    return null;
  }
  
  async promptSignIn() {
    if (!this.supported) {
      return this.fallbackSignIn();
    }
    
    const credential = await navigator.credentials.get({
      password: true,
      federated: { providers: this.providers },
      mediation: 'optional'
    });
    
    if (credential) {
      return await this.signIn(credential);
    }
    
    return null;
  }
  
  async signIn(credential) {
    // Implement based on credential type
    const response = await this.handleCredential(credential);
    
    if (response.ok) {
      return await response.json();
    }
    
    throw new Error('Sign-in failed');
  }
  
  async saveCredentials(username, password) {
    if (!this.supported) return;
    
    const credential = new PasswordCredential({
      id: username,
      password
    });
    
    await navigator.credentials.store(credential);
  }
  
  async signOut() {
    if (this.supported) {
      await navigator.credentials.preventSilentAccess();
    }
  }
}
```

---

## 18.2.9 Summary

### Methods

| Method | Description |
|--------|-------------|
| `get(options)` | Retrieve credentials |
| `store(credential)` | Save credentials |
| `create(options)` | Create new credential |
| `preventSilentAccess()` | Disable silent retrieval |

### Get Options

| Option | Type | Description |
|--------|------|-------------|
| `password` | Boolean | Allow password credentials |
| `federated` | Object | Federated provider config |
| `publicKey` | Object | WebAuthn options |
| `mediation` | String | UI behavior |

### Mediation Values

| Value | Behavior |
|-------|----------|
| `silent` | No UI, auto-select |
| `optional` | Show UI if needed |
| `required` | Always show UI |

### Best Practices

1. **Try silent first** for seamless UX
2. **Fall back to optional** if silent fails
3. **Call preventSilentAccess** on logout
4. **Store after successful login**
5. **Support multiple providers**
6. **Handle errors gracefully**

---

**End of Chapter 18.2: Operations**

Next chapter: **18.3 Web Authentication** — biometric and hardware key authentication.
# 18.3 Web Authentication (WebAuthn)

Web Authentication (WebAuthn) enables passwordless authentication using biometrics, security keys, or platform authenticators. This chapter covers registration, authentication, and best practices.

---

## 18.3.1 Overview

### What is WebAuthn?

```javascript
// WebAuthn provides:
// - Passwordless login
// - Two-factor authentication
// - Phishing resistance
// - Biometric authentication

// Check support
if (window.PublicKeyCredential) {
  console.log('WebAuthn supported');
}

// Check platform authenticator
const hasPlatformAuth = await PublicKeyCredential
  .isUserVerifyingPlatformAuthenticatorAvailable();
console.log('Platform authenticator:', hasPlatformAuth);
```

---

## 18.3.2 Registration (Create Credential)

### Basic Registration

```javascript
async function registerWebAuthn(userId, username) {
  // Get challenge from server
  const options = await fetch('/api/webauthn/register/options', {
    method: 'POST',
    body: JSON.stringify({ userId, username }),
    headers: { 'Content-Type': 'application/json' }
  }).then(r => r.json());
  
  // Convert base64 to ArrayBuffer
  options.challenge = base64ToBuffer(options.challenge);
  options.user.id = base64ToBuffer(options.user.id);
  
  // Create credential
  const credential = await navigator.credentials.create({
    publicKey: options
  });
  
  // Send to server for verification
  const response = await fetch('/api/webauthn/register/verify', {
    method: 'POST',
    body: JSON.stringify({
      id: credential.id,
      rawId: bufferToBase64(credential.rawId),
      type: credential.type,
      response: {
        clientDataJSON: bufferToBase64(credential.response.clientDataJSON),
        attestationObject: bufferToBase64(credential.response.attestationObject)
      }
    }),
    headers: { 'Content-Type': 'application/json' }
  });
  
  return response.json();
}
```

### PublicKeyCredentialCreationOptions

```javascript
const creationOptions = {
  // Random challenge from server (prevent replay attacks)
  challenge: new Uint8Array(32),
  
  // Relying Party (your site)
  rp: {
    name: 'Example Site',
    id: 'example.com'  // Must match domain
  },
  
  // User info
  user: {
    id: new Uint8Array(16),  // Unique user ID
    name: 'user@example.com',
    displayName: 'John Doe'
  },
  
  // Supported algorithms
  pubKeyCredParams: [
    { type: 'public-key', alg: -7 },   // ES256
    { type: 'public-key', alg: -257 }  // RS256
  ],
  
  // Authenticator requirements
  authenticatorSelection: {
    authenticatorAttachment: 'platform',  // or 'cross-platform'
    userVerification: 'required',         // or 'preferred', 'discouraged'
    residentKey: 'required'               // for discoverable credentials
  },
  
  // Timeout
  timeout: 60000,
  
  // Attestation
  attestation: 'none'  // or 'indirect', 'direct'
};
```

---

## 18.3.3 Authentication (Get Credential)

### Basic Authentication

```javascript
async function authenticateWebAuthn() {
  // Get challenge from server
  const options = await fetch('/api/webauthn/login/options')
    .then(r => r.json());
  
  // Convert challenge
  options.challenge = base64ToBuffer(options.challenge);
  
  // Convert allowed credentials
  if (options.allowCredentials) {
    options.allowCredentials = options.allowCredentials.map(cred => ({
      ...cred,
      id: base64ToBuffer(cred.id)
    }));
  }
  
  // Get credential
  const credential = await navigator.credentials.get({
    publicKey: options
  });
  
  // Send to server for verification
  const response = await fetch('/api/webauthn/login/verify', {
    method: 'POST',
    body: JSON.stringify({
      id: credential.id,
      rawId: bufferToBase64(credential.rawId),
      type: credential.type,
      response: {
        clientDataJSON: bufferToBase64(credential.response.clientDataJSON),
        authenticatorData: bufferToBase64(credential.response.authenticatorData),
        signature: bufferToBase64(credential.response.signature),
        userHandle: credential.response.userHandle 
          ? bufferToBase64(credential.response.userHandle) 
          : null
      }
    }),
    headers: { 'Content-Type': 'application/json' }
  });
  
  return response.json();
}
```

### PublicKeyCredentialRequestOptions

```javascript
const requestOptions = {
  // Challenge from server
  challenge: new Uint8Array(32),
  
  // Timeout
  timeout: 60000,
  
  // RP ID (domain)
  rpId: 'example.com',
  
  // Allowed credentials (optional for discoverable)
  allowCredentials: [
    {
      type: 'public-key',
      id: credentialId,  // ArrayBuffer
      transports: ['internal', 'usb', 'ble', 'nfc']
    }
  ],
  
  // User verification
  userVerification: 'required'
};
```

---

## 18.3.4 Authenticator Types

### Platform vs Cross-Platform

```javascript
// Platform authenticator (built-in)
// - Touch ID, Face ID
// - Windows Hello
// - Android fingerprint

const platformOptions = {
  authenticatorSelection: {
    authenticatorAttachment: 'platform',
    userVerification: 'required'
  }
};

// Cross-platform (external)
// - Security keys (YubiKey)
// - USB, NFC, Bluetooth

const crossPlatformOptions = {
  authenticatorSelection: {
    authenticatorAttachment: 'cross-platform'
  }
};

// Any authenticator
const anyOptions = {
  // Don't specify authenticatorAttachment
};
```

---

## 18.3.5 Discoverable Credentials (Passkeys)

### Passwordless Flow

```javascript
// Registration with discoverable credential
const options = {
  // ... other options
  authenticatorSelection: {
    residentKey: 'required',
    userVerification: 'required'
  }
};

const credential = await navigator.credentials.create({
  publicKey: options
});

// Authentication without specifying credentials
const authOptions = {
  challenge: challenge,
  rpId: 'example.com',
  userVerification: 'required'
  // No allowCredentials - user selects from stored passkeys
};

const assertion = await navigator.credentials.get({
  publicKey: authOptions
});
```

### Conditional UI (Autofill)

```javascript
// Check support
const conditionalSupported = await PublicKeyCredential
  .isConditionalMediationAvailable();

if (conditionalSupported) {
  // Trigger passkey autofill
  const credential = await navigator.credentials.get({
    publicKey: {
      challenge: challenge,
      rpId: 'example.com',
      userVerification: 'preferred'
    },
    mediation: 'conditional'
  });
}
```

```html
<!-- Enable passkey autofill -->
<input type="text" 
       autocomplete="username webauthn"
       placeholder="Username or use passkey">
```

---

## 18.3.6 Helper Functions

### Buffer Conversions

```javascript
function base64ToBuffer(base64) {
  const binary = atob(base64.replace(/-/g, '+').replace(/_/g, '/'));
  const bytes = new Uint8Array(binary.length);
  for (let i = 0; i < binary.length; i++) {
    bytes[i] = binary.charCodeAt(i);
  }
  return bytes.buffer;
}

function bufferToBase64(buffer) {
  const bytes = new Uint8Array(buffer);
  let binary = '';
  for (const byte of bytes) {
    binary += String.fromCharCode(byte);
  }
  return btoa(binary)
    .replace(/\+/g, '-')
    .replace(/\//g, '_')
    .replace(/=/g, '');
}
```

---

## 18.3.7 Error Handling

### Common Errors

```javascript
async function handleWebAuthn() {
  try {
    const credential = await navigator.credentials.create({
      publicKey: options
    });
    return credential;
    
  } catch (error) {
    switch (error.name) {
      case 'NotAllowedError':
        console.log('User cancelled or timeout');
        break;
        
      case 'InvalidStateError':
        console.log('Credential already registered');
        break;
        
      case 'NotSupportedError':
        console.log('Authenticator not supported');
        break;
        
      case 'SecurityError':
        console.log('Domain mismatch or insecure context');
        break;
        
      case 'AbortError':
        console.log('Operation aborted');
        break;
        
      default:
        console.error('WebAuthn error:', error);
    }
    
    throw error;
  }
}
```

---

## 18.3.8 Complete Implementation

### WebAuthn Manager

```javascript
class WebAuthnManager {
  constructor(rpId) {
    this.rpId = rpId;
    this.supported = !!window.PublicKeyCredential;
  }
  
  async isAvailable() {
    if (!this.supported) return false;
    return await PublicKeyCredential
      .isUserVerifyingPlatformAuthenticatorAvailable();
  }
  
  async register(user) {
    const options = await this.fetchOptions('/api/webauthn/register', user);
    
    const credential = await navigator.credentials.create({
      publicKey: this.prepareCreationOptions(options)
    });
    
    return await this.verifyRegistration(credential);
  }
  
  async authenticate(username = null) {
    const options = await this.fetchOptions('/api/webauthn/login', { username });
    
    const credential = await navigator.credentials.get({
      publicKey: this.prepareRequestOptions(options)
    });
    
    return await this.verifyAuthentication(credential);
  }
  
  prepareCreationOptions(options) {
    return {
      ...options,
      challenge: base64ToBuffer(options.challenge),
      user: {
        ...options.user,
        id: base64ToBuffer(options.user.id)
      }
    };
  }
  
  prepareRequestOptions(options) {
    return {
      ...options,
      challenge: base64ToBuffer(options.challenge),
      allowCredentials: options.allowCredentials?.map(cred => ({
        ...cred,
        id: base64ToBuffer(cred.id)
      }))
    };
  }
  
  // ... fetch and verify methods
}
```

---

## 18.3.9 Summary

### Key Concepts

| Term | Description |
|------|-------------|
| Relying Party (RP) | Your website |
| Authenticator | Device that creates/verifies credentials |
| Discoverable | Credential stored on authenticator |
| User Verification | Biometric/PIN check |
| Attestation | Proof of authenticator type |

### Methods

| Method | Purpose |
|--------|---------|
| `credentials.create()` | Register new credential |
| `credentials.get()` | Authenticate with credential |

### Authenticator Attachment

| Value | Meaning |
|-------|---------|
| `platform` | Built-in (Touch ID, Windows Hello) |
| `cross-platform` | External (USB key, NFC) |

### Best Practices

1. **Always use HTTPS** — required for WebAuthn
2. **Generate challenges server-side** — prevent replay attacks
3. **Verify responses server-side** — never trust client
4. **Support multiple authenticators** per user
5. **Provide fallback** authentication methods
6. **Handle errors** with user-friendly messages

---

**End of Chapter 18.3: Web Authentication**

This completes Group 18 — Credential Management API. Next section: **Group 19 — Permissions API**.
# 19.1 Permission Queries

The Permissions API provides a consistent way to query and monitor the status of user permissions. This chapter covers querying permissions and handling permission changes.

---

## 19.1.1 Basic Query

### Check Permission Status

```javascript
async function checkPermission(name) {
  try {
    const result = await navigator.permissions.query({ name });
    console.log(`${name}: ${result.state}`);
    return result.state;
  } catch (error) {
    console.error(`Permission '${name}' not supported:`, error);
    return 'unsupported';
  }
}

// Usage
const status = await checkPermission('geolocation');
// Returns: 'granted', 'denied', or 'prompt'
```

---

## 19.1.2 Permission States

### State Values

```javascript
// 'granted' - Permission has been granted
// 'denied' - Permission has been denied
// 'prompt' - User will be prompted when API is used

const result = await navigator.permissions.query({ name: 'camera' });

switch (result.state) {
  case 'granted':
    startCamera();
    break;
    
  case 'denied':
    showPermissionDeniedMessage();
    break;
    
  case 'prompt':
    showPermissionExplanation();
    break;
}
```

---

## 19.1.3 Available Permissions

### Common Permissions

```javascript
// Geolocation
await navigator.permissions.query({ name: 'geolocation' });

// Notifications
await navigator.permissions.query({ name: 'notifications' });

// Camera
await navigator.permissions.query({ name: 'camera' });

// Microphone
await navigator.permissions.query({ name: 'microphone' });

// Clipboard
await navigator.permissions.query({ name: 'clipboard-read' });
await navigator.permissions.query({ name: 'clipboard-write' });

// Push notifications
await navigator.permissions.query({ name: 'push', userVisibleOnly: true });

// MIDI
await navigator.permissions.query({ name: 'midi', sysex: true });
```

### Check Multiple

```javascript
async function checkAllPermissions() {
  const permissions = [
    'geolocation',
    'notifications',
    'camera',
    'microphone',
    'clipboard-read'
  ];
  
  const results = {};
  
  for (const name of permissions) {
    try {
      const result = await navigator.permissions.query({ name });
      results[name] = result.state;
    } catch {
      results[name] = 'unsupported';
    }
  }
  
  return results;
}
```

---

## 19.1.4 Permission Change Events

### Monitor Changes

```javascript
async function watchPermission(name, callback) {
  try {
    const permission = await navigator.permissions.query({ name });
    
    // Initial state
    callback(permission.state);
    
    // Watch for changes
    permission.addEventListener('change', () => {
      callback(permission.state);
    });
    
    return permission;
  } catch (error) {
    console.error('Cannot watch permission:', error);
  }
}

// Usage
watchPermission('geolocation', (state) => {
  console.log('Geolocation permission:', state);
  updateUI(state);
});
```

### Update UI on Change

```javascript
const indicator = document.getElementById('location-status');

const permission = await navigator.permissions.query({ name: 'geolocation' });

function updateIndicator() {
  indicator.className = `status-${permission.state}`;
  indicator.textContent = permission.state;
}

permission.addEventListener('change', updateIndicator);
updateIndicator();
```

---

## 19.1.5 Permission with Options

### Device-Specific Permissions

```javascript
// Specific camera
const camera = await navigator.permissions.query({
  name: 'camera',
  // deviceId: 'specific-camera-id'  // If supported
});

// Push with user-visible requirement
const push = await navigator.permissions.query({
  name: 'push',
  userVisibleOnly: true
});

// MIDI with system exclusive
const midi = await navigator.permissions.query({
  name: 'midi',
  sysex: true
});
```

---

## 19.1.6 Permission Manager Class

### Reusable Manager

```javascript
class PermissionManager {
  constructor() {
    this.permissions = new Map();
    this.listeners = new Map();
  }
  
  async check(name, options = {}) {
    try {
      const descriptor = { name, ...options };
      const status = await navigator.permissions.query(descriptor);
      
      this.permissions.set(name, status);
      
      return status.state;
    } catch (error) {
      return 'unsupported';
    }
  }
  
  async watch(name, callback, options = {}) {
    const state = await this.check(name, options);
    callback(state);
    
    const status = this.permissions.get(name);
    if (status) {
      const handler = () => callback(status.state);
      status.addEventListener('change', handler);
      this.listeners.set(name, handler);
    }
  }
  
  unwatch(name) {
    const status = this.permissions.get(name);
    const handler = this.listeners.get(name);
    
    if (status && handler) {
      status.removeEventListener('change', handler);
      this.listeners.delete(name);
    }
  }
  
  async checkMultiple(names) {
    const results = {};
    
    await Promise.all(names.map(async (name) => {
      results[name] = await this.check(name);
    }));
    
    return results;
  }
}

// Usage
const pm = new PermissionManager();

pm.watch('geolocation', (state) => {
  console.log('Location permission:', state);
});

const allPermissions = await pm.checkMultiple([
  'geolocation',
  'notifications',
  'camera'
]);
```

---

## 19.1.7 Request Patterns

### Request After Check

```javascript
async function requestNotificationPermission() {
  // Check first
  const status = await navigator.permissions.query({ name: 'notifications' });
  
  if (status.state === 'granted') {
    return true;
  }
  
  if (status.state === 'denied') {
    showSettingsInstructions();
    return false;
  }
  
  // State is 'prompt' - request permission
  const result = await Notification.requestPermission();
  return result === 'granted';
}
```

### Request with Explanation

```javascript
async function requestCameraWithExplanation() {
  const status = await navigator.permissions.query({ name: 'camera' });
  
  if (status.state === 'prompt') {
    // Show explanation before requesting
    const confirmed = await showModal(
      'Camera Access',
      'We need camera access to enable video calls.',
      ['Allow', 'Cancel']
    );
    
    if (!confirmed) return false;
  }
  
  try {
    const stream = await navigator.mediaDevices.getUserMedia({ video: true });
    return stream;
  } catch (error) {
    if (error.name === 'NotAllowedError') {
      showPermissionDeniedMessage();
    }
    return null;
  }
}
```

---

## 19.1.8 Browser Support

### Feature Detection

```javascript
function isPermissionsSupported() {
  return 'permissions' in navigator;
}

async function isPermissionSupported(name) {
  if (!isPermissionsSupported()) return false;
  
  try {
    await navigator.permissions.query({ name });
    return true;
  } catch {
    return false;
  }
}

// Fallback
async function getPermissionState(name) {
  if (await isPermissionSupported(name)) {
    const result = await navigator.permissions.query({ name });
    return result.state;
  }
  
  // Fallback for unsupported browsers
  return 'unknown';
}
```

---

## 19.1.9 Summary

### Query Method

```javascript
navigator.permissions.query(descriptor)
// Returns: Promise<PermissionStatus>
```

### Permission Descriptor

| Property | Type | Description |
|----------|------|-------------|
| `name` | String | Permission name |
| Other | Various | API-specific options |

### PermissionStatus

| Property | Type | Description |
|----------|------|-------------|
| `state` | String | 'granted', 'denied', 'prompt' |
| `name` | String | Permission name |

### Events

| Event | When |
|-------|------|
| `change` | Permission state changes |

### Common Permissions

| Name | API |
|------|-----|
| `geolocation` | Geolocation API |
| `notifications` | Notifications API |
| `camera` | MediaDevices |
| `microphone` | MediaDevices |
| `push` | Push API |
| `clipboard-read` | Clipboard API |
| `clipboard-write` | Clipboard API |

### Best Practices

1. **Check before requesting** to avoid unnecessary prompts
2. **Explain why** you need the permission
3. **Handle denial** gracefully
4. **Watch for changes** to update UI
5. **Feature detect** the Permissions API
6. **Provide fallbacks** for unsupported browsers

---

**End of Chapter 19.1: Permission Queries**

This completes Group 19 — Permissions API. Next section: **Group 20 — Screen APIs**.
# 20.1 Sharing Content

The Web Share API allows web pages to invoke the native share dialog, enabling users to share content to other apps and services.

---

## 20.1.1 Basic Usage

### Share URL

```javascript
async function shareURL(url, title, text) {
  if (!navigator.share) {
    console.log('Web Share not supported');
    return false;
  }
  
  try {
    await navigator.share({
      title,
      text,
      url
    });
    console.log('Shared successfully');
    return true;
  } catch (error) {
    if (error.name === 'AbortError') {
      console.log('Share cancelled');
    } else {
      console.error('Share failed:', error);
    }
    return false;
  }
}

// Usage
await shareURL(
  'https://example.com/article',
  'Great Article',
  'Check out this article!'
);
```

---

## 20.1.2 Check Support

### Feature Detection

```javascript
function canShare() {
  return 'share' in navigator;
}

// Check with data validation
function canShareData(data) {
  if (!navigator.canShare) {
    return 'share' in navigator;
  }
  return navigator.canShare(data);
}

// Usage
const shareData = { title: 'Test', url: 'https://example.com' };

if (canShareData(shareData)) {
  navigator.share(shareData);
} else {
  showFallbackShare();
}
```

---

## 20.1.3 Share Data Options

### Available Properties

```javascript
const shareData = {
  // Page title
  title: 'My Page Title',
  
  // Description text
  text: 'Check out this awesome content!',
  
  // URL to share
  url: 'https://example.com/page',
  
  // Files to share (optional)
  files: [file1, file2]
};

await navigator.share(shareData);
```

### Minimal Share

```javascript
// URL only
await navigator.share({ url: location.href });

// Text only
await navigator.share({ text: 'Hello World!' });
```

---

## 20.1.4 Share Files

### Check File Sharing Support

```javascript
function canShareFiles(files) {
  if (!navigator.canShare) return false;
  return navigator.canShare({ files });
}
```

### Share Images

```javascript
async function shareImage(imageBlob, filename) {
  const file = new File([imageBlob], filename, { type: imageBlob.type });
  
  if (!navigator.canShare?.({ files: [file] })) {
    console.log('File sharing not supported');
    return false;
  }
  
  try {
    await navigator.share({
      title: 'Shared Image',
      files: [file]
    });
    return true;
  } catch (error) {
    console.error('Share failed:', error);
    return false;
  }
}
```

### Share Multiple Files

```javascript
async function shareFiles(files, title = 'Shared Files') {
  if (!navigator.canShare?.({ files })) {
    throw new Error('Cannot share these files');
  }
  
  await navigator.share({
    title,
    files
  });
}

// Usage
const fileInput = document.getElementById('files');
const files = Array.from(fileInput.files);
await shareFiles(files);
```

### Share Canvas

```javascript
async function shareCanvas(canvas, title) {
  const blob = await new Promise(resolve => 
    canvas.toBlob(resolve, 'image/png')
  );
  
  const file = new File([blob], 'image.png', { type: 'image/png' });
  
  await navigator.share({
    title,
    files: [file]
  });
}
```

---

## 20.1.5 Share Button Component

### Reusable Share Button

```javascript
class ShareButton {
  constructor(element, defaultData = {}) {
    this.element = element;
    this.defaultData = defaultData;
    this.supported = 'share' in navigator;
    
    this.init();
  }
  
  init() {
    if (!this.supported) {
      this.element.style.display = 'none';
      return;
    }
    
    this.element.addEventListener('click', () => this.share());
  }
  
  async share(data = {}) {
    const shareData = { ...this.defaultData, ...data };
    
    try {
      await navigator.share(shareData);
      this.onShare?.(shareData);
    } catch (error) {
      if (error.name !== 'AbortError') {
        this.onError?.(error);
      }
    }
  }
}

// Usage
const shareBtn = new ShareButton(
  document.getElementById('share'),
  {
    title: document.title,
    url: location.href
  }
);

shareBtn.onShare = (data) => console.log('Shared:', data);
```

---

## 20.1.6 Fallback Strategies

### Clipboard Fallback

```javascript
async function shareWithFallback(data) {
  if (navigator.share) {
    try {
      await navigator.share(data);
      return 'shared';
    } catch (error) {
      if (error.name !== 'AbortError') throw error;
      return 'cancelled';
    }
  }
  
  // Fallback: copy to clipboard
  const text = data.url || data.text || '';
  await navigator.clipboard.writeText(text);
  return 'copied';
}
```

### Social Links Fallback

```javascript
function getSocialShareLinks(url, title) {
  const encoded = encodeURIComponent(url);
  const encodedTitle = encodeURIComponent(title);
  
  return {
    twitter: `https://twitter.com/intent/tweet?url=${encoded}&text=${encodedTitle}`,
    facebook: `https://www.facebook.com/sharer/sharer.php?u=${encoded}`,
    linkedin: `https://www.linkedin.com/shareArticle?mini=true&url=${encoded}&title=${encodedTitle}`,
    email: `mailto:?subject=${encodedTitle}&body=${encoded}`
  };
}

function showFallbackShare(url, title) {
  const links = getSocialShareLinks(url, title);
  // Display links in a modal
  showShareModal(links);
}
```

---

## 20.1.7 Share Target API

### Receive Shares (PWA)

```json
// manifest.json
{
  "name": "My App",
  "share_target": {
    "action": "/share",
    "method": "POST",
    "enctype": "multipart/form-data",
    "params": {
      "title": "title",
      "text": "text",
      "url": "url",
      "files": [
        {
          "name": "media",
          "accept": ["image/*", "video/*"]
        }
      ]
    }
  }
}
```

### Handle Shared Data

```javascript
// Service Worker
self.addEventListener('fetch', (event) => {
  if (event.request.url.endsWith('/share') && 
      event.request.method === 'POST') {
    event.respondWith(handleShare(event.request));
  }
});

async function handleShare(request) {
  const formData = await request.formData();
  
  const title = formData.get('title');
  const text = formData.get('text');
  const url = formData.get('url');
  const files = formData.getAll('media');
  
  // Store or process shared data
  // Redirect to app
  return Response.redirect('/shared?success=true', 303);
}
```

---

## 20.1.8 Summary

### Method

```javascript
navigator.share(data)
// Returns: Promise<void>
```

### Share Data Properties

| Property | Type | Description |
|----------|------|-------------|
| `title` | String | Share title |
| `text` | String | Share text/description |
| `url` | String | URL to share |
| `files` | File[] | Files to share |

### Related Methods

| Method | Description |
|--------|-------------|
| `navigator.share(data)` | Invoke share dialog |
| `navigator.canShare(data)` | Check if data is shareable |

### Browser Support

| Feature | Chrome | Firefox | Safari |
|---------|--------|---------|--------|
| Basic share | ✅ | ✅ (Android) | ✅ |
| File sharing | ✅ | ❌ | ✅ |
| Share Target | ✅ | ❌ | ✅ |

### Best Practices

1. **Check support** before showing share button
2. **Validate with canShare** before calling share
3. **Handle AbortError** when user cancels
4. **Provide fallback** for unsupported browsers
5. **Keep share data minimal** and relevant
6. **Use Share Target** to receive shares in PWAs

---

**End of Chapter 20.1: Sharing Content**

This completes Group 20 — Web Share API. Next section: **Group 21 — Contact Picker API**.
# 21.1 Selecting Contacts

The Contact Picker API allows web applications to access user contacts with explicit permission. This chapter covers contact selection and property retrieval.

---

## 21.1.1 Basic Usage

### Select Contacts

```javascript
async function selectContacts() {
  if (!('contacts' in navigator)) {
    console.log('Contact Picker not supported');
    return null;
  }
  
  try {
    const contacts = await navigator.contacts.select(
      ['name', 'email', 'tel'],
      { multiple: true }
    );
    
    return contacts;
  } catch (error) {
    if (error.name === 'InvalidStateError') {
      console.log('Another picker is open');
    }
    console.error('Contact selection failed:', error);
    return null;
  }
}
```

---

## 21.1.2 Available Properties

### Property Types

```javascript
// Check supported properties
const supportedProps = await navigator.contacts.getProperties();
console.log('Supported:', supportedProps);

// Common properties:
// - 'name'     - Array of names
// - 'email'    - Array of emails
// - 'tel'      - Array of phone numbers
// - 'address'  - Array of addresses
// - 'icon'     - Array of Blob (contact photos)
```

### Request Specific Properties

```javascript
// Select with specific properties
const contacts = await navigator.contacts.select(
  ['name', 'email'],  // Only name and email
  { multiple: false }  // Single contact
);

const contact = contacts[0];
console.log('Name:', contact.name);    // ['John Doe']
console.log('Email:', contact.email);  // ['john@example.com']
```

---

## 21.1.3 Contact Structure

### Contact Object

```javascript
const contacts = await navigator.contacts.select(
  ['name', 'email', 'tel', 'address'],
  { multiple: true }
);

for (const contact of contacts) {
  // All properties are arrays
  console.log('Names:', contact.name);     // ['John Doe']
  console.log('Emails:', contact.email);   // ['john@example.com', 'john2@work.com']
  console.log('Phones:', contact.tel);     // ['+1234567890']
  console.log('Addresses:', contact.address);
}
```

### Address Format

```javascript
// Address is ContactAddress object
const addresses = contact.address;

for (const addr of addresses) {
  console.log(addr.streetAddress);
  console.log(addr.city);
  console.log(addr.region);  // State/Province
  console.log(addr.postalCode);
  console.log(addr.country);
}
```

### Contact Icons

```javascript
const contacts = await navigator.contacts.select(
  ['name', 'icon'],
  { multiple: false }
);

const contact = contacts[0];
if (contact.icon?.length > 0) {
  const iconBlob = contact.icon[0];
  const url = URL.createObjectURL(iconBlob);
  
  const img = document.createElement('img');
  img.src = url;
  img.onload = () => URL.revokeObjectURL(url);
}
```

---

## 21.1.4 Selection Options

### Multiple Selection

```javascript
// Single contact
const [contact] = await navigator.contacts.select(
  ['name', 'email'],
  { multiple: false }
);

// Multiple contacts
const contacts = await navigator.contacts.select(
  ['name', 'email'],
  { multiple: true }
);
```

---

## 21.1.5 Common Use Cases

### Share via Contact

```javascript
async function shareViaContact() {
  const contacts = await navigator.contacts.select(
    ['name', 'email', 'tel'],
    { multiple: true }
  );
  
  for (const contact of contacts) {
    if (contact.email?.length > 0) {
      // Email share
      await sendEmail(contact.email[0], shareContent);
    } else if (contact.tel?.length > 0) {
      // SMS share
      await sendSMS(contact.tel[0], shareContent);
    }
  }
}
```

### Import Contacts

```javascript
async function importContacts() {
  const props = await navigator.contacts.getProperties();
  
  const contacts = await navigator.contacts.select(
    props,  // All available properties
    { multiple: true }
  );
  
  // Save to app database
  for (const contact of contacts) {
    await saveContact({
      name: contact.name?.[0],
      email: contact.email?.[0],
      phone: contact.tel?.[0]
    });
  }
  
  return contacts.length;
}
```

### Contact Autocomplete

```javascript
class ContactAutocomplete {
  constructor(input) {
    this.input = input;
    this.supported = 'contacts' in navigator;
    
    if (this.supported) {
      this.addPickerButton();
    }
  }
  
  addPickerButton() {
    const button = document.createElement('button');
    button.textContent = '📇';
    button.title = 'Select from contacts';
    button.addEventListener('click', () => this.pick());
    
    this.input.parentNode.insertBefore(button, this.input.nextSibling);
  }
  
  async pick() {
    try {
      const [contact] = await navigator.contacts.select(
        ['name', 'email'],
        { multiple: false }
      );
      
      if (contact) {
        this.input.value = contact.email?.[0] || contact.name?.[0] || '';
        this.input.dispatchEvent(new Event('input'));
      }
    } catch (error) {
      console.error('Contact picker error:', error);
    }
  }
}
```

---

## 21.1.6 Privacy Considerations

### User Gesture Required

```javascript
// ❌ This won't work - no user gesture
window.addEventListener('load', async () => {
  await navigator.contacts.select(['name']);  // Fails
});

// ✅ This works - user clicked button
button.addEventListener('click', async () => {
  await navigator.contacts.select(['name']);  // Works
});
```

### Request Minimal Properties

```javascript
// ✅ Good - request only what's needed
const contacts = await navigator.contacts.select(
  ['email'],  // Only email for sharing
  { multiple: true }
);

// ❌ Avoid - requesting unnecessary data
const contacts = await navigator.contacts.select(
  ['name', 'email', 'tel', 'address', 'icon'],
  { multiple: true }
);
```

---

## 21.1.7 Browser Support

### Feature Detection

```javascript
function isContactPickerSupported() {
  return 'contacts' in navigator && 'ContactsManager' in window;
}

async function getSupportedProperties() {
  if (!isContactPickerSupported()) return [];
  return await navigator.contacts.getProperties();
}
```

### Fallback

```javascript
async function getContactInfo() {
  if (isContactPickerSupported()) {
    const [contact] = await navigator.contacts.select(['name', 'email']);
    return {
      name: contact?.name?.[0],
      email: contact?.email?.[0]
    };
  }
  
  // Fallback: manual input
  return {
    name: prompt('Enter name:'),
    email: prompt('Enter email:')
  };
}
```

---

## 21.1.8 Summary

### Methods

| Method | Description |
|--------|-------------|
| `navigator.contacts.select(props, options)` | Open contact picker |
| `navigator.contacts.getProperties()` | Get supported properties |

### Properties

| Property | Type | Description |
|----------|------|-------------|
| `name` | String[] | Contact names |
| `email` | String[] | Email addresses |
| `tel` | String[] | Phone numbers |
| `address` | ContactAddress[] | Addresses |
| `icon` | Blob[] | Contact photos |

### Options

| Option | Type | Default |
|--------|------|---------|
| `multiple` | Boolean | false |

### Best Practices

1. **Check support** before showing picker button
2. **Request user gesture** — required by spec
3. **Request minimal properties** for privacy
4. **Handle cancellation** gracefully
5. **Handle empty arrays** — properties can be missing
6. **Clean up blob URLs** from icons

---

**End of Chapter 21.1: Selecting Contacts**

This completes Group 21 — Contact Picker API. Next section: **Group 22 — Screen Wake Lock API**.
# 22.1 Preventing Sleep

The Screen Wake Lock API prevents devices from dimming or locking the screen. This chapter covers requesting, releasing, and managing wake locks.

---

## 22.1.1 Basic Usage

### Request Wake Lock

```javascript
async function requestWakeLock() {
  if (!('wakeLock' in navigator)) {
    console.log('Wake Lock not supported');
    return null;
  }
  
  try {
    const wakeLock = await navigator.wakeLock.request('screen');
    console.log('Wake Lock acquired');
    return wakeLock;
  } catch (error) {
    console.error('Wake Lock failed:', error);
    return null;
  }
}
```

---

## 22.1.2 Release Wake Lock

### Manual Release

```javascript
let wakeLock = null;

async function enableWakeLock() {
  wakeLock = await navigator.wakeLock.request('screen');
}

function disableWakeLock() {
  if (wakeLock) {
    wakeLock.release();
    wakeLock = null;
    console.log('Wake Lock released');
  }
}
```

### Automatic Release

```javascript
// Wake lock is automatically released when:
// - Tab becomes inactive
// - User switches to another app
// - Device is low on battery

const wakeLock = await navigator.wakeLock.request('screen');

wakeLock.addEventListener('release', () => {
  console.log('Wake Lock was released');
});
```

---

## 22.1.3 Re-acquire on Visibility Change

### Handle Tab Visibility

```javascript
let wakeLock = null;

async function acquireWakeLock() {
  try {
    wakeLock = await navigator.wakeLock.request('screen');
    
    wakeLock.addEventListener('release', () => {
      console.log('Wake Lock released');
      wakeLock = null;
    });
    
  } catch (error) {
    console.error('Failed to acquire:', error);
  }
}

// Re-acquire when tab becomes visible again
document.addEventListener('visibilitychange', async () => {
  if (wakeLock === null && document.visibilityState === 'visible') {
    await acquireWakeLock();
  }
});

// Initial acquire
acquireWakeLock();
```

---

## 22.1.4 WakeLockSentinel

### Properties

```javascript
const wakeLock = await navigator.wakeLock.request('screen');

wakeLock.type;      // 'screen'
wakeLock.released;  // false (until released)
```

### Events

```javascript
wakeLock.addEventListener('release', () => {
  console.log('Released');
});
```

---

## 22.1.5 Use Cases

### Video Player

```javascript
class VideoPlayer {
  constructor(video) {
    this.video = video;
    this.wakeLock = null;
    
    video.addEventListener('play', () => this.acquireLock());
    video.addEventListener('pause', () => this.releaseLock());
    video.addEventListener('ended', () => this.releaseLock());
  }
  
  async acquireLock() {
    if (!('wakeLock' in navigator)) return;
    
    try {
      this.wakeLock = await navigator.wakeLock.request('screen');
    } catch (error) {
      console.warn('Could not acquire wake lock:', error);
    }
  }
  
  releaseLock() {
    if (this.wakeLock) {
      this.wakeLock.release();
      this.wakeLock = null;
    }
  }
}
```

### Recipe App

```javascript
class RecipeViewer {
  constructor() {
    this.wakeLock = null;
    this.enabled = false;
    
    // Re-acquire on visibility change
    document.addEventListener('visibilitychange', () => {
      if (this.enabled && document.visibilityState === 'visible') {
        this.acquire();
      }
    });
  }
  
  async acquire() {
    if (!('wakeLock' in navigator)) return;
    
    try {
      this.wakeLock = await navigator.wakeLock.request('screen');
      this.wakeLock.addEventListener('release', () => {
        this.wakeLock = null;
      });
    } catch (error) {
      console.warn('Wake lock failed:', error);
    }
  }
  
  enable() {
    this.enabled = true;
    this.acquire();
  }
  
  disable() {
    this.enabled = false;
    if (this.wakeLock) {
      this.wakeLock.release();
      this.wakeLock = null;
    }
  }
}
```

### Presentation Mode

```javascript
class PresentationMode {
  constructor() {
    this.wakeLock = null;
  }
  
  async start() {
    // Request fullscreen
    await document.documentElement.requestFullscreen();
    
    // Prevent screen sleep
    if ('wakeLock' in navigator) {
      this.wakeLock = await navigator.wakeLock.request('screen');
    }
  }
  
  async stop() {
    // Exit fullscreen
    if (document.fullscreenElement) {
      await document.exitFullscreen();
    }
    
    // Release wake lock
    if (this.wakeLock) {
      await this.wakeLock.release();
      this.wakeLock = null;
    }
  }
}
```

---

## 22.1.6 Complete Wake Lock Manager

### Reusable Class

```javascript
class WakeLockManager {
  constructor() {
    this.wakeLock = null;
    this.active = false;
    this.supported = 'wakeLock' in navigator;
    
    if (this.supported) {
      document.addEventListener('visibilitychange', () => {
        this.handleVisibilityChange();
      });
    }
  }
  
  async request() {
    if (!this.supported) {
      console.warn('Wake Lock not supported');
      return false;
    }
    
    this.active = true;
    return await this.acquire();
  }
  
  async acquire() {
    if (!this.active) return false;
    
    try {
      this.wakeLock = await navigator.wakeLock.request('screen');
      
      this.wakeLock.addEventListener('release', () => {
        this.wakeLock = null;
        this.onRelease?.();
      });
      
      this.onAcquire?.();
      return true;
      
    } catch (error) {
      this.onError?.(error);
      return false;
    }
  }
  
  async release() {
    this.active = false;
    
    if (this.wakeLock) {
      await this.wakeLock.release();
      this.wakeLock = null;
    }
  }
  
  handleVisibilityChange() {
    if (this.active && document.visibilityState === 'visible' && !this.wakeLock) {
      this.acquire();
    }
  }
  
  get isLocked() {
    return this.wakeLock !== null;
  }
}

// Usage
const wakelock = new WakeLockManager();

wakelock.onAcquire = () => console.log('Screen will stay awake');
wakelock.onRelease = () => console.log('Screen may sleep');

await wakelock.request();
// ... later
await wakelock.release();
```

---

## 22.1.7 Summary

### Method

```javascript
navigator.wakeLock.request(type)
// type: 'screen' (only type currently)
// Returns: Promise<WakeLockSentinel>
```

### WakeLockSentinel

| Property | Type | Description |
|----------|------|-------------|
| `type` | String | Wake lock type ('screen') |
| `released` | Boolean | Whether released |

| Method | Description |
|--------|-------------|
| `release()` | Release the wake lock |

| Event | When |
|-------|------|
| `release` | Wake lock released |

### Automatic Release Triggers

- Tab becomes hidden
- User switches apps
- System low battery
- Manual `release()` call

### Best Practices

1. **Check support** before using
2. **Re-acquire on visibility change** if needed
3. **Release when not needed** to save battery
4. **Handle release events** for UI updates
5. **Use for appropriate scenarios** (video, recipes, maps)
6. **Don't overuse** — respect user battery

---

**End of Chapter 22.1: Preventing Sleep**

This completes Group 22 — Screen Wake Lock API. Next section: **Group 23 — Idle Detection API**.
# 23.1 User Idle State

The Idle Detection API allows applications to detect when users are idle or away from their devices. This chapter covers idle detection setup and state monitoring.

---

## 23.1.1 Basic Usage

### Create Idle Detector

```javascript
async function startIdleDetection() {
  if (!('IdleDetector' in window)) {
    console.log('Idle Detection not supported');
    return null;
  }
  
  // Request permission first
  const permission = await IdleDetector.requestPermission();
  
  if (permission !== 'granted') {
    console.log('Permission denied');
    return null;
  }
  
  const detector = new IdleDetector();
  
  detector.addEventListener('change', () => {
    console.log('User state:', detector.userState);
    console.log('Screen state:', detector.screenState);
  });
  
  await detector.start({
    threshold: 60000  // 60 seconds
  });
  
  return detector;
}
```

---

## 23.1.2 State Values

### User State

```javascript
// detector.userState values:
// 'active' - User is interacting
// 'idle' - No interaction for threshold time
```

### Screen State

```javascript
// detector.screenState values:
// 'unlocked' - Screen is on
// 'locked' - Screen is locked
```

### Combined States

```javascript
detector.addEventListener('change', () => {
  const { userState, screenState } = detector;
  
  if (userState === 'idle' && screenState === 'locked') {
    // User is away with locked screen
    handleUserAway();
  } else if (userState === 'idle') {
    // User is idle but screen on
    handleUserIdle();
  } else {
    // User is active
    handleUserActive();
  }
});
```

---

## 23.1.3 Configuration

### Threshold

```javascript
// Minimum idle time before state changes to 'idle'
await detector.start({
  threshold: 60000     // 60 seconds minimum
  // Minimum is 60000ms (1 minute)
});

// ❌ Won't work - threshold too low
await detector.start({
  threshold: 10000  // Error: must be >= 60000
});
```

---

## 23.1.4 Stop Detection

### Cleanup

```javascript
let idleDetector = null;

async function startDetection() {
  idleDetector = new IdleDetector();
  
  idleDetector.addEventListener('change', handleChange);
  
  await idleDetector.start({ threshold: 60000 });
}

function stopDetection() {
  if (idleDetector) {
    idleDetector.abort();
    idleDetector = null;
  }
}

// Stop when page unloads
window.addEventListener('beforeunload', stopDetection);
```

---

## 23.1.5 Permission Handling

### Request Permission

```javascript
async function checkIdlePermission() {
  // Check if API is available
  if (!('IdleDetector' in window)) {
    return 'unsupported';
  }
  
  // Request permission
  try {
    const permission = await IdleDetector.requestPermission();
    return permission;  // 'granted' or 'denied'
  } catch (error) {
    return 'error';
  }
}
```

### Permission UI Pattern

```javascript
async function setupIdleDetection() {
  const permission = await checkIdlePermission();
  
  switch (permission) {
    case 'granted':
      startIdleDetector();
      break;
      
    case 'denied':
      showPermissionDeniedMessage();
      break;
      
    case 'unsupported':
      useFallbackDetection();
      break;
  }
}
```

---

## 23.1.6 Use Cases

### Auto-Logout

```javascript
class AutoLogout {
  constructor(options = {}) {
    this.warningTime = options.warningTime || 4 * 60 * 1000;  // 4 min
    this.logoutTime = options.logoutTime || 5 * 60 * 1000;    // 5 min
    this.detector = null;
    this.warningTimeout = null;
    this.logoutTimeout = null;
  }
  
  async start() {
    if (!('IdleDetector' in window)) return;
    
    const permission = await IdleDetector.requestPermission();
    if (permission !== 'granted') return;
    
    this.detector = new IdleDetector();
    this.detector.addEventListener('change', () => this.handleChange());
    
    await this.detector.start({ threshold: 60000 });
  }
  
  handleChange() {
    if (this.detector.userState === 'idle') {
      this.startIdleTimers();
    } else {
      this.clearIdleTimers();
    }
  }
  
  startIdleTimers() {
    this.warningTimeout = setTimeout(() => {
      this.showWarning();
    }, this.warningTime - 60000);  // Subtract initial threshold
    
    this.logoutTimeout = setTimeout(() => {
      this.logout();
    }, this.logoutTime - 60000);
  }
  
  clearIdleTimers() {
    clearTimeout(this.warningTimeout);
    clearTimeout(this.logoutTimeout);
    this.hideWarning();
  }
  
  showWarning() {
    // Show "Are you still there?" dialog
  }
  
  hideWarning() {
    // Hide warning dialog
  }
  
  logout() {
    // Perform logout
    window.location.href = '/logout';
  }
  
  stop() {
    this.clearIdleTimers();
    this.detector?.abort();
  }
}
```

### Presence Indicator

```javascript
class PresenceIndicator {
  constructor(userId) {
    this.userId = userId;
    this.detector = null;
    this.lastState = 'active';
  }
  
  async start() {
    if (!('IdleDetector' in window)) {
      // Fallback: just report as active
      this.updatePresence('active');
      return;
    }
    
    const permission = await IdleDetector.requestPermission();
    if (permission !== 'granted') return;
    
    this.detector = new IdleDetector();
    this.detector.addEventListener('change', () => this.handleChange());
    
    await this.detector.start({ threshold: 120000 });  // 2 min
  }
  
  handleChange() {
    const { userState, screenState } = this.detector;
    let presence;
    
    if (userState === 'active') {
      presence = 'online';
    } else if (screenState === 'locked') {
      presence = 'away';
    } else {
      presence = 'idle';
    }
    
    if (presence !== this.lastState) {
      this.lastState = presence;
      this.updatePresence(presence);
    }
  }
  
  async updatePresence(status) {
    await fetch('/api/presence', {
      method: 'POST',
      body: JSON.stringify({
        userId: this.userId,
        status
      }),
      headers: { 'Content-Type': 'application/json' }
    });
  }
  
  stop() {
    this.detector?.abort();
    this.updatePresence('offline');
  }
}
```

### Pause Media When Idle

```javascript
class SmartMediaPlayer {
  constructor(mediaElement) {
    this.media = mediaElement;
    this.detector = null;
    this.wasPlayingBeforeIdle = false;
  }
  
  async enableIdlePause() {
    if (!('IdleDetector' in window)) return;
    
    const permission = await IdleDetector.requestPermission();
    if (permission !== 'granted') return;
    
    this.detector = new IdleDetector();
    this.detector.addEventListener('change', () => {
      if (this.detector.userState === 'idle') {
        this.handleIdle();
      } else {
        this.handleActive();
      }
    });
    
    await this.detector.start({ threshold: 60000 });
  }
  
  handleIdle() {
    if (!this.media.paused) {
      this.wasPlayingBeforeIdle = true;
      this.media.pause();
    }
  }
  
  handleActive() {
    if (this.wasPlayingBeforeIdle) {
      this.wasPlayingBeforeIdle = false;
      this.media.play();
    }
  }
}
```

---

## 23.1.7 Summary

### Static Methods

| Method | Description |
|--------|-------------|
| `IdleDetector.requestPermission()` | Request permission |

### Instance Methods

| Method | Description |
|--------|-------------|
| `start(options)` | Start detecting |
| `abort()` | Stop detecting |

### Properties

| Property | Values | Description |
|----------|--------|-------------|
| `userState` | 'active', 'idle' | User interaction state |
| `screenState` | 'unlocked', 'locked' | Screen lock state |

### Start Options

| Option | Type | Description |
|--------|------|-------------|
| `threshold` | Number | Idle time in ms (min 60000) |

### Events

| Event | When |
|-------|------|
| `change` | User or screen state changes |

### Best Practices

1. **Request permission** with user explanation
2. **Handle denied permission** gracefully
3. **Use appropriate threshold** (1-5 minutes typical)
4. **Clean up** with abort() when done
5. **Provide fallback** for unsupported browsers
6. **Respect privacy** — don't track unnecessarily

---

**End of Chapter 23.1: User Idle State**

This completes Group 23 — Idle Detection API. Continuing with specialized device APIs.
# 24.1 Serial Port Access

The Web Serial API provides access to serial devices connected via USB, RS-232, or Bluetooth. This chapter covers port selection, reading, and writing.

---

## 24.1.1 Basic Usage

### Request Port

```javascript
async function connectSerial() {
  if (!('serial' in navigator)) {
    console.log('Web Serial not supported');
    return null;
  }
  
  try {
    // User must select a port
    const port = await navigator.serial.requestPort();
    
    // Open with settings
    await port.open({ baudRate: 9600 });
    
    console.log('Connected');
    return port;
    
  } catch (error) {
    console.error('Connection failed:', error);
    return null;
  }
}
```

---

## 24.1.2 Port Settings

### Open Options

```javascript
await port.open({
  baudRate: 9600,      // Required
  dataBits: 8,         // 7 or 8
  stopBits: 1,         // 1 or 2
  parity: 'none',      // 'none', 'even', 'odd'
  bufferSize: 255,     // Read buffer size
  flowControl: 'none'  // 'none' or 'hardware'
});
```

### Common Baud Rates

```javascript
// Common baud rates
// 9600  - Default for many devices
// 115200 - Fast serial
// 57600, 38400, 19200, 4800, 2400, 1200
```

---

## 24.1.3 Reading Data

### Stream Reader

```javascript
async function readSerial(port) {
  const decoder = new TextDecoderStream();
  const reader = port.readable.pipeThrough(decoder).getReader();
  
  try {
    while (true) {
      const { value, done } = await reader.read();
      
      if (done) {
        console.log('Reader closed');
        break;
      }
      
      console.log('Received:', value);
    }
  } catch (error) {
    console.error('Read error:', error);
  } finally {
    reader.releaseLock();
  }
}
```

### Read Raw Bytes

```javascript
async function readBytes(port) {
  const reader = port.readable.getReader();
  
  try {
    const { value, done } = await reader.read();
    
    if (!done) {
      // value is Uint8Array
      console.log('Bytes:', value);
    }
  } finally {
    reader.releaseLock();
  }
}
```

---

## 24.1.4 Writing Data

### Write Text

```javascript
async function writeSerial(port, text) {
  const encoder = new TextEncoder();
  const writer = port.writable.getWriter();
  
  try {
    await writer.write(encoder.encode(text));
  } finally {
    writer.releaseLock();
  }
}
```

### Write Bytes

```javascript
async function writeBytes(port, bytes) {
  const writer = port.writable.getWriter();
  
  try {
    await writer.write(new Uint8Array(bytes));
  } finally {
    writer.releaseLock();
  }
}

// Usage
await writeBytes(port, [0x01, 0x02, 0x03]);
```

---

## 24.1.5 Close Connection

### Clean Disconnect

```javascript
async function disconnectSerial(port, reader, writer) {
  // Release locks first
  reader?.releaseLock();
  writer?.releaseLock();
  
  // Close port
  await port.close();
  console.log('Disconnected');
}
```

---

## 24.1.6 Port Events

### Connection Events

```javascript
navigator.serial.addEventListener('connect', (event) => {
  console.log('Port connected:', event.target);
});

navigator.serial.addEventListener('disconnect', (event) => {
  console.log('Port disconnected:', event.target);
});
```

---

## 24.1.7 Previously Connected Ports

### Get Authorized Ports

```javascript
async function getKnownPorts() {
  const ports = await navigator.serial.getPorts();
  
  for (const port of ports) {
    const info = port.getInfo();
    console.log('Known port:', info);
  }
  
  return ports;
}
```

---

## 24.1.8 Complete Example

### Serial Terminal

```javascript
class SerialTerminal {
  constructor() {
    this.port = null;
    this.reader = null;
    this.writer = null;
  }
  
  async connect(baudRate = 9600) {
    this.port = await navigator.serial.requestPort();
    await this.port.open({ baudRate });
    
    this.startReading();
    return true;
  }
  
  async startReading() {
    const decoder = new TextDecoderStream();
    this.reader = this.port.readable.pipeThrough(decoder).getReader();
    
    try {
      while (true) {
        const { value, done } = await this.reader.read();
        if (done) break;
        this.onData?.(value);
      }
    } catch (error) {
      this.onError?.(error);
    }
  }
  
  async send(text) {
    if (!this.port?.writable) return;
    
    const encoder = new TextEncoder();
    const writer = this.port.writable.getWriter();
    
    try {
      await writer.write(encoder.encode(text + '\n'));
    } finally {
      writer.releaseLock();
    }
  }
  
  async disconnect() {
    this.reader?.cancel();
    this.reader?.releaseLock();
    await this.port?.close();
    this.port = null;
  }
}

// Usage
const terminal = new SerialTerminal();
terminal.onData = (data) => console.log('RX:', data);
await terminal.connect(115200);
await terminal.send('Hello');
```

---

## 24.1.9 Summary

### Methods

| Method | Description |
|--------|-------------|
| `navigator.serial.requestPort()` | User selects port |
| `navigator.serial.getPorts()` | Get authorized ports |
| `port.open(options)` | Open port |
| `port.close()` | Close port |
| `port.getInfo()` | Get port info |

### Open Options

| Option | Type | Default |
|--------|------|---------|
| `baudRate` | Number | Required |
| `dataBits` | Number | 8 |
| `stopBits` | Number | 1 |
| `parity` | String | 'none' |
| `flowControl` | String | 'none' |

### Events

| Event | When |
|-------|------|
| `connect` | Port connected |
| `disconnect` | Port disconnected |

### Best Practices

1. **Request port via user gesture**
2. **Handle disconnect events**
3. **Release locks before closing**
4. **Use TextEncoderStream/DecoderStream** for text
5. **Buffer incoming data** if parsing packets
6. **Handle errors** gracefully

---

**End of Chapter 24.1: Serial Port Access**

Next: **25.1 USB Device Access** — Web USB API.
# 25.1 USB Device Access

The WebUSB API provides access to USB devices from web pages. This chapter covers device selection, communication, and data transfer.

---

## 25.1.1 Basic Usage

### Request Device

```javascript
async function connectUSB() {
  if (!('usb' in navigator)) {
    console.log('WebUSB not supported');
    return null;
  }
  
  try {
    const device = await navigator.usb.requestDevice({
      filters: [
        { vendorId: 0x1234 }  // Filter by vendor
      ]
    });
    
    await device.open();
    console.log('Connected:', device.productName);
    
    return device;
    
  } catch (error) {
    console.error('Connection failed:', error);
    return null;
  }
}
```

---

## 25.1.2 Device Filters

### Filter Options

```javascript
// Filter by vendor
const device = await navigator.usb.requestDevice({
  filters: [{ vendorId: 0x1234 }]
});

// Filter by vendor and product
const device = await navigator.usb.requestDevice({
  filters: [{
    vendorId: 0x1234,
    productId: 0x5678
  }]
});

// Multiple filters (OR logic)
const device = await navigator.usb.requestDevice({
  filters: [
    { vendorId: 0x1234 },
    { vendorId: 0x5678 }
  ]
});

// Filter by class
const device = await navigator.usb.requestDevice({
  filters: [{
    classCode: 0xFF  // Vendor-specific
  }]
});
```

---

## 25.1.3 Device Setup

### Open and Configure

```javascript
async function setupDevice(device) {
  // Open device
  await device.open();
  
  // Select configuration
  if (device.configuration === null) {
    await device.selectConfiguration(1);
  }
  
  // Claim interface
  await device.claimInterface(0);
  
  console.log('Device ready');
}
```

---

## 25.1.4 Control Transfers

### Send Control Command

```javascript
async function controlOut(device, request, value, data) {
  const result = await device.controlTransferOut({
    requestType: 'vendor',
    recipient: 'device',
    request,
    value,
    index: 0
  }, data);
  
  return result.status === 'ok';
}

// Read control response
async function controlIn(device, request, value, length) {
  const result = await device.controlTransferIn({
    requestType: 'vendor',
    recipient: 'device',
    request,
    value,
    index: 0
  }, length);
  
  if (result.status === 'ok') {
    return result.data;  // DataView
  }
  
  throw new Error('Control transfer failed');
}
```

---

## 25.1.5 Bulk Transfers

### Send Data

```javascript
async function bulkOut(device, endpoint, data) {
  const result = await device.transferOut(endpoint, data);
  
  if (result.status !== 'ok') {
    throw new Error(`Transfer failed: ${result.status}`);
  }
  
  return result.bytesWritten;
}

// Usage
const encoder = new TextEncoder();
await bulkOut(device, 1, encoder.encode('Hello'));
```

### Receive Data

```javascript
async function bulkIn(device, endpoint, length) {
  const result = await device.transferIn(endpoint, length);
  
  if (result.status === 'ok') {
    return new Uint8Array(result.data.buffer);
  }
  
  throw new Error(`Transfer failed: ${result.status}`);
}

// Usage
const data = await bulkIn(device, 1, 64);
```

---

## 25.1.6 Close Device

### Clean Disconnect

```javascript
async function disconnectUSB(device) {
  try {
    await device.releaseInterface(0);
    await device.close();
    console.log('Disconnected');
  } catch (error) {
    console.error('Disconnect error:', error);
  }
}
```

---

## 25.1.7 Device Events

### Connection Events

```javascript
navigator.usb.addEventListener('connect', (event) => {
  console.log('Device connected:', event.device.productName);
});

navigator.usb.addEventListener('disconnect', (event) => {
  console.log('Device disconnected:', event.device.productName);
});
```

---

## 25.1.8 Get Authorized Devices

### Previously Connected

```javascript
async function getKnownDevices() {
  const devices = await navigator.usb.getDevices();
  
  for (const device of devices) {
    console.log('Known device:', device.productName);
  }
  
  return devices;
}
```

---

## 25.1.9 Complete Example

### USB Device Class

```javascript
class USBDevice {
  constructor() {
    this.device = null;
  }
  
  async connect(vendorId) {
    this.device = await navigator.usb.requestDevice({
      filters: [{ vendorId }]
    });
    
    await this.device.open();
    await this.device.selectConfiguration(1);
    await this.device.claimInterface(0);
    
    return true;
  }
  
  async send(endpoint, data) {
    if (!this.device) throw new Error('Not connected');
    
    const result = await this.device.transferOut(endpoint, data);
    return result.status === 'ok';
  }
  
  async receive(endpoint, length) {
    if (!this.device) throw new Error('Not connected');
    
    const result = await this.device.transferIn(endpoint, length);
    
    if (result.status === 'ok') {
      return new Uint8Array(result.data.buffer);
    }
    
    return null;
  }
  
  async disconnect() {
    if (this.device) {
      await this.device.releaseInterface(0);
      await this.device.close();
      this.device = null;
    }
  }
}
```

---

## 25.1.10 Summary

### Methods

| Method | Description |
|--------|-------------|
| `navigator.usb.requestDevice(options)` | User selects device |
| `navigator.usb.getDevices()` | Get authorized devices |
| `device.open()` | Open device |
| `device.close()` | Close device |
| `device.selectConfiguration(n)` | Select config |
| `device.claimInterface(n)` | Claim interface |
| `device.releaseInterface(n)` | Release interface |

### Transfer Methods

| Method | Description |
|--------|-------------|
| `controlTransferIn(setup, length)` | Read control |
| `controlTransferOut(setup, data)` | Write control |
| `transferIn(endpoint, length)` | Read bulk |
| `transferOut(endpoint, data)` | Write bulk |

### Best Practices

1. **Filter by vendor ID** when possible
2. **Select configuration** before claiming interface
3. **Release interface** before closing
4. **Handle disconnect** events
5. **Use appropriate transfer type** for data

---

**End of Chapter 25.1: USB Device Access**

Next: **26.1 Bluetooth Device Access** — Web Bluetooth API.
# 26.1 Bluetooth Device Access

The Web Bluetooth API enables communication with Bluetooth Low Energy (BLE) devices. This chapter covers device discovery, GATT services, and data exchange.

---

## 26.1.1 Basic Usage

### Request Device

```javascript
async function connectBluetooth() {
  if (!('bluetooth' in navigator)) {
    console.log('Web Bluetooth not supported');
    return null;
  }
  
  try {
    const device = await navigator.bluetooth.requestDevice({
      filters: [{ services: ['heart_rate'] }]
    });
    
    console.log('Selected:', device.name);
    
    const server = await device.gatt.connect();
    console.log('Connected');
    
    return { device, server };
    
  } catch (error) {
    console.error('Connection failed:', error);
    return null;
  }
}
```

---

## 26.1.2 Device Filters

### Filter by Service

```javascript
const device = await navigator.bluetooth.requestDevice({
  filters: [
    { services: ['heart_rate'] },
    { services: ['battery_service'] }
  ]
});
```

### Filter by Name

```javascript
const device = await navigator.bluetooth.requestDevice({
  filters: [
    { name: 'MyDevice' },
    { namePrefix: 'My' }
  ],
  optionalServices: ['battery_service']
});
```

### Accept All Devices

```javascript
// ⚠️ Shows all Bluetooth devices
const device = await navigator.bluetooth.requestDevice({
  acceptAllDevices: true,
  optionalServices: ['battery_service']
});
```

---

## 26.1.3 GATT Server

### Connect to GATT

```javascript
const server = await device.gatt.connect();

// Check connection
console.log('Connected:', server.connected);

// Disconnect
device.gatt.disconnect();
```

### Handle Disconnection

```javascript
device.addEventListener('gattserverdisconnected', () => {
  console.log('Device disconnected');
  
  // Attempt reconnect
  setTimeout(() => reconnect(device), 1000);
});

async function reconnect(device) {
  try {
    await device.gatt.connect();
    console.log('Reconnected');
  } catch (error) {
    console.log('Reconnect failed');
  }
}
```

---

## 26.1.4 Services and Characteristics

### Get Service

```javascript
const service = await server.getPrimaryService('heart_rate');

// Or by UUID
const service = await server.getPrimaryService(
  '0000180d-0000-1000-8000-00805f9b34fb'
);
```

### Get Characteristic

```javascript
const characteristic = await service.getCharacteristic('heart_rate_measurement');

// Or by UUID
const characteristic = await service.getCharacteristic(
  '00002a37-0000-1000-8000-00805f9b34fb'
);
```

---

## 26.1.5 Reading Values

### Read Characteristic

```javascript
const value = await characteristic.readValue();

// value is DataView
const heartRate = value.getUint8(1);
console.log('Heart Rate:', heartRate);
```

### Read Battery Level

```javascript
async function getBatteryLevel(server) {
  const service = await server.getPrimaryService('battery_service');
  const char = await service.getCharacteristic('battery_level');
  const value = await char.readValue();
  
  return value.getUint8(0);
}
```

---

## 26.1.6 Writing Values

### Write Characteristic

```javascript
// Write with response
await characteristic.writeValueWithResponse(
  new Uint8Array([0x01, 0x02])
);

// Write without response (faster)
await characteristic.writeValueWithoutResponse(
  new Uint8Array([0x01, 0x02])
);
```

---

## 26.1.7 Notifications

### Subscribe to Changes

```javascript
async function subscribeToHeartRate(characteristic) {
  // Start notifications
  await characteristic.startNotifications();
  
  characteristic.addEventListener('characteristicvaluechanged', (event) => {
    const value = event.target.value;
    const heartRate = value.getUint8(1);
    console.log('Heart Rate:', heartRate);
  });
}

// Stop notifications
await characteristic.stopNotifications();
```

---

## 26.1.8 Complete Example

### Heart Rate Monitor

```javascript
class HeartRateMonitor {
  constructor() {
    this.device = null;
    this.server = null;
    this.characteristic = null;
  }
  
  async connect() {
    this.device = await navigator.bluetooth.requestDevice({
      filters: [{ services: ['heart_rate'] }]
    });
    
    this.device.addEventListener('gattserverdisconnected', 
      () => this.onDisconnect());
    
    this.server = await this.device.gatt.connect();
    
    const service = await this.server.getPrimaryService('heart_rate');
    this.characteristic = await service.getCharacteristic('heart_rate_measurement');
    
    await this.characteristic.startNotifications();
    this.characteristic.addEventListener('characteristicvaluechanged', 
      (e) => this.handleHeartRate(e));
    
    return true;
  }
  
  handleHeartRate(event) {
    const value = event.target.value;
    const flags = value.getUint8(0);
    let heartRate;
    
    if (flags & 0x01) {
      heartRate = value.getUint16(1, true);
    } else {
      heartRate = value.getUint8(1);
    }
    
    this.onHeartRate?.(heartRate);
  }
  
  onDisconnect() {
    console.log('Disconnected');
    this.onDisconnected?.();
  }
  
  disconnect() {
    if (this.characteristic) {
      this.characteristic.stopNotifications();
    }
    if (this.device?.gatt.connected) {
      this.device.gatt.disconnect();
    }
  }
}

// Usage
const monitor = new HeartRateMonitor();
monitor.onHeartRate = (bpm) => console.log('BPM:', bpm);
await monitor.connect();
```

---

## 26.1.9 Summary

### Methods

| Method | Description |
|--------|-------------|
| `navigator.bluetooth.requestDevice(options)` | Select device |
| `device.gatt.connect()` | Connect to GATT |
| `device.gatt.disconnect()` | Disconnect |
| `server.getPrimaryService(name)` | Get service |
| `service.getCharacteristic(name)` | Get characteristic |

### Characteristic Methods

| Method | Description |
|--------|-------------|
| `readValue()` | Read value |
| `writeValueWithResponse(data)` | Write with confirmation |
| `writeValueWithoutResponse(data)` | Write without confirmation |
| `startNotifications()` | Subscribe to changes |
| `stopNotifications()` | Unsubscribe |

### Common Service UUIDs

| Service | UUID/Name |
|---------|-----------|
| Heart Rate | `heart_rate` |
| Battery | `battery_service` |
| Device Info | `device_information` |

### Best Practices

1. **Use filters** to find relevant devices
2. **Handle disconnection** with reconnect logic
3. **Stop notifications** when done
4. **Check characteristic properties** before operations
5. **Parse DataView** correctly based on protocol

---

**End of Chapter 26.1: Bluetooth Device Access**

Next: **27.1 NFC Operations** — Web NFC API.
# 27.1 NFC Operations

The Web NFC API enables reading and writing NFC tags on supported devices. This chapter covers NFC tag reading, writing, and NDEF message handling.

---

## 27.1.1 Basic Usage

### Read NFC Tag

```javascript
async function readNFC() {
  if (!('NDEFReader' in window)) {
    console.log('Web NFC not supported');
    return;
  }
  
  const reader = new NDEFReader();
  
  try {
    await reader.scan();
    console.log('Scanning...');
    
    reader.addEventListener('reading', (event) => {
      console.log('Serial:', event.serialNumber);
      
      for (const record of event.message.records) {
        console.log('Type:', record.recordType);
        console.log('Data:', record.data);
      }
    });
    
  } catch (error) {
    console.error('Scan failed:', error);
  }
}
```

---

## 27.1.2 NDEF Records

### Record Types

```javascript
reader.addEventListener('reading', (event) => {
  for (const record of event.message.records) {
    switch (record.recordType) {
      case 'text':
        const decoder = new TextDecoder(record.encoding);
        console.log('Text:', decoder.decode(record.data));
        break;
        
      case 'url':
        console.log('URL:', new TextDecoder().decode(record.data));
        break;
        
      case 'mime':
        console.log('MIME type:', record.mediaType);
        break;
        
      case 'smart-poster':
        // Contains nested records
        break;
    }
  }
});
```

### Read Text Record

```javascript
function readTextRecord(record) {
  const decoder = new TextDecoder(record.encoding);
  return decoder.decode(record.data);
}
```

### Read URL Record

```javascript
function readURLRecord(record) {
  const decoder = new TextDecoder();
  return decoder.decode(record.data);
}
```

---

## 27.1.3 Write NFC Tag

### Write Text

```javascript
async function writeText(text) {
  const writer = new NDEFReader();
  
  try {
    await writer.write({
      records: [{
        recordType: 'text',
        data: text
      }]
    });
    
    console.log('Written successfully');
    
  } catch (error) {
    console.error('Write failed:', error);
  }
}
```

### Write URL

```javascript
async function writeURL(url) {
  const writer = new NDEFReader();
  
  await writer.write({
    records: [{
      recordType: 'url',
      data: url
    }]
  });
}
```

### Write Multiple Records

```javascript
async function writeMultiple() {
  const writer = new NDEFReader();
  
  await writer.write({
    records: [
      {
        recordType: 'url',
        data: 'https://example.com'
      },
      {
        recordType: 'text',
        data: 'Visit our website'
      }
    ]
  });
}
```

---

## 27.1.4 Write Options

### Signal for Abort

```javascript
const controller = new AbortController();

const writer = new NDEFReader();

await writer.write(
  { records: [{ recordType: 'text', data: 'Hello' }] },
  { signal: controller.signal }
);

// Cancel write
controller.abort();
```

### Overwrite Protection

```javascript
await writer.write(
  { records: [{ recordType: 'text', data: 'Hello' }] },
  { overwrite: false }  // Don't overwrite existing data
);
```

---

## 27.1.5 Reading Events

### Handle Multiple Tags

```javascript
const reader = new NDEFReader();

reader.addEventListener('reading', (event) => {
  console.log('Tag serial:', event.serialNumber);
  processTag(event.message);
});

reader.addEventListener('readingerror', (event) => {
  console.error('Read error');
});

await reader.scan();
```

---

## 27.1.6 Permission Handling

### Request Permission

```javascript
async function checkNFCPermission() {
  try {
    const permission = await navigator.permissions.query({ name: 'nfc' });
    return permission.state;
  } catch {
    return 'unsupported';
  }
}
```

---

## 27.1.7 Complete Example

### NFC Card Reader

```javascript
class NFCCardReader {
  constructor() {
    this.reader = null;
    this.controller = null;
  }
  
  async startScanning() {
    if (!('NDEFReader' in window)) {
      throw new Error('NFC not supported');
    }
    
    this.reader = new NDEFReader();
    this.controller = new AbortController();
    
    this.reader.addEventListener('reading', (e) => this.handleRead(e));
    this.reader.addEventListener('readingerror', () => this.onError?.());
    
    await this.reader.scan({ signal: this.controller.signal });
  }
  
  handleRead(event) {
    const data = {
      serialNumber: event.serialNumber,
      records: []
    };
    
    for (const record of event.message.records) {
      const decoder = new TextDecoder(record.encoding || 'utf-8');
      
      data.records.push({
        type: record.recordType,
        data: decoder.decode(record.data)
      });
    }
    
    this.onRead?.(data);
  }
  
  async write(records) {
    const writer = new NDEFReader();
    await writer.write({ records });
  }
  
  stopScanning() {
    this.controller?.abort();
  }
}

// Usage
const nfc = new NFCCardReader();
nfc.onRead = (data) => console.log('Read:', data);
await nfc.startScanning();
```

---

## 27.1.8 Summary

### NDEFReader Methods

| Method | Description |
|--------|-------------|
| `scan(options)` | Start scanning |
| `write(message, options)` | Write to tag |

### Events

| Event | When |
|-------|------|
| `reading` | Tag read successfully |
| `readingerror` | Tag read failed |

### Record Types

| Type | Description |
|------|-------------|
| `text` | Text record |
| `url` | URL record |
| `mime` | MIME type record |
| `smart-poster` | Smart poster |
| `empty` | Empty record |
| `unknown` | Unknown type |

### Best Practices

1. **Check support** before using
2. **Handle permission** gracefully
3. **Use AbortController** to stop scanning
4. **Decode data** with correct encoding
5. **Handle errors** for read failures
6. **Test on real devices** — emulators limited

---

**End of Chapter 27.1: NFC Operations**

Next: **28.1 MIDI Access** — Web MIDI API.
# 28.1 MIDI Access

The Web MIDI API provides access to MIDI devices for musical input and output. This chapter covers MIDI input/output, message handling, and device communication.

---

## 28.1.1 Basic Usage

### Request MIDI Access

```javascript
async function connectMIDI() {
  if (!('requestMIDIAccess' in navigator)) {
    console.log('Web MIDI not supported');
    return null;
  }
  
  try {
    const midiAccess = await navigator.requestMIDIAccess();
    console.log('MIDI access granted');
    
    listDevices(midiAccess);
    return midiAccess;
    
  } catch (error) {
    console.error('MIDI access denied:', error);
    return null;
  }
}
```

---

## 28.1.2 List Devices

### Inputs and Outputs

```javascript
function listDevices(midiAccess) {
  console.log('--- Inputs ---');
  for (const input of midiAccess.inputs.values()) {
    console.log(input.name, input.manufacturer);
  }
  
  console.log('--- Outputs ---');
  for (const output of midiAccess.outputs.values()) {
    console.log(output.name, output.manufacturer);
  }
}
```

---

## 28.1.3 Receive MIDI Messages

### Listen to Input

```javascript
function setupInput(midiAccess) {
  for (const input of midiAccess.inputs.values()) {
    input.addEventListener('midimessage', handleMIDI);
  }
}

function handleMIDI(event) {
  const [status, data1, data2] = event.data;
  
  const command = status >> 4;
  const channel = status & 0xF;
  
  switch (command) {
    case 9:  // Note On
      if (data2 > 0) {
        console.log('Note On:', data1, 'Velocity:', data2);
      } else {
        console.log('Note Off:', data1);
      }
      break;
      
    case 8:  // Note Off
      console.log('Note Off:', data1);
      break;
      
    case 11:  // Control Change
      console.log('CC:', data1, 'Value:', data2);
      break;
  }
}
```

---

## 28.1.4 Send MIDI Messages

### Send to Output

```javascript
function sendNoteOn(output, note, velocity = 127, channel = 0) {
  const status = 0x90 | channel;  // Note On, channel
  output.send([status, note, velocity]);
}

function sendNoteOff(output, note, channel = 0) {
  const status = 0x80 | channel;  // Note Off, channel
  output.send([status, note, 0]);
}

function sendCC(output, controller, value, channel = 0) {
  const status = 0xB0 | channel;  // Control Change
  output.send([status, controller, value]);
}
```

### Timed Messages

```javascript
// Send with timestamp
output.send([0x90, 60, 127], performance.now() + 1000);

// Clear scheduled messages
output.clear();
```

---

## 28.1.5 Device Events

### Connection Changes

```javascript
midiAccess.addEventListener('statechange', (event) => {
  const port = event.port;
  
  console.log(port.type, port.name, port.state);
  // port.state: 'connected' or 'disconnected'
});
```

---

## 28.1.6 Sysex Messages

### System Exclusive

```javascript
// Request sysex access
const midiAccess = await navigator.requestMIDIAccess({
  sysex: true
});

// Send sysex
const sysex = [0xF0, 0x41, 0x10, 0x42, 0x12, /* ... */, 0xF7];
output.send(sysex);
```

---

## 28.1.7 Complete Example

### MIDI Controller

```javascript
class MIDIController {
  constructor() {
    this.access = null;
    this.inputs = [];
    this.outputs = [];
  }
  
  async connect() {
    this.access = await navigator.requestMIDIAccess();
    
    this.access.addEventListener('statechange', 
      () => this.updateDevices());
    
    this.updateDevices();
    return true;
  }
  
  updateDevices() {
    this.inputs = [...this.access.inputs.values()];
    this.outputs = [...this.access.outputs.values()];
    
    for (const input of this.inputs) {
      input.onmidimessage = (e) => this.handleMessage(e);
    }
    
    this.onDevicesChanged?.();
  }
  
  handleMessage(event) {
    const [status, data1, data2] = event.data;
    const command = status >> 4;
    const channel = status & 0xF;
    
    if (command === 9 && data2 > 0) {
      this.onNoteOn?.(data1, data2, channel);
    } else if (command === 8 || (command === 9 && data2 === 0)) {
      this.onNoteOff?.(data1, channel);
    } else if (command === 11) {
      this.onControlChange?.(data1, data2, channel);
    }
  }
  
  sendNote(outputIndex, note, velocity, duration = 500) {
    const output = this.outputs[outputIndex];
    if (!output) return;
    
    output.send([0x90, note, velocity]);
    output.send([0x80, note, 0], performance.now() + duration);
  }
}

// Usage
const midi = new MIDIController();
midi.onNoteOn = (note, vel, ch) => console.log('Note:', note);
await midi.connect();
```

---

## 28.1.8 Summary

### Request Access

```javascript
navigator.requestMIDIAccess(options)
// options: { sysex: true }
```

### MIDIAccess Properties

| Property | Type | Description |
|----------|------|-------------|
| `inputs` | Map | Input ports |
| `outputs` | Map | Output ports |
| `sysexEnabled` | Boolean | Sysex allowed |

### MIDIPort Properties

| Property | Description |
|----------|-------------|
| `name` | Device name |
| `manufacturer` | Manufacturer |
| `state` | 'connected'/'disconnected' |
| `type` | 'input'/'output' |

### MIDI Commands

| Command | Hex | Description |
|---------|-----|-------------|
| Note Off | 0x8n | Note release |
| Note On | 0x9n | Note press |
| Aftertouch | 0xAn | Key pressure |
| Control Change | 0xBn | CC message |
| Program Change | 0xCn | Patch change |
| Pitch Bend | 0xEn | Pitch wheel |

### Best Practices

1. **Check support** before using
2. **Handle disconnection** events
3. **Parse status byte** for command and channel
4. **Use timestamps** for precise timing
5. **Request sysex** only when needed

---

**End of Chapter 28.1: MIDI Access**

Next: **29.1 Gamepad Input** — Gamepad API.
# 29.1 Gamepad Input

The Gamepad API provides access to game controllers and joysticks. This chapter covers gamepad detection, button and axis reading, and input handling.

---

## 29.1.1 Basic Usage

### Detect Gamepads

```javascript
window.addEventListener('gamepadconnected', (event) => {
  console.log('Gamepad connected:', event.gamepad.id);
  console.log('Index:', event.gamepad.index);
  console.log('Buttons:', event.gamepad.buttons.length);
  console.log('Axes:', event.gamepad.axes.length);
});

window.addEventListener('gamepaddisconnected', (event) => {
  console.log('Gamepad disconnected:', event.gamepad.id);
});
```

---

## 29.1.2 Get Gamepads

### Poll for Gamepads

```javascript
function getGamepads() {
  return navigator.getGamepads().filter(gp => gp !== null);
}

// Must poll - state doesn't update automatically
function gameLoop() {
  const gamepads = getGamepads();
  
  for (const gamepad of gamepads) {
    processGamepad(gamepad);
  }
  
  requestAnimationFrame(gameLoop);
}
```

---

## 29.1.3 Read Buttons

### Button State

```javascript
function processButtons(gamepad) {
  for (let i = 0; i < gamepad.buttons.length; i++) {
    const button = gamepad.buttons[i];
    
    if (button.pressed) {
      console.log('Button', i, 'pressed');
      console.log('Value:', button.value);  // 0-1 for analog
    }
  }
}
```

### Standard Gamepad Mapping

```javascript
// Standard mapping (Xbox-style)
const BUTTONS = {
  A: 0,
  B: 1,
  X: 2,
  Y: 3,
  LB: 4,
  RB: 5,
  LT: 6,
  RT: 7,
  BACK: 8,
  START: 9,
  L3: 10,  // Left stick press
  R3: 11,  // Right stick press
  UP: 12,
  DOWN: 13,
  LEFT: 14,
  RIGHT: 15,
  HOME: 16
};

function isButtonPressed(gamepad, button) {
  return gamepad.buttons[button]?.pressed || false;
}

if (isButtonPressed(gamepad, BUTTONS.A)) {
  jump();
}
```

---

## 29.1.4 Read Axes

### Axis Values

```javascript
function processAxes(gamepad) {
  // Standard mapping:
  // 0: Left stick X (-1 left, +1 right)
  // 1: Left stick Y (-1 up, +1 down)
  // 2: Right stick X
  // 3: Right stick Y
  
  const leftX = gamepad.axes[0];
  const leftY = gamepad.axes[1];
  const rightX = gamepad.axes[2];
  const rightY = gamepad.axes[3];
  
  console.log('Left stick:', leftX, leftY);
  console.log('Right stick:', rightX, rightY);
}
```

### Deadzone Handling

```javascript
function applyDeadzone(value, deadzone = 0.1) {
  if (Math.abs(value) < deadzone) {
    return 0;
  }
  
  // Normalize remaining range
  const sign = Math.sign(value);
  const normalized = (Math.abs(value) - deadzone) / (1 - deadzone);
  return sign * normalized;
}

const leftX = applyDeadzone(gamepad.axes[0]);
const leftY = applyDeadzone(gamepad.axes[1]);
```

---

## 29.1.5 Vibration

### Haptic Feedback

```javascript
function vibrate(gamepad, duration = 200, intensity = 1.0) {
  if (gamepad.vibrationActuator) {
    gamepad.vibrationActuator.playEffect('dual-rumble', {
      startDelay: 0,
      duration,
      weakMagnitude: intensity,
      strongMagnitude: intensity
    });
  }
}
```

---

## 29.1.6 Complete Example

### Gamepad Manager

```javascript
class GamepadManager {
  constructor() {
    this.gamepads = new Map();
    this.previousState = new Map();
    
    window.addEventListener('gamepadconnected', (e) => {
      this.gamepads.set(e.gamepad.index, e.gamepad);
      this.onConnect?.(e.gamepad);
    });
    
    window.addEventListener('gamepaddisconnected', (e) => {
      this.gamepads.delete(e.gamepad.index);
      this.onDisconnect?.(e.gamepad);
    });
  }
  
  update() {
    const current = navigator.getGamepads();
    
    for (const gamepad of current) {
      if (!gamepad) continue;
      
      const prev = this.previousState.get(gamepad.index) || {
        buttons: [],
        axes: []
      };
      
      // Check button changes
      for (let i = 0; i < gamepad.buttons.length; i++) {
        const wasPressed = prev.buttons[i];
        const isPressed = gamepad.buttons[i].pressed;
        
        if (isPressed && !wasPressed) {
          this.onButtonDown?.(gamepad.index, i);
        } else if (!isPressed && wasPressed) {
          this.onButtonUp?.(gamepad.index, i);
        }
      }
      
      // Store current state
      this.previousState.set(gamepad.index, {
        buttons: gamepad.buttons.map(b => b.pressed),
        axes: [...gamepad.axes]
      });
    }
  }
  
  getAxes(gamepadIndex, deadzone = 0.1) {
    const gamepad = navigator.getGamepads()[gamepadIndex];
    if (!gamepad) return null;
    
    return {
      leftX: this.applyDeadzone(gamepad.axes[0], deadzone),
      leftY: this.applyDeadzone(gamepad.axes[1], deadzone),
      rightX: this.applyDeadzone(gamepad.axes[2], deadzone),
      rightY: this.applyDeadzone(gamepad.axes[3], deadzone)
    };
  }
  
  applyDeadzone(value, deadzone) {
    if (Math.abs(value) < deadzone) return 0;
    const sign = Math.sign(value);
    return sign * (Math.abs(value) - deadzone) / (1 - deadzone);
  }
  
  isPressed(gamepadIndex, buttonIndex) {
    const gamepad = navigator.getGamepads()[gamepadIndex];
    return gamepad?.buttons[buttonIndex]?.pressed || false;
  }
}

// Usage
const gamepadManager = new GamepadManager();
gamepadManager.onButtonDown = (gp, btn) => console.log('Pressed:', btn);

function gameLoop() {
  gamepadManager.update();
  
  const axes = gamepadManager.getAxes(0);
  if (axes) {
    movePlayer(axes.leftX, axes.leftY);
  }
  
  requestAnimationFrame(gameLoop);
}

gameLoop();
```

---

## 29.1.7 Summary

### Methods

| Method | Description |
|--------|-------------|
| `navigator.getGamepads()` | Get all gamepads |

### Gamepad Properties

| Property | Type | Description |
|----------|------|-------------|
| `id` | String | Gamepad identifier |
| `index` | Number | Gamepad index |
| `connected` | Boolean | Connection status |
| `mapping` | String | 'standard' or '' |
| `buttons` | Array | Button states |
| `axes` | Array | Axis values |
| `timestamp` | Number | Last update time |

### Button Properties

| Property | Type | Description |
|----------|------|-------------|
| `pressed` | Boolean | Is pressed |
| `touched` | Boolean | Is touched |
| `value` | Number | 0-1 analog value |

### Events

| Event | When |
|-------|------|
| `gamepadconnected` | Gamepad connected |
| `gamepaddisconnected` | Gamepad disconnected |

### Best Practices

1. **Poll gamepad state** in animation frame
2. **Apply deadzone** to axes
3. **Track button changes** for press/release events
4. **Check mapping** property for standard layout
5. **Handle multiple gamepads**
6. **Test with various controllers**

---

**End of Chapter 29.1: Gamepad Input**

This completes the device APIs group. Next: **Group 30 — Screen Orientation API**.
# 30.1 Orientation Control

The Screen Orientation API provides control over screen orientation, enabling apps to lock orientation and detect changes.

---

## 30.1.1 Current Orientation

### Get Orientation

```javascript
const orientation = screen.orientation;

console.log('Type:', orientation.type);
// 'portrait-primary', 'portrait-secondary',
// 'landscape-primary', 'landscape-secondary'

console.log('Angle:', orientation.angle);
// 0, 90, 180, 270
```

---

## 30.1.2 Lock Orientation

### Lock to Specific Type

```javascript
async function lockOrientation(type) {
  try {
    await screen.orientation.lock(type);
    console.log('Locked to:', type);
  } catch (error) {
    console.error('Lock failed:', error);
  }
}

// Usage
await lockOrientation('landscape');
await lockOrientation('portrait');
await lockOrientation('landscape-primary');
```

### Lock Types

```javascript
// Primary orientations
'portrait-primary'     // Normal portrait
'landscape-primary'    // Normal landscape

// Secondary orientations (upside down)
'portrait-secondary'
'landscape-secondary'

// Any orientation within category
'portrait'             // Either portrait
'landscape'            // Either landscape

// Natural orientation
'natural'              // Device's natural orientation

// Any orientation
'any'                  // Allow all orientations
```

---

## 30.1.3 Unlock Orientation

### Release Lock

```javascript
screen.orientation.unlock();
console.log('Orientation unlocked');
```

---

## 30.1.4 Orientation Change Event

### Listen for Changes

```javascript
screen.orientation.addEventListener('change', () => {
  console.log('New orientation:', screen.orientation.type);
  console.log('Angle:', screen.orientation.angle);
  
  handleOrientationChange();
});

function handleOrientationChange() {
  const isLandscape = screen.orientation.type.includes('landscape');
  
  if (isLandscape) {
    showLandscapeUI();
  } else {
    showPortraitUI();
  }
}
```

---

## 30.1.5 Requirements

### Fullscreen Required

```javascript
// Orientation lock often requires fullscreen
async function lockLandscape() {
  try {
    // Enter fullscreen first
    await document.documentElement.requestFullscreen();
    
    // Then lock orientation
    await screen.orientation.lock('landscape');
    
  } catch (error) {
    console.error('Failed:', error);
  }
}
```

---

## 30.1.6 Complete Example

### Orientation Manager

```javascript
class OrientationManager {
  constructor() {
    this.locked = false;
    
    screen.orientation.addEventListener('change', () => {
      this.onChange?.();
    });
  }
  
  get current() {
    return screen.orientation.type;
  }
  
  get angle() {
    return screen.orientation.angle;
  }
  
  get isPortrait() {
    return this.current.includes('portrait');
  }
  
  get isLandscape() {
    return this.current.includes('landscape');
  }
  
  async lock(type = 'landscape') {
    try {
      // May need fullscreen
      if (!document.fullscreenElement) {
        await document.documentElement.requestFullscreen();
      }
      
      await screen.orientation.lock(type);
      this.locked = true;
      return true;
      
    } catch (error) {
      console.warn('Lock failed:', error);
      return false;
    }
  }
  
  unlock() {
    screen.orientation.unlock();
    this.locked = false;
  }
}

// Usage
const orientation = new OrientationManager();
orientation.onChange = () => console.log('Changed:', orientation.current);
await orientation.lock('landscape');
```

---

## 30.1.7 Summary

### Properties

| Property | Type | Description |
|----------|------|-------------|
| `screen.orientation.type` | String | Current orientation |
| `screen.orientation.angle` | Number | Rotation angle |

### Methods

| Method | Description |
|--------|-------------|
| `lock(type)` | Lock to orientation |
| `unlock()` | Release lock |

### Orientation Types

| Type | Description |
|------|-------------|
| `portrait-primary` | Normal portrait |
| `portrait-secondary` | Upside-down portrait |
| `landscape-primary` | Normal landscape |
| `landscape-secondary` | Upside-down landscape |
| `portrait` | Any portrait |
| `landscape` | Any landscape |
| `natural` | Device natural |
| `any` | All allowed |

### Best Practices

1. **Check fullscreen** — often required for lock
2. **Handle errors** — lock may not be supported
3. **Unlock when done** — respect user preference
4. **Listen for changes** — adapt UI

---

**End of Chapter 30.1: Orientation Control**

Next: **31.1 Fullscreen Mode** — Fullscreen API.
# 31.1 Fullscreen Mode

The Fullscreen API enables elements to be displayed in fullscreen mode, providing immersive experiences for videos, games, and presentations.

---

## 31.1.1 Enter Fullscreen

### Request Fullscreen

```javascript
async function enterFullscreen(element = document.documentElement) {
  try {
    await element.requestFullscreen();
    console.log('Entered fullscreen');
  } catch (error) {
    console.error('Fullscreen failed:', error);
  }
}

// Fullscreen the page
await enterFullscreen();

// Fullscreen a video
const video = document.querySelector('video');
await enterFullscreen(video);
```

### With Options

```javascript
await element.requestFullscreen({
  navigationUI: 'hide'  // 'auto', 'hide', or 'show'
});
```

---

## 31.1.2 Exit Fullscreen

### Exit Fullscreen

```javascript
async function exitFullscreen() {
  if (document.fullscreenElement) {
    await document.exitFullscreen();
    console.log('Exited fullscreen');
  }
}
```

---

## 31.1.3 Check Fullscreen State

### Current State

```javascript
// Check if in fullscreen
if (document.fullscreenElement) {
  console.log('Fullscreen element:', document.fullscreenElement);
} else {
  console.log('Not in fullscreen');
}

// Check if fullscreen is enabled
if (document.fullscreenEnabled) {
  console.log('Fullscreen is available');
}
```

---

## 31.1.4 Fullscreen Events

### Listen for Changes

```javascript
document.addEventListener('fullscreenchange', () => {
  if (document.fullscreenElement) {
    console.log('Entered fullscreen');
  } else {
    console.log('Exited fullscreen');
  }
});

document.addEventListener('fullscreenerror', (event) => {
  console.error('Fullscreen error:', event);
});
```

---

## 31.1.5 Toggle Fullscreen

### Toggle Function

```javascript
async function toggleFullscreen(element = document.documentElement) {
  if (document.fullscreenElement) {
    await document.exitFullscreen();
  } else {
    await element.requestFullscreen();
  }
}

// Usage
button.addEventListener('click', () => toggleFullscreen());
```

---

## 31.1.6 Fullscreen CSS

### Style Fullscreen Elements

```css
/* Style the fullscreen element */
:fullscreen {
  background: black;
}

/* Style elements inside fullscreen */
:fullscreen video {
  width: 100%;
  height: 100%;
}

/* Backdrop color */
::backdrop {
  background: black;
}
```

---

## 31.1.7 Complete Example

### Video Player Fullscreen

```javascript
class FullscreenVideo {
  constructor(video, container) {
    this.video = video;
    this.container = container;
    
    document.addEventListener('fullscreenchange', () => {
      this.onFullscreenChange();
    });
  }
  
  async toggleFullscreen() {
    if (document.fullscreenElement) {
      await document.exitFullscreen();
    } else {
      await this.container.requestFullscreen();
    }
  }
  
  onFullscreenChange() {
    const isFullscreen = !!document.fullscreenElement;
    
    this.container.classList.toggle('fullscreen', isFullscreen);
    this.onStateChange?.(isFullscreen);
  }
  
  get isFullscreen() {
    return document.fullscreenElement === this.container;
  }
}

// Usage
const player = new FullscreenVideo(video, videoContainer);
fullscreenButton.addEventListener('click', () => {
  player.toggleFullscreen();
});
```

---

## 31.1.8 Summary

### Methods

| Method | Description |
|--------|-------------|
| `element.requestFullscreen(options)` | Enter fullscreen |
| `document.exitFullscreen()` | Exit fullscreen |

### Properties

| Property | Description |
|----------|-------------|
| `document.fullscreenElement` | Current fullscreen element |
| `document.fullscreenEnabled` | Fullscreen available |

### Events

| Event | When |
|-------|------|
| `fullscreenchange` | Fullscreen state changes |
| `fullscreenerror` | Fullscreen request fails |

### CSS Selectors

| Selector | Description |
|----------|-------------|
| `:fullscreen` | Fullscreen element |
| `::backdrop` | Backdrop behind element |

### Best Practices

1. **Use user gesture** — required for request
2. **Handle errors** — may be blocked
3. **Listen for change** — update UI
4. **Style with :fullscreen** — adapt layout
5. **Provide exit control** — keyboard/button

---

**End of Chapter 31.1: Fullscreen Mode**

Next: **32.1 Mouse Lock** — Pointer Lock API.
# 32.1 Mouse Lock

The Pointer Lock API captures the mouse cursor, enabling unlimited mouse movement for games and 3D applications.

---

## 32.1.1 Request Pointer Lock

### Lock Pointer

```javascript
async function lockPointer(element) {
  try {
    await element.requestPointerLock();
    console.log('Pointer locked');
  } catch (error) {
    console.error('Lock failed:', error);
  }
}

// Usage - requires user gesture
canvas.addEventListener('click', () => {
  lockPointer(canvas);
});
```

---

## 32.1.2 Exit Pointer Lock

### Release Lock

```javascript
function exitPointerLock() {
  document.exitPointerLock();
}

// Or press Escape key (automatic)
```

---

## 32.1.3 Check Lock State

### Current State

```javascript
if (document.pointerLockElement) {
  console.log('Locked to:', document.pointerLockElement);
} else {
  console.log('Not locked');
}
```

---

## 32.1.4 Movement Data

### Get Mouse Movement

```javascript
document.addEventListener('mousemove', (event) => {
  if (!document.pointerLockElement) return;
  
  // Movement delta (not absolute position)
  const deltaX = event.movementX;
  const deltaY = event.movementY;
  
  console.log('Movement:', deltaX, deltaY);
});
```

### Use for Camera Control

```javascript
let cameraYaw = 0;
let cameraPitch = 0;
const sensitivity = 0.002;

document.addEventListener('mousemove', (event) => {
  if (!document.pointerLockElement) return;
  
  cameraYaw -= event.movementX * sensitivity;
  cameraPitch -= event.movementY * sensitivity;
  
  // Clamp pitch
  cameraPitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, cameraPitch));
  
  updateCamera();
});
```

---

## 32.1.5 Lock Events

### Listen for Changes

```javascript
document.addEventListener('pointerlockchange', () => {
  if (document.pointerLockElement) {
    console.log('Pointer locked');
    showCrosshair();
  } else {
    console.log('Pointer unlocked');
    hideCrosshair();
  }
});

document.addEventListener('pointerlockerror', () => {
  console.error('Pointer lock failed');
});
```

---

## 32.1.6 Complete Example

### First-Person Controls

```javascript
class FPSControls {
  constructor(element) {
    this.element = element;
    this.locked = false;
    
    this.yaw = 0;
    this.pitch = 0;
    this.sensitivity = 0.002;
    
    this.setupEvents();
  }
  
  setupEvents() {
    this.element.addEventListener('click', () => {
      this.lock();
    });
    
    document.addEventListener('pointerlockchange', () => {
      this.locked = document.pointerLockElement === this.element;
      this.onLockChange?.(this.locked);
    });
    
    document.addEventListener('mousemove', (e) => {
      if (!this.locked) return;
      
      this.yaw -= e.movementX * this.sensitivity;
      this.pitch -= e.movementY * this.sensitivity;
      
      // Clamp pitch to prevent flipping
      this.pitch = Math.max(-Math.PI / 2 + 0.01, 
                   Math.min(Math.PI / 2 - 0.01, this.pitch));
      
      this.onMove?.(this.yaw, this.pitch);
    });
  }
  
  async lock() {
    try {
      await this.element.requestPointerLock();
    } catch (error) {
      console.error('Lock failed:', error);
    }
  }
  
  unlock() {
    document.exitPointerLock();
  }
  
  getDirection() {
    return {
      x: Math.sin(this.yaw) * Math.cos(this.pitch),
      y: Math.sin(this.pitch),
      z: Math.cos(this.yaw) * Math.cos(this.pitch)
    };
  }
}

// Usage
const controls = new FPSControls(canvas);
controls.onMove = (yaw, pitch) => {
  camera.rotation.set(pitch, yaw, 0);
};
```

---

## 32.1.7 Summary

### Methods

| Method | Description |
|--------|-------------|
| `element.requestPointerLock()` | Lock pointer |
| `document.exitPointerLock()` | Release lock |

### Properties

| Property | Description |
|----------|-------------|
| `document.pointerLockElement` | Locked element |

### Mouse Event Properties

| Property | Description |
|----------|-------------|
| `movementX` | Horizontal delta |
| `movementY` | Vertical delta |

### Events

| Event | When |
|-------|------|
| `pointerlockchange` | Lock state changes |
| `pointerlockerror` | Lock request fails |

### Best Practices

1. **Request on user gesture** — required
2. **Use in fullscreen** — better UX
3. **Provide escape method** — Escape key or button
4. **Show custom cursor** — crosshair for games
5. **Clamp pitch** — prevent camera flip

---

**End of Chapter 32.1: Mouse Lock**

Next: **33.1 Visibility State** — Page Visibility API.
# 33.1 Visibility State

The Page Visibility API detects when a page becomes visible or hidden, enabling efficient resource management.

---

## 33.1.1 Current State

### Check Visibility

```javascript
// Is page hidden?
console.log('Hidden:', document.hidden);

// Visibility state
console.log('State:', document.visibilityState);
// 'visible', 'hidden', or 'prerender'
```

---

## 33.1.2 Visibility Change Event

### Listen for Changes

```javascript
document.addEventListener('visibilitychange', () => {
  if (document.hidden) {
    console.log('Page is hidden');
    pauseActivity();
  } else {
    console.log('Page is visible');
    resumeActivity();
  }
});
```

---

## 33.1.3 Common Use Cases

### Pause Video

```javascript
const video = document.querySelector('video');

document.addEventListener('visibilitychange', () => {
  if (document.hidden) {
    video.pause();
  } else {
    video.play();
  }
});
```

### Pause Game

```javascript
document.addEventListener('visibilitychange', () => {
  if (document.hidden) {
    game.pause();
    showPauseMenu();
  }
});
```

### Stop Polling

```javascript
let pollInterval;

function startPolling() {
  pollInterval = setInterval(fetchData, 5000);
}

function stopPolling() {
  clearInterval(pollInterval);
}

document.addEventListener('visibilitychange', () => {
  if (document.hidden) {
    stopPolling();
  } else {
    startPolling();
  }
});

startPolling();
```

### Analytics

```javascript
let startTime = Date.now();
let totalTime = 0;

document.addEventListener('visibilitychange', () => {
  if (document.hidden) {
    totalTime += Date.now() - startTime;
    sendAnalytics('page_hidden', { timeSpent: totalTime });
  } else {
    startTime = Date.now();
  }
});
```

---

## 33.1.4 Complete Example

### Visibility Manager

```javascript
class VisibilityManager {
  constructor() {
    this.visible = !document.hidden;
    this.callbacks = { show: [], hide: [] };
    
    document.addEventListener('visibilitychange', () => {
      this.visible = !document.hidden;
      
      const event = this.visible ? 'show' : 'hide';
      this.callbacks[event].forEach(cb => cb());
    });
  }
  
  onShow(callback) {
    this.callbacks.show.push(callback);
    return this;
  }
  
  onHide(callback) {
    this.callbacks.hide.push(callback);
    return this;
  }
  
  get isVisible() {
    return this.visible;
  }
}

// Usage
const visibility = new VisibilityManager();

visibility
  .onHide(() => {
    video.pause();
    stopAnimations();
  })
  .onShow(() => {
    video.play();
    resumeAnimations();
  });
```

---

## 33.1.5 Summary

### Properties

| Property | Type | Description |
|----------|------|-------------|
| `document.hidden` | Boolean | Is page hidden |
| `document.visibilityState` | String | Current state |

### Visibility States

| State | Description |
|-------|-------------|
| `visible` | Page is visible |
| `hidden` | Page is hidden |
| `prerender` | Page is prerendering |

### Events

| Event | When |
|-------|------|
| `visibilitychange` | Visibility changes |

### Best Practices

1. **Pause media** when hidden
2. **Stop animations** to save resources
3. **Pause polling** and timers
4. **Resume on visible** — don't assume state
5. **Track time** for analytics

---

**End of Chapter 33.1: Visibility State**

Next: **34.1 Element Visibility Detection** — Intersection Observer API.
# 34.1 Element Visibility Detection

The Intersection Observer API detects when elements enter or exit the viewport, enabling lazy loading and infinite scroll.

---

## 34.1.1 Basic Usage

### Create Observer

```javascript
const observer = new IntersectionObserver((entries) => {
  entries.forEach(entry => {
    if (entry.isIntersecting) {
      console.log('Element is visible:', entry.target);
    } else {
      console.log('Element is hidden:', entry.target);
    }
  });
});

// Observe element
observer.observe(document.querySelector('.target'));
```

---

## 34.1.2 Observer Options

### Configure Observer

```javascript
const observer = new IntersectionObserver(callback, {
  // Root element (default: viewport)
  root: document.querySelector('.scroll-container'),
  
  // Margin around root
  rootMargin: '100px 0px',  // top/bottom left/right
  
  // Visibility thresholds (0-1)
  threshold: [0, 0.5, 1]  // Callback at 0%, 50%, 100% visible
});
```

---

## 34.1.3 Intersection Entry

### Entry Properties

```javascript
const observer = new IntersectionObserver((entries) => {
  entries.forEach(entry => {
    entry.target;              // Observed element
    entry.isIntersecting;      // Is visible
    entry.intersectionRatio;   // 0-1 visibility ratio
    entry.boundingClientRect;  // Element bounds
    entry.rootBounds;          // Root bounds
    entry.intersectionRect;    // Intersection bounds
    entry.time;                // Timestamp
  });
});
```

---

## 34.1.4 Stop Observing

### Unobserve

```javascript
// Stop observing one element
observer.unobserve(element);

// Stop all observations
observer.disconnect();
```

---

## 34.1.5 Lazy Loading Images

### Image Lazy Load

```javascript
function lazyLoadImages() {
  const images = document.querySelectorAll('img[data-src]');
  
  const observer = new IntersectionObserver((entries) => {
    entries.forEach(entry => {
      if (entry.isIntersecting) {
        const img = entry.target;
        img.src = img.dataset.src;
        img.removeAttribute('data-src');
        observer.unobserve(img);
      }
    });
  }, {
    rootMargin: '100px'  // Load 100px before visible
  });
  
  images.forEach(img => observer.observe(img));
}
```

```html
<img data-src="image.jpg" alt="Lazy loaded">
```

---

## 34.1.6 Infinite Scroll

### Load More on Scroll

```javascript
function setupInfiniteScroll(sentinel, loadMore) {
  const observer = new IntersectionObserver((entries) => {
    if (entries[0].isIntersecting) {
      loadMore();
    }
  });
  
  observer.observe(sentinel);
}

// Usage
const sentinel = document.querySelector('.sentinel');
setupInfiniteScroll(sentinel, async () => {
  const items = await fetchMoreItems();
  appendItems(items);
});
```

---

## 34.1.7 Animate on Scroll

### Trigger Animations

```javascript
function animateOnScroll() {
  const elements = document.querySelectorAll('.animate-on-scroll');
  
  const observer = new IntersectionObserver((entries) => {
    entries.forEach(entry => {
      if (entry.isIntersecting) {
        entry.target.classList.add('animated');
        observer.unobserve(entry.target);  // Only once
      }
    });
  }, {
    threshold: 0.2  // 20% visible
  });
  
  elements.forEach(el => observer.observe(el));
}
```

---

## 34.1.8 Track Visibility

### Analytics Tracking

```javascript
function trackVisibility(elements, onVisible) {
  const seen = new Set();
  
  const observer = new IntersectionObserver((entries) => {
    entries.forEach(entry => {
      if (entry.isIntersecting && !seen.has(entry.target)) {
        seen.add(entry.target);
        onVisible(entry.target);
      }
    });
  }, {
    threshold: 0.5  // 50% visible
  });
  
  elements.forEach(el => observer.observe(el));
  
  return observer;
}

// Track ad impressions
trackVisibility(document.querySelectorAll('.ad'), (ad) => {
  sendAnalytics('ad_impression', { id: ad.dataset.adId });
});
```

---

## 34.1.9 Complete Example

### Lazy Load Manager

```javascript
class LazyLoader {
  constructor(options = {}) {
    this.options = {
      root: null,
      rootMargin: '100px',
      threshold: 0,
      ...options
    };
    
    this.observer = new IntersectionObserver(
      (entries) => this.handleIntersection(entries),
      this.options
    );
  }
  
  handleIntersection(entries) {
    entries.forEach(entry => {
      if (entry.isIntersecting) {
        this.load(entry.target);
        this.observer.unobserve(entry.target);
      }
    });
  }
  
  load(element) {
    if (element.dataset.src) {
      element.src = element.dataset.src;
    }
    
    if (element.dataset.bgSrc) {
      element.style.backgroundImage = `url(${element.dataset.bgSrc})`;
    }
    
    element.classList.add('loaded');
  }
  
  observe(selector) {
    document.querySelectorAll(selector).forEach(el => {
      this.observer.observe(el);
    });
  }
  
  destroy() {
    this.observer.disconnect();
  }
}

// Usage
const lazy = new LazyLoader({ rootMargin: '200px' });
lazy.observe('[data-src], [data-bg-src]');
```

---

## 34.1.10 Summary

### Constructor

```javascript
new IntersectionObserver(callback, options)
```

### Options

| Option | Type | Default | Description |
|--------|------|---------|-------------|
| `root` | Element | viewport | Scroll container |
| `rootMargin` | String | '0px' | Margin around root |
| `threshold` | Number/Array | 0 | Visibility thresholds |

### Methods

| Method | Description |
|--------|-------------|
| `observe(element)` | Start observing |
| `unobserve(element)` | Stop observing |
| `disconnect()` | Stop all |
| `takeRecords()` | Get pending entries |

### Entry Properties

| Property | Type | Description |
|----------|------|-------------|
| `target` | Element | Observed element |
| `isIntersecting` | Boolean | Is visible |
| `intersectionRatio` | Number | 0-1 ratio |

### Best Practices

1. **Unobserve after load** — don't waste resources
2. **Use rootMargin** — preload before visible
3. **Set threshold** — appropriate for use case
4. **Disconnect** — cleanup when done
5. **Batch observations** — single observer for many elements

---

**End of Chapter 34.1: Element Visibility Detection**

Next: **35.1 DOM Change Detection** — Mutation Observer API.
# 35.1 DOM Change Detection

The MutationObserver API watches for DOM changes, enabling reactions to dynamic content modifications.

---

## 35.1.1 Basic Usage

### Create Observer

```javascript
const observer = new MutationObserver((mutations) => {
  mutations.forEach(mutation => {
    console.log('Change type:', mutation.type);
    console.log('Target:', mutation.target);
  });
});

// Start observing
observer.observe(document.body, {
  childList: true,    // Child additions/removals
  subtree: true       // Include descendants
});
```

---

## 35.1.2 Observer Options

### Configuration

```javascript
observer.observe(element, {
  // Watch child nodes
  childList: true,
  
  // Include all descendants
  subtree: true,
  
  // Watch attributes
  attributes: true,
  
  // Record old attribute values
  attributeOldValue: true,
  
  // Filter specific attributes
  attributeFilter: ['class', 'style'],
  
  // Watch text content
  characterData: true,
  
  // Record old text values
  characterDataOldValue: true
});
```

---

## 35.1.3 Mutation Records

### Record Properties

```javascript
const observer = new MutationObserver((mutations) => {
  mutations.forEach(mutation => {
    // Common properties
    mutation.type;          // 'attributes', 'childList', 'characterData'
    mutation.target;        // Element that changed
    
    // For attributes
    mutation.attributeName; // Changed attribute name
    mutation.oldValue;      // Previous value (if recorded)
    
    // For childList
    mutation.addedNodes;    // NodeList of added nodes
    mutation.removedNodes;  // NodeList of removed nodes
    mutation.previousSibling;
    mutation.nextSibling;
  });
});
```

---

## 35.1.4 Stop Observing

### Disconnect

```javascript
// Stop observing
observer.disconnect();

// Get pending mutations
const pendingMutations = observer.takeRecords();
```

---

## 35.1.5 Watch Attribute Changes

### Class Changes

```javascript
const observer = new MutationObserver((mutations) => {
  mutations.forEach(mutation => {
    if (mutation.attributeName === 'class') {
      console.log('Class changed to:', mutation.target.className);
    }
  });
});

observer.observe(element, {
  attributes: true,
  attributeFilter: ['class']
});
```

---

## 35.1.6 Watch Child Changes

### Added/Removed Nodes

```javascript
const observer = new MutationObserver((mutations) => {
  mutations.forEach(mutation => {
    mutation.addedNodes.forEach(node => {
      if (node.nodeType === Node.ELEMENT_NODE) {
        console.log('Added:', node.tagName);
      }
    });
    
    mutation.removedNodes.forEach(node => {
      if (node.nodeType === Node.ELEMENT_NODE) {
        console.log('Removed:', node.tagName);
      }
    });
  });
});

observer.observe(container, {
  childList: true,
  subtree: true
});
```

---

## 35.1.7 Watch Text Changes

### Character Data

```javascript
const observer = new MutationObserver((mutations) => {
  mutations.forEach(mutation => {
    console.log('Text changed to:', mutation.target.textContent);
    console.log('Old value:', mutation.oldValue);
  });
});

observer.observe(textNode, {
  characterData: true,
  characterDataOldValue: true
});
```

---

## 35.1.8 Complete Example

### DOM Watcher

```javascript
class DOMWatcher {
  constructor(root = document.body) {
    this.root = root;
    this.callbacks = {
      add: [],
      remove: [],
      attribute: [],
      text: []
    };
    
    this.observer = new MutationObserver((mutations) => {
      this.handleMutations(mutations);
    });
  }
  
  handleMutations(mutations) {
    mutations.forEach(mutation => {
      switch (mutation.type) {
        case 'childList':
          mutation.addedNodes.forEach(node => {
            if (node.nodeType === Node.ELEMENT_NODE) {
              this.emit('add', node);
            }
          });
          mutation.removedNodes.forEach(node => {
            if (node.nodeType === Node.ELEMENT_NODE) {
              this.emit('remove', node);
            }
          });
          break;
          
        case 'attributes':
          this.emit('attribute', {
            element: mutation.target,
            name: mutation.attributeName,
            oldValue: mutation.oldValue
          });
          break;
          
        case 'characterData':
          this.emit('text', {
            node: mutation.target,
            oldValue: mutation.oldValue
          });
          break;
      }
    });
  }
  
  emit(event, data) {
    this.callbacks[event].forEach(cb => cb(data));
  }
  
  on(event, callback) {
    this.callbacks[event].push(callback);
    return this;
  }
  
  start(options = {}) {
    this.observer.observe(this.root, {
      childList: true,
      subtree: true,
      attributes: true,
      attributeOldValue: true,
      characterData: true,
      characterDataOldValue: true,
      ...options
    });
  }
  
  stop() {
    this.observer.disconnect();
  }
}

// Usage
const watcher = new DOMWatcher();

watcher
  .on('add', (element) => console.log('Added:', element))
  .on('remove', (element) => console.log('Removed:', element))
  .on('attribute', ({ element, name }) => {
    console.log('Attribute changed:', name, 'on', element);
  })
  .start();
```

---

## 35.1.9 Summary

### Constructor

```javascript
new MutationObserver(callback)
```

### Methods

| Method | Description |
|--------|-------------|
| `observe(target, options)` | Start observing |
| `disconnect()` | Stop observing |
| `takeRecords()` | Get pending mutations |

### Options

| Option | Type | Description |
|--------|------|-------------|
| `childList` | Boolean | Watch children |
| `subtree` | Boolean | Include descendants |
| `attributes` | Boolean | Watch attributes |
| `attributeOldValue` | Boolean | Record old values |
| `attributeFilter` | Array | Specific attributes |
| `characterData` | Boolean | Watch text |
| `characterDataOldValue` | Boolean | Record old text |

### Mutation Types

| Type | Description |
|------|-------------|
| `childList` | Child nodes changed |
| `attributes` | Attribute changed |
| `characterData` | Text changed |

### Best Practices

1. **Be specific** — only watch what you need
2. **Use attributeFilter** — limit attribute watching
3. **Avoid infinite loops** — don't mutate observed nodes in callback
4. **Disconnect** — when no longer needed
5. **Batch processing** — handle multiple mutations efficiently

---

**End of Chapter 35.1: DOM Change Detection**

Next: **36.1 Element Size Changes** — Resize Observer API.
# 36.1 Element Size Changes

The ResizeObserver API detects element size changes, enabling responsive components and dynamic layouts.

---

## 36.1.1 Basic Usage

### Create Observer

```javascript
const observer = new ResizeObserver((entries) => {
  entries.forEach(entry => {
    console.log('Element:', entry.target);
    console.log('Width:', entry.contentRect.width);
    console.log('Height:', entry.contentRect.height);
  });
});

// Observe element
observer.observe(document.querySelector('.resizable'));
```

---

## 36.1.2 Entry Properties

### ResizeObserverEntry

```javascript
const observer = new ResizeObserver((entries) => {
  entries.forEach(entry => {
    // Content box (without padding)
    const contentRect = entry.contentRect;
    console.log(contentRect.width, contentRect.height);
    
    // Border box (including padding and border)
    const borderBox = entry.borderBoxSize[0];
    console.log(borderBox.inlineSize, borderBox.blockSize);
    
    // Content box size array
    const contentBox = entry.contentBoxSize[0];
    console.log(contentBox.inlineSize, contentBox.blockSize);
    
    // Device pixel content box
    const devicePixelBox = entry.devicePixelContentBoxSize?.[0];
  });
});
```

---

## 36.1.3 Box Options

### Specify Box Model

```javascript
observer.observe(element, {
  box: 'content-box'  // Default
});

observer.observe(element, {
  box: 'border-box'   // Include padding/border
});

observer.observe(element, {
  box: 'device-pixel-content-box'  // Device pixels
});
```

---

## 36.1.4 Stop Observing

### Unobserve

```javascript
// Stop one element
observer.unobserve(element);

// Stop all
observer.disconnect();
```

---

## 36.1.5 Responsive Components

### Adapt to Size

```javascript
function makeResponsive(element) {
  const observer = new ResizeObserver((entries) => {
    const { width } = entries[0].contentRect;
    
    element.classList.remove('small', 'medium', 'large');
    
    if (width < 400) {
      element.classList.add('small');
    } else if (width < 800) {
      element.classList.add('medium');
    } else {
      element.classList.add('large');
    }
  });
  
  observer.observe(element);
  return observer;
}
```

---

## 36.1.6 Canvas Resize

### Handle Canvas Sizing

```javascript
function setupCanvas(canvas) {
  const observer = new ResizeObserver((entries) => {
    const { width, height } = entries[0].contentRect;
    
    // Set canvas resolution
    canvas.width = width * devicePixelRatio;
    canvas.height = height * devicePixelRatio;
    
    // Scale for CSS pixels
    const ctx = canvas.getContext('2d');
    ctx.scale(devicePixelRatio, devicePixelRatio);
    
    // Redraw
    draw();
  });
  
  observer.observe(canvas);
}
```

---

## 36.1.7 Complete Example

### Resize Manager

```javascript
class ResizeManager {
  constructor() {
    this.callbacks = new Map();
    
    this.observer = new ResizeObserver((entries) => {
      entries.forEach(entry => {
        const callback = this.callbacks.get(entry.target);
        if (callback) {
          callback({
            width: entry.contentRect.width,
            height: entry.contentRect.height,
            target: entry.target
          });
        }
      });
    });
  }
  
  observe(element, callback) {
    this.callbacks.set(element, callback);
    this.observer.observe(element);
    return this;
  }
  
  unobserve(element) {
    this.callbacks.delete(element);
    this.observer.unobserve(element);
    return this;
  }
  
  destroy() {
    this.observer.disconnect();
    this.callbacks.clear();
  }
}

// Usage
const resizer = new ResizeManager();

resizer.observe(container, ({ width, height }) => {
  console.log('Size changed:', width, height);
  updateLayout(width, height);
});
```

---

## 36.1.8 Summary

### Constructor

```javascript
new ResizeObserver(callback)
```

### Methods

| Method | Description |
|--------|-------------|
| `observe(element, options)` | Start observing |
| `unobserve(element)` | Stop observing |
| `disconnect()` | Stop all |

### Entry Properties

| Property | Description |
|----------|-------------|
| `target` | Observed element |
| `contentRect` | Content box DOMRect |
| `borderBoxSize` | Border box sizes |
| `contentBoxSize` | Content box sizes |

### Box Options

| Value | Description |
|-------|-------------|
| `content-box` | Content only (default) |
| `border-box` | With padding/border |
| `device-pixel-content-box` | Device pixels |

### Best Practices

1. **Debounce** if doing expensive work
2. **Use contentRect** for simple cases
3. **Use borderBoxSize** for precise layouts
4. **Disconnect** when no longer needed
5. **Handle initial size** — callback fires immediately

---

**End of Chapter 36.1: Element Size Changes**

This completes Group 36 — Resize Observer API. Next: **Group 37 — Performance APIs**.
# 37.1 Performance Object

The Performance API provides access to high-resolution timing and performance metrics. This chapter covers the performance object basics.

---

## 37.1.1 High-Resolution Time

### performance.now()

```javascript
// High-resolution timestamp in milliseconds
const start = performance.now();

// Do work
doSomething();

const end = performance.now();
console.log(`Took ${end - start} ms`);
```

### Precision

```javascript
// Sub-millisecond precision
console.log(performance.now());  // e.g., 1234.567890123
```

---

## 37.1.2 Time Origin

### performance.timeOrigin

```javascript
// Time origin (document load start) as Unix timestamp
const origin = performance.timeOrigin;
console.log(new Date(origin));

// Current Unix time
const now = performance.timeOrigin + performance.now();
```

---

## 37.1.3 Performance Entries

### Get All Entries

```javascript
const entries = performance.getEntries();
entries.forEach(entry => {
  console.log(entry.name, entry.entryType, entry.duration);
});
```

### Get by Type

```javascript
// Navigation entries
const navEntries = performance.getEntriesByType('navigation');

// Resource entries
const resourceEntries = performance.getEntriesByType('resource');

// Paint entries
const paintEntries = performance.getEntriesByType('paint');
```

### Get by Name

```javascript
const entries = performance.getEntriesByName('https://example.com/script.js');
```

---

## 37.1.4 Clear Entries

### Clear Performance Data

```javascript
// Clear resource entries
performance.clearResourceTimings();

// Clear marks
performance.clearMarks();
performance.clearMarks('mark-name');

// Clear measures
performance.clearMeasures();
performance.clearMeasures('measure-name');
```

---

## 37.1.5 Summary

### Methods

| Method | Description |
|--------|-------------|
| `now()` | High-res timestamp |
| `getEntries()` | All entries |
| `getEntriesByType(type)` | Entries by type |
| `getEntriesByName(name)` | Entries by name |
| `clearResourceTimings()` | Clear resources |
| `clearMarks(name?)` | Clear marks |
| `clearMeasures(name?)` | Clear measures |

### Properties

| Property | Description |
|----------|-------------|
| `timeOrigin` | Navigation start time |

---

**End of Chapter 37.1: Performance Object**

Next: **37.2 Navigation Timing API**.
# 37.2 Navigation Timing API

The Navigation Timing API provides metrics about page load performance. This chapter covers navigation timing entries.

---

## 37.2.1 Get Navigation Timing

### Access Metrics

```javascript
const [navigation] = performance.getEntriesByType('navigation');

console.log('Type:', navigation.type);  // 'navigate', 'reload', 'back_forward'
console.log('Duration:', navigation.duration);
```

---

## 37.2.2 Timing Metrics

### Key Timestamps

```javascript
const nav = performance.getEntriesByType('navigation')[0];

// DNS lookup
const dnsTime = nav.domainLookupEnd - nav.domainLookupStart;

// TCP connection
const tcpTime = nav.connectEnd - nav.connectStart;

// TLS handshake
const tlsTime = nav.secureConnectionStart > 0 
  ? nav.connectEnd - nav.secureConnectionStart : 0;

// Request/Response
const requestTime = nav.responseStart - nav.requestStart;
const responseTime = nav.responseEnd - nav.responseStart;

// DOM processing
const domProcessing = nav.domComplete - nav.responseEnd;

// Total load time
const totalTime = nav.loadEventEnd - nav.startTime;
```

---

## 37.2.3 Page Load Metrics

### Common Measurements

```javascript
const nav = performance.getEntriesByType('navigation')[0];

// Time to First Byte (TTFB)
const ttfb = nav.responseStart - nav.requestStart;

// DOM Content Loaded
const dcl = nav.domContentLoadedEventEnd - nav.startTime;

// Load Event
const load = nav.loadEventEnd - nav.startTime;

// DOM Interactive
const domInteractive = nav.domInteractive - nav.startTime;

console.log('TTFB:', ttfb);
console.log('DOMContentLoaded:', dcl);
console.log('Load:', load);
```

---

## 37.2.4 Summary

### Timeline Properties

| Property | Description |
|----------|-------------|
| `startTime` | Navigation start |
| `domainLookupStart/End` | DNS timing |
| `connectStart/End` | TCP timing |
| `secureConnectionStart` | TLS start |
| `requestStart` | Request sent |
| `responseStart/End` | Response timing |
| `domInteractive` | DOM interactive |
| `domContentLoadedEventStart/End` | DCL event |
| `loadEventStart/End` | Load event |
| `domComplete` | DOM complete |

---

**End of Chapter 37.2: Navigation Timing API**

Next: **37.3 Resource Timing API**.
# 37.3 Resource Timing API

The Resource Timing API provides timing data for resources loaded on a page.

---

## 37.3.1 Get Resource Entries

### Access Resource Timing

```javascript
const resources = performance.getEntriesByType('resource');

resources.forEach(resource => {
  console.log(resource.name);
  console.log('Duration:', resource.duration);
  console.log('Size:', resource.transferSize);
});
```

---

## 37.3.2 Resource Properties

### Timing Data

```javascript
resources.forEach(res => {
  // Timing
  const dns = res.domainLookupEnd - res.domainLookupStart;
  const tcp = res.connectEnd - res.connectStart;
  const request = res.responseStart - res.requestStart;
  const response = res.responseEnd - res.responseStart;
  
  // Size (requires Timing-Allow-Origin header)
  console.log('Transfer size:', res.transferSize);
  console.log('Encoded size:', res.encodedBodySize);
  console.log('Decoded size:', res.decodedBodySize);
  
  // Type
  console.log('Initiator:', res.initiatorType);  // script, img, css, etc.
});
```

---

## 37.3.3 Filter Resources

### By Type

```javascript
const scripts = performance.getEntriesByType('resource')
  .filter(r => r.initiatorType === 'script');

const images = performance.getEntriesByType('resource')
  .filter(r => r.initiatorType === 'img');
```

---

## 37.3.4 Summary

### Resource Entry Properties

| Property | Description |
|----------|-------------|
| `name` | Resource URL |
| `initiatorType` | script, img, css, etc. |
| `duration` | Total load time |
| `transferSize` | Transfer size |
| `encodedBodySize` | Compressed size |
| `decodedBodySize` | Decompressed size |

---

**End of Chapter 37.3: Resource Timing API**

Next: **37.4 User Timing API**.
# 37.4 User Timing API

The User Timing API enables custom performance measurements with marks and measures.

---

## 37.4.1 Performance Marks

### Create Marks

```javascript
// Create a mark
performance.mark('start-task');

// Do work
doTask();

// Create end mark
performance.mark('end-task');
```

### Get Marks

```javascript
const marks = performance.getEntriesByType('mark');
const startMark = performance.getEntriesByName('start-task')[0];

console.log('Mark time:', startMark.startTime);
```

---

## 37.4.2 Performance Measures

### Create Measures

```javascript
// Measure between two marks
performance.measure('task-duration', 'start-task', 'end-task');

// Measure from navigation start
performance.measure('time-to-task', undefined, 'end-task');

// Get measure
const measures = performance.getEntriesByType('measure');
console.log('Duration:', measures[0].duration);
```

### Measure Options

```javascript
performance.measure('my-measure', {
  start: 'mark-a',
  end: 'mark-b',
  detail: { info: 'custom data' }
});
```

---

## 37.4.3 Clear Timing Data

```javascript
performance.clearMarks();
performance.clearMarks('specific-mark');

performance.clearMeasures();
performance.clearMeasures('specific-measure');
```

---

## 37.4.4 Example: Function Timing

```javascript
function timeFunction(fn, name) {
  const markStart = `${name}-start`;
  const markEnd = `${name}-end`;
  
  performance.mark(markStart);
  const result = fn();
  performance.mark(markEnd);
  
  performance.measure(name, markStart, markEnd);
  
  const [measure] = performance.getEntriesByName(name);
  console.log(`${name}: ${measure.duration}ms`);
  
  return result;
}
```

---

## 37.4.5 Summary

### Methods

| Method | Description |
|--------|-------------|
| `mark(name, options?)` | Create mark |
| `measure(name, start?, end?)` | Create measure |
| `clearMarks(name?)` | Clear marks |
| `clearMeasures(name?)` | Clear measures |

---

**End of Chapter 37.4: User Timing API**

Next: **37.5 Paint Timing API**.
# 37.5 Paint Timing API

The Paint Timing API provides metrics for First Paint and First Contentful Paint.

---

## 37.5.1 Get Paint Entries

### Access Paint Timing

```javascript
const paintEntries = performance.getEntriesByType('paint');

paintEntries.forEach(entry => {
  console.log(entry.name, entry.startTime);
});

// Output:
// first-paint 123.45
// first-contentful-paint 234.56
```

---

## 37.5.2 Paint Metrics

### First Paint (FP)

```javascript
const fp = performance.getEntriesByName('first-paint')[0];
console.log('First Paint:', fp?.startTime);
```

### First Contentful Paint (FCP)

```javascript
const fcp = performance.getEntriesByName('first-contentful-paint')[0];
console.log('FCP:', fcp?.startTime);
```

---

## 37.5.3 With PerformanceObserver

```javascript
const observer = new PerformanceObserver((list) => {
  list.getEntries().forEach(entry => {
    console.log(entry.name, entry.startTime);
  });
});

observer.observe({ type: 'paint', buffered: true });
```

---

## 37.5.4 Summary

### Paint Entry Types

| Name | Description |
|------|-------------|
| `first-paint` | First pixel rendered |
| `first-contentful-paint` | First content rendered |

---

**End of Chapter 37.5: Paint Timing API**

Next: **37.6 Long Tasks API**.
# 37.6 Long Tasks API

The Long Tasks API detects JavaScript tasks that block the main thread for more than 50ms.

---

## 37.6.1 Observe Long Tasks

### Setup Observer

```javascript
const observer = new PerformanceObserver((list) => {
  list.getEntries().forEach(entry => {
    console.log('Long task detected');
    console.log('Duration:', entry.duration);
    console.log('Start:', entry.startTime);
    console.log('Attribution:', entry.attribution);
  });
});

observer.observe({ type: 'longtask', buffered: true });
```

---

## 37.6.2 Task Attribution

### Identify Source

```javascript
entry.attribution.forEach(attr => {
  console.log('Container:', attr.containerType);
  console.log('Container ID:', attr.containerId);
  console.log('Container Name:', attr.containerName);
  console.log('Container Src:', attr.containerSrc);
});
```

---

## 37.6.3 Use Cases

### Detect Jank

```javascript
let longTaskCount = 0;
let totalBlockingTime = 0;

const observer = new PerformanceObserver((list) => {
  list.getEntries().forEach(entry => {
    longTaskCount++;
    totalBlockingTime += entry.duration - 50;  // Blocking time above 50ms
  });
});

observer.observe({ type: 'longtask', buffered: true });
```

---

## 37.6.4 Summary

### Long Task Properties

| Property | Description |
|----------|-------------|
| `duration` | Task duration (>50ms) |
| `startTime` | Task start time |
| `attribution` | Source attribution |

---

**End of Chapter 37.6: Long Tasks API**

Next: **37.7 Element Timing API**.
# 37.7 Element Timing API

The Element Timing API measures render timing for specific elements marked with the `elementtiming` attribute.

---

## 37.7.1 Mark Elements

### HTML Attribute

```html
<img src="hero.jpg" elementtiming="hero-image" alt="Hero">
<div elementtiming="main-content">Main content here</div>
```

---

## 37.7.2 Observe Element Timing

### Setup Observer

```javascript
const observer = new PerformanceObserver((list) => {
  list.getEntries().forEach(entry => {
    console.log('Element:', entry.identifier);
    console.log('Render time:', entry.renderTime);
    console.log('Load time:', entry.loadTime);
    console.log('Size:', entry.intersectionRect);
  });
});

observer.observe({ type: 'element', buffered: true });
```

---

## 37.7.3 Entry Properties

### Available Data

```javascript
entry.identifier;      // elementtiming attribute value
entry.renderTime;      // When element was painted
entry.loadTime;        // When element finished loading
entry.element;         // The element reference
entry.url;             // Resource URL (for images)
entry.naturalWidth;    // Image natural width
entry.naturalHeight;   // Image natural height
```

---

## 37.7.4 Summary

### Setup Steps

1. Add `elementtiming="name"` to elements
2. Create PerformanceObserver for 'element' type
3. Read timing entries

---

**End of Chapter 37.7: Element Timing API**

Next: **37.8 Event Timing API**.
# 37.8 Event Timing API

The Event Timing API measures input responsiveness, including First Input Delay (FID) and Interaction to Next Paint (INP).

---

## 37.8.1 Observe Event Timing

### Setup Observer

```javascript
const observer = new PerformanceObserver((list) => {
  list.getEntries().forEach(entry => {
    // Input delay
    const delay = entry.processingStart - entry.startTime;
    
    // Processing time
    const processing = entry.processingEnd - entry.processingStart;
    
    // Total duration
    console.log('Delay:', delay);
    console.log('Processing:', processing);
    console.log('Duration:', entry.duration);
  });
});

observer.observe({ type: 'event', buffered: true });
```

---

## 37.8.2 First Input Delay

### Measure FID

```javascript
const observer = new PerformanceObserver((list) => {
  const firstInput = list.getEntries()[0];
  const fid = firstInput.processingStart - firstInput.startTime;
  
  console.log('FID:', fid);
  observer.disconnect();
});

observer.observe({ type: 'first-input', buffered: true });
```

---

## 37.8.3 Event Entry Properties

| Property | Description |
|----------|-------------|
| `name` | Event type |
| `startTime` | Event timestamp |
| `processingStart` | Handler start |
| `processingEnd` | Handler end |
| `duration` | Total duration |
| `cancelable` | Was cancelable |

---

**End of Chapter 37.8: Event Timing API**

Next: **37.9 Server Timing API**.
# 37.9 Server Timing API

The Server Timing API exposes backend performance metrics through HTTP headers.

---

## 37.9.1 Server Header

### Send Timing Data

```http
Server-Timing: db;dur=53, app;dur=47.2;desc="app logic", cache;desc="Cache Read"
```

---

## 37.9.2 Access in JavaScript

### Read Server Timing

```javascript
const resources = performance.getEntriesByType('resource');

resources.forEach(resource => {
  if (resource.serverTiming) {
    resource.serverTiming.forEach(timing => {
      console.log(timing.name);        // "db", "app", "cache"
      console.log(timing.duration);    // 53, 47.2, 0
      console.log(timing.description); // "", "app logic", "Cache Read"
    });
  }
});
```

---

## 37.9.3 Navigation Server Timing

```javascript
const [nav] = performance.getEntriesByType('navigation');

nav.serverTiming?.forEach(timing => {
  console.log(timing.name, timing.duration);
});
```

---

## 37.9.4 Summary

### ServerTiming Entry

| Property | Description |
|----------|-------------|
| `name` | Metric name |
| `duration` | Duration in ms |
| `description` | Description string |

---

**End of Chapter 37.9: Server Timing API**

Next: **37.10 Performance Observer**.
# 37.10 Performance Observer

PerformanceObserver provides an efficient way to subscribe to performance entries as they occur.

---

## 37.10.1 Basic Usage

### Create Observer

```javascript
const observer = new PerformanceObserver((list, observer) => {
  list.getEntries().forEach(entry => {
    console.log(entry.entryType, entry.name, entry.duration);
  });
});

// Observe specific types
observer.observe({ entryTypes: ['resource', 'paint'] });
```

---

## 37.10.2 Observe Options

### Entry Types

```javascript
// Multiple types
observer.observe({ entryTypes: ['resource', 'measure', 'mark'] });

// Single type with buffered
observer.observe({ type: 'paint', buffered: true });
```

### Buffered Entries

```javascript
// Get entries from before observer was created
observer.observe({ type: 'navigation', buffered: true });
```

---

## 37.10.3 Disconnect

### Stop Observing

```javascript
// Stop observer
observer.disconnect();

// Get pending entries
const pending = observer.takeRecords();
```

---

## 37.10.4 Supported Types

| Type | Description |
|------|-------------|
| `navigation` | Page navigation |
| `resource` | Resource loads |
| `paint` | Paint events |
| `mark` | User marks |
| `measure` | User measures |
| `longtask` | Long tasks |
| `element` | Element timing |
| `event` | Event timing |
| `first-input` | First input |
| `largest-contentful-paint` | LCP |
| `layout-shift` | CLS |

---

## 37.10.5 Complete Example

```javascript
// Monitor all Web Vitals
function observeWebVitals() {
  // LCP
  new PerformanceObserver((list) => {
    const entries = list.getEntries();
    const lcp = entries[entries.length - 1];
    console.log('LCP:', lcp.startTime);
  }).observe({ type: 'largest-contentful-paint', buffered: true });
  
  // FID
  new PerformanceObserver((list) => {
    const fid = list.getEntries()[0];
    console.log('FID:', fid.processingStart - fid.startTime);
  }).observe({ type: 'first-input', buffered: true });
  
  // CLS
  let clsValue = 0;
  new PerformanceObserver((list) => {
    list.getEntries().forEach(entry => {
      if (!entry.hadRecentInput) {
        clsValue += entry.value;
      }
    });
    console.log('CLS:', clsValue);
  }).observe({ type: 'layout-shift', buffered: true });
}
```

---

**End of Chapter 37.10: Performance Observer**

This completes Group 37 — Performance APIs. Next: **Group 38 — Reporting API**.
# 38.1 Deprecation Reports

The Reporting API allows browsers to report deprecation warnings when your code uses obsolete features.

---

## 38.1.1 Configure Reporting

### HTTP Header

```http
Report-To: { "group": "default", "max_age": 86400, "endpoints": [{ "url": "https://example.com/reports" }] }
```

### Reporting-Endpoints Header

```http
Reporting-Endpoints: default="https://example.com/reports"
```

---

## 38.1.2 Deprecation Report Structure

### Report Format

```json
{
  "type": "deprecation",
  "age": 20,
  "url": "https://example.com/page.html",
  "body": {
    "id": "feature-id",
    "message": "Feature X is deprecated",
    "anticipatedRemoval": "2024-01-01",
    "sourceFile": "https://example.com/script.js",
    "lineNumber": 42,
    "columnNumber": 15
  }
}
```

---

## 38.1.3 JavaScript Access

### ReportingObserver

```javascript
const observer = new ReportingObserver((reports, observer) => {
  reports.forEach(report => {
    if (report.type === 'deprecation') {
      console.warn('Deprecation:', report.body.message);
      console.log('Feature:', report.body.id);
    }
  });
});

observer.observe();
```

---

## 38.1.4 Summary

| Property | Description |
|----------|-------------|
| `id` | Deprecation identifier |
| `message` | Human-readable message |
| `anticipatedRemoval` | Removal date |
| `sourceFile` | Script file |
| `lineNumber` | Line number |

---

**End of Chapter 38.1: Deprecation Reports**

Next: **38.2 Intervention Reports**.
# 38.2 Intervention Reports

Intervention reports notify when the browser modifies your code's behavior for user experience or security.

---

## 38.2.1 What Are Interventions?

Browsers may block or modify behavior:
- Auto-playing audio without user gesture
- Blocking expensive timers on background pages
- Preventing excessive DOM manipulation
- Throttling excessive CPU usage

---

## 38.2.2 Report Structure

```json
{
  "type": "intervention",
  "url": "https://example.com/page.html",
  "body": {
    "id": "audio-autoplay",
    "message": "Audio playback was blocked because user didn't interact",
    "sourceFile": "https://example.com/player.js",
    "lineNumber": 15,
    "columnNumber": 10
  }
}
```

---

## 38.2.3 Observe Interventions

```javascript
const observer = new ReportingObserver((reports) => {
  reports.forEach(report => {
    if (report.type === 'intervention') {
      console.warn('Intervention:', report.body.message);
      analytics.track('browser-intervention', report.body);
    }
  });
}, { types: ['intervention'] });

observer.observe();
```

---

## 38.2.4 Summary

| Intervention | Description |
|--------------|-------------|
| Audio autoplay | Blocked without gesture |
| Background timers | Throttled |
| Heavy ads | May be unloaded |
| CPU usage | May be throttled |

---

**End of Chapter 38.2: Intervention Reports**

Next: **38.3 Crash Reports**.
# 38.3 Crash Reports

Crash reports inform when a document unexpectedly terminates.

---

## 38.3.1 Configure Crash Reporting

### Document-Policy Header

```http
Document-Policy: document-write=?0
Reporting-Endpoints: default="https://example.com/reports"
```

---

## 38.3.2 Report Structure

```json
{
  "type": "crash",
  "url": "https://example.com/page.html",
  "body": {
    "reason": "oom"  // out of memory
  }
}
```

---

## 38.3.3 Crash Reasons

| Reason | Description |
|--------|-------------|
| `oom` | Out of memory |
| `unresponsive` | Page became unresponsive |

---

## 38.3.4 Note

Crash reports are sent asynchronously by the browser after the crash. They cannot be observed with `ReportingObserver` since JavaScript is no longer running.

---

**End of Chapter 38.3: Crash Reports**

Next: **38.4 ReportingObserver**.
# 38.4 ReportingObserver

ReportingObserver provides JavaScript access to browser reports for deprecations and interventions.

---

## 38.4.1 Create Observer

```javascript
const observer = new ReportingObserver((reports, observer) => {
  for (const report of reports) {
    console.log('Type:', report.type);
    console.log('URL:', report.url);
    console.log('Body:', report.body);
  }
});

observer.observe();
```

---

## 38.4.2 Observer Options

### Filter by Type

```javascript
const observer = new ReportingObserver(callback, {
  types: ['deprecation']  // Only deprecation reports
});

// Or multiple types
const observer2 = new ReportingObserver(callback, {
  types: ['deprecation', 'intervention']
});
```

### Buffered Reports

```javascript
const observer = new ReportingObserver(callback, {
  types: ['deprecation'],
  buffered: true  // Include reports from before observer creation
});
```

---

## 38.4.3 Methods

### takeRecords()

```javascript
// Get pending reports synchronously
const pendingReports = observer.takeRecords();
```

### disconnect()

```javascript
// Stop observing
observer.disconnect();
```

---

## 38.4.4 Summary

| Method | Description |
|--------|-------------|
| `observe()` | Start observing |
| `disconnect()` | Stop observing |
| `takeRecords()` | Get pending reports |

| Option | Description |
|--------|-------------|
| `types` | Report types to observe |
| `buffered` | Include buffered reports |

---

**End of Chapter 38.4: ReportingObserver**

This completes Group 38 — Reporting API. Next: **Group 39 — Web Speech API**.
# 39.1 Speech Recognition

The Web Speech API provides speech-to-text capabilities through the SpeechRecognition interface.

---

## 39.1.1 Create Recognition

```javascript
const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;

if (!SpeechRecognition) {
  console.error('Speech recognition not supported');
}

const recognition = new SpeechRecognition();
```

---

## 39.1.2 Configuration

```javascript
recognition.continuous = true;       // Keep listening
recognition.interimResults = true;   // Get results while speaking
recognition.lang = 'en-US';          // Language
recognition.maxAlternatives = 3;     // Number of alternatives
```

---

## 39.1.3 Events

### Handle Results

```javascript
recognition.onresult = (event) => {
  for (let i = event.resultIndex; i < event.results.length; i++) {
    const result = event.results[i];
    const transcript = result[0].transcript;
    const confidence = result[0].confidence;
    
    if (result.isFinal) {
      console.log('Final:', transcript, confidence);
    } else {
      console.log('Interim:', transcript);
    }
  }
};
```

### Other Events

```javascript
recognition.onstart = () => console.log('Started');
recognition.onend = () => console.log('Ended');
recognition.onerror = (e) => console.error(e.error);
recognition.onspeechstart = () => console.log('Speech detected');
recognition.onspeechend = () => console.log('Speech ended');
```

---

## 39.1.4 Control

```javascript
// Start
recognition.start();

// Stop (returns final result)
recognition.stop();

// Abort (no result)
recognition.abort();
```

---

## 39.1.5 Summary

| Property | Description |
|----------|-------------|
| `continuous` | Keep listening |
| `interimResults` | Interim results |
| `lang` | Language code |
| `maxAlternatives` | Number of alternatives |

---

**End of Chapter 39.1: Speech Recognition**

Next: **39.2 Speech Synthesis**.
# 39.2 Speech Synthesis

Speech Synthesis provides text-to-speech capabilities.

---

## 39.2.1 Basic Usage

```javascript
const utterance = new SpeechSynthesisUtterance('Hello, world!');
speechSynthesis.speak(utterance);
```

---

## 39.2.2 Configuration

```javascript
const utterance = new SpeechSynthesisUtterance('Hello');

utterance.rate = 1.0;    // 0.1 to 10
utterance.pitch = 1.0;   // 0 to 2
utterance.volume = 1.0;  // 0 to 1
utterance.lang = 'en-US';
```

---

## 39.2.3 Voices

### Get Available Voices

```javascript
// May need to wait for voices to load
speechSynthesis.onvoiceschanged = () => {
  const voices = speechSynthesis.getVoices();
  
  voices.forEach(voice => {
    console.log(voice.name, voice.lang, voice.default);
  });
};
```

### Set Voice

```javascript
const voices = speechSynthesis.getVoices();
const englishVoice = voices.find(v => v.lang.startsWith('en'));

utterance.voice = englishVoice;
```

---

## 39.2.4 Control

```javascript
// Pause/Resume
speechSynthesis.pause();
speechSynthesis.resume();

// Cancel all queued
speechSynthesis.cancel();

// Check state
speechSynthesis.speaking;  // Currently speaking
speechSynthesis.pending;   // Queued utterances
speechSynthesis.paused;    // Is paused
```

---

## 39.2.5 Events

```javascript
utterance.onstart = () => console.log('Started');
utterance.onend = () => console.log('Ended');
utterance.onpause = () => console.log('Paused');
utterance.onresume = () => console.log('Resumed');
utterance.onerror = (e) => console.error(e.error);

utterance.onboundary = (e) => {
  console.log('Boundary:', e.name, e.charIndex);
};
```

---

## 39.2.6 Summary

| Property | Range | Description |
|----------|-------|-------------|
| `rate` | 0.1-10 | Speech speed |
| `pitch` | 0-2 | Voice pitch |
| `volume` | 0-1 | Volume level |
| `voice` | Voice | Voice to use |
| `lang` | string | Language code |

---

**End of Chapter 39.2: Speech Synthesis**

This completes Group 39 — Web Speech API. Next: **Group 40 — Web Components**.
# 40.1 Custom Elements

Custom Elements allow you to define new HTML elements with custom behavior.

---

## 40.1.1 Define Custom Element

### Autonomous Custom Element

```javascript
class MyButton extends HTMLElement {
  constructor() {
    super();
    // Don't manipulate DOM in constructor
  }
  
  connectedCallback() {
    this.innerHTML = '<button>Click me</button>';
    this.querySelector('button').onclick = () => this.handleClick();
  }
  
  handleClick() {
    this.dispatchEvent(new CustomEvent('my-click'));
  }
}

customElements.define('my-button', MyButton);
```

### Usage

```html
<my-button></my-button>
```

---

## 40.1.2 Lifecycle Callbacks

```javascript
class MyElement extends HTMLElement {
  connectedCallback() {
    // Added to DOM
  }
  
  disconnectedCallback() {
    // Removed from DOM
  }
  
  adoptedCallback() {
    // Moved to new document
  }
  
  attributeChangedCallback(name, oldValue, newValue) {
    // Observed attribute changed
  }
  
  static get observedAttributes() {
    return ['disabled', 'value'];
  }
}
```

---

## 40.1.3 Customized Built-in Elements

```javascript
class FancyButton extends HTMLButtonElement {
  connectedCallback() {
    this.style.background = 'linear-gradient(45deg, red, blue)';
  }
}

customElements.define('fancy-button', FancyButton, { extends: 'button' });
```

### Usage

```html
<button is="fancy-button">Click</button>
```

---

## 40.1.4 Wait for Definition

```javascript
// Check if defined
const isDefined = customElements.get('my-element') !== undefined;

// Wait for definition
await customElements.whenDefined('my-element');
```

---

## 40.1.5 Summary

| Callback | When Called |
|----------|-------------|
| `connectedCallback` | Added to DOM |
| `disconnectedCallback` | Removed from DOM |
| `adoptedCallback` | Moved to new document |
| `attributeChangedCallback` | Attribute changed |

---

**End of Chapter 40.1: Custom Elements**

Next: **40.2 Shadow DOM**.
# 40.2 Shadow DOM

Shadow DOM provides encapsulation for component styles and markup.

---

## 40.2.1 Attach Shadow Root

```javascript
class MyCard extends HTMLElement {
  constructor() {
    super();
    this.attachShadow({ mode: 'open' });
  }
  
  connectedCallback() {
    this.shadowRoot.innerHTML = `
      <style>
        :host { display: block; border: 1px solid #ccc; }
        .title { font-weight: bold; }
      </style>
      <div class="title"><slot name="title"></slot></div>
      <div class="content"><slot></slot></div>
    `;
  }
}
```

---

## 40.2.2 Mode: Open vs Closed

```javascript
// Open - shadowRoot accessible from outside
this.attachShadow({ mode: 'open' });
element.shadowRoot;  // Returns shadow root

// Closed - shadowRoot not accessible
this.attachShadow({ mode: 'closed' });
element.shadowRoot;  // Returns null
```

---

## 40.2.3 Slots

### Named Slots

```html
<my-card>
  <span slot="title">Card Title</span>
  <p>Card content goes here</p>
</my-card>
```

### Slot Events

```javascript
const slot = this.shadowRoot.querySelector('slot');

slot.addEventListener('slotchange', () => {
  const nodes = slot.assignedNodes();
  console.log('Slotted:', nodes);
});
```

---

## 40.2.4 Styling

### :host Selector

```css
:host { display: block; }
:host([disabled]) { opacity: 0.5; }
:host(:hover) { background: #f0f0f0; }
:host-context(.dark-theme) { background: #333; }
```

### ::slotted Selector

```css
::slotted(*) { margin: 0; }
::slotted(p) { color: blue; }
```

---

## 40.2.5 Summary

| Concept | Description |
|---------|-------------|
| `attachShadow()` | Create shadow root |
| `mode: 'open'` | Accessible shadow |
| `mode: 'closed'` | Hidden shadow |
| `<slot>` | Content projection |
| `:host` | Style host element |

---

**End of Chapter 40.2: Shadow DOM**

Next: **40.3 HTML Templates**.
# 40.3 HTML Templates

The `<template>` element holds HTML that isn't rendered until cloned.

---

## 40.3.1 Define Template

```html
<template id="card-template">
  <style>
    .card { border: 1px solid #ccc; padding: 16px; }
  </style>
  <div class="card">
    <h2></h2>
    <p></p>
  </div>
</template>
```

---

## 40.3.2 Clone and Use

```javascript
const template = document.getElementById('card-template');
const clone = template.content.cloneNode(true);

clone.querySelector('h2').textContent = 'Title';
clone.querySelector('p').textContent = 'Description';

document.body.appendChild(clone);
```

---

## 40.3.3 With Custom Elements

```javascript
class MyCard extends HTMLElement {
  constructor() {
    super();
    const template = document.getElementById('card-template');
    const content = template.content.cloneNode(true);
    
    this.attachShadow({ mode: 'open' });
    this.shadowRoot.appendChild(content);
  }
}
```

---

## 40.3.4 Declarative Shadow DOM

```html
<my-element>
  <template shadowrootmode="open">
    <style>:host { color: blue; }</style>
    <slot></slot>
  </template>
  Content here
</my-element>
```

---

## 40.3.5 Summary

| Method | Description |
|--------|-------------|
| `template.content` | DocumentFragment |
| `cloneNode(true)` | Deep clone |
| `shadowrootmode` | Declarative shadow |

---

**End of Chapter 40.3: HTML Templates**

This completes Group 40 — Web Components. Next: **Group 41 — Encoding API**.
# 41.1 TextEncoder

TextEncoder converts strings to UTF-8 encoded bytes.

---

## 41.1.1 Basic Usage

```javascript
const encoder = new TextEncoder();

const bytes = encoder.encode('Hello, 世界');
console.log(bytes);  // Uint8Array

console.log(encoder.encoding);  // 'utf-8'
```

---

## 41.1.2 Encode Into Buffer

```javascript
const encoder = new TextEncoder();
const buffer = new Uint8Array(100);

const { read, written } = encoder.encodeInto('Hello', buffer);
console.log('Characters read:', read);
console.log('Bytes written:', written);
```

---

## 41.1.3 Use Cases

### Prepare for Crypto

```javascript
async function hashString(str) {
  const encoder = new TextEncoder();
  const data = encoder.encode(str);
  const hash = await crypto.subtle.digest('SHA-256', data);
  return hash;
}
```

### Write to Stream

```javascript
const encoder = new TextEncoder();
const writer = writableStream.getWriter();

await writer.write(encoder.encode('data'));
```

---

## 41.1.4 Summary

| Method | Description |
|--------|-------------|
| `encode(string)` | Returns Uint8Array |
| `encodeInto(string, buffer)` | Encode into existing buffer |

---

**End of Chapter 41.1: TextEncoder**

Next: **41.2 TextDecoder**.
# 41.2 TextDecoder

TextDecoder converts encoded bytes to strings.

---

## 41.2.1 Basic Usage

```javascript
const decoder = new TextDecoder();

const bytes = new Uint8Array([72, 101, 108, 108, 111]);
const text = decoder.decode(bytes);
console.log(text);  // 'Hello'
```

---

## 41.2.2 Specify Encoding

```javascript
// UTF-8 (default)
const utf8Decoder = new TextDecoder('utf-8');

// UTF-16
const utf16Decoder = new TextDecoder('utf-16le');

// ISO-8859-1
const latinDecoder = new TextDecoder('iso-8859-1');

// Check encoding
console.log(utf8Decoder.encoding);  // 'utf-8'
```

---

## 41.2.3 Options

```javascript
const decoder = new TextDecoder('utf-8', {
  fatal: true,    // Throw on invalid sequences
  ignoreBOM: true // Ignore byte order mark
});
```

---

## 41.2.4 Streaming Decode

```javascript
const decoder = new TextDecoder();

// First chunk (incomplete)
let text = decoder.decode(chunk1, { stream: true });

// Subsequent chunks
text += decoder.decode(chunk2, { stream: true });

// Final chunk
text += decoder.decode(chunk3);  // stream: false (default)
```

---

## 41.2.5 Summary

| Option | Description |
|--------|-------------|
| `fatal` | Throw on invalid bytes |
| `ignoreBOM` | Ignore BOM |
| `stream` | Streaming mode |

### Supported Encodings

UTF-8, UTF-16, ISO-8859-1 through 16, Windows-1250 through 1258, and more.

---

**End of Chapter 41.2: TextDecoder**

This completes Group 41 — Encoding API. Next: **Group 42 — Compression Streams API**.
# 42.1 CompressionStream

CompressionStream compresses data using gzip or deflate algorithms.

---

## 42.1.1 Basic Usage

```javascript
const stream = new CompressionStream('gzip');

const input = new Response('Hello, World!').body;
const compressed = input.pipeThrough(stream);

const blob = await new Response(compressed).blob();
```

---

## 42.1.2 Compression Formats

```javascript
// gzip compression
const gzipStream = new CompressionStream('gzip');

// deflate compression
const deflateStream = new CompressionStream('deflate');

// deflate-raw (no header)
const rawStream = new CompressionStream('deflate-raw');
```

---

## 42.1.3 Compress Data

```javascript
async function compress(data) {
  const encoder = new TextEncoder();
  const input = encoder.encode(data);
  
  const stream = new CompressionStream('gzip');
  const writer = stream.writable.getWriter();
  const reader = stream.readable.getReader();
  
  writer.write(input);
  writer.close();
  
  const chunks = [];
  while (true) {
    const { done, value } = await reader.read();
    if (done) break;
    chunks.push(value);
  }
  
  return new Blob(chunks);
}
```

---

## 42.1.4 With Fetch

```javascript
async function uploadCompressed(url, data) {
  const stream = new Blob([data]).stream()
    .pipeThrough(new CompressionStream('gzip'));
  
  await fetch(url, {
    method: 'POST',
    headers: { 'Content-Encoding': 'gzip' },
    body: stream
  });
}
```

---

## 42.1.5 Summary

| Format | Description |
|--------|-------------|
| `gzip` | Gzip compression |
| `deflate` | Deflate with header |
| `deflate-raw` | Raw deflate |

---

**End of Chapter 42.1: CompressionStream**

Next: **42.2 DecompressionStream**.
# 42.2 DecompressionStream

DecompressionStream decompresses gzip or deflate compressed data.

---

## 42.2.1 Basic Usage

```javascript
const stream = new DecompressionStream('gzip');

const compressed = await fetch('data.gz').then(r => r.body);
const decompressed = compressed.pipeThrough(stream);

const text = await new Response(decompressed).text();
```

---

## 42.2.2 Decompress Blob

```javascript
async function decompress(compressedBlob, format = 'gzip') {
  const stream = new DecompressionStream(format);
  const decompressed = compressedBlob.stream().pipeThrough(stream);
  return new Response(decompressed).blob();
}
```

---

## 42.2.3 Handle Compressed Response

```javascript
async function fetchDecompressed(url) {
  const response = await fetch(url);
  
  const encoding = response.headers.get('Content-Encoding');
  
  if (encoding === 'gzip') {
    const decompressed = response.body
      .pipeThrough(new DecompressionStream('gzip'));
    return new Response(decompressed).text();
  }
  
  return response.text();
}
```

---

## 42.2.4 Summary

| Method | Description |
|--------|-------------|
| `new DecompressionStream(format)` | Create decompressor |
| `.readable` | Readable stream output |
| `.writable` | Writable stream input |
| `pipeThrough()` | Connect streams |

---

**End of Chapter 42.2: DecompressionStream**

This completes Group 42 — Compression Streams API. Next: **Group 43 — Streams API**.
# 43.1 ReadableStream

ReadableStream represents a source of data that can be read chunk by chunk.

---

## 43.1.1 Create ReadableStream

```javascript
const stream = new ReadableStream({
  start(controller) {
    controller.enqueue('chunk 1');
    controller.enqueue('chunk 2');
    controller.close();
  }
});
```

---

## 43.1.2 Pull-Based Stream

```javascript
let i = 0;
const stream = new ReadableStream({
  pull(controller) {
    if (i < 10) {
      controller.enqueue(`chunk ${i++}`);
    } else {
      controller.close();
    }
  }
});
```

---

## 43.1.3 Reading Data

### Using Reader

```javascript
const reader = stream.getReader();

while (true) {
  const { done, value } = await reader.read();
  if (done) break;
  console.log(value);
}

reader.releaseLock();
```

### Using for-await

```javascript
for await (const chunk of stream) {
  console.log(chunk);
}
```

---

## 43.1.4 Tee (Fork)

```javascript
const [stream1, stream2] = stream.tee();
// Both streams receive same data
```

---

## 43.1.5 Piping

```javascript
// Pipe through transform
const result = readable
  .pipeThrough(transformStream)
  .pipeTo(writableStream);
```

---

## 43.1.6 Summary

| Method | Description |
|--------|-------------|
| `getReader()` | Get reader |
| `tee()` | Fork stream |
| `pipeThrough()` | Transform |
| `pipeTo()` | Write to dest |
| `cancel()` | Cancel stream |

---

**End of Chapter 43.1: ReadableStream**

Next: **43.2 WritableStream**.
# 43.2 WritableStream

WritableStream represents a destination for data.

---

## 43.2.1 Create WritableStream

```javascript
const stream = new WritableStream({
  write(chunk) {
    console.log('Received:', chunk);
  },
  close() {
    console.log('Stream closed');
  },
  abort(reason) {
    console.error('Aborted:', reason);
  }
});
```

---

## 43.2.2 Write Data

### Using Writer

```javascript
const writer = stream.getWriter();

await writer.write('chunk 1');
await writer.write('chunk 2');
await writer.close();
```

---

## 43.2.3 Backpressure

```javascript
const writer = stream.getWriter();

// Wait for ready signal
await writer.ready;
await writer.write(data);

// Check desired size
console.log(writer.desiredSize);
```

---

## 43.2.4 Abort Stream

```javascript
const writer = stream.getWriter();

// Abort with reason
await writer.abort(new Error('Cancelled'));
```

---

## 43.2.5 With Queuing Strategy

```javascript
const stream = new WritableStream({
  write(chunk) { /* ... */ }
}, new CountQueuingStrategy({ highWaterMark: 10 }));
```

---

## 43.2.6 Summary

| Method | Description |
|--------|-------------|
| `getWriter()` | Get writer |
| `writer.write()` | Write chunk |
| `writer.close()` | Close stream |
| `writer.abort()` | Abort stream |
| `writer.ready` | Ready promise |

---

**End of Chapter 43.2: WritableStream**

Next: **43.3 TransformStream**.
# 43.3 TransformStream

TransformStream transforms data as it passes through.

---

## 43.3.1 Create TransformStream

```javascript
const transform = new TransformStream({
  transform(chunk, controller) {
    controller.enqueue(chunk.toUpperCase());
  }
});
```

---

## 43.3.2 Using TransformStream

```javascript
const uppercase = new TransformStream({
  transform(chunk, controller) {
    controller.enqueue(chunk.toUpperCase());
  }
});

const result = await readableStream
  .pipeThrough(uppercase)
  .pipeTo(writableStream);
```

---

## 43.3.3 Async Transform

```javascript
const asyncTransform = new TransformStream({
  async transform(chunk, controller) {
    const processed = await processAsync(chunk);
    controller.enqueue(processed);
  }
});
```

---

## 43.3.4 Flush on Close

```javascript
const transform = new TransformStream({
  buffer: [],
  
  transform(chunk, controller) {
    this.buffer.push(chunk);
    if (this.buffer.length >= 10) {
      controller.enqueue(this.buffer);
      this.buffer = [];
    }
  },
  
  flush(controller) {
    if (this.buffer.length > 0) {
      controller.enqueue(this.buffer);
    }
  }
});
```

---

## 43.3.5 Access Sides

```javascript
const { readable, writable } = transform;

// Use readable and writable separately
writer = writable.getWriter();
reader = readable.getReader();
```

---

## 43.3.6 Summary

| Property | Description |
|----------|-------------|
| `readable` | Output stream |
| `writable` | Input stream |

| Callback | Description |
|----------|-------------|
| `transform()` | Process chunk |
| `flush()` | Final processing |

---

**End of Chapter 43.3: TransformStream**

Next: **43.4 Byte Streams**.
# 43.4 Byte Streams

Byte streams handle binary data efficiently with BYOB (Bring Your Own Buffer) readers.

---

## 43.4.1 Create Byte Stream

```javascript
const stream = new ReadableStream({
  type: 'bytes',
  
  pull(controller) {
    // Create view into controller's buffer
    const view = controller.byobRequest?.view;
    
    if (view) {
      // Fill provided buffer
      const bytesRead = fillBuffer(view);
      controller.byobRequest.respond(bytesRead);
    } else {
      // Fallback to enqueue
      controller.enqueue(new Uint8Array([1, 2, 3]));
    }
  }
});
```

---

## 43.4.2 BYOB Reader

```javascript
const reader = stream.getReader({ mode: 'byob' });

const buffer = new ArrayBuffer(1024);
let view = new Uint8Array(buffer);

while (true) {
  const { done, value } = await reader.read(view);
  if (done) break;
  
  console.log('Read', value.byteLength, 'bytes');
  view = new Uint8Array(value.buffer);  // Reuse buffer
}
```

---

## 43.4.3 Benefits

- Zero-copy reads
- Memory efficient
- Better for large binary data

---

## 43.4.4 Summary

| Feature | Description |
|---------|-------------|
| `type: 'bytes'` | Enable byte stream |
| `getReader({ mode: 'byob' })` | BYOB reader |
| `byobRequest` | Buffer request |

---

**End of Chapter 43.4: Byte Streams**

This completes Group 43 — Streams API. Next: **Group 44 — Web Cryptography API**.
# 44.1 SubtleCrypto

The SubtleCrypto interface provides low-level cryptographic operations.

---

## 44.1.1 Access SubtleCrypto

```javascript
const subtle = crypto.subtle;
// Or: window.crypto.subtle
```

---

## 44.1.2 Hashing

```javascript
async function hash(message) {
  const encoder = new TextEncoder();
  const data = encoder.encode(message);
  
  const hash = await crypto.subtle.digest('SHA-256', data);
  
  return Array.from(new Uint8Array(hash))
    .map(b => b.toString(16).padStart(2, '0'))
    .join('');
}

await hash('Hello');  // 64-char hex string
```

---

## 44.1.3 Generate Keys

```javascript
// Symmetric key (AES)
const aesKey = await crypto.subtle.generateKey(
  { name: 'AES-GCM', length: 256 },
  true,  // extractable
  ['encrypt', 'decrypt']
);

// Asymmetric keys (RSA)
const rsaKeys = await crypto.subtle.generateKey(
  {
    name: 'RSA-OAEP',
    modulusLength: 2048,
    publicExponent: new Uint8Array([1, 0, 1]),
    hash: 'SHA-256'
  },
  true,
  ['encrypt', 'decrypt']
);
```

---

## 44.1.4 Encrypt/Decrypt

### AES-GCM

```javascript
const iv = crypto.getRandomValues(new Uint8Array(12));

// Encrypt
const ciphertext = await crypto.subtle.encrypt(
  { name: 'AES-GCM', iv },
  key,
  data
);

// Decrypt
const plaintext = await crypto.subtle.decrypt(
  { name: 'AES-GCM', iv },
  key,
  ciphertext
);
```

---

## 44.1.5 Sign/Verify

```javascript
// Sign
const signature = await crypto.subtle.sign(
  { name: 'RSASSA-PKCS1-v1_5' },
  privateKey,
  data
);

// Verify
const valid = await crypto.subtle.verify(
  { name: 'RSASSA-PKCS1-v1_5' },
  publicKey,
  signature,
  data
);
```

---

## 44.1.6 Export/Import Keys

```javascript
// Export
const exported = await crypto.subtle.exportKey('jwk', key);

// Import
const imported = await crypto.subtle.importKey(
  'jwk',
  jwkData,
  { name: 'AES-GCM' },
  true,
  ['encrypt', 'decrypt']
);
```

---

## 44.1.7 Summary

| Method | Description |
|--------|-------------|
| `digest()` | Hash data |
| `generateKey()` | Create keys |
| `encrypt()/decrypt()` | Symmetric encryption |
| `sign()/verify()` | Digital signatures |
| `importKey()/exportKey()` | Key management |

---

**End of Chapter 44.1: SubtleCrypto**

Next: **44.2 Random Values**.
# 44.2 Random Values

The Crypto interface provides cryptographically secure random number generation.

---

## 44.2.1 getRandomValues

```javascript
// Generate random bytes
const array = new Uint8Array(16);
crypto.getRandomValues(array);

// Different typed arrays
const int32 = new Int32Array(4);
crypto.getRandomValues(int32);
```

---

## 44.2.2 Random UUID

```javascript
const uuid = crypto.randomUUID();
// "a1b2c3d4-e5f6-4a7b-8c9d-0e1f2a3b4c5d"
```

---

## 44.2.3 Random Integer in Range

```javascript
function randomInt(min, max) {
  const range = max - min;
  const bytesNeeded = Math.ceil(Math.log2(range) / 8);
  const randomBytes = new Uint8Array(bytesNeeded);
  
  let value;
  do {
    crypto.getRandomValues(randomBytes);
    value = randomBytes.reduce((acc, byte) => acc * 256 + byte, 0);
  } while (value >= Math.floor(256 ** bytesNeeded / range) * range);
  
  return min + (value % range);
}
```

---

## 44.2.4 Security Note

```javascript
// ❌ Not cryptographically secure
Math.random();

// ✅ Cryptographically secure
crypto.getRandomValues(new Uint8Array(16));
```

---

## 44.2.5 Summary

| Method | Description |
|--------|-------------|
| `getRandomValues(array)` | Fill with random bytes |
| `randomUUID()` | Generate UUID v4 |

---

**End of Chapter 44.2: Random Values**

This completes Group 44 — Web Cryptography API. Next: **Group 45 — WebGL API**.
# 45.1 WebGL Context

WebGL provides hardware-accelerated 3D graphics in the browser.

---

## 45.1.1 Get Context

```javascript
const canvas = document.getElementById('canvas');

// WebGL 1.0
const gl = canvas.getContext('webgl');

// WebGL 2.0
const gl2 = canvas.getContext('webgl2');

if (!gl) {
  console.error('WebGL not supported');
}
```

---

## 45.1.2 Context Options

```javascript
const gl = canvas.getContext('webgl', {
  alpha: true,              // Transparent background
  depth: true,              // Depth buffer
  stencil: false,           // Stencil buffer
  antialias: true,          // Antialiasing
  premultipliedAlpha: true, // Alpha handling
  preserveDrawingBuffer: false,
  powerPreference: 'high-performance'
});
```

---

## 45.1.3 Basic Setup

```javascript
// Set viewport
gl.viewport(0, 0, canvas.width, canvas.height);

// Clear color
gl.clearColor(0.0, 0.0, 0.0, 1.0);

// Enable depth testing
gl.enable(gl.DEPTH_TEST);

// Clear buffers
gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
```

---

## 45.1.4 Summary

| Method | Description |
|--------|-------------|
| `getContext('webgl')` | Get WebGL 1.0 |
| `getContext('webgl2')` | Get WebGL 2.0 |
| `viewport()` | Set viewport |
| `clearColor()` | Set clear color |
| `clear()` | Clear buffers |

---

**End of Chapter 45.1: WebGL Context**

Next: **45.2 Shaders**.
# 45.2 Shaders

Shaders are programs that run on the GPU to process vertices and pixels.

---

## 45.2.1 Shader Types

### Vertex Shader

```glsl
attribute vec4 a_position;
uniform mat4 u_matrix;

void main() {
  gl_Position = u_matrix * a_position;
}
```

### Fragment Shader

```glsl
precision mediump float;
uniform vec4 u_color;

void main() {
  gl_FragColor = u_color;
}
```

---

## 45.2.2 Create Shaders

```javascript
function createShader(gl, type, source) {
  const shader = gl.createShader(type);
  gl.shaderSource(shader, source);
  gl.compileShader(shader);
  
  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
    console.error(gl.getShaderInfoLog(shader));
    gl.deleteShader(shader);
    return null;
  }
  
  return shader;
}

const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexSource);
const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentSource);
```

---

## 45.2.3 Create Program

```javascript
function createProgram(gl, vertexShader, fragmentShader) {
  const program = gl.createProgram();
  gl.attachShader(program, vertexShader);
  gl.attachShader(program, fragmentShader);
  gl.linkProgram(program);
  
  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
    console.error(gl.getProgramInfoLog(program));
    gl.deleteProgram(program);
    return null;
  }
  
  return program;
}

gl.useProgram(program);
```

---

## 45.2.4 Summary

| Shader Type | Purpose |
|-------------|---------|
| Vertex | Position vertices |
| Fragment | Color pixels |

---

**End of Chapter 45.2: Shaders**

Next: **45.3 Buffers and Drawing**.
# 45.3 Buffers and Drawing

Buffers store vertex data on the GPU for efficient rendering.

---

## 45.3.1 Create Buffer

```javascript
const positions = new Float32Array([
  0.0,  0.5,
 -0.5, -0.5,
  0.5, -0.5
]);

const buffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);
```

---

## 45.3.2 Connect to Attribute

```javascript
const positionLoc = gl.getAttribLocation(program, 'a_position');

gl.enableVertexAttribArray(positionLoc);
gl.vertexAttribPointer(
  positionLoc,
  2,          // 2 components per vertex
  gl.FLOAT,   // data type
  false,      // normalize
  0,          // stride
  0           // offset
);
```

---

## 45.3.3 Set Uniforms

```javascript
const colorLoc = gl.getUniformLocation(program, 'u_color');
gl.uniform4f(colorLoc, 1.0, 0.0, 0.0, 1.0);  // Red

const matrixLoc = gl.getUniformLocation(program, 'u_matrix');
gl.uniformMatrix4fv(matrixLoc, false, matrix);
```

---

## 45.3.4 Draw

```javascript
// Draw triangles
gl.drawArrays(gl.TRIANGLES, 0, 3);

// Draw with indices
const indexBuffer = gl.createBuffer();
gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);
gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);
```

---

## 45.3.5 Summary

| Draw Mode | Description |
|-----------|-------------|
| `POINTS` | Individual points |
| `LINES` | Line segments |
| `TRIANGLES` | Filled triangles |
| `TRIANGLE_STRIP` | Connected triangles |

---

**End of Chapter 45.3: Buffers and Drawing**

This completes Group 45 — WebGL API. Next: **Group 46 — WebGPU API**.
# 46.1 WebGPU Basics

WebGPU is the next-generation graphics API, providing modern GPU access.

---

## 46.1.1 Get Adapter and Device

```javascript
if (!navigator.gpu) {
  throw new Error('WebGPU not supported');
}

const adapter = await navigator.gpu.requestAdapter();
const device = await adapter.requestDevice();
```

---

## 46.1.2 Configure Canvas

```javascript
const canvas = document.getElementById('canvas');
const context = canvas.getContext('webgpu');

context.configure({
  device,
  format: navigator.gpu.getPreferredCanvasFormat(),
  alphaMode: 'opaque'
});
```

---

## 46.1.3 Create Pipeline

```javascript
const pipeline = device.createRenderPipeline({
  layout: 'auto',
  vertex: {
    module: device.createShaderModule({ code: vertexShader }),
    entryPoint: 'main'
  },
  fragment: {
    module: device.createShaderModule({ code: fragmentShader }),
    entryPoint: 'main',
    targets: [{ format: navigator.gpu.getPreferredCanvasFormat() }]
  }
});
```

---

## 46.1.4 Render Pass

```javascript
const commandEncoder = device.createCommandEncoder();

const renderPass = commandEncoder.beginRenderPass({
  colorAttachments: [{
    view: context.getCurrentTexture().createView(),
    clearValue: { r: 0, g: 0, b: 0, a: 1 },
    loadOp: 'clear',
    storeOp: 'store'
  }]
});

renderPass.setPipeline(pipeline);
renderPass.draw(3);
renderPass.end();

device.queue.submit([commandEncoder.finish()]);
```

---

## 46.1.5 Summary

| Concept | Description |
|---------|-------------|
| Adapter | GPU hardware |
| Device | Logical connection |
| Pipeline | Render configuration |
| Command Encoder | GPU commands |

---

**End of Chapter 46.1: WebGPU Basics**

This completes Group 46 — WebGPU API. Next: **Group 47 — WebXR API**.
# 47.1 WebXR Device API

WebXR provides access to virtual reality (VR) and augmented reality (AR) devices.

---

## 47.1.1 Check Support

```javascript
if (!navigator.xr) {
  console.error('WebXR not supported');
}

// Check VR support
const vrSupported = await navigator.xr.isSessionSupported('immersive-vr');

// Check AR support
const arSupported = await navigator.xr.isSessionSupported('immersive-ar');
```

---

## 47.1.2 Start Session

```javascript
const session = await navigator.xr.requestSession('immersive-vr', {
  requiredFeatures: ['local-floor'],
  optionalFeatures: ['hand-tracking']
});
```

---

## 47.1.3 Render Loop

```javascript
const gl = canvas.getContext('webgl2', { xrCompatible: true });
const glLayer = new XRWebGLLayer(session, gl);

session.updateRenderState({
  baseLayer: glLayer
});

const referenceSpace = await session.requestReferenceSpace('local-floor');

session.requestAnimationFrame(function onFrame(time, frame) {
  session.requestAnimationFrame(onFrame);
  
  const pose = frame.getViewerPose(referenceSpace);
  
  if (pose) {
    for (const view of pose.views) {
      const viewport = glLayer.getViewport(view);
      gl.viewport(viewport.x, viewport.y, viewport.width, viewport.height);
      
      // Render scene with view.transform and view.projectionMatrix
    }
  }
});
```

---

## 47.1.4 Input Sources

```javascript
session.addEventListener('inputsourceschange', (event) => {
  for (const source of event.added) {
    console.log('Input added:', source.handedness, source.targetRayMode);
  }
});

// In render loop
for (const source of session.inputSources) {
  const pose = frame.getPose(source.targetRaySpace, referenceSpace);
  // Use pose.transform for controller position/rotation
}
```

---

## 47.1.5 Summary

| Session Type | Description |
|--------------|-------------|
| `inline` | In-page (no headset) |
| `immersive-vr` | Full VR |
| `immersive-ar` | Full AR |

---

**End of Chapter 47.1: WebXR Device API**

This completes Group 47 — WebXR API. Next: **Group 48 — Picture-in-Picture API**.
# 48.1 Picture-in-Picture

The Picture-in-Picture API allows video to play in a floating window.

---

## 48.1.1 Check Support

```javascript
if (!document.pictureInPictureEnabled) {
  console.log('PiP not supported');
}

// Check if element supports PiP
if (video.disablePictureInPicture) {
  console.log('PiP disabled for this video');
}
```

---

## 48.1.2 Enter Picture-in-Picture

```javascript
const video = document.getElementById('video');

async function enterPiP() {
  try {
    await video.requestPictureInPicture();
  } catch (error) {
    console.error('Failed to enter PiP:', error);
  }
}
```

---

## 48.1.3 Exit Picture-in-Picture

```javascript
if (document.pictureInPictureElement) {
  await document.exitPictureInPicture();
}
```

---

## 48.1.4 Events

```javascript
video.addEventListener('enterpictureinpicture', (event) => {
  const pipWindow = event.pictureInPictureWindow;
  console.log('PiP size:', pipWindow.width, pipWindow.height);
});

video.addEventListener('leavepictureinpicture', () => {
  console.log('Left PiP');
});

// Window resize
pipWindow.addEventListener('resize', (event) => {
  console.log('New size:', event.target.width, event.target.height);
});
```

---

## 48.1.5 Summary

| Property/Method | Description |
|-----------------|-------------|
| `requestPictureInPicture()` | Enter PiP |
| `exitPictureInPicture()` | Exit PiP |
| `pictureInPictureElement` | Current PiP element |
| `pictureInPictureEnabled` | Is PiP available |

---

**End of Chapter 48.1: Picture-in-Picture**

This completes Group 48. Next: **Group 49 — Document Picture-in-Picture API**.
# 49.1 Document Picture-in-Picture

Document Picture-in-Picture allows any HTML content in a floating window, not just video.

---

## 49.1.1 Check Support

```javascript
if (!('documentPictureInPicture' in window)) {
  console.log('Document PiP not supported');
}
```

---

## 49.1.2 Open Window

```javascript
const pipWindow = await documentPictureInPicture.requestWindow({
  width: 400,
  height: 300
});
```

---

## 49.1.3 Add Content

```javascript
// Add styles
const style = document.createElement('style');
style.textContent = `
  body { font-family: system-ui; padding: 16px; }
`;
pipWindow.document.head.appendChild(style);

// Add content
const content = document.createElement('div');
content.innerHTML = '<h1>Mini Player</h1><button>Play</button>';
pipWindow.document.body.appendChild(content);
```

---

## 49.1.4 Move Existing Element

```javascript
const player = document.getElementById('player');

// Move to PiP window
pipWindow.document.body.appendChild(player);

// Move back on close
pipWindow.addEventListener('pagehide', () => {
  document.body.appendChild(player);
});
```

---

## 49.1.5 Summary

| Method | Description |
|--------|-------------|
| `requestWindow()` | Open PiP window |
| `pipWindow.document` | Window's document |
| `pagehide` event | Window closed |

---

**End of Chapter 49.1: Document Picture-in-Picture**

This completes Group 49. Next: **Group 50 — View Transitions API**.
# 50.1 View Transitions

The View Transitions API enables smooth animated transitions between DOM states.

---

## 50.1.1 Basic Transition

```javascript
document.startViewTransition(() => {
  // Update DOM
  document.body.innerHTML = newContent;
});
```

---

## 50.1.2 Transition Lifecycle

```javascript
const transition = document.startViewTransition(async () => {
  await updateDOM();
});

// Wait for transition ready (screenshot taken)
await transition.ready;

// Wait for animation complete
await transition.finished;
```

---

## 50.1.3 Custom Animations

```css
::view-transition-old(root) {
  animation: fade-out 0.3s ease-out;
}

::view-transition-new(root) {
  animation: fade-in 0.3s ease-in;
}

@keyframes fade-out {
  from { opacity: 1; }
  to { opacity: 0; }
}

@keyframes fade-in {
  from { opacity: 0; }
  to { opacity: 1; }
}
```

---

## 50.1.4 Named Transitions

```html
<header style="view-transition-name: header"></header>
```

```css
::view-transition-old(header) {
  animation: slide-out 0.3s;
}

::view-transition-new(header) {
  animation: slide-in 0.3s;
}
```

---

## 50.1.5 Skip Transition

```javascript
const transition = document.startViewTransition(() => updateDOM());

// Skip animation
transition.skipTransition();
```

---

## 50.1.6 Summary

| Pseudo-element | Description |
|----------------|-------------|
| `::view-transition` | Transition root |
| `::view-transition-old(name)` | Outgoing state |
| `::view-transition-new(name)` | Incoming state |
| `::view-transition-group(name)` | Transition group |
| `::view-transition-image-pair(name)` | Image pair |

---

**End of Chapter 50.1: View Transitions**

This completes Group 50 — View Transitions API. Next: **Group 51 — Popover API**.
# 51.1 Popover API

The Popover API provides native support for dismissible popup content.

---

## 51.1.1 Declarative Popover

```html
<button popovertarget="my-popover">Open</button>

<div id="my-popover" popover>
  <p>Popover content</p>
</div>
```

---

## 51.1.2 Popover Modes

```html
<!-- Auto: closes when clicking outside or pressing Escape -->
<div popover="auto">Auto popover</div>

<!-- Manual: must be closed programmatically -->
<div popover="manual">Manual popover</div>
```

---

## 51.1.3 JavaScript Control

```javascript
const popover = document.getElementById('my-popover');

// Show
popover.showPopover();

// Hide
popover.hidePopover();

// Toggle
popover.togglePopover();

// Check state
console.log(popover.matches(':popover-open'));
```

---

## 51.1.4 Events

```javascript
popover.addEventListener('toggle', (event) => {
  if (event.newState === 'open') {
    console.log('Popover opened');
  } else {
    console.log('Popover closed');
  }
});

popover.addEventListener('beforetoggle', (event) => {
  if (event.newState === 'open') {
    // Prepare content before opening
  }
});
```

---

## 51.1.5 Styling

```css
[popover] {
  /* Positioning */
  position: fixed;
  inset: unset;
  top: 100px;
  left: 50%;
  transform: translateX(-50%);
}

/* Backdrop */
[popover]::backdrop {
  background: rgba(0, 0, 0, 0.5);
}

/* Open state */
[popover]:popover-open {
  display: block;
}
```

---

## 51.1.6 Summary

| Attribute/Method | Description |
|------------------|-------------|
| `popover="auto"` | Light dismiss |
| `popover="manual"` | Manual control |
| `showPopover()` | Open popover |
| `hidePopover()` | Close popover |
| `togglePopover()` | Toggle state |

---

**End of Chapter 51.1: Popover API**

This completes Group 51. Next: **Group 52 — Dialog Element**.
# 52.1 Dialog Element

The `<dialog>` element provides native modal and non-modal dialog support.

---

## 52.1.1 Basic Dialog

```html
<dialog id="my-dialog">
  <h2>Dialog Title</h2>
  <p>Dialog content here.</p>
  <button onclick="this.closest('dialog').close()">Close</button>
</dialog>

<button onclick="document.getElementById('my-dialog').showModal()">
  Open Dialog
</button>
```

---

## 52.1.2 Modal vs Non-Modal

```javascript
const dialog = document.getElementById('my-dialog');

// Modal (with backdrop, traps focus)
dialog.showModal();

// Non-modal (no backdrop)
dialog.show();

// Close
dialog.close();
dialog.close('return-value');  // With return value
```

---

## 52.1.3 Return Value

```javascript
dialog.addEventListener('close', () => {
  console.log('Return value:', dialog.returnValue);
});

// Set via close()
dialog.close('submitted');

// Or via form
<form method="dialog">
  <button value="cancel">Cancel</button>
  <button value="confirm">Confirm</button>
</form>
```

---

## 52.1.4 Events

```javascript
dialog.addEventListener('close', () => {
  console.log('Dialog closed');
});

dialog.addEventListener('cancel', (event) => {
  // Escape key pressed
  event.preventDefault();  // Optional: prevent closing
});
```

---

## 52.1.5 Styling

```css
dialog {
  border: none;
  border-radius: 8px;
  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
  max-width: 400px;
}

dialog::backdrop {
  background: rgba(0, 0, 0, 0.5);
  backdrop-filter: blur(4px);
}

dialog[open] {
  animation: fade-in 0.3s;
}
```

---

## 52.1.6 Summary

| Method | Description |
|--------|-------------|
| `show()` | Open non-modal |
| `showModal()` | Open modal |
| `close(value?)` | Close dialog |
| `returnValue` | Get return value |

---

**End of Chapter 52.1: Dialog Element**

This completes Group 52. Next: **Group 53 — Content Security Policy API**.
# 53.1 Content Security Policy API

CSP helps prevent XSS attacks by controlling which resources can be loaded.

---

## 53.1.1 HTTP Header

```http
Content-Security-Policy: default-src 'self'; script-src 'self' https://cdn.example.com
```

---

## 53.1.2 Meta Tag

```html
<meta http-equiv="Content-Security-Policy" 
      content="default-src 'self'; img-src *">
```

---

## 53.1.3 Common Directives

| Directive | Controls |
|-----------|----------|
| `default-src` | Fallback for all |
| `script-src` | Scripts |
| `style-src` | Stylesheets |
| `img-src` | Images |
| `connect-src` | Fetch, WebSocket |
| `font-src` | Fonts |
| `frame-src` | Iframes |
| `media-src` | Audio/Video |

---

## 53.1.4 Source Values

```http
Content-Security-Policy: script-src 'self' 'unsafe-inline' 'unsafe-eval' https: nonce-abc123
```

| Value | Meaning |
|-------|---------|
| `'self'` | Same origin |
| `'none'` | Block all |
| `'unsafe-inline'` | Allow inline |
| `'unsafe-eval'` | Allow eval() |
| `'nonce-xxx'` | Nonce token |
| `'sha256-xxx'` | Hash |

---

## 53.1.5 Violation Reporting

```http
Content-Security-Policy: default-src 'self'; report-uri /csp-report
Content-Security-Policy-Report-Only: default-src 'self'; report-uri /csp-report
```

### JavaScript Detection

```javascript
document.addEventListener('securitypolicyviolation', (event) => {
  console.log('CSP violation:', event.violatedDirective);
  console.log('Blocked URI:', event.blockedURI);
});
```

---

## 53.1.6 Summary

| Header | Behavior |
|--------|----------|
| `Content-Security-Policy` | Enforce |
| `Content-Security-Policy-Report-Only` | Report only |

---

**End of Chapter 53.1: Content Security Policy API**

This completes Group 53. Next: **Group 54 — Trusted Types API**.
# 54.1 Trusted Types API

Trusted Types prevent DOM XSS by requiring safe values for dangerous sinks.

---

## 54.1.1 Enable Trusted Types

```http
Content-Security-Policy: require-trusted-types-for 'script'
```

---

## 54.1.2 Create Policy

```javascript
const policy = trustedTypes.createPolicy('myPolicy', {
  createHTML: (input) => {
    // Sanitize input
    return DOMPurify.sanitize(input);
  },
  createScript: (input) => input,
  createScriptURL: (input) => {
    if (input.startsWith('https://trusted.com/')) {
      return input;
    }
    throw new Error('Untrusted URL');
  }
});
```

---

## 54.1.3 Use Trusted Values

```javascript
// Without Trusted Types (throws error when enforced)
element.innerHTML = userInput;

// With Trusted Types
element.innerHTML = policy.createHTML(userInput);
```

---

## 54.1.4 Default Policy

```javascript
trustedTypes.createPolicy('default', {
  createHTML: (input, sink) => {
    console.warn('Unsafe HTML assignment to', sink);
    return DOMPurify.sanitize(input);
  }
});
```

---

## 54.1.5 Check Support

```javascript
if (window.trustedTypes) {
  // Trusted Types supported
}

// Check if enforced
if (trustedTypes.isHTML) {
  // Can check trusted values
}
```

---

## 54.1.6 Summary

| Method | Creates |
|--------|---------|
| `createHTML()` | TrustedHTML |
| `createScript()` | TrustedScript |
| `createScriptURL()` | TrustedScriptURL |

---

**End of Chapter 54.1: Trusted Types API**

This completes Group 54. Next: **Group 55 — Feature Policy API**.
# 55.1 Permissions Policy

Permissions Policy (formerly Feature Policy) controls browser features.

---

## 55.1.1 HTTP Header

```http
Permissions-Policy: geolocation=(), camera=(self), microphone=(self "https://example.com")
```

---

## 55.1.2 Iframe Allow Attribute

```html
<iframe src="https://example.com" 
        allow="camera; microphone; fullscreen">
</iframe>
```

---

## 55.1.3 Common Features

| Feature | Description |
|---------|-------------|
| `accelerometer` | Motion sensors |
| `camera` | Camera access |
| `geolocation` | Location access |
| `microphone` | Microphone access |
| `fullscreen` | Fullscreen API |
| `payment` | Payment Request API |
| `autoplay` | Media autoplay |

---

## 55.1.4 JavaScript Detection

```javascript
// Check if feature allowed
document.featurePolicy.allowsFeature('geolocation');
// true or false

// Check for specific origin
document.featurePolicy.allowsFeature('camera', 'https://example.com');

// List all features
document.featurePolicy.features();

// List allowed origins for feature
document.featurePolicy.getAllowlistForFeature('microphone');
```

---

## 55.1.5 Policy Values

```http
# Disable for all
Permissions-Policy: camera=()

# Allow for same origin
Permissions-Policy: camera=(self)

# Allow for specific origins
Permissions-Policy: camera=(self "https://example.com")

# Allow for all (wildcard)
Permissions-Policy: camera=*
```

---

## 55.1.6 Summary

| Syntax | Meaning |
|--------|---------|
| `()` | Disabled |
| `(self)` | Same origin |
| `*` | All origins |
| `("url")` | Specific origin |

---

**End of Chapter 55.1: Permissions Policy**

This completes Group 55. Next: **Group 56 — Launch Handler API**.
# 56.1 Launch Handler API

The Launch Handler API controls how a PWA handles being launched.

---

## 56.1.1 Manifest Configuration

```json
{
  "name": "My App",
  "launch_handler": {
    "client_mode": "navigate-new"
  }
}
```

---

## 56.1.2 Client Modes

| Mode | Behavior |
|------|----------|
| `auto` | Browser decides |
| `navigate-new` | Always new window |
| `navigate-existing` | Focus existing, navigate |
| `focus-existing` | Focus existing, don't navigate |

---

## 56.1.3 Handle Launch

```javascript
if ('launchQueue' in window) {
  launchQueue.setConsumer((launchParams) => {
    if (launchParams.targetURL) {
      console.log('Launched with:', launchParams.targetURL);
    }
    
    if (launchParams.files?.length > 0) {
      // Handle file launch
      for (const file of launchParams.files) {
        handleFile(file);
      }
    }
  });
}
```

---

## 56.1.4 Launch with Files

```json
{
  "file_handlers": [
    {
      "action": "/open",
      "accept": {
        "text/plain": [".txt"]
      }
    }
  ],
  "launch_handler": {
    "client_mode": "focus-existing"
  }
}
```

---

## 56.1.5 Summary

| Property | Description |
|----------|-------------|
| `launchQueue` | Queue of launch events |
| `setConsumer()` | Handle launches |
| `targetURL` | URL that triggered launch |
| `files` | Files opened with app |

---

**End of Chapter 56.1: Launch Handler API**

This completes Group 56. Next: **Group 57 — Window Management API**.
# 57.1 Window Management API

The Window Management API enables multi-screen window placement.

---

## 57.1.1 Get Screen Details

```javascript
const screenDetails = await window.getScreenDetails();

console.log('Screens:', screenDetails.screens.length);
console.log('Current:', screenDetails.currentScreen);

for (const screen of screenDetails.screens) {
  console.log(screen.label, screen.width, screen.height);
  console.log('Position:', screen.left, screen.top);
  console.log('Primary:', screen.isPrimary);
}
```

---

## 57.1.2 Monitor Changes

```javascript
screenDetails.addEventListener('screenschange', () => {
  console.log('Screen configuration changed');
});

screenDetails.addEventListener('currentscreenchange', () => {
  console.log('Current screen changed');
});
```

---

## 57.1.3 Position Windows

```javascript
const screens = await window.getScreenDetails();
const secondScreen = screens.screens[1];

if (secondScreen) {
  const popup = window.open('', '', 
    `left=${secondScreen.left},top=${secondScreen.top},width=800,height=600`
  );
}
```

---

## 57.1.4 Fullscreen on Specific Screen

```javascript
const screens = await window.getScreenDetails();
const targetScreen = screens.screens[1];

await document.body.requestFullscreen({
  screen: targetScreen
});
```

---

## 57.1.5 Permission

```javascript
const permission = await navigator.permissions.query({
  name: 'window-management'
});

if (permission.state === 'granted') {
  // Can use window management
}
```

---

## 57.1.6 Summary

| Property | Description |
|----------|-------------|
| `screens` | Array of screens |
| `currentScreen` | Current screen |
| `screen.left/top` | Screen position |
| `screen.width/height` | Screen dimensions |
| `screen.isPrimary` | Is primary display |
| `screen.label` | Screen name |

---

**End of Chapter 57.1: Window Management API**

This completes Group 57 — the final group of the BrowserJS section.
# 58.1 ARIA Fundamentals

Accessible Rich Internet Applications (ARIA) enhances HTML accessibility for assistive technologies.

---

## 58.1.1 ARIA Roles

### Landmark Roles

```html
<header role="banner">...</header>
<nav role="navigation">...</nav>
<main role="main">...</main>
<aside role="complementary">...</aside>
<footer role="contentinfo">...</footer>
```

### Widget Roles

```html
<div role="button" tabindex="0">Click me</div>
<div role="checkbox" aria-checked="false">Option</div>
<div role="dialog" aria-labelledby="title">...</div>
<ul role="menu">...</ul>
<div role="tablist">...</div>
```

---

## 58.1.2 ARIA States and Properties

### Common States

```html
<!-- Expanded/Collapsed -->
<button aria-expanded="false" aria-controls="menu">Menu</button>

<!-- Selected -->
<li role="option" aria-selected="true">Item</li>

<!-- Disabled -->
<button aria-disabled="true">Disabled</button>

<!-- Busy/Loading -->
<div aria-busy="true">Loading...</div>
```

### Common Properties

```html
<!-- Label -->
<input aria-label="Search" type="search">

<!-- Labelled by -->
<div id="title">Dialog Title</div>
<div role="dialog" aria-labelledby="title">...</div>

<!-- Described by -->
<input aria-describedby="hint">
<p id="hint">Enter your email</p>
```

---

## 58.1.3 Live Regions

### Announce Changes

```html
<!-- Polite: announce when idle -->
<div aria-live="polite" aria-atomic="true">
  Status message
</div>

<!-- Assertive: announce immediately -->
<div aria-live="assertive" role="alert">
  Error: Invalid input
</div>
```

### Dynamic Updates

```javascript
const status = document.getElementById('status');
status.setAttribute('aria-live', 'polite');

// Changes will be announced
status.textContent = 'File uploaded successfully';
```

---

## 58.1.4 Best Practices

### Use Semantic HTML First

```html
<!-- ❌ ARIA when native element exists -->
<div role="button">Click</div>

<!-- ✅ Use native elements -->
<button>Click</button>
```

### Don't Override Semantics

```html
<!-- ❌ Wrong: button with heading role -->
<button role="heading">Title</button>

<!-- ✅ Correct -->
<h2>Title</h2>
```

---

## 58.1.5 Summary

| Category | Examples |
|----------|----------|
| Landmarks | banner, navigation, main, complementary |
| Widgets | button, checkbox, dialog, menu, tab |
| States | expanded, selected, disabled, busy |
| Properties | label, labelledby, describedby |
| Live Regions | polite, assertive, atomic |

---

**End of Chapter 58.1: ARIA Fundamentals**

Next: **58.2 Keyboard Navigation**.
# 58.2 Keyboard Navigation

Proper keyboard navigation ensures all users can interact with your application.

---

## 58.2.1 Tab Order

### Natural Tab Order

```html
<!-- Follow DOM order -->
<input type="text">    <!-- Tab 1 -->
<button>Submit</button> <!-- Tab 2 -->
<a href="#">Link</a>    <!-- Tab 3 -->
```

### Modify Tab Order

```html
<!-- Remove from tab order -->
<div tabindex="-1">Not tabbable, but focusable programmatically</div>

<!-- Add to tab order -->
<div tabindex="0">Tabbable in DOM order</div>

<!-- ❌ Avoid positive tabindex -->
<div tabindex="1">Avoid this</div>
```

---

## 58.2.2 Focus Management

### Programmatic Focus

```javascript
// Focus element
element.focus();

// Focus with scroll prevention
element.focus({ preventScroll: true });

// Check current focus
const focused = document.activeElement;
```

### Focus Trapping (Modal)

```javascript
function trapFocus(modal) {
  const focusable = modal.querySelectorAll(
    'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
  );
  const first = focusable[0];
  const last = focusable[focusable.length - 1];
  
  modal.addEventListener('keydown', (e) => {
    if (e.key !== 'Tab') return;
    
    if (e.shiftKey && document.activeElement === first) {
      e.preventDefault();
      last.focus();
    } else if (!e.shiftKey && document.activeElement === last) {
      e.preventDefault();
      first.focus();
    }
  });
}
```

---

## 58.2.3 Keyboard Shortcuts

### Handle Key Events

```javascript
element.addEventListener('keydown', (e) => {
  switch (e.key) {
    case 'Enter':
    case ' ':
      e.preventDefault();
      activate();
      break;
    case 'Escape':
      close();
      break;
    case 'ArrowDown':
      e.preventDefault();
      focusNext();
      break;
    case 'ArrowUp':
      e.preventDefault();
      focusPrevious();
      break;
  }
});
```

---

## 58.2.4 Focus Indicators

### CSS Focus Styles

```css
/* Always provide visible focus */
:focus {
  outline: 2px solid #0066cc;
  outline-offset: 2px;
}

/* Focus-visible for keyboard only */
:focus:not(:focus-visible) {
  outline: none;
}

:focus-visible {
  outline: 2px solid #0066cc;
  outline-offset: 2px;
}
```

---

## 58.2.5 Summary

| Concept | Best Practice |
|---------|---------------|
| Tab order | Use tabindex 0 or -1 only |
| Focus management | Trap focus in modals |
| Keyboard events | Handle Enter, Space, Escape, Arrows |
| Focus indicators | Always visible, use :focus-visible |

---

**End of Chapter 58.2: Keyboard Navigation**

Next: **58.3 Screen Reader Support**.
# 58.3 Screen Reader Support

Screen readers vocalize page content for visually impaired users.

---

## 58.3.1 Accessible Names

### Provide Labels

```html
<!-- Visible label -->
<label for="email">Email</label>
<input id="email" type="email">

<!-- aria-label (invisible) -->
<button aria-label="Close dialog">×</button>

<!-- aria-labelledby -->
<h2 id="section-title">Settings</h2>
<section aria-labelledby="section-title">...</section>
```

---

## 58.3.2 Alternative Text

### Images

```html
<!-- Informative image -->
<img src="chart.png" alt="Sales increased 25% in Q4">

<!-- Decorative image -->
<img src="decoration.png" alt="" role="presentation">

<!-- Complex image -->
<figure>
  <img src="diagram.png" alt="System architecture diagram">
  <figcaption>Detailed description...</figcaption>
</figure>
```

---

## 58.3.3 Hidden Content

### Visually Hidden

```css
.visually-hidden {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0, 0, 0, 0);
  white-space: nowrap;
  border: 0;
}
```

```html
<button>
  <span class="visually-hidden">Close</span>
  <span aria-hidden="true">×</span>
</button>
```

### Hide from Screen Readers

```html
<!-- Hide decorative content -->
<span aria-hidden="true">★★★★☆</span>
<span class="visually-hidden">4 out of 5 stars</span>
```

---

## 58.3.4 Descriptions

### Additional Context

```html
<input 
  type="password"
  aria-describedby="password-requirements"
>
<p id="password-requirements">
  Must be 8+ characters with a number
</p>
```

---

## 58.3.5 Summary

| Technique | Use Case |
|-----------|----------|
| `aria-label` | Invisible label |
| `aria-labelledby` | Reference existing text |
| `aria-describedby` | Additional context |
| `aria-hidden` | Hide from screen readers |
| `alt=""` | Decorative images |
| `.visually-hidden` | Screen reader only text |

---

**End of Chapter 58.3: Screen Reader Support**

Next: **58.4 Accessible Forms**.
# 58.4 Accessible Forms

Forms must be usable by all users including those with assistive technologies.

---

## 58.4.1 Labels

### Explicit Labels

```html
<label for="name">Name</label>
<input id="name" type="text">
```

### Implicit Labels

```html
<label>
  Name
  <input type="text">
</label>
```

---

## 58.4.2 Required Fields

```html
<label for="email">
  Email <span aria-hidden="true">*</span>
</label>
<input id="email" type="email" aria-required="true" required>
```

---

## 58.4.3 Error Messages

### Associate Errors

```html
<label for="email">Email</label>
<input 
  id="email" 
  type="email"
  aria-invalid="true"
  aria-describedby="email-error"
>
<p id="email-error" role="alert">
  Please enter a valid email address
</p>
```

### Error Summary

```html
<div role="alert" aria-labelledby="error-heading">
  <h2 id="error-heading">Please fix the following errors:</h2>
  <ul>
    <li><a href="#email">Email is required</a></li>
    <li><a href="#password">Password too short</a></li>
  </ul>
</div>
```

---

## 58.4.4 Field Groups

```html
<fieldset>
  <legend>Shipping Address</legend>
  <label for="street">Street</label>
  <input id="street" type="text">
  <!-- More fields -->
</fieldset>

<!-- Radio/Checkbox groups -->
<fieldset>
  <legend>Payment Method</legend>
  <input type="radio" id="card" name="payment">
  <label for="card">Credit Card</label>
  <input type="radio" id="paypal" name="payment">
  <label for="paypal">PayPal</label>
</fieldset>
```

---

## 58.4.5 Input Hints

```html
<label for="dob">Date of Birth</label>
<input 
  id="dob" 
  type="text"
  aria-describedby="dob-format"
  placeholder="MM/DD/YYYY"
>
<p id="dob-format">Format: MM/DD/YYYY</p>
```

---

## 58.4.6 Summary

| Requirement | Implementation |
|-------------|----------------|
| Labels | `<label>` with `for` attribute |
| Required fields | `aria-required` + `required` |
| Errors | `aria-invalid` + `aria-describedby` |
| Groups | `<fieldset>` + `<legend>` |
| Hints | `aria-describedby` |

---

**End of Chapter 58.4: Accessible Forms**

Next: **58.5 Accessible Components**.
# 58.5 Accessible Components

Common UI components require specific accessibility patterns.

---

## 58.5.1 Modal Dialogs

```html
<div 
  role="dialog"
  aria-modal="true"
  aria-labelledby="dialog-title"
>
  <h2 id="dialog-title">Confirm Delete</h2>
  <p>Are you sure you want to delete this item?</p>
  <button>Cancel</button>
  <button>Delete</button>
</div>
```

```javascript
function openModal(modal) {
  const previousFocus = document.activeElement;
  modal.hidden = false;
  modal.querySelector('button').focus();
  
  // Return focus on close
  modal.addEventListener('close', () => {
    previousFocus.focus();
  });
}
```

---

## 58.5.2 Tabs

```html
<div role="tablist" aria-label="Settings">
  <button role="tab" aria-selected="true" aria-controls="panel1" id="tab1">
    General
  </button>
  <button role="tab" aria-selected="false" aria-controls="panel2" id="tab2">
    Privacy
  </button>
</div>

<div role="tabpanel" id="panel1" aria-labelledby="tab1">
  General settings content
</div>
<div role="tabpanel" id="panel2" aria-labelledby="tab2" hidden>
  Privacy settings content
</div>
```

---

## 58.5.3 Menus

```html
<button aria-haspopup="menu" aria-expanded="false" aria-controls="menu">
  Options
</button>
<ul role="menu" id="menu" hidden>
  <li role="menuitem" tabindex="-1">Edit</li>
  <li role="menuitem" tabindex="-1">Delete</li>
  <li role="separator"></li>
  <li role="menuitem" tabindex="-1">Settings</li>
</ul>
```

---

## 58.5.4 Accordions

```html
<div class="accordion">
  <h3>
    <button aria-expanded="false" aria-controls="section1">
      Section 1
    </button>
  </h3>
  <div id="section1" hidden>
    Section 1 content
  </div>
</div>
```

---

## 58.5.5 Carousels

```html
<div role="region" aria-label="Featured products" aria-roledescription="carousel">
  <button aria-label="Previous slide">←</button>
  
  <div aria-live="polite">
    <div role="group" aria-roledescription="slide" aria-label="1 of 5">
      Slide content
    </div>
  </div>
  
  <button aria-label="Next slide">→</button>
</div>
```

---

## 58.5.6 Summary

| Component | Key Attributes |
|-----------|----------------|
| Dialog | `role="dialog"`, `aria-modal`, `aria-labelledby` |
| Tabs | `role="tablist/tab/tabpanel"`, `aria-selected` |
| Menu | `role="menu/menuitem"`, `aria-haspopup`, `aria-expanded` |
| Accordion | `aria-expanded`, `aria-controls` |
| Carousel | `aria-roledescription`, `aria-live` |

---

**End of Chapter 58.5: Accessible Components**

Next: **58.6 Testing for Accessibility**.
# 58.6 Testing for Accessibility

Accessibility testing ensures your application is usable by everyone.

---

## 58.6.1 Automated Testing

### Browser DevTools

```javascript
// Chrome DevTools Lighthouse
// Accessibility audit in Performance tab

// Firefox Accessibility Inspector
// Shows accessibility tree
```

### axe-core

```javascript
import axe from 'axe-core';

axe.run(document, (err, results) => {
  results.violations.forEach(violation => {
    console.log(violation.id, violation.description);
    violation.nodes.forEach(node => {
      console.log('Element:', node.html);
      console.log('Fix:', node.failureSummary);
    });
  });
});
```

### Testing Library

```javascript
import { render } from '@testing-library/react';
import { axe, toHaveNoViolations } from 'jest-axe';

expect.extend(toHaveNoViolations);

test('should have no accessibility violations', async () => {
  const { container } = render(<MyComponent />);
  const results = await axe(container);
  expect(results).toHaveNoViolations();
});
```

---

## 58.6.2 Manual Testing

### Keyboard Testing

1. Tab through entire page
2. Verify all interactive elements are focusable
3. Check focus is visible
4. Verify Enter/Space activate controls
5. Check Escape closes modals

### Screen Reader Testing

| Reader | Platform | Shortcut |
|--------|----------|----------|
| NVDA | Windows | Free download |
| VoiceOver | macOS | Cmd+F5 |
| VoiceOver | iOS | Settings > Accessibility |
| TalkBack | Android | Settings > Accessibility |

---

## 58.6.3 Color Contrast

### WCAG Requirements

| Level | Normal Text | Large Text |
|-------|-------------|------------|
| AA | 4.5:1 | 3:1 |
| AAA | 7:1 | 4.5:1 |

### Check Contrast

```javascript
// Use browser DevTools color picker
// Shows contrast ratio automatically
```

---

## 58.6.4 ARIA Validation

```javascript
// Check for common ARIA issues
const issues = [];

// Missing labels
document.querySelectorAll('button:not([aria-label])').forEach(btn => {
  if (!btn.textContent.trim()) {
    issues.push('Button without accessible name');
  }
});

// Invalid ARIA references
document.querySelectorAll('[aria-labelledby]').forEach(el => {
  const id = el.getAttribute('aria-labelledby');
  if (!document.getElementById(id)) {
    issues.push(`aria-labelledby references missing ID: ${id}`);
  }
});
```

---

## 58.6.5 Testing Checklist

| Category | Checks |
|----------|--------|
| Keyboard | Tab order, focus visible, shortcuts work |
| Screen reader | All content announced, live regions work |
| Visual | Contrast, text resize, motion reduced |
| Forms | Labels, errors, required fields |
| Structure | Headings, landmarks, page title |

---

## 58.6.6 Summary

| Tool/Method | Purpose |
|-------------|---------|
| Lighthouse | Automated browser audit |
| axe-core | Programmatic testing |
| jest-axe | Jest integration |
| Keyboard testing | Manual navigation check |
| Screen reader | Real-world assistive tech |
| Color contrast | Visual accessibility |

---

**End of Chapter 58.6: Testing for Accessibility**

This completes Group 58 — Accessibility, and the entire BrowserJS section.
